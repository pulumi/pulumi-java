// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package io.pulumi.awsnative.cloudformation;

import io.pulumi.awsnative.cloudformation.enums.TypeActivationType;
import io.pulumi.awsnative.cloudformation.enums.TypeActivationVersionBump;
import io.pulumi.awsnative.cloudformation.inputs.TypeActivationLoggingConfigArgs;
import io.pulumi.core.Input;
import io.pulumi.core.annotations.InputImport;
import java.lang.Boolean;
import java.lang.String;
import java.util.Objects;
import javax.annotation.Nullable;


public final class TypeActivationArgs extends io.pulumi.resources.ResourceArgs {

    public static final TypeActivationArgs Empty = new TypeActivationArgs();

    /**
     * Whether to automatically update the extension in this account and region when a new minor version is published by the extension publisher. Major versions released by the publisher must be manually updated.
     * 
     */
    @InputImport(name="autoUpdate")
      private final @Nullable Input<Boolean> autoUpdate;

    public Input<Boolean> getAutoUpdate() {
        return this.autoUpdate == null ? Input.empty() : this.autoUpdate;
    }

    /**
     * The Amazon Resource Name (ARN) of the IAM execution role to use to register the type. If your resource type calls AWS APIs in any of its handlers, you must create an IAM execution role that includes the necessary permissions to call those AWS APIs, and provision that execution role in your account. CloudFormation then assumes that execution role to provide your resource type with the appropriate credentials.
     * 
     */
    @InputImport(name="executionRoleArn")
      private final @Nullable Input<String> executionRoleArn;

    public Input<String> getExecutionRoleArn() {
        return this.executionRoleArn == null ? Input.empty() : this.executionRoleArn;
    }

    /**
     * Specifies logging configuration information for a type.
     * 
     */
    @InputImport(name="loggingConfig")
      private final @Nullable Input<TypeActivationLoggingConfigArgs> loggingConfig;

    public Input<TypeActivationLoggingConfigArgs> getLoggingConfig() {
        return this.loggingConfig == null ? Input.empty() : this.loggingConfig;
    }

    /**
     * The Major Version of the type you want to enable
     * 
     */
    @InputImport(name="majorVersion")
      private final @Nullable Input<String> majorVersion;

    public Input<String> getMajorVersion() {
        return this.majorVersion == null ? Input.empty() : this.majorVersion;
    }

    /**
     * The Amazon Resource Number (ARN) assigned to the public extension upon publication
     * 
     */
    @InputImport(name="publicTypeArn")
      private final @Nullable Input<String> publicTypeArn;

    public Input<String> getPublicTypeArn() {
        return this.publicTypeArn == null ? Input.empty() : this.publicTypeArn;
    }

    /**
     * The publisher id assigned by CloudFormation for publishing in this region.
     * 
     */
    @InputImport(name="publisherId")
      private final @Nullable Input<String> publisherId;

    public Input<String> getPublisherId() {
        return this.publisherId == null ? Input.empty() : this.publisherId;
    }

    /**
     * The kind of extension
     * 
     */
    @InputImport(name="type")
      private final @Nullable Input<TypeActivationType> type;

    public Input<TypeActivationType> getType() {
        return this.type == null ? Input.empty() : this.type;
    }

    /**
     * The name of the type being registered.
     * 
     * We recommend that type names adhere to the following pattern: company_or_organization::service::type.
     * 
     */
    @InputImport(name="typeName")
      private final @Nullable Input<String> typeName;

    public Input<String> getTypeName() {
        return this.typeName == null ? Input.empty() : this.typeName;
    }

    /**
     * An alias to assign to the public extension in this account and region. If you specify an alias for the extension, you must then use the alias to refer to the extension in your templates.
     * 
     */
    @InputImport(name="typeNameAlias")
      private final @Nullable Input<String> typeNameAlias;

    public Input<String> getTypeNameAlias() {
        return this.typeNameAlias == null ? Input.empty() : this.typeNameAlias;
    }

    /**
     * Manually updates a previously-enabled type to a new major or minor version, if available. You can also use this parameter to update the value of AutoUpdateEnabled
     * 
     */
    @InputImport(name="versionBump")
      private final @Nullable Input<TypeActivationVersionBump> versionBump;

    public Input<TypeActivationVersionBump> getVersionBump() {
        return this.versionBump == null ? Input.empty() : this.versionBump;
    }

    public TypeActivationArgs(
        @Nullable Input<Boolean> autoUpdate,
        @Nullable Input<String> executionRoleArn,
        @Nullable Input<TypeActivationLoggingConfigArgs> loggingConfig,
        @Nullable Input<String> majorVersion,
        @Nullable Input<String> publicTypeArn,
        @Nullable Input<String> publisherId,
        @Nullable Input<TypeActivationType> type,
        @Nullable Input<String> typeName,
        @Nullable Input<String> typeNameAlias,
        @Nullable Input<TypeActivationVersionBump> versionBump) {
        this.autoUpdate = autoUpdate;
        this.executionRoleArn = executionRoleArn;
        this.loggingConfig = loggingConfig;
        this.majorVersion = majorVersion;
        this.publicTypeArn = publicTypeArn;
        this.publisherId = publisherId;
        this.type = type;
        this.typeName = typeName;
        this.typeNameAlias = typeNameAlias;
        this.versionBump = versionBump;
    }

    private TypeActivationArgs() {
        this.autoUpdate = Input.empty();
        this.executionRoleArn = Input.empty();
        this.loggingConfig = Input.empty();
        this.majorVersion = Input.empty();
        this.publicTypeArn = Input.empty();
        this.publisherId = Input.empty();
        this.type = Input.empty();
        this.typeName = Input.empty();
        this.typeNameAlias = Input.empty();
        this.versionBump = Input.empty();
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(TypeActivationArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private @Nullable Input<Boolean> autoUpdate;
        private @Nullable Input<String> executionRoleArn;
        private @Nullable Input<TypeActivationLoggingConfigArgs> loggingConfig;
        private @Nullable Input<String> majorVersion;
        private @Nullable Input<String> publicTypeArn;
        private @Nullable Input<String> publisherId;
        private @Nullable Input<TypeActivationType> type;
        private @Nullable Input<String> typeName;
        private @Nullable Input<String> typeNameAlias;
        private @Nullable Input<TypeActivationVersionBump> versionBump;

        public Builder() {
    	      // Empty
        }

        public Builder(TypeActivationArgs defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.autoUpdate = defaults.autoUpdate;
    	      this.executionRoleArn = defaults.executionRoleArn;
    	      this.loggingConfig = defaults.loggingConfig;
    	      this.majorVersion = defaults.majorVersion;
    	      this.publicTypeArn = defaults.publicTypeArn;
    	      this.publisherId = defaults.publisherId;
    	      this.type = defaults.type;
    	      this.typeName = defaults.typeName;
    	      this.typeNameAlias = defaults.typeNameAlias;
    	      this.versionBump = defaults.versionBump;
        }

        public Builder autoUpdate(@Nullable Input<Boolean> autoUpdate) {
            this.autoUpdate = autoUpdate;
            return this;
        }

        public Builder autoUpdate(@Nullable Boolean autoUpdate) {
            this.autoUpdate = Input.ofNullable(autoUpdate);
            return this;
        }

        public Builder executionRoleArn(@Nullable Input<String> executionRoleArn) {
            this.executionRoleArn = executionRoleArn;
            return this;
        }

        public Builder executionRoleArn(@Nullable String executionRoleArn) {
            this.executionRoleArn = Input.ofNullable(executionRoleArn);
            return this;
        }

        public Builder loggingConfig(@Nullable Input<TypeActivationLoggingConfigArgs> loggingConfig) {
            this.loggingConfig = loggingConfig;
            return this;
        }

        public Builder loggingConfig(@Nullable TypeActivationLoggingConfigArgs loggingConfig) {
            this.loggingConfig = Input.ofNullable(loggingConfig);
            return this;
        }

        public Builder majorVersion(@Nullable Input<String> majorVersion) {
            this.majorVersion = majorVersion;
            return this;
        }

        public Builder majorVersion(@Nullable String majorVersion) {
            this.majorVersion = Input.ofNullable(majorVersion);
            return this;
        }

        public Builder publicTypeArn(@Nullable Input<String> publicTypeArn) {
            this.publicTypeArn = publicTypeArn;
            return this;
        }

        public Builder publicTypeArn(@Nullable String publicTypeArn) {
            this.publicTypeArn = Input.ofNullable(publicTypeArn);
            return this;
        }

        public Builder publisherId(@Nullable Input<String> publisherId) {
            this.publisherId = publisherId;
            return this;
        }

        public Builder publisherId(@Nullable String publisherId) {
            this.publisherId = Input.ofNullable(publisherId);
            return this;
        }

        public Builder type(@Nullable Input<TypeActivationType> type) {
            this.type = type;
            return this;
        }

        public Builder type(@Nullable TypeActivationType type) {
            this.type = Input.ofNullable(type);
            return this;
        }

        public Builder typeName(@Nullable Input<String> typeName) {
            this.typeName = typeName;
            return this;
        }

        public Builder typeName(@Nullable String typeName) {
            this.typeName = Input.ofNullable(typeName);
            return this;
        }

        public Builder typeNameAlias(@Nullable Input<String> typeNameAlias) {
            this.typeNameAlias = typeNameAlias;
            return this;
        }

        public Builder typeNameAlias(@Nullable String typeNameAlias) {
            this.typeNameAlias = Input.ofNullable(typeNameAlias);
            return this;
        }

        public Builder versionBump(@Nullable Input<TypeActivationVersionBump> versionBump) {
            this.versionBump = versionBump;
            return this;
        }

        public Builder versionBump(@Nullable TypeActivationVersionBump versionBump) {
            this.versionBump = Input.ofNullable(versionBump);
            return this;
        }
        public TypeActivationArgs build() {
            return new TypeActivationArgs(autoUpdate, executionRoleArn, loggingConfig, majorVersion, publicTypeArn, publisherId, type, typeName, typeNameAlias, versionBump);
        }
    }
}
