// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package io.pulumi.awsnative.redshift;

import io.pulumi.awsnative.redshift.inputs.ClusterEndpointArgs;
import io.pulumi.awsnative.redshift.inputs.ClusterLoggingPropertiesArgs;
import io.pulumi.awsnative.redshift.inputs.ClusterTagArgs;
import io.pulumi.core.Input;
import io.pulumi.core.annotations.InputImport;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import javax.annotation.Nullable;


public final class ClusterArgs extends io.pulumi.resources.ResourceArgs {

    public static final ClusterArgs Empty = new ClusterArgs();

    /**
     * Major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. Default value is True
     * 
     */
    @InputImport(name="allowVersionUpgrade")
      private final @Nullable Input<Boolean> allowVersionUpgrade;

    public Input<Boolean> getAllowVersionUpgrade() {
        return this.allowVersionUpgrade == null ? Input.empty() : this.allowVersionUpgrade;
    }

    /**
     * The value represents how the cluster is configured to use AQUA (Advanced Query Accelerator) after the cluster is restored. Possible values include the following.
     * 
     * enabled - Use AQUA if it is available for the current Region and Amazon Redshift node type.
     * disabled - Don't use AQUA.
     * auto - Amazon Redshift determines whether to use AQUA.
     * 
     */
    @InputImport(name="aquaConfigurationStatus")
      private final @Nullable Input<String> aquaConfigurationStatus;

    public Input<String> getAquaConfigurationStatus() {
        return this.aquaConfigurationStatus == null ? Input.empty() : this.aquaConfigurationStatus;
    }

    /**
     * The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Default value is 1
     * 
     */
    @InputImport(name="automatedSnapshotRetentionPeriod")
      private final @Nullable Input<Integer> automatedSnapshotRetentionPeriod;

    public Input<Integer> getAutomatedSnapshotRetentionPeriod() {
        return this.automatedSnapshotRetentionPeriod == null ? Input.empty() : this.automatedSnapshotRetentionPeriod;
    }

    /**
     * The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. Default: A random, system-chosen Availability Zone in the region that is specified by the endpoint
     * 
     */
    @InputImport(name="availabilityZone")
      private final @Nullable Input<String> availabilityZone;

    public Input<String> getAvailabilityZone() {
        return this.availabilityZone == null ? Input.empty() : this.availabilityZone;
    }

    /**
     * The option to enable relocation for an Amazon Redshift cluster between Availability Zones after the cluster modification is complete.
     * 
     */
    @InputImport(name="availabilityZoneRelocation")
      private final @Nullable Input<Boolean> availabilityZoneRelocation;

    public Input<Boolean> getAvailabilityZoneRelocation() {
        return this.availabilityZoneRelocation == null ? Input.empty() : this.availabilityZoneRelocation;
    }

    /**
     * The availability zone relocation status of the cluster
     * 
     */
    @InputImport(name="availabilityZoneRelocationStatus")
      private final @Nullable Input<String> availabilityZoneRelocationStatus;

    public Input<String> getAvailabilityZoneRelocationStatus() {
        return this.availabilityZoneRelocationStatus == null ? Input.empty() : this.availabilityZoneRelocationStatus;
    }

    /**
     * A boolean value indicating whether the resize operation is using the classic resize process. If you don't provide this parameter or set the value to false , the resize type is elastic.
     * 
     */
    @InputImport(name="classic")
      private final @Nullable Input<Boolean> classic;

    public Input<Boolean> getClassic() {
        return this.classic == null ? Input.empty() : this.classic;
    }

    /**
     * A unique identifier for the cluster. You use this identifier to refer to the cluster for any subsequent cluster operations such as deleting or modifying. All alphabetical characters must be lower case, no hypens at the end, no two consecutive hyphens. Cluster name should be unique for all clusters within an AWS account
     * 
     */
    @InputImport(name="clusterIdentifier")
      private final @Nullable Input<String> clusterIdentifier;

    public Input<String> getClusterIdentifier() {
        return this.clusterIdentifier == null ? Input.empty() : this.clusterIdentifier;
    }

    /**
     * The name of the parameter group to be associated with this cluster.
     * 
     */
    @InputImport(name="clusterParameterGroupName")
      private final @Nullable Input<String> clusterParameterGroupName;

    public Input<String> getClusterParameterGroupName() {
        return this.clusterParameterGroupName == null ? Input.empty() : this.clusterParameterGroupName;
    }

    /**
     * A list of security groups to be associated with this cluster.
     * 
     */
    @InputImport(name="clusterSecurityGroups")
      private final @Nullable Input<List<String>> clusterSecurityGroups;

    public Input<List<String>> getClusterSecurityGroups() {
        return this.clusterSecurityGroups == null ? Input.empty() : this.clusterSecurityGroups;
    }

    /**
     * The name of a cluster subnet group to be associated with this cluster.
     * 
     */
    @InputImport(name="clusterSubnetGroupName")
      private final @Nullable Input<String> clusterSubnetGroupName;

    public Input<String> getClusterSubnetGroupName() {
        return this.clusterSubnetGroupName == null ? Input.empty() : this.clusterSubnetGroupName;
    }

    /**
     * The type of the cluster. When cluster type is specified as single-node, the NumberOfNodes parameter is not required and if multi-node, the NumberOfNodes parameter is required
     * 
     */
    @InputImport(name="clusterType", required=true)
      private final Input<String> clusterType;

    public Input<String> getClusterType() {
        return this.clusterType;
    }

    /**
     * The version of the Amazon Redshift engine software that you want to deploy on the cluster.The version selected runs on all the nodes in the cluster.
     * 
     */
    @InputImport(name="clusterVersion")
      private final @Nullable Input<String> clusterVersion;

    public Input<String> getClusterVersion() {
        return this.clusterVersion == null ? Input.empty() : this.clusterVersion;
    }

    /**
     * The name of the first database to be created when the cluster is created. To create additional databases after the cluster is created, connect to the cluster with a SQL client and use SQL commands to create a database.
     * 
     */
    @InputImport(name="dBName", required=true)
      private final Input<String> dBName;

    public Input<String> getDBName() {
        return this.dBName;
    }

    /**
     * A boolean indicating whether to enable the deferred maintenance window.
     * 
     */
    @InputImport(name="deferMaintenance")
      private final @Nullable Input<Boolean> deferMaintenance;

    public Input<Boolean> getDeferMaintenance() {
        return this.deferMaintenance == null ? Input.empty() : this.deferMaintenance;
    }

    /**
     * An integer indicating the duration of the maintenance window in days. If you specify a duration, you can't specify an end time. The duration must be 45 days or less.
     * 
     */
    @InputImport(name="deferMaintenanceDuration")
      private final @Nullable Input<Integer> deferMaintenanceDuration;

    public Input<Integer> getDeferMaintenanceDuration() {
        return this.deferMaintenanceDuration == null ? Input.empty() : this.deferMaintenanceDuration;
    }

    /**
     * A timestamp indicating end time for the deferred maintenance window. If you specify an end time, you can't specify a duration.
     * 
     */
    @InputImport(name="deferMaintenanceEndTime")
      private final @Nullable Input<String> deferMaintenanceEndTime;

    public Input<String> getDeferMaintenanceEndTime() {
        return this.deferMaintenanceEndTime == null ? Input.empty() : this.deferMaintenanceEndTime;
    }

    /**
     * A timestamp indicating the start time for the deferred maintenance window.
     * 
     */
    @InputImport(name="deferMaintenanceStartTime")
      private final @Nullable Input<String> deferMaintenanceStartTime;

    public Input<String> getDeferMaintenanceStartTime() {
        return this.deferMaintenanceStartTime == null ? Input.empty() : this.deferMaintenanceStartTime;
    }

    /**
     * The destination AWS Region that you want to copy snapshots to. Constraints: Must be the name of a valid AWS Region. For more information, see Regions and Endpoints in the Amazon Web Services [https://docs.aws.amazon.com/general/latest/gr/rande.html#redshift_region] General Reference
     * 
     */
    @InputImport(name="destinationRegion")
      private final @Nullable Input<String> destinationRegion;

    public Input<String> getDestinationRegion() {
        return this.destinationRegion == null ? Input.empty() : this.destinationRegion;
    }

    /**
     * The Elastic IP (EIP) address for the cluster.
     * 
     */
    @InputImport(name="elasticIp")
      private final @Nullable Input<String> elasticIp;

    public Input<String> getElasticIp() {
        return this.elasticIp == null ? Input.empty() : this.elasticIp;
    }

    /**
     * If true, the data in the cluster is encrypted at rest.
     * 
     */
    @InputImport(name="encrypted")
      private final @Nullable Input<Boolean> encrypted;

    public Input<Boolean> getEncrypted() {
        return this.encrypted == null ? Input.empty() : this.encrypted;
    }

    @InputImport(name="endpoint")
      private final @Nullable Input<ClusterEndpointArgs> endpoint;

    public Input<ClusterEndpointArgs> getEndpoint() {
        return this.endpoint == null ? Input.empty() : this.endpoint;
    }

    /**
     * An option that specifies whether to create the cluster with enhanced VPC routing enabled. To create a cluster that uses enhanced VPC routing, the cluster must be in a VPC. For more information, see Enhanced VPC Routing in the Amazon Redshift Cluster Management Guide.
     * 
     * If this option is true , enhanced VPC routing is enabled.
     * 
     * Default: false
     * 
     */
    @InputImport(name="enhancedVpcRouting")
      private final @Nullable Input<Boolean> enhancedVpcRouting;

    public Input<Boolean> getEnhancedVpcRouting() {
        return this.enhancedVpcRouting == null ? Input.empty() : this.enhancedVpcRouting;
    }

    /**
     * Specifies the name of the HSM client certificate the Amazon Redshift cluster uses to retrieve the data encryption keys stored in an HSM
     * 
     */
    @InputImport(name="hsmClientCertificateIdentifier")
      private final @Nullable Input<String> hsmClientCertificateIdentifier;

    public Input<String> getHsmClientCertificateIdentifier() {
        return this.hsmClientCertificateIdentifier == null ? Input.empty() : this.hsmClientCertificateIdentifier;
    }

    /**
     * Specifies the name of the HSM configuration that contains the information the Amazon Redshift cluster can use to retrieve and store keys in an HSM.
     * 
     */
    @InputImport(name="hsmConfigurationIdentifier")
      private final @Nullable Input<String> hsmConfigurationIdentifier;

    public Input<String> getHsmConfigurationIdentifier() {
        return this.hsmConfigurationIdentifier == null ? Input.empty() : this.hsmConfigurationIdentifier;
    }

    /**
     * A list of AWS Identity and Access Management (IAM) roles that can be used by the cluster to access other AWS services. You must supply the IAM roles in their Amazon Resource Name (ARN) format. You can supply up to 10 IAM roles in a single request
     * 
     */
    @InputImport(name="iamRoles")
      private final @Nullable Input<List<String>> iamRoles;

    public Input<List<String>> getIamRoles() {
        return this.iamRoles == null ? Input.empty() : this.iamRoles;
    }

    /**
     * The AWS Key Management Service (KMS) key ID of the encryption key that you want to use to encrypt data in the cluster.
     * 
     */
    @InputImport(name="kmsKeyId")
      private final @Nullable Input<String> kmsKeyId;

    public Input<String> getKmsKeyId() {
        return this.kmsKeyId == null ? Input.empty() : this.kmsKeyId;
    }

    @InputImport(name="loggingProperties")
      private final @Nullable Input<ClusterLoggingPropertiesArgs> loggingProperties;

    public Input<ClusterLoggingPropertiesArgs> getLoggingProperties() {
        return this.loggingProperties == null ? Input.empty() : this.loggingProperties;
    }

    /**
     * The name for the maintenance track that you want to assign for the cluster. This name change is asynchronous. The new track name stays in the PendingModifiedValues for the cluster until the next maintenance window. When the maintenance track changes, the cluster is switched to the latest cluster release available for the maintenance track. At this point, the maintenance track name is applied.
     * 
     */
    @InputImport(name="maintenanceTrackName")
      private final @Nullable Input<String> maintenanceTrackName;

    public Input<String> getMaintenanceTrackName() {
        return this.maintenanceTrackName == null ? Input.empty() : this.maintenanceTrackName;
    }

    /**
     * The number of days to retain newly copied snapshots in the destination AWS Region after they are copied from the source AWS Region. If the value is -1, the manual snapshot is retained indefinitely.
     * 
     * The value must be either -1 or an integer between 1 and 3,653.
     * 
     */
    @InputImport(name="manualSnapshotRetentionPeriod")
      private final @Nullable Input<Integer> manualSnapshotRetentionPeriod;

    public Input<Integer> getManualSnapshotRetentionPeriod() {
        return this.manualSnapshotRetentionPeriod == null ? Input.empty() : this.manualSnapshotRetentionPeriod;
    }

    /**
     * The password associated with the master user account for the cluster that is being created. Password must be between 8 and 64 characters in length, should have at least one uppercase letter.Must contain at least one lowercase letter.Must contain one number.Can be any printable ASCII character.
     * 
     */
    @InputImport(name="masterUserPassword", required=true)
      private final Input<String> masterUserPassword;

    public Input<String> getMasterUserPassword() {
        return this.masterUserPassword;
    }

    /**
     * The user name associated with the master user account for the cluster that is being created. The user name can't be PUBLIC and first character must be a letter.
     * 
     */
    @InputImport(name="masterUsername", required=true)
      private final Input<String> masterUsername;

    public Input<String> getMasterUsername() {
        return this.masterUsername;
    }

    /**
     * The node type to be provisioned for the cluster.Valid Values: ds2.xlarge | ds2.8xlarge | dc1.large | dc1.8xlarge | dc2.large | dc2.8xlarge | ra3.4xlarge | ra3.16xlarge
     * 
     */
    @InputImport(name="nodeType", required=true)
      private final Input<String> nodeType;

    public Input<String> getNodeType() {
        return this.nodeType;
    }

    /**
     * The number of compute nodes in the cluster. This parameter is required when the ClusterType parameter is specified as multi-node.
     * 
     */
    @InputImport(name="numberOfNodes")
      private final @Nullable Input<Integer> numberOfNodes;

    public Input<Integer> getNumberOfNodes() {
        return this.numberOfNodes == null ? Input.empty() : this.numberOfNodes;
    }

    @InputImport(name="ownerAccount")
      private final @Nullable Input<String> ownerAccount;

    public Input<String> getOwnerAccount() {
        return this.ownerAccount == null ? Input.empty() : this.ownerAccount;
    }

    /**
     * The port number on which the cluster accepts incoming connections. The cluster is accessible only via the JDBC and ODBC connection strings
     * 
     */
    @InputImport(name="port")
      private final @Nullable Input<Integer> port;

    public Input<Integer> getPort() {
        return this.port == null ? Input.empty() : this.port;
    }

    /**
     * The weekly time range (in UTC) during which automated cluster maintenance can occur.
     * 
     */
    @InputImport(name="preferredMaintenanceWindow")
      private final @Nullable Input<String> preferredMaintenanceWindow;

    public Input<String> getPreferredMaintenanceWindow() {
        return this.preferredMaintenanceWindow == null ? Input.empty() : this.preferredMaintenanceWindow;
    }

    /**
     * If true, the cluster can be accessed from a public network.
     * 
     */
    @InputImport(name="publiclyAccessible")
      private final @Nullable Input<Boolean> publiclyAccessible;

    public Input<Boolean> getPubliclyAccessible() {
        return this.publiclyAccessible == null ? Input.empty() : this.publiclyAccessible;
    }

    /**
     * The Redshift operation to be performed. Resource Action supports pause-cluster, resume-cluster APIs
     * 
     */
    @InputImport(name="resourceAction")
      private final @Nullable Input<String> resourceAction;

    public Input<String> getResourceAction() {
        return this.resourceAction == null ? Input.empty() : this.resourceAction;
    }

    /**
     * The identifier of the database revision. You can retrieve this value from the response to the DescribeClusterDbRevisions request.
     * 
     */
    @InputImport(name="revisionTarget")
      private final @Nullable Input<String> revisionTarget;

    public Input<String> getRevisionTarget() {
        return this.revisionTarget == null ? Input.empty() : this.revisionTarget;
    }

    /**
     * A boolean indicating if we want to rotate Encryption Keys.
     * 
     */
    @InputImport(name="rotateEncryptionKey")
      private final @Nullable Input<Boolean> rotateEncryptionKey;

    public Input<Boolean> getRotateEncryptionKey() {
        return this.rotateEncryptionKey == null ? Input.empty() : this.rotateEncryptionKey;
    }

    /**
     * The name of the cluster the source snapshot was created from. This parameter is required if your IAM user has a policy containing a snapshot resource element that specifies anything other than * for the cluster name.
     * 
     */
    @InputImport(name="snapshotClusterIdentifier")
      private final @Nullable Input<String> snapshotClusterIdentifier;

    public Input<String> getSnapshotClusterIdentifier() {
        return this.snapshotClusterIdentifier == null ? Input.empty() : this.snapshotClusterIdentifier;
    }

    /**
     * The name of the snapshot copy grant to use when snapshots of an AWS KMS-encrypted cluster are copied to the destination region.
     * 
     */
    @InputImport(name="snapshotCopyGrantName")
      private final @Nullable Input<String> snapshotCopyGrantName;

    public Input<String> getSnapshotCopyGrantName() {
        return this.snapshotCopyGrantName == null ? Input.empty() : this.snapshotCopyGrantName;
    }

    /**
     * Indicates whether to apply the snapshot retention period to newly copied manual snapshots instead of automated snapshots.
     * 
     */
    @InputImport(name="snapshotCopyManual")
      private final @Nullable Input<Boolean> snapshotCopyManual;

    public Input<Boolean> getSnapshotCopyManual() {
        return this.snapshotCopyManual == null ? Input.empty() : this.snapshotCopyManual;
    }

    /**
     * The number of days to retain automated snapshots in the destination region after they are copied from the source region.
     * 
     *  Default is 7.
     * 
     *  Constraints: Must be at least 1 and no more than 35.
     * 
     */
    @InputImport(name="snapshotCopyRetentionPeriod")
      private final @Nullable Input<Integer> snapshotCopyRetentionPeriod;

    public Input<Integer> getSnapshotCopyRetentionPeriod() {
        return this.snapshotCopyRetentionPeriod == null ? Input.empty() : this.snapshotCopyRetentionPeriod;
    }

    /**
     * The name of the snapshot from which to create the new cluster. This parameter isn't case sensitive.
     * 
     */
    @InputImport(name="snapshotIdentifier")
      private final @Nullable Input<String> snapshotIdentifier;

    public Input<String> getSnapshotIdentifier() {
        return this.snapshotIdentifier == null ? Input.empty() : this.snapshotIdentifier;
    }

    /**
     * The list of tags for the cluster parameter group.
     * 
     */
    @InputImport(name="tags")
      private final @Nullable Input<List<ClusterTagArgs>> tags;

    public Input<List<ClusterTagArgs>> getTags() {
        return this.tags == null ? Input.empty() : this.tags;
    }

    /**
     * A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.
     * 
     */
    @InputImport(name="vpcSecurityGroupIds")
      private final @Nullable Input<List<String>> vpcSecurityGroupIds;

    public Input<List<String>> getVpcSecurityGroupIds() {
        return this.vpcSecurityGroupIds == null ? Input.empty() : this.vpcSecurityGroupIds;
    }

    public ClusterArgs(
        @Nullable Input<Boolean> allowVersionUpgrade,
        @Nullable Input<String> aquaConfigurationStatus,
        @Nullable Input<Integer> automatedSnapshotRetentionPeriod,
        @Nullable Input<String> availabilityZone,
        @Nullable Input<Boolean> availabilityZoneRelocation,
        @Nullable Input<String> availabilityZoneRelocationStatus,
        @Nullable Input<Boolean> classic,
        @Nullable Input<String> clusterIdentifier,
        @Nullable Input<String> clusterParameterGroupName,
        @Nullable Input<List<String>> clusterSecurityGroups,
        @Nullable Input<String> clusterSubnetGroupName,
        Input<String> clusterType,
        @Nullable Input<String> clusterVersion,
        Input<String> dBName,
        @Nullable Input<Boolean> deferMaintenance,
        @Nullable Input<Integer> deferMaintenanceDuration,
        @Nullable Input<String> deferMaintenanceEndTime,
        @Nullable Input<String> deferMaintenanceStartTime,
        @Nullable Input<String> destinationRegion,
        @Nullable Input<String> elasticIp,
        @Nullable Input<Boolean> encrypted,
        @Nullable Input<ClusterEndpointArgs> endpoint,
        @Nullable Input<Boolean> enhancedVpcRouting,
        @Nullable Input<String> hsmClientCertificateIdentifier,
        @Nullable Input<String> hsmConfigurationIdentifier,
        @Nullable Input<List<String>> iamRoles,
        @Nullable Input<String> kmsKeyId,
        @Nullable Input<ClusterLoggingPropertiesArgs> loggingProperties,
        @Nullable Input<String> maintenanceTrackName,
        @Nullable Input<Integer> manualSnapshotRetentionPeriod,
        Input<String> masterUserPassword,
        Input<String> masterUsername,
        Input<String> nodeType,
        @Nullable Input<Integer> numberOfNodes,
        @Nullable Input<String> ownerAccount,
        @Nullable Input<Integer> port,
        @Nullable Input<String> preferredMaintenanceWindow,
        @Nullable Input<Boolean> publiclyAccessible,
        @Nullable Input<String> resourceAction,
        @Nullable Input<String> revisionTarget,
        @Nullable Input<Boolean> rotateEncryptionKey,
        @Nullable Input<String> snapshotClusterIdentifier,
        @Nullable Input<String> snapshotCopyGrantName,
        @Nullable Input<Boolean> snapshotCopyManual,
        @Nullable Input<Integer> snapshotCopyRetentionPeriod,
        @Nullable Input<String> snapshotIdentifier,
        @Nullable Input<List<ClusterTagArgs>> tags,
        @Nullable Input<List<String>> vpcSecurityGroupIds) {
        this.allowVersionUpgrade = allowVersionUpgrade;
        this.aquaConfigurationStatus = aquaConfigurationStatus;
        this.automatedSnapshotRetentionPeriod = automatedSnapshotRetentionPeriod;
        this.availabilityZone = availabilityZone;
        this.availabilityZoneRelocation = availabilityZoneRelocation;
        this.availabilityZoneRelocationStatus = availabilityZoneRelocationStatus;
        this.classic = classic;
        this.clusterIdentifier = clusterIdentifier;
        this.clusterParameterGroupName = clusterParameterGroupName;
        this.clusterSecurityGroups = clusterSecurityGroups;
        this.clusterSubnetGroupName = clusterSubnetGroupName;
        this.clusterType = Objects.requireNonNull(clusterType, "expected parameter 'clusterType' to be non-null");
        this.clusterVersion = clusterVersion;
        this.dBName = Objects.requireNonNull(dBName, "expected parameter 'dBName' to be non-null");
        this.deferMaintenance = deferMaintenance;
        this.deferMaintenanceDuration = deferMaintenanceDuration;
        this.deferMaintenanceEndTime = deferMaintenanceEndTime;
        this.deferMaintenanceStartTime = deferMaintenanceStartTime;
        this.destinationRegion = destinationRegion;
        this.elasticIp = elasticIp;
        this.encrypted = encrypted;
        this.endpoint = endpoint;
        this.enhancedVpcRouting = enhancedVpcRouting;
        this.hsmClientCertificateIdentifier = hsmClientCertificateIdentifier;
        this.hsmConfigurationIdentifier = hsmConfigurationIdentifier;
        this.iamRoles = iamRoles;
        this.kmsKeyId = kmsKeyId;
        this.loggingProperties = loggingProperties;
        this.maintenanceTrackName = maintenanceTrackName;
        this.manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod;
        this.masterUserPassword = Objects.requireNonNull(masterUserPassword, "expected parameter 'masterUserPassword' to be non-null");
        this.masterUsername = Objects.requireNonNull(masterUsername, "expected parameter 'masterUsername' to be non-null");
        this.nodeType = Objects.requireNonNull(nodeType, "expected parameter 'nodeType' to be non-null");
        this.numberOfNodes = numberOfNodes;
        this.ownerAccount = ownerAccount;
        this.port = port;
        this.preferredMaintenanceWindow = preferredMaintenanceWindow;
        this.publiclyAccessible = publiclyAccessible;
        this.resourceAction = resourceAction;
        this.revisionTarget = revisionTarget;
        this.rotateEncryptionKey = rotateEncryptionKey;
        this.snapshotClusterIdentifier = snapshotClusterIdentifier;
        this.snapshotCopyGrantName = snapshotCopyGrantName;
        this.snapshotCopyManual = snapshotCopyManual;
        this.snapshotCopyRetentionPeriod = snapshotCopyRetentionPeriod;
        this.snapshotIdentifier = snapshotIdentifier;
        this.tags = tags;
        this.vpcSecurityGroupIds = vpcSecurityGroupIds;
    }

    private ClusterArgs() {
        this.allowVersionUpgrade = Input.empty();
        this.aquaConfigurationStatus = Input.empty();
        this.automatedSnapshotRetentionPeriod = Input.empty();
        this.availabilityZone = Input.empty();
        this.availabilityZoneRelocation = Input.empty();
        this.availabilityZoneRelocationStatus = Input.empty();
        this.classic = Input.empty();
        this.clusterIdentifier = Input.empty();
        this.clusterParameterGroupName = Input.empty();
        this.clusterSecurityGroups = Input.empty();
        this.clusterSubnetGroupName = Input.empty();
        this.clusterType = Input.empty();
        this.clusterVersion = Input.empty();
        this.dBName = Input.empty();
        this.deferMaintenance = Input.empty();
        this.deferMaintenanceDuration = Input.empty();
        this.deferMaintenanceEndTime = Input.empty();
        this.deferMaintenanceStartTime = Input.empty();
        this.destinationRegion = Input.empty();
        this.elasticIp = Input.empty();
        this.encrypted = Input.empty();
        this.endpoint = Input.empty();
        this.enhancedVpcRouting = Input.empty();
        this.hsmClientCertificateIdentifier = Input.empty();
        this.hsmConfigurationIdentifier = Input.empty();
        this.iamRoles = Input.empty();
        this.kmsKeyId = Input.empty();
        this.loggingProperties = Input.empty();
        this.maintenanceTrackName = Input.empty();
        this.manualSnapshotRetentionPeriod = Input.empty();
        this.masterUserPassword = Input.empty();
        this.masterUsername = Input.empty();
        this.nodeType = Input.empty();
        this.numberOfNodes = Input.empty();
        this.ownerAccount = Input.empty();
        this.port = Input.empty();
        this.preferredMaintenanceWindow = Input.empty();
        this.publiclyAccessible = Input.empty();
        this.resourceAction = Input.empty();
        this.revisionTarget = Input.empty();
        this.rotateEncryptionKey = Input.empty();
        this.snapshotClusterIdentifier = Input.empty();
        this.snapshotCopyGrantName = Input.empty();
        this.snapshotCopyManual = Input.empty();
        this.snapshotCopyRetentionPeriod = Input.empty();
        this.snapshotIdentifier = Input.empty();
        this.tags = Input.empty();
        this.vpcSecurityGroupIds = Input.empty();
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(ClusterArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private @Nullable Input<Boolean> allowVersionUpgrade;
        private @Nullable Input<String> aquaConfigurationStatus;
        private @Nullable Input<Integer> automatedSnapshotRetentionPeriod;
        private @Nullable Input<String> availabilityZone;
        private @Nullable Input<Boolean> availabilityZoneRelocation;
        private @Nullable Input<String> availabilityZoneRelocationStatus;
        private @Nullable Input<Boolean> classic;
        private @Nullable Input<String> clusterIdentifier;
        private @Nullable Input<String> clusterParameterGroupName;
        private @Nullable Input<List<String>> clusterSecurityGroups;
        private @Nullable Input<String> clusterSubnetGroupName;
        private Input<String> clusterType;
        private @Nullable Input<String> clusterVersion;
        private Input<String> dBName;
        private @Nullable Input<Boolean> deferMaintenance;
        private @Nullable Input<Integer> deferMaintenanceDuration;
        private @Nullable Input<String> deferMaintenanceEndTime;
        private @Nullable Input<String> deferMaintenanceStartTime;
        private @Nullable Input<String> destinationRegion;
        private @Nullable Input<String> elasticIp;
        private @Nullable Input<Boolean> encrypted;
        private @Nullable Input<ClusterEndpointArgs> endpoint;
        private @Nullable Input<Boolean> enhancedVpcRouting;
        private @Nullable Input<String> hsmClientCertificateIdentifier;
        private @Nullable Input<String> hsmConfigurationIdentifier;
        private @Nullable Input<List<String>> iamRoles;
        private @Nullable Input<String> kmsKeyId;
        private @Nullable Input<ClusterLoggingPropertiesArgs> loggingProperties;
        private @Nullable Input<String> maintenanceTrackName;
        private @Nullable Input<Integer> manualSnapshotRetentionPeriod;
        private Input<String> masterUserPassword;
        private Input<String> masterUsername;
        private Input<String> nodeType;
        private @Nullable Input<Integer> numberOfNodes;
        private @Nullable Input<String> ownerAccount;
        private @Nullable Input<Integer> port;
        private @Nullable Input<String> preferredMaintenanceWindow;
        private @Nullable Input<Boolean> publiclyAccessible;
        private @Nullable Input<String> resourceAction;
        private @Nullable Input<String> revisionTarget;
        private @Nullable Input<Boolean> rotateEncryptionKey;
        private @Nullable Input<String> snapshotClusterIdentifier;
        private @Nullable Input<String> snapshotCopyGrantName;
        private @Nullable Input<Boolean> snapshotCopyManual;
        private @Nullable Input<Integer> snapshotCopyRetentionPeriod;
        private @Nullable Input<String> snapshotIdentifier;
        private @Nullable Input<List<ClusterTagArgs>> tags;
        private @Nullable Input<List<String>> vpcSecurityGroupIds;

        public Builder() {
    	      // Empty
        }

        public Builder(ClusterArgs defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.allowVersionUpgrade = defaults.allowVersionUpgrade;
    	      this.aquaConfigurationStatus = defaults.aquaConfigurationStatus;
    	      this.automatedSnapshotRetentionPeriod = defaults.automatedSnapshotRetentionPeriod;
    	      this.availabilityZone = defaults.availabilityZone;
    	      this.availabilityZoneRelocation = defaults.availabilityZoneRelocation;
    	      this.availabilityZoneRelocationStatus = defaults.availabilityZoneRelocationStatus;
    	      this.classic = defaults.classic;
    	      this.clusterIdentifier = defaults.clusterIdentifier;
    	      this.clusterParameterGroupName = defaults.clusterParameterGroupName;
    	      this.clusterSecurityGroups = defaults.clusterSecurityGroups;
    	      this.clusterSubnetGroupName = defaults.clusterSubnetGroupName;
    	      this.clusterType = defaults.clusterType;
    	      this.clusterVersion = defaults.clusterVersion;
    	      this.dBName = defaults.dBName;
    	      this.deferMaintenance = defaults.deferMaintenance;
    	      this.deferMaintenanceDuration = defaults.deferMaintenanceDuration;
    	      this.deferMaintenanceEndTime = defaults.deferMaintenanceEndTime;
    	      this.deferMaintenanceStartTime = defaults.deferMaintenanceStartTime;
    	      this.destinationRegion = defaults.destinationRegion;
    	      this.elasticIp = defaults.elasticIp;
    	      this.encrypted = defaults.encrypted;
    	      this.endpoint = defaults.endpoint;
    	      this.enhancedVpcRouting = defaults.enhancedVpcRouting;
    	      this.hsmClientCertificateIdentifier = defaults.hsmClientCertificateIdentifier;
    	      this.hsmConfigurationIdentifier = defaults.hsmConfigurationIdentifier;
    	      this.iamRoles = defaults.iamRoles;
    	      this.kmsKeyId = defaults.kmsKeyId;
    	      this.loggingProperties = defaults.loggingProperties;
    	      this.maintenanceTrackName = defaults.maintenanceTrackName;
    	      this.manualSnapshotRetentionPeriod = defaults.manualSnapshotRetentionPeriod;
    	      this.masterUserPassword = defaults.masterUserPassword;
    	      this.masterUsername = defaults.masterUsername;
    	      this.nodeType = defaults.nodeType;
    	      this.numberOfNodes = defaults.numberOfNodes;
    	      this.ownerAccount = defaults.ownerAccount;
    	      this.port = defaults.port;
    	      this.preferredMaintenanceWindow = defaults.preferredMaintenanceWindow;
    	      this.publiclyAccessible = defaults.publiclyAccessible;
    	      this.resourceAction = defaults.resourceAction;
    	      this.revisionTarget = defaults.revisionTarget;
    	      this.rotateEncryptionKey = defaults.rotateEncryptionKey;
    	      this.snapshotClusterIdentifier = defaults.snapshotClusterIdentifier;
    	      this.snapshotCopyGrantName = defaults.snapshotCopyGrantName;
    	      this.snapshotCopyManual = defaults.snapshotCopyManual;
    	      this.snapshotCopyRetentionPeriod = defaults.snapshotCopyRetentionPeriod;
    	      this.snapshotIdentifier = defaults.snapshotIdentifier;
    	      this.tags = defaults.tags;
    	      this.vpcSecurityGroupIds = defaults.vpcSecurityGroupIds;
        }

        public Builder setAllowVersionUpgrade(@Nullable Input<Boolean> allowVersionUpgrade) {
            this.allowVersionUpgrade = allowVersionUpgrade;
            return this;
        }

        public Builder setAllowVersionUpgrade(@Nullable Boolean allowVersionUpgrade) {
            this.allowVersionUpgrade = Input.ofNullable(allowVersionUpgrade);
            return this;
        }

        public Builder setAquaConfigurationStatus(@Nullable Input<String> aquaConfigurationStatus) {
            this.aquaConfigurationStatus = aquaConfigurationStatus;
            return this;
        }

        public Builder setAquaConfigurationStatus(@Nullable String aquaConfigurationStatus) {
            this.aquaConfigurationStatus = Input.ofNullable(aquaConfigurationStatus);
            return this;
        }

        public Builder setAutomatedSnapshotRetentionPeriod(@Nullable Input<Integer> automatedSnapshotRetentionPeriod) {
            this.automatedSnapshotRetentionPeriod = automatedSnapshotRetentionPeriod;
            return this;
        }

        public Builder setAutomatedSnapshotRetentionPeriod(@Nullable Integer automatedSnapshotRetentionPeriod) {
            this.automatedSnapshotRetentionPeriod = Input.ofNullable(automatedSnapshotRetentionPeriod);
            return this;
        }

        public Builder setAvailabilityZone(@Nullable Input<String> availabilityZone) {
            this.availabilityZone = availabilityZone;
            return this;
        }

        public Builder setAvailabilityZone(@Nullable String availabilityZone) {
            this.availabilityZone = Input.ofNullable(availabilityZone);
            return this;
        }

        public Builder setAvailabilityZoneRelocation(@Nullable Input<Boolean> availabilityZoneRelocation) {
            this.availabilityZoneRelocation = availabilityZoneRelocation;
            return this;
        }

        public Builder setAvailabilityZoneRelocation(@Nullable Boolean availabilityZoneRelocation) {
            this.availabilityZoneRelocation = Input.ofNullable(availabilityZoneRelocation);
            return this;
        }

        public Builder setAvailabilityZoneRelocationStatus(@Nullable Input<String> availabilityZoneRelocationStatus) {
            this.availabilityZoneRelocationStatus = availabilityZoneRelocationStatus;
            return this;
        }

        public Builder setAvailabilityZoneRelocationStatus(@Nullable String availabilityZoneRelocationStatus) {
            this.availabilityZoneRelocationStatus = Input.ofNullable(availabilityZoneRelocationStatus);
            return this;
        }

        public Builder setClassic(@Nullable Input<Boolean> classic) {
            this.classic = classic;
            return this;
        }

        public Builder setClassic(@Nullable Boolean classic) {
            this.classic = Input.ofNullable(classic);
            return this;
        }

        public Builder setClusterIdentifier(@Nullable Input<String> clusterIdentifier) {
            this.clusterIdentifier = clusterIdentifier;
            return this;
        }

        public Builder setClusterIdentifier(@Nullable String clusterIdentifier) {
            this.clusterIdentifier = Input.ofNullable(clusterIdentifier);
            return this;
        }

        public Builder setClusterParameterGroupName(@Nullable Input<String> clusterParameterGroupName) {
            this.clusterParameterGroupName = clusterParameterGroupName;
            return this;
        }

        public Builder setClusterParameterGroupName(@Nullable String clusterParameterGroupName) {
            this.clusterParameterGroupName = Input.ofNullable(clusterParameterGroupName);
            return this;
        }

        public Builder setClusterSecurityGroups(@Nullable Input<List<String>> clusterSecurityGroups) {
            this.clusterSecurityGroups = clusterSecurityGroups;
            return this;
        }

        public Builder setClusterSecurityGroups(@Nullable List<String> clusterSecurityGroups) {
            this.clusterSecurityGroups = Input.ofNullable(clusterSecurityGroups);
            return this;
        }

        public Builder setClusterSubnetGroupName(@Nullable Input<String> clusterSubnetGroupName) {
            this.clusterSubnetGroupName = clusterSubnetGroupName;
            return this;
        }

        public Builder setClusterSubnetGroupName(@Nullable String clusterSubnetGroupName) {
            this.clusterSubnetGroupName = Input.ofNullable(clusterSubnetGroupName);
            return this;
        }

        public Builder setClusterType(Input<String> clusterType) {
            this.clusterType = Objects.requireNonNull(clusterType);
            return this;
        }

        public Builder setClusterType(String clusterType) {
            this.clusterType = Input.of(Objects.requireNonNull(clusterType));
            return this;
        }

        public Builder setClusterVersion(@Nullable Input<String> clusterVersion) {
            this.clusterVersion = clusterVersion;
            return this;
        }

        public Builder setClusterVersion(@Nullable String clusterVersion) {
            this.clusterVersion = Input.ofNullable(clusterVersion);
            return this;
        }

        public Builder setDBName(Input<String> dBName) {
            this.dBName = Objects.requireNonNull(dBName);
            return this;
        }

        public Builder setDBName(String dBName) {
            this.dBName = Input.of(Objects.requireNonNull(dBName));
            return this;
        }

        public Builder setDeferMaintenance(@Nullable Input<Boolean> deferMaintenance) {
            this.deferMaintenance = deferMaintenance;
            return this;
        }

        public Builder setDeferMaintenance(@Nullable Boolean deferMaintenance) {
            this.deferMaintenance = Input.ofNullable(deferMaintenance);
            return this;
        }

        public Builder setDeferMaintenanceDuration(@Nullable Input<Integer> deferMaintenanceDuration) {
            this.deferMaintenanceDuration = deferMaintenanceDuration;
            return this;
        }

        public Builder setDeferMaintenanceDuration(@Nullable Integer deferMaintenanceDuration) {
            this.deferMaintenanceDuration = Input.ofNullable(deferMaintenanceDuration);
            return this;
        }

        public Builder setDeferMaintenanceEndTime(@Nullable Input<String> deferMaintenanceEndTime) {
            this.deferMaintenanceEndTime = deferMaintenanceEndTime;
            return this;
        }

        public Builder setDeferMaintenanceEndTime(@Nullable String deferMaintenanceEndTime) {
            this.deferMaintenanceEndTime = Input.ofNullable(deferMaintenanceEndTime);
            return this;
        }

        public Builder setDeferMaintenanceStartTime(@Nullable Input<String> deferMaintenanceStartTime) {
            this.deferMaintenanceStartTime = deferMaintenanceStartTime;
            return this;
        }

        public Builder setDeferMaintenanceStartTime(@Nullable String deferMaintenanceStartTime) {
            this.deferMaintenanceStartTime = Input.ofNullable(deferMaintenanceStartTime);
            return this;
        }

        public Builder setDestinationRegion(@Nullable Input<String> destinationRegion) {
            this.destinationRegion = destinationRegion;
            return this;
        }

        public Builder setDestinationRegion(@Nullable String destinationRegion) {
            this.destinationRegion = Input.ofNullable(destinationRegion);
            return this;
        }

        public Builder setElasticIp(@Nullable Input<String> elasticIp) {
            this.elasticIp = elasticIp;
            return this;
        }

        public Builder setElasticIp(@Nullable String elasticIp) {
            this.elasticIp = Input.ofNullable(elasticIp);
            return this;
        }

        public Builder setEncrypted(@Nullable Input<Boolean> encrypted) {
            this.encrypted = encrypted;
            return this;
        }

        public Builder setEncrypted(@Nullable Boolean encrypted) {
            this.encrypted = Input.ofNullable(encrypted);
            return this;
        }

        public Builder setEndpoint(@Nullable Input<ClusterEndpointArgs> endpoint) {
            this.endpoint = endpoint;
            return this;
        }

        public Builder setEndpoint(@Nullable ClusterEndpointArgs endpoint) {
            this.endpoint = Input.ofNullable(endpoint);
            return this;
        }

        public Builder setEnhancedVpcRouting(@Nullable Input<Boolean> enhancedVpcRouting) {
            this.enhancedVpcRouting = enhancedVpcRouting;
            return this;
        }

        public Builder setEnhancedVpcRouting(@Nullable Boolean enhancedVpcRouting) {
            this.enhancedVpcRouting = Input.ofNullable(enhancedVpcRouting);
            return this;
        }

        public Builder setHsmClientCertificateIdentifier(@Nullable Input<String> hsmClientCertificateIdentifier) {
            this.hsmClientCertificateIdentifier = hsmClientCertificateIdentifier;
            return this;
        }

        public Builder setHsmClientCertificateIdentifier(@Nullable String hsmClientCertificateIdentifier) {
            this.hsmClientCertificateIdentifier = Input.ofNullable(hsmClientCertificateIdentifier);
            return this;
        }

        public Builder setHsmConfigurationIdentifier(@Nullable Input<String> hsmConfigurationIdentifier) {
            this.hsmConfigurationIdentifier = hsmConfigurationIdentifier;
            return this;
        }

        public Builder setHsmConfigurationIdentifier(@Nullable String hsmConfigurationIdentifier) {
            this.hsmConfigurationIdentifier = Input.ofNullable(hsmConfigurationIdentifier);
            return this;
        }

        public Builder setIamRoles(@Nullable Input<List<String>> iamRoles) {
            this.iamRoles = iamRoles;
            return this;
        }

        public Builder setIamRoles(@Nullable List<String> iamRoles) {
            this.iamRoles = Input.ofNullable(iamRoles);
            return this;
        }

        public Builder setKmsKeyId(@Nullable Input<String> kmsKeyId) {
            this.kmsKeyId = kmsKeyId;
            return this;
        }

        public Builder setKmsKeyId(@Nullable String kmsKeyId) {
            this.kmsKeyId = Input.ofNullable(kmsKeyId);
            return this;
        }

        public Builder setLoggingProperties(@Nullable Input<ClusterLoggingPropertiesArgs> loggingProperties) {
            this.loggingProperties = loggingProperties;
            return this;
        }

        public Builder setLoggingProperties(@Nullable ClusterLoggingPropertiesArgs loggingProperties) {
            this.loggingProperties = Input.ofNullable(loggingProperties);
            return this;
        }

        public Builder setMaintenanceTrackName(@Nullable Input<String> maintenanceTrackName) {
            this.maintenanceTrackName = maintenanceTrackName;
            return this;
        }

        public Builder setMaintenanceTrackName(@Nullable String maintenanceTrackName) {
            this.maintenanceTrackName = Input.ofNullable(maintenanceTrackName);
            return this;
        }

        public Builder setManualSnapshotRetentionPeriod(@Nullable Input<Integer> manualSnapshotRetentionPeriod) {
            this.manualSnapshotRetentionPeriod = manualSnapshotRetentionPeriod;
            return this;
        }

        public Builder setManualSnapshotRetentionPeriod(@Nullable Integer manualSnapshotRetentionPeriod) {
            this.manualSnapshotRetentionPeriod = Input.ofNullable(manualSnapshotRetentionPeriod);
            return this;
        }

        public Builder setMasterUserPassword(Input<String> masterUserPassword) {
            this.masterUserPassword = Objects.requireNonNull(masterUserPassword);
            return this;
        }

        public Builder setMasterUserPassword(String masterUserPassword) {
            this.masterUserPassword = Input.of(Objects.requireNonNull(masterUserPassword));
            return this;
        }

        public Builder setMasterUsername(Input<String> masterUsername) {
            this.masterUsername = Objects.requireNonNull(masterUsername);
            return this;
        }

        public Builder setMasterUsername(String masterUsername) {
            this.masterUsername = Input.of(Objects.requireNonNull(masterUsername));
            return this;
        }

        public Builder setNodeType(Input<String> nodeType) {
            this.nodeType = Objects.requireNonNull(nodeType);
            return this;
        }

        public Builder setNodeType(String nodeType) {
            this.nodeType = Input.of(Objects.requireNonNull(nodeType));
            return this;
        }

        public Builder setNumberOfNodes(@Nullable Input<Integer> numberOfNodes) {
            this.numberOfNodes = numberOfNodes;
            return this;
        }

        public Builder setNumberOfNodes(@Nullable Integer numberOfNodes) {
            this.numberOfNodes = Input.ofNullable(numberOfNodes);
            return this;
        }

        public Builder setOwnerAccount(@Nullable Input<String> ownerAccount) {
            this.ownerAccount = ownerAccount;
            return this;
        }

        public Builder setOwnerAccount(@Nullable String ownerAccount) {
            this.ownerAccount = Input.ofNullable(ownerAccount);
            return this;
        }

        public Builder setPort(@Nullable Input<Integer> port) {
            this.port = port;
            return this;
        }

        public Builder setPort(@Nullable Integer port) {
            this.port = Input.ofNullable(port);
            return this;
        }

        public Builder setPreferredMaintenanceWindow(@Nullable Input<String> preferredMaintenanceWindow) {
            this.preferredMaintenanceWindow = preferredMaintenanceWindow;
            return this;
        }

        public Builder setPreferredMaintenanceWindow(@Nullable String preferredMaintenanceWindow) {
            this.preferredMaintenanceWindow = Input.ofNullable(preferredMaintenanceWindow);
            return this;
        }

        public Builder setPubliclyAccessible(@Nullable Input<Boolean> publiclyAccessible) {
            this.publiclyAccessible = publiclyAccessible;
            return this;
        }

        public Builder setPubliclyAccessible(@Nullable Boolean publiclyAccessible) {
            this.publiclyAccessible = Input.ofNullable(publiclyAccessible);
            return this;
        }

        public Builder setResourceAction(@Nullable Input<String> resourceAction) {
            this.resourceAction = resourceAction;
            return this;
        }

        public Builder setResourceAction(@Nullable String resourceAction) {
            this.resourceAction = Input.ofNullable(resourceAction);
            return this;
        }

        public Builder setRevisionTarget(@Nullable Input<String> revisionTarget) {
            this.revisionTarget = revisionTarget;
            return this;
        }

        public Builder setRevisionTarget(@Nullable String revisionTarget) {
            this.revisionTarget = Input.ofNullable(revisionTarget);
            return this;
        }

        public Builder setRotateEncryptionKey(@Nullable Input<Boolean> rotateEncryptionKey) {
            this.rotateEncryptionKey = rotateEncryptionKey;
            return this;
        }

        public Builder setRotateEncryptionKey(@Nullable Boolean rotateEncryptionKey) {
            this.rotateEncryptionKey = Input.ofNullable(rotateEncryptionKey);
            return this;
        }

        public Builder setSnapshotClusterIdentifier(@Nullable Input<String> snapshotClusterIdentifier) {
            this.snapshotClusterIdentifier = snapshotClusterIdentifier;
            return this;
        }

        public Builder setSnapshotClusterIdentifier(@Nullable String snapshotClusterIdentifier) {
            this.snapshotClusterIdentifier = Input.ofNullable(snapshotClusterIdentifier);
            return this;
        }

        public Builder setSnapshotCopyGrantName(@Nullable Input<String> snapshotCopyGrantName) {
            this.snapshotCopyGrantName = snapshotCopyGrantName;
            return this;
        }

        public Builder setSnapshotCopyGrantName(@Nullable String snapshotCopyGrantName) {
            this.snapshotCopyGrantName = Input.ofNullable(snapshotCopyGrantName);
            return this;
        }

        public Builder setSnapshotCopyManual(@Nullable Input<Boolean> snapshotCopyManual) {
            this.snapshotCopyManual = snapshotCopyManual;
            return this;
        }

        public Builder setSnapshotCopyManual(@Nullable Boolean snapshotCopyManual) {
            this.snapshotCopyManual = Input.ofNullable(snapshotCopyManual);
            return this;
        }

        public Builder setSnapshotCopyRetentionPeriod(@Nullable Input<Integer> snapshotCopyRetentionPeriod) {
            this.snapshotCopyRetentionPeriod = snapshotCopyRetentionPeriod;
            return this;
        }

        public Builder setSnapshotCopyRetentionPeriod(@Nullable Integer snapshotCopyRetentionPeriod) {
            this.snapshotCopyRetentionPeriod = Input.ofNullable(snapshotCopyRetentionPeriod);
            return this;
        }

        public Builder setSnapshotIdentifier(@Nullable Input<String> snapshotIdentifier) {
            this.snapshotIdentifier = snapshotIdentifier;
            return this;
        }

        public Builder setSnapshotIdentifier(@Nullable String snapshotIdentifier) {
            this.snapshotIdentifier = Input.ofNullable(snapshotIdentifier);
            return this;
        }

        public Builder setTags(@Nullable Input<List<ClusterTagArgs>> tags) {
            this.tags = tags;
            return this;
        }

        public Builder setTags(@Nullable List<ClusterTagArgs> tags) {
            this.tags = Input.ofNullable(tags);
            return this;
        }

        public Builder setVpcSecurityGroupIds(@Nullable Input<List<String>> vpcSecurityGroupIds) {
            this.vpcSecurityGroupIds = vpcSecurityGroupIds;
            return this;
        }

        public Builder setVpcSecurityGroupIds(@Nullable List<String> vpcSecurityGroupIds) {
            this.vpcSecurityGroupIds = Input.ofNullable(vpcSecurityGroupIds);
            return this;
        }
        public ClusterArgs build() {
            return new ClusterArgs(allowVersionUpgrade, aquaConfigurationStatus, automatedSnapshotRetentionPeriod, availabilityZone, availabilityZoneRelocation, availabilityZoneRelocationStatus, classic, clusterIdentifier, clusterParameterGroupName, clusterSecurityGroups, clusterSubnetGroupName, clusterType, clusterVersion, dBName, deferMaintenance, deferMaintenanceDuration, deferMaintenanceEndTime, deferMaintenanceStartTime, destinationRegion, elasticIp, encrypted, endpoint, enhancedVpcRouting, hsmClientCertificateIdentifier, hsmConfigurationIdentifier, iamRoles, kmsKeyId, loggingProperties, maintenanceTrackName, manualSnapshotRetentionPeriod, masterUserPassword, masterUsername, nodeType, numberOfNodes, ownerAccount, port, preferredMaintenanceWindow, publiclyAccessible, resourceAction, revisionTarget, rotateEncryptionKey, snapshotClusterIdentifier, snapshotCopyGrantName, snapshotCopyManual, snapshotCopyRetentionPeriod, snapshotIdentifier, tags, vpcSecurityGroupIds);
        }
    }
}
