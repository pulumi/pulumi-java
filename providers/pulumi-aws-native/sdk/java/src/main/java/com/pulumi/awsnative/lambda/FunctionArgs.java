// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.awsnative.lambda;

import com.pulumi.awsnative.lambda.enums.FunctionArchitecturesItem;
import com.pulumi.awsnative.lambda.enums.FunctionPackageType;
import com.pulumi.awsnative.lambda.inputs.FunctionCodeArgs;
import com.pulumi.awsnative.lambda.inputs.FunctionDeadLetterConfigArgs;
import com.pulumi.awsnative.lambda.inputs.FunctionEnvironmentArgs;
import com.pulumi.awsnative.lambda.inputs.FunctionFileSystemConfigArgs;
import com.pulumi.awsnative.lambda.inputs.FunctionImageConfigArgs;
import com.pulumi.awsnative.lambda.inputs.FunctionTagArgs;
import com.pulumi.awsnative.lambda.inputs.FunctionTracingConfigArgs;
import com.pulumi.awsnative.lambda.inputs.FunctionVpcConfigArgs;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class FunctionArgs extends com.pulumi.resources.ResourceArgs {

    public static final FunctionArgs Empty = new FunctionArgs();

    @Import(name="architectures")
    private @Nullable Output<List<FunctionArchitecturesItem>> architectures;

    public Optional<Output<List<FunctionArchitecturesItem>>> architectures() {
        return Optional.ofNullable(this.architectures);
    }

    /**
     * The code for the function.
     * 
     */
    @Import(name="code", required=true)
    private Output<FunctionCodeArgs> code;

    public Output<FunctionCodeArgs> code() {
        return this.code;
    }

    /**
     * A unique Arn for CodeSigningConfig resource
     * 
     */
    @Import(name="codeSigningConfigArn")
    private @Nullable Output<String> codeSigningConfigArn;

    public Optional<Output<String>> codeSigningConfigArn() {
        return Optional.ofNullable(this.codeSigningConfigArn);
    }

    /**
     * A dead letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events when they fail processing.
     * 
     */
    @Import(name="deadLetterConfig")
    private @Nullable Output<FunctionDeadLetterConfigArgs> deadLetterConfig;

    public Optional<Output<FunctionDeadLetterConfigArgs>> deadLetterConfig() {
        return Optional.ofNullable(this.deadLetterConfig);
    }

    /**
     * A description of the function.
     * 
     */
    @Import(name="description")
    private @Nullable Output<String> description;

    public Optional<Output<String>> description() {
        return Optional.ofNullable(this.description);
    }

    /**
     * Environment variables that are accessible from function code during execution.
     * 
     */
    @Import(name="environment")
    private @Nullable Output<FunctionEnvironmentArgs> environment;

    public Optional<Output<FunctionEnvironmentArgs>> environment() {
        return Optional.ofNullable(this.environment);
    }

    /**
     * Connection settings for an Amazon EFS file system. To connect a function to a file system, a mount target must be available in every Availability Zone that your function connects to. If your template contains an AWS::EFS::MountTarget resource, you must also specify a DependsOn attribute to ensure that the mount target is created or updated before the function.
     * 
     */
    @Import(name="fileSystemConfigs")
    private @Nullable Output<List<FunctionFileSystemConfigArgs>> fileSystemConfigs;

    public Optional<Output<List<FunctionFileSystemConfigArgs>>> fileSystemConfigs() {
        return Optional.ofNullable(this.fileSystemConfigs);
    }

    /**
     * The name of the Lambda function, up to 64 characters in length. If you don&#39;t specify a name, AWS CloudFormation generates one.
     * 
     */
    @Import(name="functionName")
    private @Nullable Output<String> functionName;

    public Optional<Output<String>> functionName() {
        return Optional.ofNullable(this.functionName);
    }

    /**
     * The name of the method within your code that Lambda calls to execute your function. The format includes the file name. It can also include namespaces and other qualifiers, depending on the runtime
     * 
     */
    @Import(name="handler")
    private @Nullable Output<String> handler;

    public Optional<Output<String>> handler() {
        return Optional.ofNullable(this.handler);
    }

    /**
     * ImageConfig
     * 
     */
    @Import(name="imageConfig")
    private @Nullable Output<FunctionImageConfigArgs> imageConfig;

    public Optional<Output<FunctionImageConfigArgs>> imageConfig() {
        return Optional.ofNullable(this.imageConfig);
    }

    /**
     * The ARN of the AWS Key Management Service (AWS KMS) key that&#39;s used to encrypt your function&#39;s environment variables. If it&#39;s not provided, AWS Lambda uses a default service key.
     * 
     */
    @Import(name="kmsKeyArn")
    private @Nullable Output<String> kmsKeyArn;

    public Optional<Output<String>> kmsKeyArn() {
        return Optional.ofNullable(this.kmsKeyArn);
    }

    /**
     * A list of function layers to add to the function&#39;s execution environment. Specify each layer by its ARN, including the version.
     * 
     */
    @Import(name="layers")
    private @Nullable Output<List<String>> layers;

    public Optional<Output<List<String>>> layers() {
        return Optional.ofNullable(this.layers);
    }

    /**
     * The amount of memory that your function has access to. Increasing the function&#39;s memory also increases its CPU allocation. The default value is 128 MB. The value must be a multiple of 64 MB.
     * 
     */
    @Import(name="memorySize")
    private @Nullable Output<Integer> memorySize;

    public Optional<Output<Integer>> memorySize() {
        return Optional.ofNullable(this.memorySize);
    }

    /**
     * PackageType.
     * 
     */
    @Import(name="packageType")
    private @Nullable Output<FunctionPackageType> packageType;

    public Optional<Output<FunctionPackageType>> packageType() {
        return Optional.ofNullable(this.packageType);
    }

    /**
     * The number of simultaneous executions to reserve for the function.
     * 
     */
    @Import(name="reservedConcurrentExecutions")
    private @Nullable Output<Integer> reservedConcurrentExecutions;

    public Optional<Output<Integer>> reservedConcurrentExecutions() {
        return Optional.ofNullable(this.reservedConcurrentExecutions);
    }

    /**
     * The Amazon Resource Name (ARN) of the function&#39;s execution role.
     * 
     */
    @Import(name="role", required=true)
    private Output<String> role;

    public Output<String> role() {
        return this.role;
    }

    /**
     * The identifier of the function&#39;s runtime.
     * 
     */
    @Import(name="runtime")
    private @Nullable Output<String> runtime;

    public Optional<Output<String>> runtime() {
        return Optional.ofNullable(this.runtime);
    }

    /**
     * A list of tags to apply to the function.
     * 
     */
    @Import(name="tags")
    private @Nullable Output<List<FunctionTagArgs>> tags;

    public Optional<Output<List<FunctionTagArgs>>> tags() {
        return Optional.ofNullable(this.tags);
    }

    /**
     * The amount of time that Lambda allows a function to run before stopping it. The default is 3 seconds. The maximum allowed value is 900 seconds.
     * 
     */
    @Import(name="timeout")
    private @Nullable Output<Integer> timeout;

    public Optional<Output<Integer>> timeout() {
        return Optional.ofNullable(this.timeout);
    }

    /**
     * Set Mode to Active to sample and trace a subset of incoming requests with AWS X-Ray.
     * 
     */
    @Import(name="tracingConfig")
    private @Nullable Output<FunctionTracingConfigArgs> tracingConfig;

    public Optional<Output<FunctionTracingConfigArgs>> tracingConfig() {
        return Optional.ofNullable(this.tracingConfig);
    }

    /**
     * For network connectivity to AWS resources in a VPC, specify a list of security groups and subnets in the VPC.
     * 
     */
    @Import(name="vpcConfig")
    private @Nullable Output<FunctionVpcConfigArgs> vpcConfig;

    public Optional<Output<FunctionVpcConfigArgs>> vpcConfig() {
        return Optional.ofNullable(this.vpcConfig);
    }

    private FunctionArgs() {}

    private FunctionArgs(FunctionArgs $) {
        this.architectures = $.architectures;
        this.code = $.code;
        this.codeSigningConfigArn = $.codeSigningConfigArn;
        this.deadLetterConfig = $.deadLetterConfig;
        this.description = $.description;
        this.environment = $.environment;
        this.fileSystemConfigs = $.fileSystemConfigs;
        this.functionName = $.functionName;
        this.handler = $.handler;
        this.imageConfig = $.imageConfig;
        this.kmsKeyArn = $.kmsKeyArn;
        this.layers = $.layers;
        this.memorySize = $.memorySize;
        this.packageType = $.packageType;
        this.reservedConcurrentExecutions = $.reservedConcurrentExecutions;
        this.role = $.role;
        this.runtime = $.runtime;
        this.tags = $.tags;
        this.timeout = $.timeout;
        this.tracingConfig = $.tracingConfig;
        this.vpcConfig = $.vpcConfig;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(FunctionArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private FunctionArgs $;

        public Builder() {
            $ = new FunctionArgs();
        }

        public Builder(FunctionArgs defaults) {
            $ = new FunctionArgs(Objects.requireNonNull(defaults));
        }

        public Builder architectures(@Nullable Output<List<FunctionArchitecturesItem>> architectures) {
            $.architectures = architectures;
            return this;
        }

        public Builder architectures(List<FunctionArchitecturesItem> architectures) {
            return architectures(Output.of(architectures));
        }

        public Builder architectures(FunctionArchitecturesItem... architectures) {
            return architectures(List.of(architectures));
        }

        public Builder code(Output<FunctionCodeArgs> code) {
            $.code = code;
            return this;
        }

        public Builder code(FunctionCodeArgs code) {
            return code(Output.of(code));
        }

        public Builder codeSigningConfigArn(@Nullable Output<String> codeSigningConfigArn) {
            $.codeSigningConfigArn = codeSigningConfigArn;
            return this;
        }

        public Builder codeSigningConfigArn(String codeSigningConfigArn) {
            return codeSigningConfigArn(Output.of(codeSigningConfigArn));
        }

        public Builder deadLetterConfig(@Nullable Output<FunctionDeadLetterConfigArgs> deadLetterConfig) {
            $.deadLetterConfig = deadLetterConfig;
            return this;
        }

        public Builder deadLetterConfig(FunctionDeadLetterConfigArgs deadLetterConfig) {
            return deadLetterConfig(Output.of(deadLetterConfig));
        }

        public Builder description(@Nullable Output<String> description) {
            $.description = description;
            return this;
        }

        public Builder description(String description) {
            return description(Output.of(description));
        }

        public Builder environment(@Nullable Output<FunctionEnvironmentArgs> environment) {
            $.environment = environment;
            return this;
        }

        public Builder environment(FunctionEnvironmentArgs environment) {
            return environment(Output.of(environment));
        }

        public Builder fileSystemConfigs(@Nullable Output<List<FunctionFileSystemConfigArgs>> fileSystemConfigs) {
            $.fileSystemConfigs = fileSystemConfigs;
            return this;
        }

        public Builder fileSystemConfigs(List<FunctionFileSystemConfigArgs> fileSystemConfigs) {
            return fileSystemConfigs(Output.of(fileSystemConfigs));
        }

        public Builder fileSystemConfigs(FunctionFileSystemConfigArgs... fileSystemConfigs) {
            return fileSystemConfigs(List.of(fileSystemConfigs));
        }

        public Builder functionName(@Nullable Output<String> functionName) {
            $.functionName = functionName;
            return this;
        }

        public Builder functionName(String functionName) {
            return functionName(Output.of(functionName));
        }

        public Builder handler(@Nullable Output<String> handler) {
            $.handler = handler;
            return this;
        }

        public Builder handler(String handler) {
            return handler(Output.of(handler));
        }

        public Builder imageConfig(@Nullable Output<FunctionImageConfigArgs> imageConfig) {
            $.imageConfig = imageConfig;
            return this;
        }

        public Builder imageConfig(FunctionImageConfigArgs imageConfig) {
            return imageConfig(Output.of(imageConfig));
        }

        public Builder kmsKeyArn(@Nullable Output<String> kmsKeyArn) {
            $.kmsKeyArn = kmsKeyArn;
            return this;
        }

        public Builder kmsKeyArn(String kmsKeyArn) {
            return kmsKeyArn(Output.of(kmsKeyArn));
        }

        public Builder layers(@Nullable Output<List<String>> layers) {
            $.layers = layers;
            return this;
        }

        public Builder layers(List<String> layers) {
            return layers(Output.of(layers));
        }

        public Builder layers(String... layers) {
            return layers(List.of(layers));
        }

        public Builder memorySize(@Nullable Output<Integer> memorySize) {
            $.memorySize = memorySize;
            return this;
        }

        public Builder memorySize(Integer memorySize) {
            return memorySize(Output.of(memorySize));
        }

        public Builder packageType(@Nullable Output<FunctionPackageType> packageType) {
            $.packageType = packageType;
            return this;
        }

        public Builder packageType(FunctionPackageType packageType) {
            return packageType(Output.of(packageType));
        }

        public Builder reservedConcurrentExecutions(@Nullable Output<Integer> reservedConcurrentExecutions) {
            $.reservedConcurrentExecutions = reservedConcurrentExecutions;
            return this;
        }

        public Builder reservedConcurrentExecutions(Integer reservedConcurrentExecutions) {
            return reservedConcurrentExecutions(Output.of(reservedConcurrentExecutions));
        }

        public Builder role(Output<String> role) {
            $.role = role;
            return this;
        }

        public Builder role(String role) {
            return role(Output.of(role));
        }

        public Builder runtime(@Nullable Output<String> runtime) {
            $.runtime = runtime;
            return this;
        }

        public Builder runtime(String runtime) {
            return runtime(Output.of(runtime));
        }

        public Builder tags(@Nullable Output<List<FunctionTagArgs>> tags) {
            $.tags = tags;
            return this;
        }

        public Builder tags(List<FunctionTagArgs> tags) {
            return tags(Output.of(tags));
        }

        public Builder tags(FunctionTagArgs... tags) {
            return tags(List.of(tags));
        }

        public Builder timeout(@Nullable Output<Integer> timeout) {
            $.timeout = timeout;
            return this;
        }

        public Builder timeout(Integer timeout) {
            return timeout(Output.of(timeout));
        }

        public Builder tracingConfig(@Nullable Output<FunctionTracingConfigArgs> tracingConfig) {
            $.tracingConfig = tracingConfig;
            return this;
        }

        public Builder tracingConfig(FunctionTracingConfigArgs tracingConfig) {
            return tracingConfig(Output.of(tracingConfig));
        }

        public Builder vpcConfig(@Nullable Output<FunctionVpcConfigArgs> vpcConfig) {
            $.vpcConfig = vpcConfig;
            return this;
        }

        public Builder vpcConfig(FunctionVpcConfigArgs vpcConfig) {
            return vpcConfig(Output.of(vpcConfig));
        }

        public FunctionArgs build() {
            $.code = Objects.requireNonNull($.code, "expected parameter 'code' to be non-null");
            $.role = Objects.requireNonNull($.role, "expected parameter 'role' to be non-null");
            return $;
        }
    }

}
