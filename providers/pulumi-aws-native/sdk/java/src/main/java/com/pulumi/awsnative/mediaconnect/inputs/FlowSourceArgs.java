// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.awsnative.mediaconnect.inputs;

import com.pulumi.awsnative.mediaconnect.enums.FlowSourceProtocol;
import com.pulumi.awsnative.mediaconnect.inputs.FlowEncryptionArgs;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Integer;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


/**
 * The settings for the source of the flow.
 * 
 */
public final class FlowSourceArgs extends com.pulumi.resources.ResourceArgs {

    public static final FlowSourceArgs Empty = new FlowSourceArgs();

    /**
     * The type of decryption that is used on the content ingested from this source.
     * 
     */
    @Import(name="decryption")
    private @Nullable Output<FlowEncryptionArgs> decryption;

    public Optional<Output<FlowEncryptionArgs>> decryption() {
        return Optional.ofNullable(this.decryption);
    }

    /**
     * A description for the source. This value is not used or seen outside of the current AWS Elemental MediaConnect account.
     * 
     */
    @Import(name="description")
    private @Nullable Output<String> description;

    public Optional<Output<String>> description() {
        return Optional.ofNullable(this.description);
    }

    /**
     * The ARN of the entitlement that allows you to subscribe to content that comes from another AWS account. The entitlement is set by the content originator and the ARN is generated as part of the originator&#39;s flow.
     * 
     */
    @Import(name="entitlementArn")
    private @Nullable Output<String> entitlementArn;

    public Optional<Output<String>> entitlementArn() {
        return Optional.ofNullable(this.entitlementArn);
    }

    /**
     * The IP address that the flow will be listening on for incoming content.
     * 
     */
    @Import(name="ingestIp")
    private @Nullable Output<String> ingestIp;

    public Optional<Output<String>> ingestIp() {
        return Optional.ofNullable(this.ingestIp);
    }

    /**
     * The port that the flow will be listening on for incoming content.
     * 
     */
    @Import(name="ingestPort")
    private @Nullable Output<Integer> ingestPort;

    public Optional<Output<Integer>> ingestPort() {
        return Optional.ofNullable(this.ingestPort);
    }

    /**
     * The smoothing max bitrate for RIST, RTP, and RTP-FEC streams.
     * 
     */
    @Import(name="maxBitrate")
    private @Nullable Output<Integer> maxBitrate;

    public Optional<Output<Integer>> maxBitrate() {
        return Optional.ofNullable(this.maxBitrate);
    }

    /**
     * The maximum latency in milliseconds. This parameter applies only to RIST-based and Zixi-based streams.
     * 
     */
    @Import(name="maxLatency")
    private @Nullable Output<Integer> maxLatency;

    public Optional<Output<Integer>> maxLatency() {
        return Optional.ofNullable(this.maxLatency);
    }

    /**
     * The minimum latency in milliseconds.
     * 
     */
    @Import(name="minLatency")
    private @Nullable Output<Integer> minLatency;

    public Optional<Output<Integer>> minLatency() {
        return Optional.ofNullable(this.minLatency);
    }

    /**
     * The name of the source.
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * The protocol that is used by the source or output.
     * 
     */
    @Import(name="protocol")
    private @Nullable Output<FlowSourceProtocol> protocol;

    public Optional<Output<FlowSourceProtocol>> protocol() {
        return Optional.ofNullable(this.protocol);
    }

    /**
     * The ARN of the source.
     * 
     */
    @Import(name="sourceArn")
    private @Nullable Output<String> sourceArn;

    public Optional<Output<String>> sourceArn() {
        return Optional.ofNullable(this.sourceArn);
    }

    /**
     * The port that the flow will be listening on for incoming content.(ReadOnly)
     * 
     */
    @Import(name="sourceIngestPort")
    private @Nullable Output<String> sourceIngestPort;

    public Optional<Output<String>> sourceIngestPort() {
        return Optional.ofNullable(this.sourceIngestPort);
    }

    /**
     * The stream ID that you want to use for this transport. This parameter applies only to Zixi-based streams.
     * 
     */
    @Import(name="streamId")
    private @Nullable Output<String> streamId;

    public Optional<Output<String>> streamId() {
        return Optional.ofNullable(this.streamId);
    }

    /**
     * The name of the VPC Interface this Source is configured with.
     * 
     */
    @Import(name="vpcInterfaceName")
    private @Nullable Output<String> vpcInterfaceName;

    public Optional<Output<String>> vpcInterfaceName() {
        return Optional.ofNullable(this.vpcInterfaceName);
    }

    /**
     * The range of IP addresses that should be allowed to contribute content to your source. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
     * 
     */
    @Import(name="whitelistCidr")
    private @Nullable Output<String> whitelistCidr;

    public Optional<Output<String>> whitelistCidr() {
        return Optional.ofNullable(this.whitelistCidr);
    }

    private FlowSourceArgs() {}

    private FlowSourceArgs(FlowSourceArgs $) {
        this.decryption = $.decryption;
        this.description = $.description;
        this.entitlementArn = $.entitlementArn;
        this.ingestIp = $.ingestIp;
        this.ingestPort = $.ingestPort;
        this.maxBitrate = $.maxBitrate;
        this.maxLatency = $.maxLatency;
        this.minLatency = $.minLatency;
        this.name = $.name;
        this.protocol = $.protocol;
        this.sourceArn = $.sourceArn;
        this.sourceIngestPort = $.sourceIngestPort;
        this.streamId = $.streamId;
        this.vpcInterfaceName = $.vpcInterfaceName;
        this.whitelistCidr = $.whitelistCidr;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(FlowSourceArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private FlowSourceArgs $;

        public Builder() {
            $ = new FlowSourceArgs();
        }

        public Builder(FlowSourceArgs defaults) {
            $ = new FlowSourceArgs(Objects.requireNonNull(defaults));
        }

        public Builder decryption(@Nullable Output<FlowEncryptionArgs> decryption) {
            $.decryption = decryption;
            return this;
        }

        public Builder decryption(FlowEncryptionArgs decryption) {
            return decryption(Output.of(decryption));
        }

        public Builder description(@Nullable Output<String> description) {
            $.description = description;
            return this;
        }

        public Builder description(String description) {
            return description(Output.of(description));
        }

        public Builder entitlementArn(@Nullable Output<String> entitlementArn) {
            $.entitlementArn = entitlementArn;
            return this;
        }

        public Builder entitlementArn(String entitlementArn) {
            return entitlementArn(Output.of(entitlementArn));
        }

        public Builder ingestIp(@Nullable Output<String> ingestIp) {
            $.ingestIp = ingestIp;
            return this;
        }

        public Builder ingestIp(String ingestIp) {
            return ingestIp(Output.of(ingestIp));
        }

        public Builder ingestPort(@Nullable Output<Integer> ingestPort) {
            $.ingestPort = ingestPort;
            return this;
        }

        public Builder ingestPort(Integer ingestPort) {
            return ingestPort(Output.of(ingestPort));
        }

        public Builder maxBitrate(@Nullable Output<Integer> maxBitrate) {
            $.maxBitrate = maxBitrate;
            return this;
        }

        public Builder maxBitrate(Integer maxBitrate) {
            return maxBitrate(Output.of(maxBitrate));
        }

        public Builder maxLatency(@Nullable Output<Integer> maxLatency) {
            $.maxLatency = maxLatency;
            return this;
        }

        public Builder maxLatency(Integer maxLatency) {
            return maxLatency(Output.of(maxLatency));
        }

        public Builder minLatency(@Nullable Output<Integer> minLatency) {
            $.minLatency = minLatency;
            return this;
        }

        public Builder minLatency(Integer minLatency) {
            return minLatency(Output.of(minLatency));
        }

        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        public Builder name(String name) {
            return name(Output.of(name));
        }

        public Builder protocol(@Nullable Output<FlowSourceProtocol> protocol) {
            $.protocol = protocol;
            return this;
        }

        public Builder protocol(FlowSourceProtocol protocol) {
            return protocol(Output.of(protocol));
        }

        public Builder sourceArn(@Nullable Output<String> sourceArn) {
            $.sourceArn = sourceArn;
            return this;
        }

        public Builder sourceArn(String sourceArn) {
            return sourceArn(Output.of(sourceArn));
        }

        public Builder sourceIngestPort(@Nullable Output<String> sourceIngestPort) {
            $.sourceIngestPort = sourceIngestPort;
            return this;
        }

        public Builder sourceIngestPort(String sourceIngestPort) {
            return sourceIngestPort(Output.of(sourceIngestPort));
        }

        public Builder streamId(@Nullable Output<String> streamId) {
            $.streamId = streamId;
            return this;
        }

        public Builder streamId(String streamId) {
            return streamId(Output.of(streamId));
        }

        public Builder vpcInterfaceName(@Nullable Output<String> vpcInterfaceName) {
            $.vpcInterfaceName = vpcInterfaceName;
            return this;
        }

        public Builder vpcInterfaceName(String vpcInterfaceName) {
            return vpcInterfaceName(Output.of(vpcInterfaceName));
        }

        public Builder whitelistCidr(@Nullable Output<String> whitelistCidr) {
            $.whitelistCidr = whitelistCidr;
            return this;
        }

        public Builder whitelistCidr(String whitelistCidr) {
            return whitelistCidr(Output.of(whitelistCidr));
        }

        public FlowSourceArgs build() {
            return $;
        }
    }

}
