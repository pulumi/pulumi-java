// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.oci.DataSafe.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Double;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class LibraryMasingFormatFormatEntryArgs extends com.pulumi.resources.ResourceArgs {

    public static final LibraryMasingFormatFormatEntryArgs Empty = new LibraryMasingFormatFormatEntryArgs();

    /**
     * (Updatable) The name of the substitution column.
     * 
     */
    @Import(name="columnName")
    private @Nullable Output<String> columnName;

    /**
     * @return (Updatable) The name of the substitution column.
     * 
     */
    public Optional<Output<String>> columnName() {
        return Optional.ofNullable(this.columnName);
    }

    /**
     * (Updatable) The description of the format entry.
     * 
     */
    @Import(name="description")
    private @Nullable Output<String> description;

    /**
     * @return (Updatable) The description of the format entry.
     * 
     */
    public Optional<Output<String>> description() {
        return Optional.ofNullable(this.description);
    }

    /**
     * (Updatable) The upper bound of the range within which all the original column values fall. The end date must be greater than or equal to the start date.
     * 
     */
    @Import(name="endDate")
    private @Nullable Output<String> endDate;

    /**
     * @return (Updatable) The upper bound of the range within which all the original column values fall. The end date must be greater than or equal to the start date.
     * 
     */
    public Optional<Output<String>> endDate() {
        return Optional.ofNullable(this.endDate);
    }

    /**
     * (Updatable) The maximum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be greater than or equal to  the start length.
     * 
     */
    @Import(name="endLength")
    private @Nullable Output<Integer> endLength;

    /**
     * @return (Updatable) The maximum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be greater than or equal to  the start length.
     * 
     */
    public Optional<Output<Integer>> endLength() {
        return Optional.ofNullable(this.endLength);
    }

    /**
     * (Updatable) The upper bound of the range within which random decimal numbers should be generated. It must be greater than or equal to the start value. It supports  input of double type.
     * 
     */
    @Import(name="endValue")
    private @Nullable Output<Double> endValue;

    /**
     * @return (Updatable) The upper bound of the range within which random decimal numbers should be generated. It must be greater than or equal to the start value. It supports  input of double type.
     * 
     */
    public Optional<Output<Double>> endValue() {
        return Optional.ofNullable(this.endValue);
    }

    /**
     * (Updatable) The constant number to be used for masking.
     * 
     */
    @Import(name="fixedNumber")
    private @Nullable Output<Double> fixedNumber;

    /**
     * @return (Updatable) The constant number to be used for masking.
     * 
     */
    public Optional<Output<Double>> fixedNumber() {
        return Optional.ofNullable(this.fixedNumber);
    }

    /**
     * (Updatable) The constant string to be used for masking.
     * 
     */
    @Import(name="fixedString")
    private @Nullable Output<String> fixedString;

    /**
     * @return (Updatable) The constant string to be used for masking.
     * 
     */
    public Optional<Output<String>> fixedString() {
        return Optional.ofNullable(this.fixedString);
    }

    /**
     * (Updatable) One or more reference columns to be used to group column values so that they can be shuffled within their own group. The grouping columns and  the column to be masked must belong to the same table.
     * 
     */
    @Import(name="groupingColumns")
    private @Nullable Output<List<String>> groupingColumns;

    /**
     * @return (Updatable) One or more reference columns to be used to group column values so that they can be shuffled within their own group. The grouping columns and  the column to be masked must belong to the same table.
     * 
     */
    public Optional<Output<List<String>>> groupingColumns() {
        return Optional.ofNullable(this.groupingColumns);
    }

    /**
     * (Updatable) The number of characters that should be there in the substring. It should be an integer and greater than zero.
     * 
     */
    @Import(name="length")
    private @Nullable Output<Integer> length;

    /**
     * @return (Updatable) The number of characters that should be there in the substring. It should be an integer and greater than zero.
     * 
     */
    public Optional<Output<Integer>> length() {
        return Optional.ofNullable(this.length);
    }

    /**
     * (Updatable) The OCID of the library masking format.
     * 
     */
    @Import(name="libraryMaskingFormatId")
    private @Nullable Output<String> libraryMaskingFormatId;

    /**
     * @return (Updatable) The OCID of the library masking format.
     * 
     */
    public Optional<Output<String>> libraryMaskingFormatId() {
        return Optional.ofNullable(this.libraryMaskingFormatId);
    }

    /**
     * (Updatable) The post processing function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format. It can be a standalone or packaged function, so PACKAGE_NAME is optional.
     * 
     */
    @Import(name="postProcessingFunction")
    private @Nullable Output<String> postProcessingFunction;

    /**
     * @return (Updatable) The post processing function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format. It can be a standalone or packaged function, so PACKAGE_NAME is optional.
     * 
     */
    public Optional<Output<String>> postProcessingFunction() {
        return Optional.ofNullable(this.postProcessingFunction);
    }

    /**
     * (Updatable) A comma-separated list of values to be used to replace column values. The list can be of strings, numbers, or dates. The data type of each value in the list must be compatible with the data type of the column. The number of entries in the list cannot be more than 999.
     * 
     */
    @Import(name="randomLists")
    private @Nullable Output<List<String>> randomLists;

    /**
     * @return (Updatable) A comma-separated list of values to be used to replace column values. The list can be of strings, numbers, or dates. The data type of each value in the list must be compatible with the data type of the column. The number of entries in the list cannot be more than 999.
     * 
     */
    public Optional<Output<List<String>>> randomLists() {
        return Optional.ofNullable(this.randomLists);
    }

    /**
     * (Updatable) The regular expression to be used for masking. For data with characters in the ASCII character set, providing a regular expression is optional. However, it  is required if the data contains multi-byte characters. If not provided, an  error is returned when a multi-byte character is found.
     * 
     */
    @Import(name="regularExpression")
    private @Nullable Output<String> regularExpression;

    /**
     * @return (Updatable) The regular expression to be used for masking. For data with characters in the ASCII character set, providing a regular expression is optional. However, it  is required if the data contains multi-byte characters. If not provided, an  error is returned when a multi-byte character is found.
     * 
     */
    public Optional<Output<String>> regularExpression() {
        return Optional.ofNullable(this.regularExpression);
    }

    /**
     * (Updatable) The value that should be used to replace the data matching the regular  expression. It can be a fixed string, fixed number, null value, or  SQL expression.
     * 
     */
    @Import(name="replaceWith")
    private @Nullable Output<String> replaceWith;

    /**
     * @return (Updatable) The value that should be used to replace the data matching the regular  expression. It can be a fixed string, fixed number, null value, or  SQL expression.
     * 
     */
    public Optional<Output<String>> replaceWith() {
        return Optional.ofNullable(this.replaceWith);
    }

    /**
     * (Updatable) The name of the schema that contains the substitution column.
     * 
     */
    @Import(name="schemaName")
    private @Nullable Output<String> schemaName;

    /**
     * @return (Updatable) The name of the schema that contains the substitution column.
     * 
     */
    public Optional<Output<String>> schemaName() {
        return Optional.ofNullable(this.schemaName);
    }

    /**
     * (Updatable) The SQL expression to be used to generate the masked values. It can  consist of one or more values, operators, and SQL functions that  evaluate to a value. It can also contain substitution columns from  the same table. Specify the substitution columns within percent (%)  symbols.
     * 
     */
    @Import(name="sqlExpression")
    private @Nullable Output<String> sqlExpression;

    /**
     * @return (Updatable) The SQL expression to be used to generate the masked values. It can  consist of one or more values, operators, and SQL functions that  evaluate to a value. It can also contain substitution columns from  the same table. Specify the substitution columns within percent (%)  symbols.
     * 
     */
    public Optional<Output<String>> sqlExpression() {
        return Optional.ofNullable(this.sqlExpression);
    }

    /**
     * (Updatable) The lower bound of the range within which all the original column values fall. The start date must be less than or equal to the end date.
     * 
     */
    @Import(name="startDate")
    private @Nullable Output<String> startDate;

    /**
     * @return (Updatable) The lower bound of the range within which all the original column values fall. The start date must be less than or equal to the end date.
     * 
     */
    public Optional<Output<String>> startDate() {
        return Optional.ofNullable(this.startDate);
    }

    /**
     * (Updatable) The minimum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be less than or equal to the  end length.
     * 
     */
    @Import(name="startLength")
    private @Nullable Output<Integer> startLength;

    /**
     * @return (Updatable) The minimum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be less than or equal to the  end length.
     * 
     */
    public Optional<Output<Integer>> startLength() {
        return Optional.ofNullable(this.startLength);
    }

    /**
     * (Updatable) The starting position in the original string from where the substring should be extracted. It can be either a positive or a negative integer. If It&#39;s negative, the counting starts from the end of the string.
     * 
     */
    @Import(name="startPosition")
    private @Nullable Output<Integer> startPosition;

    /**
     * @return (Updatable) The starting position in the original string from where the substring should be extracted. It can be either a positive or a negative integer. If It&#39;s negative, the counting starts from the end of the string.
     * 
     */
    public Optional<Output<Integer>> startPosition() {
        return Optional.ofNullable(this.startPosition);
    }

    /**
     * (Updatable) The lower bound of the range within which random decimal numbers should  be generated. It must be less than or equal to the end value. It supports  input of double type.
     * 
     */
    @Import(name="startValue")
    private @Nullable Output<Double> startValue;

    /**
     * @return (Updatable) The lower bound of the range within which random decimal numbers should  be generated. It must be less than or equal to the end value. It supports  input of double type.
     * 
     */
    public Optional<Output<Double>> startValue() {
        return Optional.ofNullable(this.startValue);
    }

    /**
     * (Updatable) The name of the table that contains the substitution column.
     * 
     */
    @Import(name="tableName")
    private @Nullable Output<String> tableName;

    /**
     * @return (Updatable) The name of the table that contains the substitution column.
     * 
     */
    public Optional<Output<String>> tableName() {
        return Optional.ofNullable(this.tableName);
    }

    /**
     * (Updatable) The type of the format entry.
     * 
     */
    @Import(name="type", required=true)
    private Output<String> type;

    /**
     * @return (Updatable) The type of the format entry.
     * 
     */
    public Output<String> type() {
        return this.type;
    }

    /**
     * (Updatable) The user-defined function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format.  It can be a standalone or packaged function, so PACKAGE_NAME is optional.
     * 
     */
    @Import(name="userDefinedFunction")
    private @Nullable Output<String> userDefinedFunction;

    /**
     * @return (Updatable) The user-defined function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format.  It can be a standalone or packaged function, so PACKAGE_NAME is optional.
     * 
     */
    public Optional<Output<String>> userDefinedFunction() {
        return Optional.ofNullable(this.userDefinedFunction);
    }

    private LibraryMasingFormatFormatEntryArgs() {}

    private LibraryMasingFormatFormatEntryArgs(LibraryMasingFormatFormatEntryArgs $) {
        this.columnName = $.columnName;
        this.description = $.description;
        this.endDate = $.endDate;
        this.endLength = $.endLength;
        this.endValue = $.endValue;
        this.fixedNumber = $.fixedNumber;
        this.fixedString = $.fixedString;
        this.groupingColumns = $.groupingColumns;
        this.length = $.length;
        this.libraryMaskingFormatId = $.libraryMaskingFormatId;
        this.postProcessingFunction = $.postProcessingFunction;
        this.randomLists = $.randomLists;
        this.regularExpression = $.regularExpression;
        this.replaceWith = $.replaceWith;
        this.schemaName = $.schemaName;
        this.sqlExpression = $.sqlExpression;
        this.startDate = $.startDate;
        this.startLength = $.startLength;
        this.startPosition = $.startPosition;
        this.startValue = $.startValue;
        this.tableName = $.tableName;
        this.type = $.type;
        this.userDefinedFunction = $.userDefinedFunction;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(LibraryMasingFormatFormatEntryArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private LibraryMasingFormatFormatEntryArgs $;

        public Builder() {
            $ = new LibraryMasingFormatFormatEntryArgs();
        }

        public Builder(LibraryMasingFormatFormatEntryArgs defaults) {
            $ = new LibraryMasingFormatFormatEntryArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param columnName (Updatable) The name of the substitution column.
         * 
         * @return builder
         * 
         */
        public Builder columnName(@Nullable Output<String> columnName) {
            $.columnName = columnName;
            return this;
        }

        /**
         * @param columnName (Updatable) The name of the substitution column.
         * 
         * @return builder
         * 
         */
        public Builder columnName(String columnName) {
            return columnName(Output.of(columnName));
        }

        /**
         * @param description (Updatable) The description of the format entry.
         * 
         * @return builder
         * 
         */
        public Builder description(@Nullable Output<String> description) {
            $.description = description;
            return this;
        }

        /**
         * @param description (Updatable) The description of the format entry.
         * 
         * @return builder
         * 
         */
        public Builder description(String description) {
            return description(Output.of(description));
        }

        /**
         * @param endDate (Updatable) The upper bound of the range within which all the original column values fall. The end date must be greater than or equal to the start date.
         * 
         * @return builder
         * 
         */
        public Builder endDate(@Nullable Output<String> endDate) {
            $.endDate = endDate;
            return this;
        }

        /**
         * @param endDate (Updatable) The upper bound of the range within which all the original column values fall. The end date must be greater than or equal to the start date.
         * 
         * @return builder
         * 
         */
        public Builder endDate(String endDate) {
            return endDate(Output.of(endDate));
        }

        /**
         * @param endLength (Updatable) The maximum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be greater than or equal to  the start length.
         * 
         * @return builder
         * 
         */
        public Builder endLength(@Nullable Output<Integer> endLength) {
            $.endLength = endLength;
            return this;
        }

        /**
         * @param endLength (Updatable) The maximum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be greater than or equal to  the start length.
         * 
         * @return builder
         * 
         */
        public Builder endLength(Integer endLength) {
            return endLength(Output.of(endLength));
        }

        /**
         * @param endValue (Updatable) The upper bound of the range within which random decimal numbers should be generated. It must be greater than or equal to the start value. It supports  input of double type.
         * 
         * @return builder
         * 
         */
        public Builder endValue(@Nullable Output<Double> endValue) {
            $.endValue = endValue;
            return this;
        }

        /**
         * @param endValue (Updatable) The upper bound of the range within which random decimal numbers should be generated. It must be greater than or equal to the start value. It supports  input of double type.
         * 
         * @return builder
         * 
         */
        public Builder endValue(Double endValue) {
            return endValue(Output.of(endValue));
        }

        /**
         * @param fixedNumber (Updatable) The constant number to be used for masking.
         * 
         * @return builder
         * 
         */
        public Builder fixedNumber(@Nullable Output<Double> fixedNumber) {
            $.fixedNumber = fixedNumber;
            return this;
        }

        /**
         * @param fixedNumber (Updatable) The constant number to be used for masking.
         * 
         * @return builder
         * 
         */
        public Builder fixedNumber(Double fixedNumber) {
            return fixedNumber(Output.of(fixedNumber));
        }

        /**
         * @param fixedString (Updatable) The constant string to be used for masking.
         * 
         * @return builder
         * 
         */
        public Builder fixedString(@Nullable Output<String> fixedString) {
            $.fixedString = fixedString;
            return this;
        }

        /**
         * @param fixedString (Updatable) The constant string to be used for masking.
         * 
         * @return builder
         * 
         */
        public Builder fixedString(String fixedString) {
            return fixedString(Output.of(fixedString));
        }

        /**
         * @param groupingColumns (Updatable) One or more reference columns to be used to group column values so that they can be shuffled within their own group. The grouping columns and  the column to be masked must belong to the same table.
         * 
         * @return builder
         * 
         */
        public Builder groupingColumns(@Nullable Output<List<String>> groupingColumns) {
            $.groupingColumns = groupingColumns;
            return this;
        }

        /**
         * @param groupingColumns (Updatable) One or more reference columns to be used to group column values so that they can be shuffled within their own group. The grouping columns and  the column to be masked must belong to the same table.
         * 
         * @return builder
         * 
         */
        public Builder groupingColumns(List<String> groupingColumns) {
            return groupingColumns(Output.of(groupingColumns));
        }

        /**
         * @param groupingColumns (Updatable) One or more reference columns to be used to group column values so that they can be shuffled within their own group. The grouping columns and  the column to be masked must belong to the same table.
         * 
         * @return builder
         * 
         */
        public Builder groupingColumns(String... groupingColumns) {
            return groupingColumns(List.of(groupingColumns));
        }

        /**
         * @param length (Updatable) The number of characters that should be there in the substring. It should be an integer and greater than zero.
         * 
         * @return builder
         * 
         */
        public Builder length(@Nullable Output<Integer> length) {
            $.length = length;
            return this;
        }

        /**
         * @param length (Updatable) The number of characters that should be there in the substring. It should be an integer and greater than zero.
         * 
         * @return builder
         * 
         */
        public Builder length(Integer length) {
            return length(Output.of(length));
        }

        /**
         * @param libraryMaskingFormatId (Updatable) The OCID of the library masking format.
         * 
         * @return builder
         * 
         */
        public Builder libraryMaskingFormatId(@Nullable Output<String> libraryMaskingFormatId) {
            $.libraryMaskingFormatId = libraryMaskingFormatId;
            return this;
        }

        /**
         * @param libraryMaskingFormatId (Updatable) The OCID of the library masking format.
         * 
         * @return builder
         * 
         */
        public Builder libraryMaskingFormatId(String libraryMaskingFormatId) {
            return libraryMaskingFormatId(Output.of(libraryMaskingFormatId));
        }

        /**
         * @param postProcessingFunction (Updatable) The post processing function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format. It can be a standalone or packaged function, so PACKAGE_NAME is optional.
         * 
         * @return builder
         * 
         */
        public Builder postProcessingFunction(@Nullable Output<String> postProcessingFunction) {
            $.postProcessingFunction = postProcessingFunction;
            return this;
        }

        /**
         * @param postProcessingFunction (Updatable) The post processing function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format. It can be a standalone or packaged function, so PACKAGE_NAME is optional.
         * 
         * @return builder
         * 
         */
        public Builder postProcessingFunction(String postProcessingFunction) {
            return postProcessingFunction(Output.of(postProcessingFunction));
        }

        /**
         * @param randomLists (Updatable) A comma-separated list of values to be used to replace column values. The list can be of strings, numbers, or dates. The data type of each value in the list must be compatible with the data type of the column. The number of entries in the list cannot be more than 999.
         * 
         * @return builder
         * 
         */
        public Builder randomLists(@Nullable Output<List<String>> randomLists) {
            $.randomLists = randomLists;
            return this;
        }

        /**
         * @param randomLists (Updatable) A comma-separated list of values to be used to replace column values. The list can be of strings, numbers, or dates. The data type of each value in the list must be compatible with the data type of the column. The number of entries in the list cannot be more than 999.
         * 
         * @return builder
         * 
         */
        public Builder randomLists(List<String> randomLists) {
            return randomLists(Output.of(randomLists));
        }

        /**
         * @param randomLists (Updatable) A comma-separated list of values to be used to replace column values. The list can be of strings, numbers, or dates. The data type of each value in the list must be compatible with the data type of the column. The number of entries in the list cannot be more than 999.
         * 
         * @return builder
         * 
         */
        public Builder randomLists(String... randomLists) {
            return randomLists(List.of(randomLists));
        }

        /**
         * @param regularExpression (Updatable) The regular expression to be used for masking. For data with characters in the ASCII character set, providing a regular expression is optional. However, it  is required if the data contains multi-byte characters. If not provided, an  error is returned when a multi-byte character is found.
         * 
         * @return builder
         * 
         */
        public Builder regularExpression(@Nullable Output<String> regularExpression) {
            $.regularExpression = regularExpression;
            return this;
        }

        /**
         * @param regularExpression (Updatable) The regular expression to be used for masking. For data with characters in the ASCII character set, providing a regular expression is optional. However, it  is required if the data contains multi-byte characters. If not provided, an  error is returned when a multi-byte character is found.
         * 
         * @return builder
         * 
         */
        public Builder regularExpression(String regularExpression) {
            return regularExpression(Output.of(regularExpression));
        }

        /**
         * @param replaceWith (Updatable) The value that should be used to replace the data matching the regular  expression. It can be a fixed string, fixed number, null value, or  SQL expression.
         * 
         * @return builder
         * 
         */
        public Builder replaceWith(@Nullable Output<String> replaceWith) {
            $.replaceWith = replaceWith;
            return this;
        }

        /**
         * @param replaceWith (Updatable) The value that should be used to replace the data matching the regular  expression. It can be a fixed string, fixed number, null value, or  SQL expression.
         * 
         * @return builder
         * 
         */
        public Builder replaceWith(String replaceWith) {
            return replaceWith(Output.of(replaceWith));
        }

        /**
         * @param schemaName (Updatable) The name of the schema that contains the substitution column.
         * 
         * @return builder
         * 
         */
        public Builder schemaName(@Nullable Output<String> schemaName) {
            $.schemaName = schemaName;
            return this;
        }

        /**
         * @param schemaName (Updatable) The name of the schema that contains the substitution column.
         * 
         * @return builder
         * 
         */
        public Builder schemaName(String schemaName) {
            return schemaName(Output.of(schemaName));
        }

        /**
         * @param sqlExpression (Updatable) The SQL expression to be used to generate the masked values. It can  consist of one or more values, operators, and SQL functions that  evaluate to a value. It can also contain substitution columns from  the same table. Specify the substitution columns within percent (%)  symbols.
         * 
         * @return builder
         * 
         */
        public Builder sqlExpression(@Nullable Output<String> sqlExpression) {
            $.sqlExpression = sqlExpression;
            return this;
        }

        /**
         * @param sqlExpression (Updatable) The SQL expression to be used to generate the masked values. It can  consist of one or more values, operators, and SQL functions that  evaluate to a value. It can also contain substitution columns from  the same table. Specify the substitution columns within percent (%)  symbols.
         * 
         * @return builder
         * 
         */
        public Builder sqlExpression(String sqlExpression) {
            return sqlExpression(Output.of(sqlExpression));
        }

        /**
         * @param startDate (Updatable) The lower bound of the range within which all the original column values fall. The start date must be less than or equal to the end date.
         * 
         * @return builder
         * 
         */
        public Builder startDate(@Nullable Output<String> startDate) {
            $.startDate = startDate;
            return this;
        }

        /**
         * @param startDate (Updatable) The lower bound of the range within which all the original column values fall. The start date must be less than or equal to the end date.
         * 
         * @return builder
         * 
         */
        public Builder startDate(String startDate) {
            return startDate(Output.of(startDate));
        }

        /**
         * @param startLength (Updatable) The minimum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be less than or equal to the  end length.
         * 
         * @return builder
         * 
         */
        public Builder startLength(@Nullable Output<Integer> startLength) {
            $.startLength = startLength;
            return this;
        }

        /**
         * @param startLength (Updatable) The minimum number of characters the generated strings should have. It can  be any integer greater than zero, but it must be less than or equal to the  end length.
         * 
         * @return builder
         * 
         */
        public Builder startLength(Integer startLength) {
            return startLength(Output.of(startLength));
        }

        /**
         * @param startPosition (Updatable) The starting position in the original string from where the substring should be extracted. It can be either a positive or a negative integer. If It&#39;s negative, the counting starts from the end of the string.
         * 
         * @return builder
         * 
         */
        public Builder startPosition(@Nullable Output<Integer> startPosition) {
            $.startPosition = startPosition;
            return this;
        }

        /**
         * @param startPosition (Updatable) The starting position in the original string from where the substring should be extracted. It can be either a positive or a negative integer. If It&#39;s negative, the counting starts from the end of the string.
         * 
         * @return builder
         * 
         */
        public Builder startPosition(Integer startPosition) {
            return startPosition(Output.of(startPosition));
        }

        /**
         * @param startValue (Updatable) The lower bound of the range within which random decimal numbers should  be generated. It must be less than or equal to the end value. It supports  input of double type.
         * 
         * @return builder
         * 
         */
        public Builder startValue(@Nullable Output<Double> startValue) {
            $.startValue = startValue;
            return this;
        }

        /**
         * @param startValue (Updatable) The lower bound of the range within which random decimal numbers should  be generated. It must be less than or equal to the end value. It supports  input of double type.
         * 
         * @return builder
         * 
         */
        public Builder startValue(Double startValue) {
            return startValue(Output.of(startValue));
        }

        /**
         * @param tableName (Updatable) The name of the table that contains the substitution column.
         * 
         * @return builder
         * 
         */
        public Builder tableName(@Nullable Output<String> tableName) {
            $.tableName = tableName;
            return this;
        }

        /**
         * @param tableName (Updatable) The name of the table that contains the substitution column.
         * 
         * @return builder
         * 
         */
        public Builder tableName(String tableName) {
            return tableName(Output.of(tableName));
        }

        /**
         * @param type (Updatable) The type of the format entry.
         * 
         * @return builder
         * 
         */
        public Builder type(Output<String> type) {
            $.type = type;
            return this;
        }

        /**
         * @param type (Updatable) The type of the format entry.
         * 
         * @return builder
         * 
         */
        public Builder type(String type) {
            return type(Output.of(type));
        }

        /**
         * @param userDefinedFunction (Updatable) The user-defined function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format.  It can be a standalone or packaged function, so PACKAGE_NAME is optional.
         * 
         * @return builder
         * 
         */
        public Builder userDefinedFunction(@Nullable Output<String> userDefinedFunction) {
            $.userDefinedFunction = userDefinedFunction;
            return this;
        }

        /**
         * @param userDefinedFunction (Updatable) The user-defined function in SCHEMA_NAME.PACKAGE_NAME.FUNCTION_NAME format.  It can be a standalone or packaged function, so PACKAGE_NAME is optional.
         * 
         * @return builder
         * 
         */
        public Builder userDefinedFunction(String userDefinedFunction) {
            return userDefinedFunction(Output.of(userDefinedFunction));
        }

        public LibraryMasingFormatFormatEntryArgs build() {
            $.type = Objects.requireNonNull($.type, "expected parameter 'type' to be non-null");
            return $;
        }
    }

}
