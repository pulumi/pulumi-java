// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.oci.Database.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class AutonomousDatabaseConnectionStringProfileArgs extends com.pulumi.resources.ResourceArgs {

    public static final AutonomousDatabaseConnectionStringProfileArgs Empty = new AutonomousDatabaseConnectionStringProfileArgs();

    /**
     * Consumer group used by the connection.
     * 
     */
    @Import(name="consumerGroup")
    private @Nullable Output<String> consumerGroup;

    /**
     * @return Consumer group used by the connection.
     * 
     */
    public Optional<Output<String>> consumerGroup() {
        return Optional.ofNullable(this.consumerGroup);
    }

    /**
     * (Updatable) The user-friendly name for the Autonomous Database. The name does not have to be unique.
     * 
     */
    @Import(name="displayName")
    private @Nullable Output<String> displayName;

    /**
     * @return (Updatable) The user-friendly name for the Autonomous Database. The name does not have to be unique.
     * 
     */
    public Optional<Output<String>> displayName() {
        return Optional.ofNullable(this.displayName);
    }

    /**
     * Host format used in connection string.
     * 
     */
    @Import(name="hostFormat")
    private @Nullable Output<String> hostFormat;

    /**
     * @return Host format used in connection string.
     * 
     */
    public Optional<Output<String>> hostFormat() {
        return Optional.ofNullable(this.hostFormat);
    }

    /**
     * Protocol used by the connection.
     * 
     */
    @Import(name="protocol")
    private @Nullable Output<String> protocol;

    /**
     * @return Protocol used by the connection.
     * 
     */
    public Optional<Output<String>> protocol() {
        return Optional.ofNullable(this.protocol);
    }

    /**
     * Specifies whether the listener performs a direct hand-off of the session, or redirects the session. In RAC deployments where SCAN is used, sessions are redirected to a Node VIP. Use `DIRECT` for direct hand-offs. Use `REDIRECT` to redirect the session.
     * 
     */
    @Import(name="sessionMode")
    private @Nullable Output<String> sessionMode;

    /**
     * @return Specifies whether the listener performs a direct hand-off of the session, or redirects the session. In RAC deployments where SCAN is used, sessions are redirected to a Node VIP. Use `DIRECT` for direct hand-offs. Use `REDIRECT` to redirect the session.
     * 
     */
    public Optional<Output<String>> sessionMode() {
        return Optional.ofNullable(this.sessionMode);
    }

    /**
     * Specifies whether the connection string is using the long (`LONG`), Easy Connect (`EZCONNECT`), or Easy Connect Plus (`EZCONNECTPLUS`) format. Autonomous Databases on shared Exadata infrastructure always use the long format.
     * 
     */
    @Import(name="syntaxFormat")
    private @Nullable Output<String> syntaxFormat;

    /**
     * @return Specifies whether the connection string is using the long (`LONG`), Easy Connect (`EZCONNECT`), or Easy Connect Plus (`EZCONNECTPLUS`) format. Autonomous Databases on shared Exadata infrastructure always use the long format.
     * 
     */
    public Optional<Output<String>> syntaxFormat() {
        return Optional.ofNullable(this.syntaxFormat);
    }

    /**
     * Specifies whether the TLS handshake is using one-way (`SERVER`) or mutual (`MUTUAL`) authentication.
     * 
     */
    @Import(name="tlsAuthentication")
    private @Nullable Output<String> tlsAuthentication;

    /**
     * @return Specifies whether the TLS handshake is using one-way (`SERVER`) or mutual (`MUTUAL`) authentication.
     * 
     */
    public Optional<Output<String>> tlsAuthentication() {
        return Optional.ofNullable(this.tlsAuthentication);
    }

    /**
     * Connection string value.
     * 
     */
    @Import(name="value")
    private @Nullable Output<String> value;

    /**
     * @return Connection string value.
     * 
     */
    public Optional<Output<String>> value() {
        return Optional.ofNullable(this.value);
    }

    private AutonomousDatabaseConnectionStringProfileArgs() {}

    private AutonomousDatabaseConnectionStringProfileArgs(AutonomousDatabaseConnectionStringProfileArgs $) {
        this.consumerGroup = $.consumerGroup;
        this.displayName = $.displayName;
        this.hostFormat = $.hostFormat;
        this.protocol = $.protocol;
        this.sessionMode = $.sessionMode;
        this.syntaxFormat = $.syntaxFormat;
        this.tlsAuthentication = $.tlsAuthentication;
        this.value = $.value;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(AutonomousDatabaseConnectionStringProfileArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private AutonomousDatabaseConnectionStringProfileArgs $;

        public Builder() {
            $ = new AutonomousDatabaseConnectionStringProfileArgs();
        }

        public Builder(AutonomousDatabaseConnectionStringProfileArgs defaults) {
            $ = new AutonomousDatabaseConnectionStringProfileArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param consumerGroup Consumer group used by the connection.
         * 
         * @return builder
         * 
         */
        public Builder consumerGroup(@Nullable Output<String> consumerGroup) {
            $.consumerGroup = consumerGroup;
            return this;
        }

        /**
         * @param consumerGroup Consumer group used by the connection.
         * 
         * @return builder
         * 
         */
        public Builder consumerGroup(String consumerGroup) {
            return consumerGroup(Output.of(consumerGroup));
        }

        /**
         * @param displayName (Updatable) The user-friendly name for the Autonomous Database. The name does not have to be unique.
         * 
         * @return builder
         * 
         */
        public Builder displayName(@Nullable Output<String> displayName) {
            $.displayName = displayName;
            return this;
        }

        /**
         * @param displayName (Updatable) The user-friendly name for the Autonomous Database. The name does not have to be unique.
         * 
         * @return builder
         * 
         */
        public Builder displayName(String displayName) {
            return displayName(Output.of(displayName));
        }

        /**
         * @param hostFormat Host format used in connection string.
         * 
         * @return builder
         * 
         */
        public Builder hostFormat(@Nullable Output<String> hostFormat) {
            $.hostFormat = hostFormat;
            return this;
        }

        /**
         * @param hostFormat Host format used in connection string.
         * 
         * @return builder
         * 
         */
        public Builder hostFormat(String hostFormat) {
            return hostFormat(Output.of(hostFormat));
        }

        /**
         * @param protocol Protocol used by the connection.
         * 
         * @return builder
         * 
         */
        public Builder protocol(@Nullable Output<String> protocol) {
            $.protocol = protocol;
            return this;
        }

        /**
         * @param protocol Protocol used by the connection.
         * 
         * @return builder
         * 
         */
        public Builder protocol(String protocol) {
            return protocol(Output.of(protocol));
        }

        /**
         * @param sessionMode Specifies whether the listener performs a direct hand-off of the session, or redirects the session. In RAC deployments where SCAN is used, sessions are redirected to a Node VIP. Use `DIRECT` for direct hand-offs. Use `REDIRECT` to redirect the session.
         * 
         * @return builder
         * 
         */
        public Builder sessionMode(@Nullable Output<String> sessionMode) {
            $.sessionMode = sessionMode;
            return this;
        }

        /**
         * @param sessionMode Specifies whether the listener performs a direct hand-off of the session, or redirects the session. In RAC deployments where SCAN is used, sessions are redirected to a Node VIP. Use `DIRECT` for direct hand-offs. Use `REDIRECT` to redirect the session.
         * 
         * @return builder
         * 
         */
        public Builder sessionMode(String sessionMode) {
            return sessionMode(Output.of(sessionMode));
        }

        /**
         * @param syntaxFormat Specifies whether the connection string is using the long (`LONG`), Easy Connect (`EZCONNECT`), or Easy Connect Plus (`EZCONNECTPLUS`) format. Autonomous Databases on shared Exadata infrastructure always use the long format.
         * 
         * @return builder
         * 
         */
        public Builder syntaxFormat(@Nullable Output<String> syntaxFormat) {
            $.syntaxFormat = syntaxFormat;
            return this;
        }

        /**
         * @param syntaxFormat Specifies whether the connection string is using the long (`LONG`), Easy Connect (`EZCONNECT`), or Easy Connect Plus (`EZCONNECTPLUS`) format. Autonomous Databases on shared Exadata infrastructure always use the long format.
         * 
         * @return builder
         * 
         */
        public Builder syntaxFormat(String syntaxFormat) {
            return syntaxFormat(Output.of(syntaxFormat));
        }

        /**
         * @param tlsAuthentication Specifies whether the TLS handshake is using one-way (`SERVER`) or mutual (`MUTUAL`) authentication.
         * 
         * @return builder
         * 
         */
        public Builder tlsAuthentication(@Nullable Output<String> tlsAuthentication) {
            $.tlsAuthentication = tlsAuthentication;
            return this;
        }

        /**
         * @param tlsAuthentication Specifies whether the TLS handshake is using one-way (`SERVER`) or mutual (`MUTUAL`) authentication.
         * 
         * @return builder
         * 
         */
        public Builder tlsAuthentication(String tlsAuthentication) {
            return tlsAuthentication(Output.of(tlsAuthentication));
        }

        /**
         * @param value Connection string value.
         * 
         * @return builder
         * 
         */
        public Builder value(@Nullable Output<String> value) {
            $.value = value;
            return this;
        }

        /**
         * @param value Connection string value.
         * 
         * @return builder
         * 
         */
        public Builder value(String value) {
            return value(Output.of(value));
        }

        public AutonomousDatabaseConnectionStringProfileArgs build() {
            return $;
        }
    }

}
