// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.oci.Logging.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.oci.Logging.inputs.UnifiedAgentConfigurationServiceConfigurationSourceParserPatternArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.Object;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class UnifiedAgentConfigurationServiceConfigurationSourceParserArgs extends com.pulumi.resources.ResourceArgs {

    public static final UnifiedAgentConfigurationServiceConfigurationSourceParserArgs Empty = new UnifiedAgentConfigurationServiceConfigurationSourceParserArgs();

    /**
     * (Updatable)
     * 
     */
    @Import(name="delimiter")
    private @Nullable Output<String> delimiter;

    /**
     * @return (Updatable)
     * 
     */
    public Optional<Output<String>> delimiter() {
        return Optional.ofNullable(this.delimiter);
    }

    /**
     * (Updatable)
     * 
     */
    @Import(name="expression")
    private @Nullable Output<String> expression;

    /**
     * @return (Updatable)
     * 
     */
    public Optional<Output<String>> expression() {
        return Optional.ofNullable(this.expression);
    }

    /**
     * (Updatable) Specify the time field for the event time. If the event doesn&#39;t have this field, the current time is used.
     * 
     */
    @Import(name="fieldTimeKey")
    private @Nullable Output<String> fieldTimeKey;

    /**
     * @return (Updatable) Specify the time field for the event time. If the event doesn&#39;t have this field, the current time is used.
     * 
     */
    public Optional<Output<String>> fieldTimeKey() {
        return Optional.ofNullable(this.fieldTimeKey);
    }

    /**
     * (Updatable)
     * 
     */
    @Import(name="formatFirstline")
    private @Nullable Output<String> formatFirstline;

    /**
     * @return (Updatable)
     * 
     */
    public Optional<Output<String>> formatFirstline() {
        return Optional.ofNullable(this.formatFirstline);
    }

    /**
     * (Updatable)
     * 
     */
    @Import(name="formats")
    private @Nullable Output<List<String>> formats;

    /**
     * @return (Updatable)
     * 
     */
    public Optional<Output<List<String>>> formats() {
        return Optional.ofNullable(this.formats);
    }

    /**
     * (Updatable)
     * 
     */
    @Import(name="grokFailureKey")
    private @Nullable Output<String> grokFailureKey;

    /**
     * @return (Updatable)
     * 
     */
    public Optional<Output<String>> grokFailureKey() {
        return Optional.ofNullable(this.grokFailureKey);
    }

    /**
     * (Updatable)
     * 
     */
    @Import(name="grokNameKey")
    private @Nullable Output<String> grokNameKey;

    /**
     * @return (Updatable)
     * 
     */
    public Optional<Output<String>> grokNameKey() {
        return Optional.ofNullable(this.grokNameKey);
    }

    /**
     * (Updatable) If true, use Fluent::EventTime.now(current time) as a timestamp when time_key is specified.
     * 
     */
    @Import(name="isEstimateCurrentEvent")
    private @Nullable Output<Boolean> isEstimateCurrentEvent;

    /**
     * @return (Updatable) If true, use Fluent::EventTime.now(current time) as a timestamp when time_key is specified.
     * 
     */
    public Optional<Output<Boolean>> isEstimateCurrentEvent() {
        return Optional.ofNullable(this.isEstimateCurrentEvent);
    }

    /**
     * (Updatable) If true, keep time field in the record.
     * 
     */
    @Import(name="isKeepTimeKey")
    private @Nullable Output<Boolean> isKeepTimeKey;

    /**
     * @return (Updatable) If true, keep time field in the record.
     * 
     */
    public Optional<Output<Boolean>> isKeepTimeKey() {
        return Optional.ofNullable(this.isKeepTimeKey);
    }

    /**
     * (Updatable) If true, an empty string field is replaced with nil.
     * 
     */
    @Import(name="isNullEmptyString")
    private @Nullable Output<Boolean> isNullEmptyString;

    /**
     * @return (Updatable) If true, an empty string field is replaced with nil.
     * 
     */
    public Optional<Output<Boolean>> isNullEmptyString() {
        return Optional.ofNullable(this.isNullEmptyString);
    }

    /**
     * (Updatable)
     * 
     */
    @Import(name="isSupportColonlessIdent")
    private @Nullable Output<Boolean> isSupportColonlessIdent;

    /**
     * @return (Updatable)
     * 
     */
    public Optional<Output<Boolean>> isSupportColonlessIdent() {
        return Optional.ofNullable(this.isSupportColonlessIdent);
    }

    /**
     * (Updatable)
     * 
     */
    @Import(name="isWithPriority")
    private @Nullable Output<Boolean> isWithPriority;

    /**
     * @return (Updatable)
     * 
     */
    public Optional<Output<Boolean>> isWithPriority() {
        return Optional.ofNullable(this.isWithPriority);
    }

    /**
     * (Updatable)
     * 
     */
    @Import(name="keys")
    private @Nullable Output<List<String>> keys;

    /**
     * @return (Updatable)
     * 
     */
    public Optional<Output<List<String>>> keys() {
        return Optional.ofNullable(this.keys);
    }

    /**
     * (Updatable)
     * 
     */
    @Import(name="messageFormat")
    private @Nullable Output<String> messageFormat;

    /**
     * @return (Updatable)
     * 
     */
    public Optional<Output<String>> messageFormat() {
        return Optional.ofNullable(this.messageFormat);
    }

    /**
     * (Updatable)
     * 
     */
    @Import(name="messageKey")
    private @Nullable Output<String> messageKey;

    /**
     * @return (Updatable)
     * 
     */
    public Optional<Output<String>> messageKey() {
        return Optional.ofNullable(this.messageKey);
    }

    /**
     * (Updatable)
     * 
     */
    @Import(name="multiLineStartRegexp")
    private @Nullable Output<String> multiLineStartRegexp;

    /**
     * @return (Updatable)
     * 
     */
    public Optional<Output<String>> multiLineStartRegexp() {
        return Optional.ofNullable(this.multiLineStartRegexp);
    }

    /**
     * (Updatable) Specify the null value pattern.
     * 
     */
    @Import(name="nullValuePattern")
    private @Nullable Output<String> nullValuePattern;

    /**
     * @return (Updatable) Specify the null value pattern.
     * 
     */
    public Optional<Output<String>> nullValuePattern() {
        return Optional.ofNullable(this.nullValuePattern);
    }

    /**
     * (Updatable) Type of fluent parser.
     * 
     */
    @Import(name="parserType", required=true)
    private Output<String> parserType;

    /**
     * @return (Updatable) Type of fluent parser.
     * 
     */
    public Output<String> parserType() {
        return this.parserType;
    }

    /**
     * (Updatable)
     * 
     */
    @Import(name="patterns")
    private @Nullable Output<List<UnifiedAgentConfigurationServiceConfigurationSourceParserPatternArgs>> patterns;

    /**
     * @return (Updatable)
     * 
     */
    public Optional<Output<List<UnifiedAgentConfigurationServiceConfigurationSourceParserPatternArgs>>> patterns() {
        return Optional.ofNullable(this.patterns);
    }

    /**
     * (Updatable)
     * 
     */
    @Import(name="rfc5424timeFormat")
    private @Nullable Output<String> rfc5424timeFormat;

    /**
     * @return (Updatable)
     * 
     */
    public Optional<Output<String>> rfc5424timeFormat() {
        return Optional.ofNullable(this.rfc5424timeFormat);
    }

    /**
     * (Updatable)
     * 
     */
    @Import(name="syslogParserType")
    private @Nullable Output<String> syslogParserType;

    /**
     * @return (Updatable)
     * 
     */
    public Optional<Output<String>> syslogParserType() {
        return Optional.ofNullable(this.syslogParserType);
    }

    /**
     * (Updatable)
     * 
     */
    @Import(name="timeFormat")
    private @Nullable Output<String> timeFormat;

    /**
     * @return (Updatable)
     * 
     */
    public Optional<Output<String>> timeFormat() {
        return Optional.ofNullable(this.timeFormat);
    }

    /**
     * (Updatable)
     * 
     */
    @Import(name="timeType")
    private @Nullable Output<String> timeType;

    /**
     * @return (Updatable)
     * 
     */
    public Optional<Output<String>> timeType() {
        return Optional.ofNullable(this.timeType);
    }

    /**
     * (Updatable) Specify the timeout for parse processing. This is mainly for detecting an incorrect regexp pattern.
     * 
     */
    @Import(name="timeoutInMilliseconds")
    private @Nullable Output<Integer> timeoutInMilliseconds;

    /**
     * @return (Updatable) Specify the timeout for parse processing. This is mainly for detecting an incorrect regexp pattern.
     * 
     */
    public Optional<Output<Integer>> timeoutInMilliseconds() {
        return Optional.ofNullable(this.timeoutInMilliseconds);
    }

    /**
     * (Updatable) Specify types for converting a field into another type.
     * 
     */
    @Import(name="types")
    private @Nullable Output<Map<String,Object>> types;

    /**
     * @return (Updatable) Specify types for converting a field into another type.
     * 
     */
    public Optional<Output<Map<String,Object>>> types() {
        return Optional.ofNullable(this.types);
    }

    private UnifiedAgentConfigurationServiceConfigurationSourceParserArgs() {}

    private UnifiedAgentConfigurationServiceConfigurationSourceParserArgs(UnifiedAgentConfigurationServiceConfigurationSourceParserArgs $) {
        this.delimiter = $.delimiter;
        this.expression = $.expression;
        this.fieldTimeKey = $.fieldTimeKey;
        this.formatFirstline = $.formatFirstline;
        this.formats = $.formats;
        this.grokFailureKey = $.grokFailureKey;
        this.grokNameKey = $.grokNameKey;
        this.isEstimateCurrentEvent = $.isEstimateCurrentEvent;
        this.isKeepTimeKey = $.isKeepTimeKey;
        this.isNullEmptyString = $.isNullEmptyString;
        this.isSupportColonlessIdent = $.isSupportColonlessIdent;
        this.isWithPriority = $.isWithPriority;
        this.keys = $.keys;
        this.messageFormat = $.messageFormat;
        this.messageKey = $.messageKey;
        this.multiLineStartRegexp = $.multiLineStartRegexp;
        this.nullValuePattern = $.nullValuePattern;
        this.parserType = $.parserType;
        this.patterns = $.patterns;
        this.rfc5424timeFormat = $.rfc5424timeFormat;
        this.syslogParserType = $.syslogParserType;
        this.timeFormat = $.timeFormat;
        this.timeType = $.timeType;
        this.timeoutInMilliseconds = $.timeoutInMilliseconds;
        this.types = $.types;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(UnifiedAgentConfigurationServiceConfigurationSourceParserArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private UnifiedAgentConfigurationServiceConfigurationSourceParserArgs $;

        public Builder() {
            $ = new UnifiedAgentConfigurationServiceConfigurationSourceParserArgs();
        }

        public Builder(UnifiedAgentConfigurationServiceConfigurationSourceParserArgs defaults) {
            $ = new UnifiedAgentConfigurationServiceConfigurationSourceParserArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param delimiter (Updatable)
         * 
         * @return builder
         * 
         */
        public Builder delimiter(@Nullable Output<String> delimiter) {
            $.delimiter = delimiter;
            return this;
        }

        /**
         * @param delimiter (Updatable)
         * 
         * @return builder
         * 
         */
        public Builder delimiter(String delimiter) {
            return delimiter(Output.of(delimiter));
        }

        /**
         * @param expression (Updatable)
         * 
         * @return builder
         * 
         */
        public Builder expression(@Nullable Output<String> expression) {
            $.expression = expression;
            return this;
        }

        /**
         * @param expression (Updatable)
         * 
         * @return builder
         * 
         */
        public Builder expression(String expression) {
            return expression(Output.of(expression));
        }

        /**
         * @param fieldTimeKey (Updatable) Specify the time field for the event time. If the event doesn&#39;t have this field, the current time is used.
         * 
         * @return builder
         * 
         */
        public Builder fieldTimeKey(@Nullable Output<String> fieldTimeKey) {
            $.fieldTimeKey = fieldTimeKey;
            return this;
        }

        /**
         * @param fieldTimeKey (Updatable) Specify the time field for the event time. If the event doesn&#39;t have this field, the current time is used.
         * 
         * @return builder
         * 
         */
        public Builder fieldTimeKey(String fieldTimeKey) {
            return fieldTimeKey(Output.of(fieldTimeKey));
        }

        /**
         * @param formatFirstline (Updatable)
         * 
         * @return builder
         * 
         */
        public Builder formatFirstline(@Nullable Output<String> formatFirstline) {
            $.formatFirstline = formatFirstline;
            return this;
        }

        /**
         * @param formatFirstline (Updatable)
         * 
         * @return builder
         * 
         */
        public Builder formatFirstline(String formatFirstline) {
            return formatFirstline(Output.of(formatFirstline));
        }

        /**
         * @param formats (Updatable)
         * 
         * @return builder
         * 
         */
        public Builder formats(@Nullable Output<List<String>> formats) {
            $.formats = formats;
            return this;
        }

        /**
         * @param formats (Updatable)
         * 
         * @return builder
         * 
         */
        public Builder formats(List<String> formats) {
            return formats(Output.of(formats));
        }

        /**
         * @param formats (Updatable)
         * 
         * @return builder
         * 
         */
        public Builder formats(String... formats) {
            return formats(List.of(formats));
        }

        /**
         * @param grokFailureKey (Updatable)
         * 
         * @return builder
         * 
         */
        public Builder grokFailureKey(@Nullable Output<String> grokFailureKey) {
            $.grokFailureKey = grokFailureKey;
            return this;
        }

        /**
         * @param grokFailureKey (Updatable)
         * 
         * @return builder
         * 
         */
        public Builder grokFailureKey(String grokFailureKey) {
            return grokFailureKey(Output.of(grokFailureKey));
        }

        /**
         * @param grokNameKey (Updatable)
         * 
         * @return builder
         * 
         */
        public Builder grokNameKey(@Nullable Output<String> grokNameKey) {
            $.grokNameKey = grokNameKey;
            return this;
        }

        /**
         * @param grokNameKey (Updatable)
         * 
         * @return builder
         * 
         */
        public Builder grokNameKey(String grokNameKey) {
            return grokNameKey(Output.of(grokNameKey));
        }

        /**
         * @param isEstimateCurrentEvent (Updatable) If true, use Fluent::EventTime.now(current time) as a timestamp when time_key is specified.
         * 
         * @return builder
         * 
         */
        public Builder isEstimateCurrentEvent(@Nullable Output<Boolean> isEstimateCurrentEvent) {
            $.isEstimateCurrentEvent = isEstimateCurrentEvent;
            return this;
        }

        /**
         * @param isEstimateCurrentEvent (Updatable) If true, use Fluent::EventTime.now(current time) as a timestamp when time_key is specified.
         * 
         * @return builder
         * 
         */
        public Builder isEstimateCurrentEvent(Boolean isEstimateCurrentEvent) {
            return isEstimateCurrentEvent(Output.of(isEstimateCurrentEvent));
        }

        /**
         * @param isKeepTimeKey (Updatable) If true, keep time field in the record.
         * 
         * @return builder
         * 
         */
        public Builder isKeepTimeKey(@Nullable Output<Boolean> isKeepTimeKey) {
            $.isKeepTimeKey = isKeepTimeKey;
            return this;
        }

        /**
         * @param isKeepTimeKey (Updatable) If true, keep time field in the record.
         * 
         * @return builder
         * 
         */
        public Builder isKeepTimeKey(Boolean isKeepTimeKey) {
            return isKeepTimeKey(Output.of(isKeepTimeKey));
        }

        /**
         * @param isNullEmptyString (Updatable) If true, an empty string field is replaced with nil.
         * 
         * @return builder
         * 
         */
        public Builder isNullEmptyString(@Nullable Output<Boolean> isNullEmptyString) {
            $.isNullEmptyString = isNullEmptyString;
            return this;
        }

        /**
         * @param isNullEmptyString (Updatable) If true, an empty string field is replaced with nil.
         * 
         * @return builder
         * 
         */
        public Builder isNullEmptyString(Boolean isNullEmptyString) {
            return isNullEmptyString(Output.of(isNullEmptyString));
        }

        /**
         * @param isSupportColonlessIdent (Updatable)
         * 
         * @return builder
         * 
         */
        public Builder isSupportColonlessIdent(@Nullable Output<Boolean> isSupportColonlessIdent) {
            $.isSupportColonlessIdent = isSupportColonlessIdent;
            return this;
        }

        /**
         * @param isSupportColonlessIdent (Updatable)
         * 
         * @return builder
         * 
         */
        public Builder isSupportColonlessIdent(Boolean isSupportColonlessIdent) {
            return isSupportColonlessIdent(Output.of(isSupportColonlessIdent));
        }

        /**
         * @param isWithPriority (Updatable)
         * 
         * @return builder
         * 
         */
        public Builder isWithPriority(@Nullable Output<Boolean> isWithPriority) {
            $.isWithPriority = isWithPriority;
            return this;
        }

        /**
         * @param isWithPriority (Updatable)
         * 
         * @return builder
         * 
         */
        public Builder isWithPriority(Boolean isWithPriority) {
            return isWithPriority(Output.of(isWithPriority));
        }

        /**
         * @param keys (Updatable)
         * 
         * @return builder
         * 
         */
        public Builder keys(@Nullable Output<List<String>> keys) {
            $.keys = keys;
            return this;
        }

        /**
         * @param keys (Updatable)
         * 
         * @return builder
         * 
         */
        public Builder keys(List<String> keys) {
            return keys(Output.of(keys));
        }

        /**
         * @param keys (Updatable)
         * 
         * @return builder
         * 
         */
        public Builder keys(String... keys) {
            return keys(List.of(keys));
        }

        /**
         * @param messageFormat (Updatable)
         * 
         * @return builder
         * 
         */
        public Builder messageFormat(@Nullable Output<String> messageFormat) {
            $.messageFormat = messageFormat;
            return this;
        }

        /**
         * @param messageFormat (Updatable)
         * 
         * @return builder
         * 
         */
        public Builder messageFormat(String messageFormat) {
            return messageFormat(Output.of(messageFormat));
        }

        /**
         * @param messageKey (Updatable)
         * 
         * @return builder
         * 
         */
        public Builder messageKey(@Nullable Output<String> messageKey) {
            $.messageKey = messageKey;
            return this;
        }

        /**
         * @param messageKey (Updatable)
         * 
         * @return builder
         * 
         */
        public Builder messageKey(String messageKey) {
            return messageKey(Output.of(messageKey));
        }

        /**
         * @param multiLineStartRegexp (Updatable)
         * 
         * @return builder
         * 
         */
        public Builder multiLineStartRegexp(@Nullable Output<String> multiLineStartRegexp) {
            $.multiLineStartRegexp = multiLineStartRegexp;
            return this;
        }

        /**
         * @param multiLineStartRegexp (Updatable)
         * 
         * @return builder
         * 
         */
        public Builder multiLineStartRegexp(String multiLineStartRegexp) {
            return multiLineStartRegexp(Output.of(multiLineStartRegexp));
        }

        /**
         * @param nullValuePattern (Updatable) Specify the null value pattern.
         * 
         * @return builder
         * 
         */
        public Builder nullValuePattern(@Nullable Output<String> nullValuePattern) {
            $.nullValuePattern = nullValuePattern;
            return this;
        }

        /**
         * @param nullValuePattern (Updatable) Specify the null value pattern.
         * 
         * @return builder
         * 
         */
        public Builder nullValuePattern(String nullValuePattern) {
            return nullValuePattern(Output.of(nullValuePattern));
        }

        /**
         * @param parserType (Updatable) Type of fluent parser.
         * 
         * @return builder
         * 
         */
        public Builder parserType(Output<String> parserType) {
            $.parserType = parserType;
            return this;
        }

        /**
         * @param parserType (Updatable) Type of fluent parser.
         * 
         * @return builder
         * 
         */
        public Builder parserType(String parserType) {
            return parserType(Output.of(parserType));
        }

        /**
         * @param patterns (Updatable)
         * 
         * @return builder
         * 
         */
        public Builder patterns(@Nullable Output<List<UnifiedAgentConfigurationServiceConfigurationSourceParserPatternArgs>> patterns) {
            $.patterns = patterns;
            return this;
        }

        /**
         * @param patterns (Updatable)
         * 
         * @return builder
         * 
         */
        public Builder patterns(List<UnifiedAgentConfigurationServiceConfigurationSourceParserPatternArgs> patterns) {
            return patterns(Output.of(patterns));
        }

        /**
         * @param patterns (Updatable)
         * 
         * @return builder
         * 
         */
        public Builder patterns(UnifiedAgentConfigurationServiceConfigurationSourceParserPatternArgs... patterns) {
            return patterns(List.of(patterns));
        }

        /**
         * @param rfc5424timeFormat (Updatable)
         * 
         * @return builder
         * 
         */
        public Builder rfc5424timeFormat(@Nullable Output<String> rfc5424timeFormat) {
            $.rfc5424timeFormat = rfc5424timeFormat;
            return this;
        }

        /**
         * @param rfc5424timeFormat (Updatable)
         * 
         * @return builder
         * 
         */
        public Builder rfc5424timeFormat(String rfc5424timeFormat) {
            return rfc5424timeFormat(Output.of(rfc5424timeFormat));
        }

        /**
         * @param syslogParserType (Updatable)
         * 
         * @return builder
         * 
         */
        public Builder syslogParserType(@Nullable Output<String> syslogParserType) {
            $.syslogParserType = syslogParserType;
            return this;
        }

        /**
         * @param syslogParserType (Updatable)
         * 
         * @return builder
         * 
         */
        public Builder syslogParserType(String syslogParserType) {
            return syslogParserType(Output.of(syslogParserType));
        }

        /**
         * @param timeFormat (Updatable)
         * 
         * @return builder
         * 
         */
        public Builder timeFormat(@Nullable Output<String> timeFormat) {
            $.timeFormat = timeFormat;
            return this;
        }

        /**
         * @param timeFormat (Updatable)
         * 
         * @return builder
         * 
         */
        public Builder timeFormat(String timeFormat) {
            return timeFormat(Output.of(timeFormat));
        }

        /**
         * @param timeType (Updatable)
         * 
         * @return builder
         * 
         */
        public Builder timeType(@Nullable Output<String> timeType) {
            $.timeType = timeType;
            return this;
        }

        /**
         * @param timeType (Updatable)
         * 
         * @return builder
         * 
         */
        public Builder timeType(String timeType) {
            return timeType(Output.of(timeType));
        }

        /**
         * @param timeoutInMilliseconds (Updatable) Specify the timeout for parse processing. This is mainly for detecting an incorrect regexp pattern.
         * 
         * @return builder
         * 
         */
        public Builder timeoutInMilliseconds(@Nullable Output<Integer> timeoutInMilliseconds) {
            $.timeoutInMilliseconds = timeoutInMilliseconds;
            return this;
        }

        /**
         * @param timeoutInMilliseconds (Updatable) Specify the timeout for parse processing. This is mainly for detecting an incorrect regexp pattern.
         * 
         * @return builder
         * 
         */
        public Builder timeoutInMilliseconds(Integer timeoutInMilliseconds) {
            return timeoutInMilliseconds(Output.of(timeoutInMilliseconds));
        }

        /**
         * @param types (Updatable) Specify types for converting a field into another type.
         * 
         * @return builder
         * 
         */
        public Builder types(@Nullable Output<Map<String,Object>> types) {
            $.types = types;
            return this;
        }

        /**
         * @param types (Updatable) Specify types for converting a field into another type.
         * 
         * @return builder
         * 
         */
        public Builder types(Map<String,Object> types) {
            return types(Output.of(types));
        }

        public UnifiedAgentConfigurationServiceConfigurationSourceParserArgs build() {
            $.parserType = Objects.requireNonNull($.parserType, "expected parameter 'parserType' to be non-null");
            return $;
        }
    }

}
