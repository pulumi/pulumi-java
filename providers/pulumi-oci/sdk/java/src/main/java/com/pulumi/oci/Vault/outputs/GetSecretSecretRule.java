// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.oci.Vault.outputs;

import com.pulumi.core.annotations.CustomType;
import java.lang.Boolean;
import java.lang.String;
import java.util.Objects;

@CustomType
public final class GetSecretSecretRule {
    /**
     * @return A property indicating whether the rule is applied even if the secret version with the content you are trying to reuse was deleted.
     * 
     */
    private final Boolean isEnforcedOnDeletedSecretVersions;
    /**
     * @return A property indicating whether to block retrieval of the secret content, on expiry. The default is false. If the secret has already expired and you would like to retrieve the secret contents, you need to edit the secret rule to disable this property, to allow reading the secret content.
     * 
     */
    private final Boolean isSecretContentRetrievalBlockedOnExpiry;
    /**
     * @return The type of rule, which either controls when the secret contents expire or whether they can be reused.
     * 
     */
    private final String ruleType;
    /**
     * @return A property indicating how long the secret contents will be considered valid, expressed in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Time_intervals) format. The secret needs to be updated when the secret content expires. No enforcement mechanism exists at this time, but audit logs record the expiration on the appropriate date, according to the time interval specified in the rule. The timer resets after you update the secret contents. The minimum value is 1 day and the maximum value is 90 days for this property. Currently, only intervals expressed in days are supported. For example, pass `P3D` to have the secret version expire every 3 days.
     * 
     */
    private final String secretVersionExpiryInterval;
    /**
     * @return An optional property indicating the absolute time when this secret will expire, expressed in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format. The minimum number of days from current time is 1 day and the maximum number of days from current time is 365 days. Example: `2019-04-03T21:10:29.600Z`
     * 
     */
    private final String timeOfAbsoluteExpiry;

    @CustomType.Constructor
    private GetSecretSecretRule(
        @CustomType.Parameter("isEnforcedOnDeletedSecretVersions") Boolean isEnforcedOnDeletedSecretVersions,
        @CustomType.Parameter("isSecretContentRetrievalBlockedOnExpiry") Boolean isSecretContentRetrievalBlockedOnExpiry,
        @CustomType.Parameter("ruleType") String ruleType,
        @CustomType.Parameter("secretVersionExpiryInterval") String secretVersionExpiryInterval,
        @CustomType.Parameter("timeOfAbsoluteExpiry") String timeOfAbsoluteExpiry) {
        this.isEnforcedOnDeletedSecretVersions = isEnforcedOnDeletedSecretVersions;
        this.isSecretContentRetrievalBlockedOnExpiry = isSecretContentRetrievalBlockedOnExpiry;
        this.ruleType = ruleType;
        this.secretVersionExpiryInterval = secretVersionExpiryInterval;
        this.timeOfAbsoluteExpiry = timeOfAbsoluteExpiry;
    }

    /**
     * @return A property indicating whether the rule is applied even if the secret version with the content you are trying to reuse was deleted.
     * 
     */
    public Boolean isEnforcedOnDeletedSecretVersions() {
        return this.isEnforcedOnDeletedSecretVersions;
    }
    /**
     * @return A property indicating whether to block retrieval of the secret content, on expiry. The default is false. If the secret has already expired and you would like to retrieve the secret contents, you need to edit the secret rule to disable this property, to allow reading the secret content.
     * 
     */
    public Boolean isSecretContentRetrievalBlockedOnExpiry() {
        return this.isSecretContentRetrievalBlockedOnExpiry;
    }
    /**
     * @return The type of rule, which either controls when the secret contents expire or whether they can be reused.
     * 
     */
    public String ruleType() {
        return this.ruleType;
    }
    /**
     * @return A property indicating how long the secret contents will be considered valid, expressed in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Time_intervals) format. The secret needs to be updated when the secret content expires. No enforcement mechanism exists at this time, but audit logs record the expiration on the appropriate date, according to the time interval specified in the rule. The timer resets after you update the secret contents. The minimum value is 1 day and the maximum value is 90 days for this property. Currently, only intervals expressed in days are supported. For example, pass `P3D` to have the secret version expire every 3 days.
     * 
     */
    public String secretVersionExpiryInterval() {
        return this.secretVersionExpiryInterval;
    }
    /**
     * @return An optional property indicating the absolute time when this secret will expire, expressed in [RFC 3339](https://tools.ietf.org/html/rfc3339) timestamp format. The minimum number of days from current time is 1 day and the maximum number of days from current time is 365 days. Example: `2019-04-03T21:10:29.600Z`
     * 
     */
    public String timeOfAbsoluteExpiry() {
        return this.timeOfAbsoluteExpiry;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetSecretSecretRule defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private Boolean isEnforcedOnDeletedSecretVersions;
        private Boolean isSecretContentRetrievalBlockedOnExpiry;
        private String ruleType;
        private String secretVersionExpiryInterval;
        private String timeOfAbsoluteExpiry;

        public Builder() {
    	      // Empty
        }

        public Builder(GetSecretSecretRule defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.isEnforcedOnDeletedSecretVersions = defaults.isEnforcedOnDeletedSecretVersions;
    	      this.isSecretContentRetrievalBlockedOnExpiry = defaults.isSecretContentRetrievalBlockedOnExpiry;
    	      this.ruleType = defaults.ruleType;
    	      this.secretVersionExpiryInterval = defaults.secretVersionExpiryInterval;
    	      this.timeOfAbsoluteExpiry = defaults.timeOfAbsoluteExpiry;
        }

        public Builder isEnforcedOnDeletedSecretVersions(Boolean isEnforcedOnDeletedSecretVersions) {
            this.isEnforcedOnDeletedSecretVersions = Objects.requireNonNull(isEnforcedOnDeletedSecretVersions);
            return this;
        }
        public Builder isSecretContentRetrievalBlockedOnExpiry(Boolean isSecretContentRetrievalBlockedOnExpiry) {
            this.isSecretContentRetrievalBlockedOnExpiry = Objects.requireNonNull(isSecretContentRetrievalBlockedOnExpiry);
            return this;
        }
        public Builder ruleType(String ruleType) {
            this.ruleType = Objects.requireNonNull(ruleType);
            return this;
        }
        public Builder secretVersionExpiryInterval(String secretVersionExpiryInterval) {
            this.secretVersionExpiryInterval = Objects.requireNonNull(secretVersionExpiryInterval);
            return this;
        }
        public Builder timeOfAbsoluteExpiry(String timeOfAbsoluteExpiry) {
            this.timeOfAbsoluteExpiry = Objects.requireNonNull(timeOfAbsoluteExpiry);
            return this;
        }        public GetSecretSecretRule build() {
            return new GetSecretSecretRule(isEnforcedOnDeletedSecretVersions, isSecretContentRetrievalBlockedOnExpiry, ruleType, secretVersionExpiryInterval, timeOfAbsoluteExpiry);
        }
    }
}
