// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package io.pulumi.aws.cloudwatch;

import io.pulumi.aws.Utilities;
import io.pulumi.aws.cloudwatch.MetricAlarmArgs;
import io.pulumi.aws.cloudwatch.inputs.MetricAlarmState;
import io.pulumi.aws.cloudwatch.outputs.MetricAlarmMetricQuery;
import io.pulumi.core.Output;
import io.pulumi.core.annotations.Export;
import io.pulumi.core.annotations.ResourceType;
import java.lang.Boolean;
import java.lang.Double;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import javax.annotation.Nullable;

/**
 * Provides a CloudWatch Metric Alarm resource.
 * 
 * {{% examples %}}
 * ## Example Usage
 * {{% example %}}
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 * 
 * const foobar = new aws.cloudwatch.MetricAlarm("foobar", {
 *     alarmDescription: "This metric monitors ec2 cpu utilization",
 *     comparisonOperator: "GreaterThanOrEqualToThreshold",
 *     evaluationPeriods: 2,
 *     insufficientDataActions: [],
 *     metricName: "CPUUtilization",
 *     namespace: "AWS/EC2",
 *     period: 120,
 *     statistic: "Average",
 *     threshold: 80,
 * });
 * ```
 * ```python
 * import pulumi
 * import pulumi_aws as aws
 * 
 * foobar = aws.cloudwatch.MetricAlarm("foobar",
 *     alarm_description="This metric monitors ec2 cpu utilization",
 *     comparison_operator="GreaterThanOrEqualToThreshold",
 *     evaluation_periods=2,
 *     insufficient_data_actions=[],
 *     metric_name="CPUUtilization",
 *     namespace="AWS/EC2",
 *     period=120,
 *     statistic="Average",
 *     threshold=80)
 * ```
 * ```csharp
 * using Pulumi;
 * using Aws = Pulumi.Aws;
 * 
 * class MyStack : Stack
 * {
 *     public MyStack()
 *     {
 *         var foobar = new Aws.CloudWatch.MetricAlarm("foobar", new Aws.CloudWatch.MetricAlarmArgs
 *         {
 *             AlarmDescription = "This metric monitors ec2 cpu utilization",
 *             ComparisonOperator = "GreaterThanOrEqualToThreshold",
 *             EvaluationPeriods = 2,
 *             InsufficientDataActions = {},
 *             MetricName = "CPUUtilization",
 *             Namespace = "AWS/EC2",
 *             Period = 120,
 *             Statistic = "Average",
 *             Threshold = 80,
 *         });
 *     }
 * 
 * }
 * ```
 * ```go
 * package main
 * 
 * import (
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/cloudwatch"
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/sns"
 * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
 * )
 * 
 * func main() {
 * 	pulumi.Run(func(ctx *pulumi.Context) error {
 * 		_, err := cloudwatch.NewMetricAlarm(ctx, "foobar", &cloudwatch.MetricAlarmArgs{
 * 			AlarmDescription:        pulumi.String("This metric monitors ec2 cpu utilization"),
 * 			ComparisonOperator:      pulumi.String("GreaterThanOrEqualToThreshold"),
 * 			EvaluationPeriods:       pulumi.Int(2),
 * 			InsufficientDataActions: pulumi.AnyArray{},
 * 			MetricName:              pulumi.String("CPUUtilization"),
 * 			Namespace:               pulumi.String("AWS/EC2"),
 * 			Period:                  pulumi.Int(120),
 * 			Statistic:               pulumi.String("Average"),
 * 			Threshold:               pulumi.Float64(80),
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		return nil
 * 	})
 * }
 * ```
 * {{% /example %}}
 * {{% /examples %}}
 * ## Example in Conjunction with Scaling Policies
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 * 
 * const batPolicy = new aws.autoscaling.Policy("batPolicy", {
 *     scalingAdjustment: 4,
 *     adjustmentType: "ChangeInCapacity",
 *     cooldown: 300,
 *     autoscalingGroupName: aws_autoscaling_group.bar.name,
 * });
 * const batMetricAlarm = new aws.cloudwatch.MetricAlarm("batMetricAlarm", {
 *     comparisonOperator: "GreaterThanOrEqualToThreshold",
 *     evaluationPeriods: "2",
 *     metricName: "CPUUtilization",
 *     namespace: "AWS/EC2",
 *     period: "120",
 *     statistic: "Average",
 *     threshold: "80",
 *     dimensions: {
 *         AutoScalingGroupName: aws_autoscaling_group.bar.name,
 *     },
 *     alarmDescription: "This metric monitors ec2 cpu utilization",
 *     alarmActions: [batPolicy.arn],
 * });
 * ```
 * ```python
 * import pulumi
 * import pulumi_aws as aws
 * 
 * bat_policy = aws.autoscaling.Policy("batPolicy",
 *     scaling_adjustment=4,
 *     adjustment_type="ChangeInCapacity",
 *     cooldown=300,
 *     autoscaling_group_name=aws_autoscaling_group["bar"]["name"])
 * bat_metric_alarm = aws.cloudwatch.MetricAlarm("batMetricAlarm",
 *     comparison_operator="GreaterThanOrEqualToThreshold",
 *     evaluation_periods=2,
 *     metric_name="CPUUtilization",
 *     namespace="AWS/EC2",
 *     period=120,
 *     statistic="Average",
 *     threshold=80,
 *     dimensions={
 *         "AutoScalingGroupName": aws_autoscaling_group["bar"]["name"],
 *     },
 *     alarm_description="This metric monitors ec2 cpu utilization",
 *     alarm_actions=[bat_policy.arn])
 * ```
 * ```csharp
 * using Pulumi;
 * using Aws = Pulumi.Aws;
 * 
 * class MyStack : Stack
 * {
 *     public MyStack()
 *     {
 *         var batPolicy = new Aws.AutoScaling.Policy("batPolicy", new Aws.AutoScaling.PolicyArgs
 *         {
 *             ScalingAdjustment = 4,
 *             AdjustmentType = "ChangeInCapacity",
 *             Cooldown = 300,
 *             AutoscalingGroupName = aws_autoscaling_group.Bar.Name,
 *         });
 *         var batMetricAlarm = new Aws.CloudWatch.MetricAlarm("batMetricAlarm", new Aws.CloudWatch.MetricAlarmArgs
 *         {
 *             ComparisonOperator = "GreaterThanOrEqualToThreshold",
 *             EvaluationPeriods = 2,
 *             MetricName = "CPUUtilization",
 *             Namespace = "AWS/EC2",
 *             Period = 120,
 *             Statistic = "Average",
 *             Threshold = 80,
 *             Dimensions = 
 *             {
 *                 { "AutoScalingGroupName", aws_autoscaling_group.Bar.Name },
 *             },
 *             AlarmDescription = "This metric monitors ec2 cpu utilization",
 *             AlarmActions = 
 *             {
 *                 batPolicy.Arn,
 *             },
 *         });
 *     }
 * 
 * }
 * ```
 * ```go
 * package main
 * 
 * import (
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/autoscaling"
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/cloudwatch"
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/sns"
 * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
 * )
 * 
 * func main() {
 * 	pulumi.Run(func(ctx *pulumi.Context) error {
 * 		batPolicy, err := autoscaling.NewPolicy(ctx, "batPolicy", &autoscaling.PolicyArgs{
 * 			ScalingAdjustment:    pulumi.Int(4),
 * 			AdjustmentType:       pulumi.String("ChangeInCapacity"),
 * 			Cooldown:             pulumi.Int(300),
 * 			AutoscalingGroupName: pulumi.Any(aws_autoscaling_group.Bar.Name),
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		_, err = cloudwatch.NewMetricAlarm(ctx, "batMetricAlarm", &cloudwatch.MetricAlarmArgs{
 * 			ComparisonOperator: pulumi.String("GreaterThanOrEqualToThreshold"),
 * 			EvaluationPeriods:  pulumi.Int(2),
 * 			MetricName:         pulumi.String("CPUUtilization"),
 * 			Namespace:          pulumi.String("AWS/EC2"),
 * 			Period:             pulumi.Int(120),
 * 			Statistic:          pulumi.String("Average"),
 * 			Threshold:          pulumi.Float64(80),
 * 			Dimensions: pulumi.StringMap{
 * 				"AutoScalingGroupName": pulumi.Any(aws_autoscaling_group.Bar.Name),
 * 			},
 * 			AlarmDescription: pulumi.String("This metric monitors ec2 cpu utilization"),
 * 			AlarmActions: pulumi.AnyArray{
 * 				batPolicy.Arn,
 * 			},
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		return nil
 * 	})
 * }
 * ```
 * 
 * ## Example with an Expression
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 * 
 * const foobar = new aws.cloudwatch.MetricAlarm("foobar", {
 *     alarmDescription: "Request error rate has exceeded 10%",
 *     comparisonOperator: "GreaterThanOrEqualToThreshold",
 *     evaluationPeriods: 2,
 *     insufficientDataActions: [],
 *     metricQueries: [
 *         {
 *             expression: "m2/m1*100",
 *             id: "e1",
 *             label: "Error Rate",
 *             returnData: true,
 *         },
 *         {
 *             id: "m1",
 *             metric: {
 *                 dimensions: {
 *                     LoadBalancer: "app/web",
 *                 },
 *                 metricName: "RequestCount",
 *                 namespace: "AWS/ApplicationELB",
 *                 period: 120,
 *                 stat: "Sum",
 *                 unit: "Count",
 *             },
 *         },
 *         {
 *             id: "m2",
 *             metric: {
 *                 dimensions: {
 *                     LoadBalancer: "app/web",
 *                 },
 *                 metricName: "HTTPCode_ELB_5XX_Count",
 *                 namespace: "AWS/ApplicationELB",
 *                 period: 120,
 *                 stat: "Sum",
 *                 unit: "Count",
 *             },
 *         },
 *     ],
 *     threshold: 10,
 * });
 * ```
 * ```python
 * import pulumi
 * import pulumi_aws as aws
 * 
 * foobar = aws.cloudwatch.MetricAlarm("foobar",
 *     alarm_description="Request error rate has exceeded 10%",
 *     comparison_operator="GreaterThanOrEqualToThreshold",
 *     evaluation_periods=2,
 *     insufficient_data_actions=[],
 *     metric_queries=[
 *         aws.cloudwatch.MetricAlarmMetricQueryArgs(
 *             expression="m2/m1*100",
 *             id="e1",
 *             label="Error Rate",
 *             return_data=True,
 *         ),
 *         aws.cloudwatch.MetricAlarmMetricQueryArgs(
 *             id="m1",
 *             metric=aws.cloudwatch.MetricAlarmMetricQueryMetricArgs(
 *                 dimensions={
 *                     "LoadBalancer": "app/web",
 *                 },
 *                 metric_name="RequestCount",
 *                 namespace="AWS/ApplicationELB",
 *                 period=120,
 *                 stat="Sum",
 *                 unit="Count",
 *             ),
 *         ),
 *         aws.cloudwatch.MetricAlarmMetricQueryArgs(
 *             id="m2",
 *             metric=aws.cloudwatch.MetricAlarmMetricQueryMetricArgs(
 *                 dimensions={
 *                     "LoadBalancer": "app/web",
 *                 },
 *                 metric_name="HTTPCode_ELB_5XX_Count",
 *                 namespace="AWS/ApplicationELB",
 *                 period=120,
 *                 stat="Sum",
 *                 unit="Count",
 *             ),
 *         ),
 *     ],
 *     threshold=10)
 * ```
 * ```csharp
 * using Pulumi;
 * using Aws = Pulumi.Aws;
 * 
 * class MyStack : Stack
 * {
 *     public MyStack()
 *     {
 *         var foobar = new Aws.CloudWatch.MetricAlarm("foobar", new Aws.CloudWatch.MetricAlarmArgs
 *         {
 *             AlarmDescription = "Request error rate has exceeded 10%",
 *             ComparisonOperator = "GreaterThanOrEqualToThreshold",
 *             EvaluationPeriods = 2,
 *             InsufficientDataActions = {},
 *             MetricQueries = 
 *             {
 *                 new Aws.CloudWatch.Inputs.MetricAlarmMetricQueryArgs
 *                 {
 *                     Expression = "m2/m1*100",
 *                     Id = "e1",
 *                     Label = "Error Rate",
 *                     ReturnData = true,
 *                 },
 *                 new Aws.CloudWatch.Inputs.MetricAlarmMetricQueryArgs
 *                 {
 *                     Id = "m1",
 *                     Metric = new Aws.CloudWatch.Inputs.MetricAlarmMetricQueryMetricArgs
 *                     {
 *                         Dimensions = 
 *                         {
 *                             { "LoadBalancer", "app/web" },
 *                         },
 *                         MetricName = "RequestCount",
 *                         Namespace = "AWS/ApplicationELB",
 *                         Period = 120,
 *                         Stat = "Sum",
 *                         Unit = "Count",
 *                     },
 *                 },
 *                 new Aws.CloudWatch.Inputs.MetricAlarmMetricQueryArgs
 *                 {
 *                     Id = "m2",
 *                     Metric = new Aws.CloudWatch.Inputs.MetricAlarmMetricQueryMetricArgs
 *                     {
 *                         Dimensions = 
 *                         {
 *                             { "LoadBalancer", "app/web" },
 *                         },
 *                         MetricName = "HTTPCode_ELB_5XX_Count",
 *                         Namespace = "AWS/ApplicationELB",
 *                         Period = 120,
 *                         Stat = "Sum",
 *                         Unit = "Count",
 *                     },
 *                 },
 *             },
 *             Threshold = 10,
 *         });
 *     }
 * 
 * }
 * ```
 * ```go
 * package main
 * 
 * import (
 * 	"fmt"
 * 
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/cloudwatch"
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/sns"
 * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
 * )
 * 
 * func main() {
 * 	pulumi.Run(func(ctx *pulumi.Context) error {
 * 		_, err := cloudwatch.NewMetricAlarm(ctx, "foobar", &cloudwatch.MetricAlarmArgs{
 * 			AlarmDescription:        pulumi.String(fmt.Sprintf("%v%v", "Request error rate has exceeded 10", "%")),
 * 			ComparisonOperator:      pulumi.String("GreaterThanOrEqualToThreshold"),
 * 			EvaluationPeriods:       pulumi.Int(2),
 * 			InsufficientDataActions: pulumi.AnyArray{},
 * 			MetricQueries: cloudwatch.MetricAlarmMetricQueryArray{
 * 				&cloudwatch.MetricAlarmMetricQueryArgs{
 * 					Expression: pulumi.String("m2/m1*100"),
 * 					Id:         pulumi.String("e1"),
 * 					Label:      pulumi.String("Error Rate"),
 * 					ReturnData: pulumi.Bool(true),
 * 				},
 * 				&cloudwatch.MetricAlarmMetricQueryArgs{
 * 					Id: pulumi.String("m1"),
 * 					Metric: &cloudwatch.MetricAlarmMetricQueryMetricArgs{
 * 						Dimensions: pulumi.StringMap{
 * 							"LoadBalancer": pulumi.String("app/web"),
 * 						},
 * 						MetricName: pulumi.String("RequestCount"),
 * 						Namespace:  pulumi.String("AWS/ApplicationELB"),
 * 						Period:     pulumi.Int(120),
 * 						Stat:       pulumi.String("Sum"),
 * 						Unit:       pulumi.String("Count"),
 * 					},
 * 				},
 * 				&cloudwatch.MetricAlarmMetricQueryArgs{
 * 					Id: pulumi.String("m2"),
 * 					Metric: &cloudwatch.MetricAlarmMetricQueryMetricArgs{
 * 						Dimensions: pulumi.StringMap{
 * 							"LoadBalancer": pulumi.String("app/web"),
 * 						},
 * 						MetricName: pulumi.String("HTTPCode_ELB_5XX_Count"),
 * 						Namespace:  pulumi.String("AWS/ApplicationELB"),
 * 						Period:     pulumi.Int(120),
 * 						Stat:       pulumi.String("Sum"),
 * 						Unit:       pulumi.String("Count"),
 * 					},
 * 				},
 * 			},
 * 			Threshold: pulumi.Float64(10),
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		return nil
 * 	})
 * }
 * ```
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 * 
 * const xxAnomalyDetection = new aws.cloudwatch.MetricAlarm("xx_anomaly_detection", {
 *     alarmDescription: "This metric monitors ec2 cpu utilization",
 *     comparisonOperator: "GreaterThanUpperThreshold",
 *     evaluationPeriods: 2,
 *     insufficientDataActions: [],
 *     metricQueries: [
 *         {
 *             expression: "ANOMALY_DETECTION_BAND(m1)",
 *             id: "e1",
 *             label: "CPUUtilization (Expected)",
 *             returnData: true,
 *         },
 *         {
 *             id: "m1",
 *             metric: {
 *                 dimensions: {
 *                     InstanceId: "i-abc123",
 *                 },
 *                 metricName: "CPUUtilization",
 *                 namespace: "AWS/EC2",
 *                 period: 120,
 *                 stat: "Average",
 *                 unit: "Count",
 *             },
 *             returnData: true,
 *         },
 *     ],
 *     thresholdMetricId: "e1",
 * });
 * ```
 * ```python
 * import pulumi
 * import pulumi_aws as aws
 * 
 * xx_anomaly_detection = aws.cloudwatch.MetricAlarm("xxAnomalyDetection",
 *     alarm_description="This metric monitors ec2 cpu utilization",
 *     comparison_operator="GreaterThanUpperThreshold",
 *     evaluation_periods=2,
 *     insufficient_data_actions=[],
 *     metric_queries=[
 *         aws.cloudwatch.MetricAlarmMetricQueryArgs(
 *             expression="ANOMALY_DETECTION_BAND(m1)",
 *             id="e1",
 *             label="CPUUtilization (Expected)",
 *             return_data=True,
 *         ),
 *         aws.cloudwatch.MetricAlarmMetricQueryArgs(
 *             id="m1",
 *             metric=aws.cloudwatch.MetricAlarmMetricQueryMetricArgs(
 *                 dimensions={
 *                     "InstanceId": "i-abc123",
 *                 },
 *                 metric_name="CPUUtilization",
 *                 namespace="AWS/EC2",
 *                 period=120,
 *                 stat="Average",
 *                 unit="Count",
 *             ),
 *             return_data=True,
 *         ),
 *     ],
 *     threshold_metric_id="e1")
 * ```
 * ```csharp
 * using Pulumi;
 * using Aws = Pulumi.Aws;
 * 
 * class MyStack : Stack
 * {
 *     public MyStack()
 *     {
 *         var xxAnomalyDetection = new Aws.CloudWatch.MetricAlarm("xxAnomalyDetection", new Aws.CloudWatch.MetricAlarmArgs
 *         {
 *             AlarmDescription = "This metric monitors ec2 cpu utilization",
 *             ComparisonOperator = "GreaterThanUpperThreshold",
 *             EvaluationPeriods = 2,
 *             InsufficientDataActions = {},
 *             MetricQueries = 
 *             {
 *                 new Aws.CloudWatch.Inputs.MetricAlarmMetricQueryArgs
 *                 {
 *                     Expression = "ANOMALY_DETECTION_BAND(m1)",
 *                     Id = "e1",
 *                     Label = "CPUUtilization (Expected)",
 *                     ReturnData = true,
 *                 },
 *                 new Aws.CloudWatch.Inputs.MetricAlarmMetricQueryArgs
 *                 {
 *                     Id = "m1",
 *                     Metric = new Aws.CloudWatch.Inputs.MetricAlarmMetricQueryMetricArgs
 *                     {
 *                         Dimensions = 
 *                         {
 *                             { "InstanceId", "i-abc123" },
 *                         },
 *                         MetricName = "CPUUtilization",
 *                         Namespace = "AWS/EC2",
 *                         Period = 120,
 *                         Stat = "Average",
 *                         Unit = "Count",
 *                     },
 *                     ReturnData = true,
 *                 },
 *             },
 *             ThresholdMetricId = "e1",
 *         });
 *     }
 * 
 * }
 * ```
 * ```go
 * package main
 * 
 * import (
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/cloudwatch"
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/sns"
 * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
 * )
 * 
 * func main() {
 * 	pulumi.Run(func(ctx *pulumi.Context) error {
 * 		_, err := cloudwatch.NewMetricAlarm(ctx, "xxAnomalyDetection", &cloudwatch.MetricAlarmArgs{
 * 			AlarmDescription:        pulumi.String("This metric monitors ec2 cpu utilization"),
 * 			ComparisonOperator:      pulumi.String("GreaterThanUpperThreshold"),
 * 			EvaluationPeriods:       pulumi.Int(2),
 * 			InsufficientDataActions: pulumi.AnyArray{},
 * 			MetricQueries: cloudwatch.MetricAlarmMetricQueryArray{
 * 				&cloudwatch.MetricAlarmMetricQueryArgs{
 * 					Expression: pulumi.String("ANOMALY_DETECTION_BAND(m1)"),
 * 					Id:         pulumi.String("e1"),
 * 					Label:      pulumi.String("CPUUtilization (Expected)"),
 * 					ReturnData: pulumi.Bool(true),
 * 				},
 * 				&cloudwatch.MetricAlarmMetricQueryArgs{
 * 					Id: pulumi.String("m1"),
 * 					Metric: &cloudwatch.MetricAlarmMetricQueryMetricArgs{
 * 						Dimensions: pulumi.StringMap{
 * 							"InstanceId": pulumi.String("i-abc123"),
 * 						},
 * 						MetricName: pulumi.String("CPUUtilization"),
 * 						Namespace:  pulumi.String("AWS/EC2"),
 * 						Period:     pulumi.Int(120),
 * 						Stat:       pulumi.String("Average"),
 * 						Unit:       pulumi.String("Count"),
 * 					},
 * 					ReturnData: pulumi.Bool(true),
 * 				},
 * 			},
 * 			ThresholdMetricId: pulumi.String("e1"),
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		return nil
 * 	})
 * }
 * ```
 * 
 * ## Example of monitoring Healthy Hosts on NLB using Target Group and NLB
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 * 
 * const nlbHealthyhosts = new aws.cloudwatch.MetricAlarm("nlbHealthyhosts", {
 *     comparisonOperator: "LessThanThreshold",
 *     evaluationPeriods: "1",
 *     metricName: "HealthyHostCount",
 *     namespace: "AWS/NetworkELB",
 *     period: "60",
 *     statistic: "Average",
 *     threshold: _var.logstash_servers_count,
 *     alarmDescription: "Number of healthy nodes in Target Group",
 *     actionsEnabled: "true",
 *     alarmActions: [aws_sns_topic.sns.arn],
 *     okActions: [aws_sns_topic.sns.arn],
 *     dimensions: {
 *         TargetGroup: aws_lb_target_group["lb-tg"].arn_suffix,
 *         LoadBalancer: aws_lb.lb.arn_suffix,
 *     },
 * });
 * ```
 * ```python
 * import pulumi
 * import pulumi_aws as aws
 * 
 * nlb_healthyhosts = aws.cloudwatch.MetricAlarm("nlbHealthyhosts",
 *     comparison_operator="LessThanThreshold",
 *     evaluation_periods=1,
 *     metric_name="HealthyHostCount",
 *     namespace="AWS/NetworkELB",
 *     period=60,
 *     statistic="Average",
 *     threshold=var["logstash_servers_count"],
 *     alarm_description="Number of healthy nodes in Target Group",
 *     actions_enabled=True,
 *     alarm_actions=[aws_sns_topic["sns"]["arn"]],
 *     ok_actions=[aws_sns_topic["sns"]["arn"]],
 *     dimensions={
 *         "TargetGroup": aws_lb_target_group["lb-tg"]["arn_suffix"],
 *         "LoadBalancer": aws_lb["lb"]["arn_suffix"],
 *     })
 * ```
 * ```csharp
 * using Pulumi;
 * using Aws = Pulumi.Aws;
 * 
 * class MyStack : Stack
 * {
 *     public MyStack()
 *     {
 *         var nlbHealthyhosts = new Aws.CloudWatch.MetricAlarm("nlbHealthyhosts", new Aws.CloudWatch.MetricAlarmArgs
 *         {
 *             ComparisonOperator = "LessThanThreshold",
 *             EvaluationPeriods = 1,
 *             MetricName = "HealthyHostCount",
 *             Namespace = "AWS/NetworkELB",
 *             Period = 60,
 *             Statistic = "Average",
 *             Threshold = @var.Logstash_servers_count,
 *             AlarmDescription = "Number of healthy nodes in Target Group",
 *             ActionsEnabled = true,
 *             AlarmActions = 
 *             {
 *                 aws_sns_topic.Sns.Arn,
 *             },
 *             OkActions = 
 *             {
 *                 aws_sns_topic.Sns.Arn,
 *             },
 *             Dimensions = 
 *             {
 *                 { "TargetGroup", aws_lb_target_group.Lb_tg.Arn_suffix },
 *                 { "LoadBalancer", aws_lb.Lb.Arn_suffix },
 *             },
 *         });
 *     }
 * 
 * }
 * ```
 * ```go
 * package main
 * 
 * import (
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/cloudwatch"
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/sns"
 * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
 * )
 * 
 * func main() {
 * 	pulumi.Run(func(ctx *pulumi.Context) error {
 * 		_, err := cloudwatch.NewMetricAlarm(ctx, "nlbHealthyhosts", &cloudwatch.MetricAlarmArgs{
 * 			ComparisonOperator: pulumi.String("LessThanThreshold"),
 * 			EvaluationPeriods:  pulumi.Int(1),
 * 			MetricName:         pulumi.String("HealthyHostCount"),
 * 			Namespace:          pulumi.String("AWS/NetworkELB"),
 * 			Period:             pulumi.Int(60),
 * 			Statistic:          pulumi.String("Average"),
 * 			Threshold:          pulumi.Any(_var.Logstash_servers_count),
 * 			AlarmDescription:   pulumi.String("Number of healthy nodes in Target Group"),
 * 			ActionsEnabled:     pulumi.Bool(true),
 * 			AlarmActions: pulumi.AnyArray{
 * 				pulumi.Any(aws_sns_topic.Sns.Arn),
 * 			},
 * 			OkActions: pulumi.AnyArray{
 * 				pulumi.Any(aws_sns_topic.Sns.Arn),
 * 			},
 * 			Dimensions: pulumi.StringMap{
 * 				"TargetGroup":  pulumi.Any(aws_lb_target_group.Lb - tg.Arn_suffix),
 * 				"LoadBalancer": pulumi.Any(aws_lb.Lb.Arn_suffix),
 * 			},
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		return nil
 * 	})
 * }
 * ```
 * 
 * > **NOTE:**  You cannot create a metric alarm consisting of both `statistic` and `extended_statistic` parameters.
 * You must choose one or the other
 * 
 * 
 * ## Import
 * 
 * CloudWatch Metric Alarm can be imported using the `alarm_name`, e.g.,
 * 
 * ```sh
 *  $ pulumi import aws:cloudwatch/metricAlarm:MetricAlarm test alarm-12345
 * ```
 * 
 *  
 */
@ResourceType(type="aws:cloudwatch/metricAlarm:MetricAlarm")
public class MetricAlarm extends io.pulumi.resources.CustomResource {
    /**
     * Indicates whether or not actions should be executed during any changes to the alarm's state. Defaults to `true`.
     * 
     */
    @Export(name="actionsEnabled", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> actionsEnabled;

    /**
     * @return Indicates whether or not actions should be executed during any changes to the alarm's state. Defaults to `true`.
     * 
     */
    public Output</* @Nullable */ Boolean> getActionsEnabled() {
        return this.actionsEnabled;
    }
    /**
     * The list of actions to execute when this alarm transitions into an ALARM state from any other state. Each action is specified as an Amazon Resource Name (ARN).
     * 
     */
    @Export(name="alarmActions", type=List.class, parameters={String.class})
    private Output</* @Nullable */ List<String>> alarmActions;

    /**
     * @return The list of actions to execute when this alarm transitions into an ALARM state from any other state. Each action is specified as an Amazon Resource Name (ARN).
     * 
     */
    public Output</* @Nullable */ List<String>> getAlarmActions() {
        return this.alarmActions;
    }
    /**
     * The description for the alarm.
     * 
     */
    @Export(name="alarmDescription", type=String.class, parameters={})
    private Output</* @Nullable */ String> alarmDescription;

    /**
     * @return The description for the alarm.
     * 
     */
    public Output</* @Nullable */ String> getAlarmDescription() {
        return this.alarmDescription;
    }
    /**
     * The ARN of the CloudWatch Metric Alarm.
     * 
     */
    @Export(name="arn", type=String.class, parameters={})
    private Output<String> arn;

    /**
     * @return The ARN of the CloudWatch Metric Alarm.
     * 
     */
    public Output<String> getArn() {
        return this.arn;
    }
    /**
     * The arithmetic operation to use when comparing the specified Statistic and Threshold. The specified Statistic value is used as the first operand. Either of the following is supported: `GreaterThanOrEqualToThreshold`, `GreaterThanThreshold`, `LessThanThreshold`, `LessThanOrEqualToThreshold`. Additionally, the values  `LessThanLowerOrGreaterThanUpperThreshold`, `LessThanLowerThreshold`, and `GreaterThanUpperThreshold` are used only for alarms based on anomaly detection models.
     * 
     */
    @Export(name="comparisonOperator", type=String.class, parameters={})
    private Output<String> comparisonOperator;

    /**
     * @return The arithmetic operation to use when comparing the specified Statistic and Threshold. The specified Statistic value is used as the first operand. Either of the following is supported: `GreaterThanOrEqualToThreshold`, `GreaterThanThreshold`, `LessThanThreshold`, `LessThanOrEqualToThreshold`. Additionally, the values  `LessThanLowerOrGreaterThanUpperThreshold`, `LessThanLowerThreshold`, and `GreaterThanUpperThreshold` are used only for alarms based on anomaly detection models.
     * 
     */
    public Output<String> getComparisonOperator() {
        return this.comparisonOperator;
    }
    /**
     * The number of datapoints that must be breaching to trigger the alarm.
     * 
     */
    @Export(name="datapointsToAlarm", type=Integer.class, parameters={})
    private Output</* @Nullable */ Integer> datapointsToAlarm;

    /**
     * @return The number of datapoints that must be breaching to trigger the alarm.
     * 
     */
    public Output</* @Nullable */ Integer> getDatapointsToAlarm() {
        return this.datapointsToAlarm;
    }
    /**
     * The dimensions for this metric.  For the list of available dimensions see the AWS documentation [here](http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/CW_Support_For_AWS.html).
     * 
     */
    @Export(name="dimensions", type=Map.class, parameters={String.class, String.class})
    private Output</* @Nullable */ Map<String,String>> dimensions;

    /**
     * @return The dimensions for this metric.  For the list of available dimensions see the AWS documentation [here](http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/CW_Support_For_AWS.html).
     * 
     */
    public Output</* @Nullable */ Map<String,String>> getDimensions() {
        return this.dimensions;
    }
    /**
     * Used only for alarms
     * based on percentiles. If you specify `ignore`, the alarm state will not
     * change during periods with too few data points to be statistically significant.
     * If you specify `evaluate` or omit this parameter, the alarm will always be
     * evaluated and possibly change state no matter how many data points are available.
     * The following values are supported: `ignore`, and `evaluate`.
     * 
     */
    @Export(name="evaluateLowSampleCountPercentiles", type=String.class, parameters={})
    private Output<String> evaluateLowSampleCountPercentiles;

    /**
     * @return Used only for alarms
     * based on percentiles. If you specify `ignore`, the alarm state will not
     * change during periods with too few data points to be statistically significant.
     * If you specify `evaluate` or omit this parameter, the alarm will always be
     * evaluated and possibly change state no matter how many data points are available.
     * The following values are supported: `ignore`, and `evaluate`.
     * 
     */
    public Output<String> getEvaluateLowSampleCountPercentiles() {
        return this.evaluateLowSampleCountPercentiles;
    }
    /**
     * The number of periods over which data is compared to the specified threshold.
     * 
     */
    @Export(name="evaluationPeriods", type=Integer.class, parameters={})
    private Output<Integer> evaluationPeriods;

    /**
     * @return The number of periods over which data is compared to the specified threshold.
     * 
     */
    public Output<Integer> getEvaluationPeriods() {
        return this.evaluationPeriods;
    }
    /**
     * The percentile statistic for the metric associated with the alarm. Specify a value between p0.0 and p100.
     * 
     */
    @Export(name="extendedStatistic", type=String.class, parameters={})
    private Output</* @Nullable */ String> extendedStatistic;

    /**
     * @return The percentile statistic for the metric associated with the alarm. Specify a value between p0.0 and p100.
     * 
     */
    public Output</* @Nullable */ String> getExtendedStatistic() {
        return this.extendedStatistic;
    }
    /**
     * The list of actions to execute when this alarm transitions into an INSUFFICIENT_DATA state from any other state. Each action is specified as an Amazon Resource Name (ARN).
     * 
     */
    @Export(name="insufficientDataActions", type=List.class, parameters={String.class})
    private Output</* @Nullable */ List<String>> insufficientDataActions;

    /**
     * @return The list of actions to execute when this alarm transitions into an INSUFFICIENT_DATA state from any other state. Each action is specified as an Amazon Resource Name (ARN).
     * 
     */
    public Output</* @Nullable */ List<String>> getInsufficientDataActions() {
        return this.insufficientDataActions;
    }
    /**
     * The name for this metric.
     * See docs for [supported metrics](https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/CW_Support_For_AWS.html).
     * 
     */
    @Export(name="metricName", type=String.class, parameters={})
    private Output</* @Nullable */ String> metricName;

    /**
     * @return The name for this metric.
     * See docs for [supported metrics](https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/CW_Support_For_AWS.html).
     * 
     */
    public Output</* @Nullable */ String> getMetricName() {
        return this.metricName;
    }
    /**
     * Enables you to create an alarm based on a metric math expression. You may specify at most 20.
     * 
     */
    @Export(name="metricQueries", type=List.class, parameters={MetricAlarmMetricQuery.class})
    private Output</* @Nullable */ List<MetricAlarmMetricQuery>> metricQueries;

    /**
     * @return Enables you to create an alarm based on a metric math expression. You may specify at most 20.
     * 
     */
    public Output</* @Nullable */ List<MetricAlarmMetricQuery>> getMetricQueries() {
        return this.metricQueries;
    }
    /**
     * The descriptive name for the alarm. This name must be unique within the user's AWS account
     * 
     */
    @Export(name="name", type=String.class, parameters={})
    private Output<String> name;

    /**
     * @return The descriptive name for the alarm. This name must be unique within the user's AWS account
     * 
     */
    public Output<String> getName() {
        return this.name;
    }
    /**
     * The namespace for this metric. See docs for the [list of namespaces](https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/aws-namespaces.html).
     * See docs for [supported metrics](https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/CW_Support_For_AWS.html).
     * 
     */
    @Export(name="namespace", type=String.class, parameters={})
    private Output</* @Nullable */ String> namespace;

    /**
     * @return The namespace for this metric. See docs for the [list of namespaces](https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/aws-namespaces.html).
     * See docs for [supported metrics](https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/CW_Support_For_AWS.html).
     * 
     */
    public Output</* @Nullable */ String> getNamespace() {
        return this.namespace;
    }
    /**
     * The list of actions to execute when this alarm transitions into an OK state from any other state. Each action is specified as an Amazon Resource Name (ARN).
     * 
     */
    @Export(name="okActions", type=List.class, parameters={String.class})
    private Output</* @Nullable */ List<String>> okActions;

    /**
     * @return The list of actions to execute when this alarm transitions into an OK state from any other state. Each action is specified as an Amazon Resource Name (ARN).
     * 
     */
    public Output</* @Nullable */ List<String>> getOkActions() {
        return this.okActions;
    }
    /**
     * The period in seconds over which the specified `stat` is applied.
     * 
     */
    @Export(name="period", type=Integer.class, parameters={})
    private Output</* @Nullable */ Integer> period;

    /**
     * @return The period in seconds over which the specified `stat` is applied.
     * 
     */
    public Output</* @Nullable */ Integer> getPeriod() {
        return this.period;
    }
    /**
     * The statistic to apply to the alarm's associated metric.
     * Either of the following is supported: `SampleCount`, `Average`, `Sum`, `Minimum`, `Maximum`
     * 
     */
    @Export(name="statistic", type=String.class, parameters={})
    private Output</* @Nullable */ String> statistic;

    /**
     * @return The statistic to apply to the alarm's associated metric.
     * Either of the following is supported: `SampleCount`, `Average`, `Sum`, `Minimum`, `Maximum`
     * 
     */
    public Output</* @Nullable */ String> getStatistic() {
        return this.statistic;
    }
    /**
     * A map of tags to assign to the resource. .If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
     * 
     */
    @Export(name="tags", type=Map.class, parameters={String.class, String.class})
    private Output</* @Nullable */ Map<String,String>> tags;

    /**
     * @return A map of tags to assign to the resource. .If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
     * 
     */
    public Output</* @Nullable */ Map<String,String>> getTags() {
        return this.tags;
    }
    /**
     * A map of tags assigned to the resource, including those inherited from the provider .
     * 
     */
    @Export(name="tagsAll", type=Map.class, parameters={String.class, String.class})
    private Output<Map<String,String>> tagsAll;

    /**
     * @return A map of tags assigned to the resource, including those inherited from the provider .
     * 
     */
    public Output<Map<String,String>> getTagsAll() {
        return this.tagsAll;
    }
    /**
     * The value against which the specified statistic is compared. This parameter is required for alarms based on static thresholds, but should not be used for alarms based on anomaly detection models.
     * 
     */
    @Export(name="threshold", type=Double.class, parameters={})
    private Output</* @Nullable */ Double> threshold;

    /**
     * @return The value against which the specified statistic is compared. This parameter is required for alarms based on static thresholds, but should not be used for alarms based on anomaly detection models.
     * 
     */
    public Output</* @Nullable */ Double> getThreshold() {
        return this.threshold;
    }
    /**
     * If this is an alarm based on an anomaly detection model, make this value match the ID of the ANOMALY_DETECTION_BAND function.
     * 
     */
    @Export(name="thresholdMetricId", type=String.class, parameters={})
    private Output</* @Nullable */ String> thresholdMetricId;

    /**
     * @return If this is an alarm based on an anomaly detection model, make this value match the ID of the ANOMALY_DETECTION_BAND function.
     * 
     */
    public Output</* @Nullable */ String> getThresholdMetricId() {
        return this.thresholdMetricId;
    }
    /**
     * Sets how this alarm is to handle missing data points. The following values are supported: `missing`, `ignore`, `breaching` and `notBreaching`. Defaults to `missing`.
     * 
     */
    @Export(name="treatMissingData", type=String.class, parameters={})
    private Output</* @Nullable */ String> treatMissingData;

    /**
     * @return Sets how this alarm is to handle missing data points. The following values are supported: `missing`, `ignore`, `breaching` and `notBreaching`. Defaults to `missing`.
     * 
     */
    public Output</* @Nullable */ String> getTreatMissingData() {
        return this.treatMissingData;
    }
    /**
     * The unit for this metric.
     * 
     */
    @Export(name="unit", type=String.class, parameters={})
    private Output</* @Nullable */ String> unit;

    /**
     * @return The unit for this metric.
     * 
     */
    public Output</* @Nullable */ String> getUnit() {
        return this.unit;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public MetricAlarm(String name) {
        this(name, MetricAlarmArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public MetricAlarm(String name, MetricAlarmArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public MetricAlarm(String name, MetricAlarmArgs args, @Nullable io.pulumi.resources.CustomResourceOptions options) {
        super("aws:cloudwatch/metricAlarm:MetricAlarm", name, args == null ? MetricAlarmArgs.Empty : args, makeResourceOptions(options, Output.empty()));
    }

    private MetricAlarm(String name, Output<String> id, @Nullable MetricAlarmState state, @Nullable io.pulumi.resources.CustomResourceOptions options) {
        super("aws:cloudwatch/metricAlarm:MetricAlarm", name, state, makeResourceOptions(options, id));
    }

    private static io.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable io.pulumi.resources.CustomResourceOptions options, @Nullable Output<String> id) {
        var defaultOptions = io.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return io.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static MetricAlarm get(String name, Output<String> id, @Nullable MetricAlarmState state, @Nullable io.pulumi.resources.CustomResourceOptions options) {
        return new MetricAlarm(name, id, state, options);
    }
}
