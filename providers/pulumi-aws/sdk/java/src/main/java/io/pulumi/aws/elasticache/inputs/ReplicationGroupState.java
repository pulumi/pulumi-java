// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package io.pulumi.aws.elasticache.inputs;

import io.pulumi.aws.elasticache.inputs.ReplicationGroupClusterModeGetArgs;
import io.pulumi.core.Input;
import io.pulumi.core.annotations.InputImport;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import javax.annotation.Nullable;


public final class ReplicationGroupState extends io.pulumi.resources.ResourceArgs {

    public static final ReplicationGroupState Empty = new ReplicationGroupState();

    /**
     * Specifies whether any modifications are applied immediately, or during the next maintenance window. Default is `false`.
     * 
     */
    @InputImport(name="applyImmediately")
      private final @Nullable Input<Boolean> applyImmediately;

    public Input<Boolean> getApplyImmediately() {
        return this.applyImmediately == null ? Input.empty() : this.applyImmediately;
    }

    /**
     * ARN of the created ElastiCache Replication Group.
     * 
     */
    @InputImport(name="arn")
      private final @Nullable Input<String> arn;

    public Input<String> getArn() {
        return this.arn == null ? Input.empty() : this.arn;
    }

    /**
     * Whether to enable encryption at rest.
     * 
     */
    @InputImport(name="atRestEncryptionEnabled")
      private final @Nullable Input<Boolean> atRestEncryptionEnabled;

    public Input<Boolean> getAtRestEncryptionEnabled() {
        return this.atRestEncryptionEnabled == null ? Input.empty() : this.atRestEncryptionEnabled;
    }

    /**
     * Password used to access a password protected server. Can be specified only if `transit_encryption_enabled = true`.
     * 
     */
    @InputImport(name="authToken")
      private final @Nullable Input<String> authToken;

    public Input<String> getAuthToken() {
        return this.authToken == null ? Input.empty() : this.authToken;
    }

    /**
     * Specifies whether a minor engine upgrades will be applied automatically to the underlying Cache Cluster instances during the maintenance window. This parameter is currently not supported by the AWS API. Defaults to `true`.
     * 
     */
    @InputImport(name="autoMinorVersionUpgrade")
      private final @Nullable Input<Boolean> autoMinorVersionUpgrade;

    public Input<Boolean> getAutoMinorVersionUpgrade() {
        return this.autoMinorVersionUpgrade == null ? Input.empty() : this.autoMinorVersionUpgrade;
    }

    /**
     * Specifies whether a read-only replica will be automatically promoted to read/write primary if the existing primary fails. If enabled, `number_cache_clusters` must be greater than 1. Must be enabled for Redis (cluster mode enabled) replication groups. Defaults to `false`.
     * 
     */
    @InputImport(name="automaticFailoverEnabled")
      private final @Nullable Input<Boolean> automaticFailoverEnabled;

    public Input<Boolean> getAutomaticFailoverEnabled() {
        return this.automaticFailoverEnabled == null ? Input.empty() : this.automaticFailoverEnabled;
    }

    /**
     * List of EC2 availability zones in which the replication group's cache clusters will be created. The order of the availability zones in the list is not important.
     * 
     */
    @InputImport(name="availabilityZones")
      private final @Nullable Input<List<String>> availabilityZones;

    public Input<List<String>> getAvailabilityZones() {
        return this.availabilityZones == null ? Input.empty() : this.availabilityZones;
    }

    /**
     * Indicates if cluster mode is enabled.
     * 
     */
    @InputImport(name="clusterEnabled")
      private final @Nullable Input<Boolean> clusterEnabled;

    public Input<Boolean> getClusterEnabled() {
        return this.clusterEnabled == null ? Input.empty() : this.clusterEnabled;
    }

    /**
     * Create a native Redis cluster. `automatic_failover_enabled` must be set to true. Cluster Mode documented below. Only 1 `cluster_mode` block is allowed. Note that configuring this block does not enable cluster mode, i.e., data sharding, this requires using a parameter group that has the parameter `cluster-enabled` set to true.
     * 
     */
    @InputImport(name="clusterMode")
      private final @Nullable Input<ReplicationGroupClusterModeGetArgs> clusterMode;

    public Input<ReplicationGroupClusterModeGetArgs> getClusterMode() {
        return this.clusterMode == null ? Input.empty() : this.clusterMode;
    }

    /**
     * Address of the replication group configuration endpoint when cluster mode is enabled.
     * 
     */
    @InputImport(name="configurationEndpointAddress")
      private final @Nullable Input<String> configurationEndpointAddress;

    public Input<String> getConfigurationEndpointAddress() {
        return this.configurationEndpointAddress == null ? Input.empty() : this.configurationEndpointAddress;
    }

    /**
     * Enables data tiering. Data tiering is only supported for replication groups using the r6gd node type. This parameter must be set to `true` when using r6gd nodes.
     * 
     */
    @InputImport(name="dataTieringEnabled")
      private final @Nullable Input<Boolean> dataTieringEnabled;

    public Input<Boolean> getDataTieringEnabled() {
        return this.dataTieringEnabled == null ? Input.empty() : this.dataTieringEnabled;
    }

    /**
     * Name of the cache engine to be used for the clusters in this replication group. The only valid value is `redis`.
     * 
     */
    @InputImport(name="engine")
      private final @Nullable Input<String> engine;

    public Input<String> getEngine() {
        return this.engine == null ? Input.empty() : this.engine;
    }

    /**
     * Version number of the cache engine to be used for the cache clusters in this replication group. If the version is 6 or higher, only the major version can be set, e.g., `6.x`, otherwise, specify the full version desired, e.g., `5.0.6`. The actual engine version used is returned in the attribute `engine_version_actual`, defined below.
     * 
     */
    @InputImport(name="engineVersion")
      private final @Nullable Input<String> engineVersion;

    public Input<String> getEngineVersion() {
        return this.engineVersion == null ? Input.empty() : this.engineVersion;
    }

    /**
     * Running version of the cache engine.
     * 
     */
    @InputImport(name="engineVersionActual")
      private final @Nullable Input<String> engineVersionActual;

    public Input<String> getEngineVersionActual() {
        return this.engineVersionActual == null ? Input.empty() : this.engineVersionActual;
    }

    /**
     * The name of your final node group (shard) snapshot. ElastiCache creates the snapshot from the primary node in the cluster. If omitted, no final snapshot will be made.
     * 
     */
    @InputImport(name="finalSnapshotIdentifier")
      private final @Nullable Input<String> finalSnapshotIdentifier;

    public Input<String> getFinalSnapshotIdentifier() {
        return this.finalSnapshotIdentifier == null ? Input.empty() : this.finalSnapshotIdentifier;
    }

    /**
     * The ID of the global replication group to which this replication group should belong. If this parameter is specified, the replication group is added to the specified global replication group as a secondary replication group; otherwise, the replication group is not part of any global replication group. If `global_replication_group_id` is set, the `num_node_groups` parameter of the `cluster_mode` block cannot be set.
     * 
     */
    @InputImport(name="globalReplicationGroupId")
      private final @Nullable Input<String> globalReplicationGroupId;

    public Input<String> getGlobalReplicationGroupId() {
        return this.globalReplicationGroupId == null ? Input.empty() : this.globalReplicationGroupId;
    }

    /**
     * The ARN of the key that you wish to use if encrypting at rest. If not supplied, uses service managed encryption. Can be specified only if `at_rest_encryption_enabled = true`.
     * 
     */
    @InputImport(name="kmsKeyId")
      private final @Nullable Input<String> kmsKeyId;

    public Input<String> getKmsKeyId() {
        return this.kmsKeyId == null ? Input.empty() : this.kmsKeyId;
    }

    /**
     * Specifies the weekly time range for when maintenance on the cache cluster is performed. The format is `ddd:hh24:mi-ddd:hh24:mi` (24H Clock UTC). The minimum maintenance window is a 60 minute period. Example: `sun:05:00-sun:09:00`
     * 
     */
    @InputImport(name="maintenanceWindow")
      private final @Nullable Input<String> maintenanceWindow;

    public Input<String> getMaintenanceWindow() {
        return this.maintenanceWindow == null ? Input.empty() : this.maintenanceWindow;
    }

    /**
     * Identifiers of all the nodes that are part of this replication group.
     * 
     */
    @InputImport(name="memberClusters")
      private final @Nullable Input<List<String>> memberClusters;

    public Input<List<String>> getMemberClusters() {
        return this.memberClusters == null ? Input.empty() : this.memberClusters;
    }

    /**
     * Specifies whether to enable Multi-AZ Support for the replication group. If `true`, `automatic_failover_enabled` must also be enabled. Defaults to `false`.
     * 
     */
    @InputImport(name="multiAzEnabled")
      private final @Nullable Input<Boolean> multiAzEnabled;

    public Input<Boolean> getMultiAzEnabled() {
        return this.multiAzEnabled == null ? Input.empty() : this.multiAzEnabled;
    }

    /**
     * Instance class to be used. See AWS documentation for information on [supported node types](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/CacheNodes.SupportedTypes.html) and [guidance on selecting node types](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/nodes-select-size.html). Required unless `global_replication_group_id` is set. Cannot be set if `global_replication_group_id` is set.
     * 
     */
    @InputImport(name="nodeType")
      private final @Nullable Input<String> nodeType;

    public Input<String> getNodeType() {
        return this.nodeType == null ? Input.empty() : this.nodeType;
    }

    /**
     * ARN of an SNS topic to send ElastiCache notifications to. Example: `arn:aws:sns:us-east-1:012345678999:my_sns_topic`
     * 
     */
    @InputImport(name="notificationTopicArn")
      private final @Nullable Input<String> notificationTopicArn;

    public Input<String> getNotificationTopicArn() {
        return this.notificationTopicArn == null ? Input.empty() : this.notificationTopicArn;
    }

    /**
     * Number of cache clusters (primary and replicas) this replication group will have. If Multi-AZ is enabled, the value of this parameter must be at least 2. Updates will occur before other modifications. One of `number_cache_clusters` or `cluster_mode` is required.
     * 
     */
    @InputImport(name="numberCacheClusters")
      private final @Nullable Input<Integer> numberCacheClusters;

    public Input<Integer> getNumberCacheClusters() {
        return this.numberCacheClusters == null ? Input.empty() : this.numberCacheClusters;
    }

    /**
     * Name of the parameter group to associate with this replication group. If this argument is omitted, the default cache parameter group for the specified engine is used. To enable "cluster mode", i.e., data sharding, use a parameter group that has the parameter `cluster-enabled` set to true.
     * 
     */
    @InputImport(name="parameterGroupName")
      private final @Nullable Input<String> parameterGroupName;

    public Input<String> getParameterGroupName() {
        return this.parameterGroupName == null ? Input.empty() : this.parameterGroupName;
    }

    /**
     * Port number on which each of the cache nodes will accept connections. For Memcache the default is 11211, and for Redis the default port is 6379.
     * 
     */
    @InputImport(name="port")
      private final @Nullable Input<Integer> port;

    public Input<Integer> getPort() {
        return this.port == null ? Input.empty() : this.port;
    }

    /**
     * (Redis only) Address of the endpoint for the primary node in the replication group, if the cluster mode is disabled.
     * 
     */
    @InputImport(name="primaryEndpointAddress")
      private final @Nullable Input<String> primaryEndpointAddress;

    public Input<String> getPrimaryEndpointAddress() {
        return this.primaryEndpointAddress == null ? Input.empty() : this.primaryEndpointAddress;
    }

    /**
     * (Redis only) Address of the endpoint for the reader node in the replication group, if the cluster mode is disabled.
     * 
     */
    @InputImport(name="readerEndpointAddress")
      private final @Nullable Input<String> readerEndpointAddress;

    public Input<String> getReaderEndpointAddress() {
        return this.readerEndpointAddress == null ? Input.empty() : this.readerEndpointAddress;
    }

    /**
     * User-created description for the replication group.
     * 
     */
    @InputImport(name="replicationGroupDescription")
      private final @Nullable Input<String> replicationGroupDescription;

    public Input<String> getReplicationGroupDescription() {
        return this.replicationGroupDescription == null ? Input.empty() : this.replicationGroupDescription;
    }

    /**
     * Replication group identifier. This parameter is stored as a lowercase string.
     * 
     */
    @InputImport(name="replicationGroupId")
      private final @Nullable Input<String> replicationGroupId;

    public Input<String> getReplicationGroupId() {
        return this.replicationGroupId == null ? Input.empty() : this.replicationGroupId;
    }

    /**
     * One or more Amazon VPC security groups associated with this replication group. Use this parameter only when you are creating a replication group in an Amazon Virtual Private Cloud
     * 
     */
    @InputImport(name="securityGroupIds")
      private final @Nullable Input<List<String>> securityGroupIds;

    public Input<List<String>> getSecurityGroupIds() {
        return this.securityGroupIds == null ? Input.empty() : this.securityGroupIds;
    }

    /**
     * List of cache security group names to associate with this replication group.
     * 
     */
    @InputImport(name="securityGroupNames")
      private final @Nullable Input<List<String>> securityGroupNames;

    public Input<List<String>> getSecurityGroupNames() {
        return this.securityGroupNames == null ? Input.empty() : this.securityGroupNames;
    }

    /**
     * List of ARNs that identify Redis RDB snapshot files stored in Amazon S3. The names object names cannot contain any commas.
     * 
     */
    @InputImport(name="snapshotArns")
      private final @Nullable Input<List<String>> snapshotArns;

    public Input<List<String>> getSnapshotArns() {
        return this.snapshotArns == null ? Input.empty() : this.snapshotArns;
    }

    /**
     * Name of a snapshot from which to restore data into the new node group. Changing the `snapshot_name` forces a new resource.
     * 
     */
    @InputImport(name="snapshotName")
      private final @Nullable Input<String> snapshotName;

    public Input<String> getSnapshotName() {
        return this.snapshotName == null ? Input.empty() : this.snapshotName;
    }

    /**
     * Number of days for which ElastiCache will retain automatic cache cluster snapshots before deleting them. For example, if you set SnapshotRetentionLimit to 5, then a snapshot that was taken today will be retained for 5 days before being deleted. If the value of `snapshot_retention_limit` is set to zero (0), backups are turned off. Please note that setting a `snapshot_retention_limit` is not supported on cache.t1.micro cache nodes
     * 
     */
    @InputImport(name="snapshotRetentionLimit")
      private final @Nullable Input<Integer> snapshotRetentionLimit;

    public Input<Integer> getSnapshotRetentionLimit() {
        return this.snapshotRetentionLimit == null ? Input.empty() : this.snapshotRetentionLimit;
    }

    /**
     * Daily time range (in UTC) during which ElastiCache will begin taking a daily snapshot of your cache cluster. The minimum snapshot window is a 60 minute period. Example: `05:00-09:00`
     * 
     */
    @InputImport(name="snapshotWindow")
      private final @Nullable Input<String> snapshotWindow;

    public Input<String> getSnapshotWindow() {
        return this.snapshotWindow == null ? Input.empty() : this.snapshotWindow;
    }

    /**
     * Name of the cache subnet group to be used for the replication group.
     * 
     */
    @InputImport(name="subnetGroupName")
      private final @Nullable Input<String> subnetGroupName;

    public Input<String> getSubnetGroupName() {
        return this.subnetGroupName == null ? Input.empty() : this.subnetGroupName;
    }

    @InputImport(name="tags")
      private final @Nullable Input<Map<String,String>> tags;

    public Input<Map<String,String>> getTags() {
        return this.tags == null ? Input.empty() : this.tags;
    }

    @InputImport(name="tagsAll")
      private final @Nullable Input<Map<String,String>> tagsAll;

    public Input<Map<String,String>> getTagsAll() {
        return this.tagsAll == null ? Input.empty() : this.tagsAll;
    }

    /**
     * Whether to enable encryption in transit.
     * 
     */
    @InputImport(name="transitEncryptionEnabled")
      private final @Nullable Input<Boolean> transitEncryptionEnabled;

    public Input<Boolean> getTransitEncryptionEnabled() {
        return this.transitEncryptionEnabled == null ? Input.empty() : this.transitEncryptionEnabled;
    }

    /**
     * User Group ID to associate with the replication group. Only a maximum of one (1) user group ID is valid. **NOTE:** This argument _is_ a set because the AWS specification allows for multiple IDs. However, in practice, AWS only allows a maximum size of one.
     * 
     */
    @InputImport(name="userGroupIds")
      private final @Nullable Input<List<String>> userGroupIds;

    public Input<List<String>> getUserGroupIds() {
        return this.userGroupIds == null ? Input.empty() : this.userGroupIds;
    }

    public ReplicationGroupState(
        @Nullable Input<Boolean> applyImmediately,
        @Nullable Input<String> arn,
        @Nullable Input<Boolean> atRestEncryptionEnabled,
        @Nullable Input<String> authToken,
        @Nullable Input<Boolean> autoMinorVersionUpgrade,
        @Nullable Input<Boolean> automaticFailoverEnabled,
        @Nullable Input<List<String>> availabilityZones,
        @Nullable Input<Boolean> clusterEnabled,
        @Nullable Input<ReplicationGroupClusterModeGetArgs> clusterMode,
        @Nullable Input<String> configurationEndpointAddress,
        @Nullable Input<Boolean> dataTieringEnabled,
        @Nullable Input<String> engine,
        @Nullable Input<String> engineVersion,
        @Nullable Input<String> engineVersionActual,
        @Nullable Input<String> finalSnapshotIdentifier,
        @Nullable Input<String> globalReplicationGroupId,
        @Nullable Input<String> kmsKeyId,
        @Nullable Input<String> maintenanceWindow,
        @Nullable Input<List<String>> memberClusters,
        @Nullable Input<Boolean> multiAzEnabled,
        @Nullable Input<String> nodeType,
        @Nullable Input<String> notificationTopicArn,
        @Nullable Input<Integer> numberCacheClusters,
        @Nullable Input<String> parameterGroupName,
        @Nullable Input<Integer> port,
        @Nullable Input<String> primaryEndpointAddress,
        @Nullable Input<String> readerEndpointAddress,
        @Nullable Input<String> replicationGroupDescription,
        @Nullable Input<String> replicationGroupId,
        @Nullable Input<List<String>> securityGroupIds,
        @Nullable Input<List<String>> securityGroupNames,
        @Nullable Input<List<String>> snapshotArns,
        @Nullable Input<String> snapshotName,
        @Nullable Input<Integer> snapshotRetentionLimit,
        @Nullable Input<String> snapshotWindow,
        @Nullable Input<String> subnetGroupName,
        @Nullable Input<Map<String,String>> tags,
        @Nullable Input<Map<String,String>> tagsAll,
        @Nullable Input<Boolean> transitEncryptionEnabled,
        @Nullable Input<List<String>> userGroupIds) {
        this.applyImmediately = applyImmediately;
        this.arn = arn;
        this.atRestEncryptionEnabled = atRestEncryptionEnabled;
        this.authToken = authToken;
        this.autoMinorVersionUpgrade = autoMinorVersionUpgrade;
        this.automaticFailoverEnabled = automaticFailoverEnabled;
        this.availabilityZones = availabilityZones;
        this.clusterEnabled = clusterEnabled;
        this.clusterMode = clusterMode;
        this.configurationEndpointAddress = configurationEndpointAddress;
        this.dataTieringEnabled = dataTieringEnabled;
        this.engine = engine;
        this.engineVersion = engineVersion;
        this.engineVersionActual = engineVersionActual;
        this.finalSnapshotIdentifier = finalSnapshotIdentifier;
        this.globalReplicationGroupId = globalReplicationGroupId;
        this.kmsKeyId = kmsKeyId;
        this.maintenanceWindow = maintenanceWindow;
        this.memberClusters = memberClusters;
        this.multiAzEnabled = multiAzEnabled;
        this.nodeType = nodeType;
        this.notificationTopicArn = notificationTopicArn;
        this.numberCacheClusters = numberCacheClusters;
        this.parameterGroupName = parameterGroupName;
        this.port = port;
        this.primaryEndpointAddress = primaryEndpointAddress;
        this.readerEndpointAddress = readerEndpointAddress;
        this.replicationGroupDescription = replicationGroupDescription;
        this.replicationGroupId = replicationGroupId;
        this.securityGroupIds = securityGroupIds;
        this.securityGroupNames = securityGroupNames;
        this.snapshotArns = snapshotArns;
        this.snapshotName = snapshotName;
        this.snapshotRetentionLimit = snapshotRetentionLimit;
        this.snapshotWindow = snapshotWindow;
        this.subnetGroupName = subnetGroupName;
        this.tags = tags;
        this.tagsAll = tagsAll;
        this.transitEncryptionEnabled = transitEncryptionEnabled;
        this.userGroupIds = userGroupIds;
    }

    private ReplicationGroupState() {
        this.applyImmediately = Input.empty();
        this.arn = Input.empty();
        this.atRestEncryptionEnabled = Input.empty();
        this.authToken = Input.empty();
        this.autoMinorVersionUpgrade = Input.empty();
        this.automaticFailoverEnabled = Input.empty();
        this.availabilityZones = Input.empty();
        this.clusterEnabled = Input.empty();
        this.clusterMode = Input.empty();
        this.configurationEndpointAddress = Input.empty();
        this.dataTieringEnabled = Input.empty();
        this.engine = Input.empty();
        this.engineVersion = Input.empty();
        this.engineVersionActual = Input.empty();
        this.finalSnapshotIdentifier = Input.empty();
        this.globalReplicationGroupId = Input.empty();
        this.kmsKeyId = Input.empty();
        this.maintenanceWindow = Input.empty();
        this.memberClusters = Input.empty();
        this.multiAzEnabled = Input.empty();
        this.nodeType = Input.empty();
        this.notificationTopicArn = Input.empty();
        this.numberCacheClusters = Input.empty();
        this.parameterGroupName = Input.empty();
        this.port = Input.empty();
        this.primaryEndpointAddress = Input.empty();
        this.readerEndpointAddress = Input.empty();
        this.replicationGroupDescription = Input.empty();
        this.replicationGroupId = Input.empty();
        this.securityGroupIds = Input.empty();
        this.securityGroupNames = Input.empty();
        this.snapshotArns = Input.empty();
        this.snapshotName = Input.empty();
        this.snapshotRetentionLimit = Input.empty();
        this.snapshotWindow = Input.empty();
        this.subnetGroupName = Input.empty();
        this.tags = Input.empty();
        this.tagsAll = Input.empty();
        this.transitEncryptionEnabled = Input.empty();
        this.userGroupIds = Input.empty();
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(ReplicationGroupState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private @Nullable Input<Boolean> applyImmediately;
        private @Nullable Input<String> arn;
        private @Nullable Input<Boolean> atRestEncryptionEnabled;
        private @Nullable Input<String> authToken;
        private @Nullable Input<Boolean> autoMinorVersionUpgrade;
        private @Nullable Input<Boolean> automaticFailoverEnabled;
        private @Nullable Input<List<String>> availabilityZones;
        private @Nullable Input<Boolean> clusterEnabled;
        private @Nullable Input<ReplicationGroupClusterModeGetArgs> clusterMode;
        private @Nullable Input<String> configurationEndpointAddress;
        private @Nullable Input<Boolean> dataTieringEnabled;
        private @Nullable Input<String> engine;
        private @Nullable Input<String> engineVersion;
        private @Nullable Input<String> engineVersionActual;
        private @Nullable Input<String> finalSnapshotIdentifier;
        private @Nullable Input<String> globalReplicationGroupId;
        private @Nullable Input<String> kmsKeyId;
        private @Nullable Input<String> maintenanceWindow;
        private @Nullable Input<List<String>> memberClusters;
        private @Nullable Input<Boolean> multiAzEnabled;
        private @Nullable Input<String> nodeType;
        private @Nullable Input<String> notificationTopicArn;
        private @Nullable Input<Integer> numberCacheClusters;
        private @Nullable Input<String> parameterGroupName;
        private @Nullable Input<Integer> port;
        private @Nullable Input<String> primaryEndpointAddress;
        private @Nullable Input<String> readerEndpointAddress;
        private @Nullable Input<String> replicationGroupDescription;
        private @Nullable Input<String> replicationGroupId;
        private @Nullable Input<List<String>> securityGroupIds;
        private @Nullable Input<List<String>> securityGroupNames;
        private @Nullable Input<List<String>> snapshotArns;
        private @Nullable Input<String> snapshotName;
        private @Nullable Input<Integer> snapshotRetentionLimit;
        private @Nullable Input<String> snapshotWindow;
        private @Nullable Input<String> subnetGroupName;
        private @Nullable Input<Map<String,String>> tags;
        private @Nullable Input<Map<String,String>> tagsAll;
        private @Nullable Input<Boolean> transitEncryptionEnabled;
        private @Nullable Input<List<String>> userGroupIds;

        public Builder() {
    	      // Empty
        }

        public Builder(ReplicationGroupState defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.applyImmediately = defaults.applyImmediately;
    	      this.arn = defaults.arn;
    	      this.atRestEncryptionEnabled = defaults.atRestEncryptionEnabled;
    	      this.authToken = defaults.authToken;
    	      this.autoMinorVersionUpgrade = defaults.autoMinorVersionUpgrade;
    	      this.automaticFailoverEnabled = defaults.automaticFailoverEnabled;
    	      this.availabilityZones = defaults.availabilityZones;
    	      this.clusterEnabled = defaults.clusterEnabled;
    	      this.clusterMode = defaults.clusterMode;
    	      this.configurationEndpointAddress = defaults.configurationEndpointAddress;
    	      this.dataTieringEnabled = defaults.dataTieringEnabled;
    	      this.engine = defaults.engine;
    	      this.engineVersion = defaults.engineVersion;
    	      this.engineVersionActual = defaults.engineVersionActual;
    	      this.finalSnapshotIdentifier = defaults.finalSnapshotIdentifier;
    	      this.globalReplicationGroupId = defaults.globalReplicationGroupId;
    	      this.kmsKeyId = defaults.kmsKeyId;
    	      this.maintenanceWindow = defaults.maintenanceWindow;
    	      this.memberClusters = defaults.memberClusters;
    	      this.multiAzEnabled = defaults.multiAzEnabled;
    	      this.nodeType = defaults.nodeType;
    	      this.notificationTopicArn = defaults.notificationTopicArn;
    	      this.numberCacheClusters = defaults.numberCacheClusters;
    	      this.parameterGroupName = defaults.parameterGroupName;
    	      this.port = defaults.port;
    	      this.primaryEndpointAddress = defaults.primaryEndpointAddress;
    	      this.readerEndpointAddress = defaults.readerEndpointAddress;
    	      this.replicationGroupDescription = defaults.replicationGroupDescription;
    	      this.replicationGroupId = defaults.replicationGroupId;
    	      this.securityGroupIds = defaults.securityGroupIds;
    	      this.securityGroupNames = defaults.securityGroupNames;
    	      this.snapshotArns = defaults.snapshotArns;
    	      this.snapshotName = defaults.snapshotName;
    	      this.snapshotRetentionLimit = defaults.snapshotRetentionLimit;
    	      this.snapshotWindow = defaults.snapshotWindow;
    	      this.subnetGroupName = defaults.subnetGroupName;
    	      this.tags = defaults.tags;
    	      this.tagsAll = defaults.tagsAll;
    	      this.transitEncryptionEnabled = defaults.transitEncryptionEnabled;
    	      this.userGroupIds = defaults.userGroupIds;
        }

        public Builder setApplyImmediately(@Nullable Input<Boolean> applyImmediately) {
            this.applyImmediately = applyImmediately;
            return this;
        }

        public Builder setApplyImmediately(@Nullable Boolean applyImmediately) {
            this.applyImmediately = Input.ofNullable(applyImmediately);
            return this;
        }

        public Builder setArn(@Nullable Input<String> arn) {
            this.arn = arn;
            return this;
        }

        public Builder setArn(@Nullable String arn) {
            this.arn = Input.ofNullable(arn);
            return this;
        }

        public Builder setAtRestEncryptionEnabled(@Nullable Input<Boolean> atRestEncryptionEnabled) {
            this.atRestEncryptionEnabled = atRestEncryptionEnabled;
            return this;
        }

        public Builder setAtRestEncryptionEnabled(@Nullable Boolean atRestEncryptionEnabled) {
            this.atRestEncryptionEnabled = Input.ofNullable(atRestEncryptionEnabled);
            return this;
        }

        public Builder setAuthToken(@Nullable Input<String> authToken) {
            this.authToken = authToken;
            return this;
        }

        public Builder setAuthToken(@Nullable String authToken) {
            this.authToken = Input.ofNullable(authToken);
            return this;
        }

        public Builder setAutoMinorVersionUpgrade(@Nullable Input<Boolean> autoMinorVersionUpgrade) {
            this.autoMinorVersionUpgrade = autoMinorVersionUpgrade;
            return this;
        }

        public Builder setAutoMinorVersionUpgrade(@Nullable Boolean autoMinorVersionUpgrade) {
            this.autoMinorVersionUpgrade = Input.ofNullable(autoMinorVersionUpgrade);
            return this;
        }

        public Builder setAutomaticFailoverEnabled(@Nullable Input<Boolean> automaticFailoverEnabled) {
            this.automaticFailoverEnabled = automaticFailoverEnabled;
            return this;
        }

        public Builder setAutomaticFailoverEnabled(@Nullable Boolean automaticFailoverEnabled) {
            this.automaticFailoverEnabled = Input.ofNullable(automaticFailoverEnabled);
            return this;
        }

        public Builder setAvailabilityZones(@Nullable Input<List<String>> availabilityZones) {
            this.availabilityZones = availabilityZones;
            return this;
        }

        public Builder setAvailabilityZones(@Nullable List<String> availabilityZones) {
            this.availabilityZones = Input.ofNullable(availabilityZones);
            return this;
        }

        public Builder setClusterEnabled(@Nullable Input<Boolean> clusterEnabled) {
            this.clusterEnabled = clusterEnabled;
            return this;
        }

        public Builder setClusterEnabled(@Nullable Boolean clusterEnabled) {
            this.clusterEnabled = Input.ofNullable(clusterEnabled);
            return this;
        }

        public Builder setClusterMode(@Nullable Input<ReplicationGroupClusterModeGetArgs> clusterMode) {
            this.clusterMode = clusterMode;
            return this;
        }

        public Builder setClusterMode(@Nullable ReplicationGroupClusterModeGetArgs clusterMode) {
            this.clusterMode = Input.ofNullable(clusterMode);
            return this;
        }

        public Builder setConfigurationEndpointAddress(@Nullable Input<String> configurationEndpointAddress) {
            this.configurationEndpointAddress = configurationEndpointAddress;
            return this;
        }

        public Builder setConfigurationEndpointAddress(@Nullable String configurationEndpointAddress) {
            this.configurationEndpointAddress = Input.ofNullable(configurationEndpointAddress);
            return this;
        }

        public Builder setDataTieringEnabled(@Nullable Input<Boolean> dataTieringEnabled) {
            this.dataTieringEnabled = dataTieringEnabled;
            return this;
        }

        public Builder setDataTieringEnabled(@Nullable Boolean dataTieringEnabled) {
            this.dataTieringEnabled = Input.ofNullable(dataTieringEnabled);
            return this;
        }

        public Builder setEngine(@Nullable Input<String> engine) {
            this.engine = engine;
            return this;
        }

        public Builder setEngine(@Nullable String engine) {
            this.engine = Input.ofNullable(engine);
            return this;
        }

        public Builder setEngineVersion(@Nullable Input<String> engineVersion) {
            this.engineVersion = engineVersion;
            return this;
        }

        public Builder setEngineVersion(@Nullable String engineVersion) {
            this.engineVersion = Input.ofNullable(engineVersion);
            return this;
        }

        public Builder setEngineVersionActual(@Nullable Input<String> engineVersionActual) {
            this.engineVersionActual = engineVersionActual;
            return this;
        }

        public Builder setEngineVersionActual(@Nullable String engineVersionActual) {
            this.engineVersionActual = Input.ofNullable(engineVersionActual);
            return this;
        }

        public Builder setFinalSnapshotIdentifier(@Nullable Input<String> finalSnapshotIdentifier) {
            this.finalSnapshotIdentifier = finalSnapshotIdentifier;
            return this;
        }

        public Builder setFinalSnapshotIdentifier(@Nullable String finalSnapshotIdentifier) {
            this.finalSnapshotIdentifier = Input.ofNullable(finalSnapshotIdentifier);
            return this;
        }

        public Builder setGlobalReplicationGroupId(@Nullable Input<String> globalReplicationGroupId) {
            this.globalReplicationGroupId = globalReplicationGroupId;
            return this;
        }

        public Builder setGlobalReplicationGroupId(@Nullable String globalReplicationGroupId) {
            this.globalReplicationGroupId = Input.ofNullable(globalReplicationGroupId);
            return this;
        }

        public Builder setKmsKeyId(@Nullable Input<String> kmsKeyId) {
            this.kmsKeyId = kmsKeyId;
            return this;
        }

        public Builder setKmsKeyId(@Nullable String kmsKeyId) {
            this.kmsKeyId = Input.ofNullable(kmsKeyId);
            return this;
        }

        public Builder setMaintenanceWindow(@Nullable Input<String> maintenanceWindow) {
            this.maintenanceWindow = maintenanceWindow;
            return this;
        }

        public Builder setMaintenanceWindow(@Nullable String maintenanceWindow) {
            this.maintenanceWindow = Input.ofNullable(maintenanceWindow);
            return this;
        }

        public Builder setMemberClusters(@Nullable Input<List<String>> memberClusters) {
            this.memberClusters = memberClusters;
            return this;
        }

        public Builder setMemberClusters(@Nullable List<String> memberClusters) {
            this.memberClusters = Input.ofNullable(memberClusters);
            return this;
        }

        public Builder setMultiAzEnabled(@Nullable Input<Boolean> multiAzEnabled) {
            this.multiAzEnabled = multiAzEnabled;
            return this;
        }

        public Builder setMultiAzEnabled(@Nullable Boolean multiAzEnabled) {
            this.multiAzEnabled = Input.ofNullable(multiAzEnabled);
            return this;
        }

        public Builder setNodeType(@Nullable Input<String> nodeType) {
            this.nodeType = nodeType;
            return this;
        }

        public Builder setNodeType(@Nullable String nodeType) {
            this.nodeType = Input.ofNullable(nodeType);
            return this;
        }

        public Builder setNotificationTopicArn(@Nullable Input<String> notificationTopicArn) {
            this.notificationTopicArn = notificationTopicArn;
            return this;
        }

        public Builder setNotificationTopicArn(@Nullable String notificationTopicArn) {
            this.notificationTopicArn = Input.ofNullable(notificationTopicArn);
            return this;
        }

        public Builder setNumberCacheClusters(@Nullable Input<Integer> numberCacheClusters) {
            this.numberCacheClusters = numberCacheClusters;
            return this;
        }

        public Builder setNumberCacheClusters(@Nullable Integer numberCacheClusters) {
            this.numberCacheClusters = Input.ofNullable(numberCacheClusters);
            return this;
        }

        public Builder setParameterGroupName(@Nullable Input<String> parameterGroupName) {
            this.parameterGroupName = parameterGroupName;
            return this;
        }

        public Builder setParameterGroupName(@Nullable String parameterGroupName) {
            this.parameterGroupName = Input.ofNullable(parameterGroupName);
            return this;
        }

        public Builder setPort(@Nullable Input<Integer> port) {
            this.port = port;
            return this;
        }

        public Builder setPort(@Nullable Integer port) {
            this.port = Input.ofNullable(port);
            return this;
        }

        public Builder setPrimaryEndpointAddress(@Nullable Input<String> primaryEndpointAddress) {
            this.primaryEndpointAddress = primaryEndpointAddress;
            return this;
        }

        public Builder setPrimaryEndpointAddress(@Nullable String primaryEndpointAddress) {
            this.primaryEndpointAddress = Input.ofNullable(primaryEndpointAddress);
            return this;
        }

        public Builder setReaderEndpointAddress(@Nullable Input<String> readerEndpointAddress) {
            this.readerEndpointAddress = readerEndpointAddress;
            return this;
        }

        public Builder setReaderEndpointAddress(@Nullable String readerEndpointAddress) {
            this.readerEndpointAddress = Input.ofNullable(readerEndpointAddress);
            return this;
        }

        public Builder setReplicationGroupDescription(@Nullable Input<String> replicationGroupDescription) {
            this.replicationGroupDescription = replicationGroupDescription;
            return this;
        }

        public Builder setReplicationGroupDescription(@Nullable String replicationGroupDescription) {
            this.replicationGroupDescription = Input.ofNullable(replicationGroupDescription);
            return this;
        }

        public Builder setReplicationGroupId(@Nullable Input<String> replicationGroupId) {
            this.replicationGroupId = replicationGroupId;
            return this;
        }

        public Builder setReplicationGroupId(@Nullable String replicationGroupId) {
            this.replicationGroupId = Input.ofNullable(replicationGroupId);
            return this;
        }

        public Builder setSecurityGroupIds(@Nullable Input<List<String>> securityGroupIds) {
            this.securityGroupIds = securityGroupIds;
            return this;
        }

        public Builder setSecurityGroupIds(@Nullable List<String> securityGroupIds) {
            this.securityGroupIds = Input.ofNullable(securityGroupIds);
            return this;
        }

        public Builder setSecurityGroupNames(@Nullable Input<List<String>> securityGroupNames) {
            this.securityGroupNames = securityGroupNames;
            return this;
        }

        public Builder setSecurityGroupNames(@Nullable List<String> securityGroupNames) {
            this.securityGroupNames = Input.ofNullable(securityGroupNames);
            return this;
        }

        public Builder setSnapshotArns(@Nullable Input<List<String>> snapshotArns) {
            this.snapshotArns = snapshotArns;
            return this;
        }

        public Builder setSnapshotArns(@Nullable List<String> snapshotArns) {
            this.snapshotArns = Input.ofNullable(snapshotArns);
            return this;
        }

        public Builder setSnapshotName(@Nullable Input<String> snapshotName) {
            this.snapshotName = snapshotName;
            return this;
        }

        public Builder setSnapshotName(@Nullable String snapshotName) {
            this.snapshotName = Input.ofNullable(snapshotName);
            return this;
        }

        public Builder setSnapshotRetentionLimit(@Nullable Input<Integer> snapshotRetentionLimit) {
            this.snapshotRetentionLimit = snapshotRetentionLimit;
            return this;
        }

        public Builder setSnapshotRetentionLimit(@Nullable Integer snapshotRetentionLimit) {
            this.snapshotRetentionLimit = Input.ofNullable(snapshotRetentionLimit);
            return this;
        }

        public Builder setSnapshotWindow(@Nullable Input<String> snapshotWindow) {
            this.snapshotWindow = snapshotWindow;
            return this;
        }

        public Builder setSnapshotWindow(@Nullable String snapshotWindow) {
            this.snapshotWindow = Input.ofNullable(snapshotWindow);
            return this;
        }

        public Builder setSubnetGroupName(@Nullable Input<String> subnetGroupName) {
            this.subnetGroupName = subnetGroupName;
            return this;
        }

        public Builder setSubnetGroupName(@Nullable String subnetGroupName) {
            this.subnetGroupName = Input.ofNullable(subnetGroupName);
            return this;
        }

        public Builder setTags(@Nullable Input<Map<String,String>> tags) {
            this.tags = tags;
            return this;
        }

        public Builder setTags(@Nullable Map<String,String> tags) {
            this.tags = Input.ofNullable(tags);
            return this;
        }

        public Builder setTagsAll(@Nullable Input<Map<String,String>> tagsAll) {
            this.tagsAll = tagsAll;
            return this;
        }

        public Builder setTagsAll(@Nullable Map<String,String> tagsAll) {
            this.tagsAll = Input.ofNullable(tagsAll);
            return this;
        }

        public Builder setTransitEncryptionEnabled(@Nullable Input<Boolean> transitEncryptionEnabled) {
            this.transitEncryptionEnabled = transitEncryptionEnabled;
            return this;
        }

        public Builder setTransitEncryptionEnabled(@Nullable Boolean transitEncryptionEnabled) {
            this.transitEncryptionEnabled = Input.ofNullable(transitEncryptionEnabled);
            return this;
        }

        public Builder setUserGroupIds(@Nullable Input<List<String>> userGroupIds) {
            this.userGroupIds = userGroupIds;
            return this;
        }

        public Builder setUserGroupIds(@Nullable List<String> userGroupIds) {
            this.userGroupIds = Input.ofNullable(userGroupIds);
            return this;
        }
        public ReplicationGroupState build() {
            return new ReplicationGroupState(applyImmediately, arn, atRestEncryptionEnabled, authToken, autoMinorVersionUpgrade, automaticFailoverEnabled, availabilityZones, clusterEnabled, clusterMode, configurationEndpointAddress, dataTieringEnabled, engine, engineVersion, engineVersionActual, finalSnapshotIdentifier, globalReplicationGroupId, kmsKeyId, maintenanceWindow, memberClusters, multiAzEnabled, nodeType, notificationTopicArn, numberCacheClusters, parameterGroupName, port, primaryEndpointAddress, readerEndpointAddress, replicationGroupDescription, replicationGroupId, securityGroupIds, securityGroupNames, snapshotArns, snapshotName, snapshotRetentionLimit, snapshotWindow, subnetGroupName, tags, tagsAll, transitEncryptionEnabled, userGroupIds);
        }
    }
}
