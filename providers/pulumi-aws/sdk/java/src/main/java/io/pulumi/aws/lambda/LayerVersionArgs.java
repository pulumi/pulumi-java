// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package io.pulumi.aws.lambda;

import io.pulumi.asset.Archive;
import io.pulumi.core.Output;
import io.pulumi.core.annotations.Import;
import io.pulumi.core.internal.Codegen;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import javax.annotation.Nullable;


public final class LayerVersionArgs extends io.pulumi.resources.ResourceArgs {

    public static final LayerVersionArgs Empty = new LayerVersionArgs();

    /**
     * Path to the function's deployment package within the local filesystem. If defined, The `s3_`-prefixed options cannot be used.
     * 
     */
    @Import(name="code")
      private final @Nullable Output<Archive> code;

    public Output<Archive> getCode() {
        return this.code == null ? Codegen.empty() : this.code;
    }

    /**
     * List of [Architectures](https://docs.aws.amazon.com/lambda/latest/dg/API_PublishLayerVersion.html#SSS-PublishLayerVersion-request-CompatibleArchitectures) this layer is compatible with. Currently `x86_64` and `arm64` can be specified.
     * 
     */
    @Import(name="compatibleArchitectures")
      private final @Nullable Output<List<String>> compatibleArchitectures;

    public Output<List<String>> getCompatibleArchitectures() {
        return this.compatibleArchitectures == null ? Codegen.empty() : this.compatibleArchitectures;
    }

    /**
     * List of [Runtimes](https://docs.aws.amazon.com/lambda/latest/dg/API_PublishLayerVersion.html#SSS-PublishLayerVersion-request-CompatibleRuntimes) this layer is compatible with. Up to 5 runtimes can be specified.
     * 
     */
    @Import(name="compatibleRuntimes")
      private final @Nullable Output<List<String>> compatibleRuntimes;

    public Output<List<String>> getCompatibleRuntimes() {
        return this.compatibleRuntimes == null ? Codegen.empty() : this.compatibleRuntimes;
    }

    /**
     * Description of what your Lambda Layer does.
     * 
     */
    @Import(name="description")
      private final @Nullable Output<String> description;

    public Output<String> getDescription() {
        return this.description == null ? Codegen.empty() : this.description;
    }

    /**
     * Unique name for your Lambda Layer
     * 
     */
    @Import(name="layerName", required=true)
      private final Output<String> layerName;

    public Output<String> getLayerName() {
        return this.layerName;
    }

    /**
     * License info for your Lambda Layer. See [License Info](https://docs.aws.amazon.com/lambda/latest/dg/API_PublishLayerVersion.html#SSS-PublishLayerVersion-request-LicenseInfo).
     * 
     */
    @Import(name="licenseInfo")
      private final @Nullable Output<String> licenseInfo;

    public Output<String> getLicenseInfo() {
        return this.licenseInfo == null ? Codegen.empty() : this.licenseInfo;
    }

    /**
     * S3 bucket location containing the function's deployment package. Conflicts with `filename`. This bucket must reside in the same AWS region where you are creating the Lambda function.
     * 
     */
    @Import(name="s3Bucket")
      private final @Nullable Output<String> s3Bucket;

    public Output<String> getS3Bucket() {
        return this.s3Bucket == null ? Codegen.empty() : this.s3Bucket;
    }

    /**
     * S3 key of an object containing the function's deployment package. Conflicts with `filename`.
     * 
     */
    @Import(name="s3Key")
      private final @Nullable Output<String> s3Key;

    public Output<String> getS3Key() {
        return this.s3Key == null ? Codegen.empty() : this.s3Key;
    }

    /**
     * Object version containing the function's deployment package. Conflicts with `filename`.
     * 
     */
    @Import(name="s3ObjectVersion")
      private final @Nullable Output<String> s3ObjectVersion;

    public Output<String> getS3ObjectVersion() {
        return this.s3ObjectVersion == null ? Codegen.empty() : this.s3ObjectVersion;
    }

    /**
     * Whether to retain the old version of a previously deployed Lambda Layer. Default is `false`. When this is not set to `true`, changing any of `compatible_architectures`, `compatible_runtimes`, `description`, `filename`, `layer_name`, `license_info`, `s3_bucket`, `s3_key`, `s3_object_version`, or `source_code_hash` forces deletion of the existing layer version and creation of a new layer version.
     * 
     */
    @Import(name="skipDestroy")
      private final @Nullable Output<Boolean> skipDestroy;

    public Output<Boolean> getSkipDestroy() {
        return this.skipDestroy == null ? Codegen.empty() : this.skipDestroy;
    }

    @Import(name="sourceCodeHash")
      private final @Nullable Output<String> sourceCodeHash;

    public Output<String> getSourceCodeHash() {
        return this.sourceCodeHash == null ? Codegen.empty() : this.sourceCodeHash;
    }

    public LayerVersionArgs(
        @Nullable Output<Archive> code,
        @Nullable Output<List<String>> compatibleArchitectures,
        @Nullable Output<List<String>> compatibleRuntimes,
        @Nullable Output<String> description,
        Output<String> layerName,
        @Nullable Output<String> licenseInfo,
        @Nullable Output<String> s3Bucket,
        @Nullable Output<String> s3Key,
        @Nullable Output<String> s3ObjectVersion,
        @Nullable Output<Boolean> skipDestroy,
        @Nullable Output<String> sourceCodeHash) {
        this.code = code;
        this.compatibleArchitectures = compatibleArchitectures;
        this.compatibleRuntimes = compatibleRuntimes;
        this.description = description;
        this.layerName = Objects.requireNonNull(layerName, "expected parameter 'layerName' to be non-null");
        this.licenseInfo = licenseInfo;
        this.s3Bucket = s3Bucket;
        this.s3Key = s3Key;
        this.s3ObjectVersion = s3ObjectVersion;
        this.skipDestroy = skipDestroy;
        this.sourceCodeHash = sourceCodeHash;
    }

    private LayerVersionArgs() {
        this.code = Codegen.empty();
        this.compatibleArchitectures = Codegen.empty();
        this.compatibleRuntimes = Codegen.empty();
        this.description = Codegen.empty();
        this.layerName = Codegen.empty();
        this.licenseInfo = Codegen.empty();
        this.s3Bucket = Codegen.empty();
        this.s3Key = Codegen.empty();
        this.s3ObjectVersion = Codegen.empty();
        this.skipDestroy = Codegen.empty();
        this.sourceCodeHash = Codegen.empty();
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(LayerVersionArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private @Nullable Output<Archive> code;
        private @Nullable Output<List<String>> compatibleArchitectures;
        private @Nullable Output<List<String>> compatibleRuntimes;
        private @Nullable Output<String> description;
        private Output<String> layerName;
        private @Nullable Output<String> licenseInfo;
        private @Nullable Output<String> s3Bucket;
        private @Nullable Output<String> s3Key;
        private @Nullable Output<String> s3ObjectVersion;
        private @Nullable Output<Boolean> skipDestroy;
        private @Nullable Output<String> sourceCodeHash;

        public Builder() {
    	      // Empty
        }

        public Builder(LayerVersionArgs defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.code = defaults.code;
    	      this.compatibleArchitectures = defaults.compatibleArchitectures;
    	      this.compatibleRuntimes = defaults.compatibleRuntimes;
    	      this.description = defaults.description;
    	      this.layerName = defaults.layerName;
    	      this.licenseInfo = defaults.licenseInfo;
    	      this.s3Bucket = defaults.s3Bucket;
    	      this.s3Key = defaults.s3Key;
    	      this.s3ObjectVersion = defaults.s3ObjectVersion;
    	      this.skipDestroy = defaults.skipDestroy;
    	      this.sourceCodeHash = defaults.sourceCodeHash;
        }

        public Builder code(@Nullable Output<Archive> code) {
            this.code = code;
            return this;
        }
        public Builder code(@Nullable Archive code) {
            this.code = Codegen.ofNullable(code);
            return this;
        }
        public Builder compatibleArchitectures(@Nullable Output<List<String>> compatibleArchitectures) {
            this.compatibleArchitectures = compatibleArchitectures;
            return this;
        }
        public Builder compatibleArchitectures(@Nullable List<String> compatibleArchitectures) {
            this.compatibleArchitectures = Codegen.ofNullable(compatibleArchitectures);
            return this;
        }
        public Builder compatibleArchitectures(String... compatibleArchitectures) {
            return compatibleArchitectures(List.of(compatibleArchitectures));
        }
        public Builder compatibleRuntimes(@Nullable Output<List<String>> compatibleRuntimes) {
            this.compatibleRuntimes = compatibleRuntimes;
            return this;
        }
        public Builder compatibleRuntimes(@Nullable List<String> compatibleRuntimes) {
            this.compatibleRuntimes = Codegen.ofNullable(compatibleRuntimes);
            return this;
        }
        public Builder compatibleRuntimes(String... compatibleRuntimes) {
            return compatibleRuntimes(List.of(compatibleRuntimes));
        }
        public Builder description(@Nullable Output<String> description) {
            this.description = description;
            return this;
        }
        public Builder description(@Nullable String description) {
            this.description = Codegen.ofNullable(description);
            return this;
        }
        public Builder layerName(Output<String> layerName) {
            this.layerName = Objects.requireNonNull(layerName);
            return this;
        }
        public Builder layerName(String layerName) {
            this.layerName = Output.of(Objects.requireNonNull(layerName));
            return this;
        }
        public Builder licenseInfo(@Nullable Output<String> licenseInfo) {
            this.licenseInfo = licenseInfo;
            return this;
        }
        public Builder licenseInfo(@Nullable String licenseInfo) {
            this.licenseInfo = Codegen.ofNullable(licenseInfo);
            return this;
        }
        public Builder s3Bucket(@Nullable Output<String> s3Bucket) {
            this.s3Bucket = s3Bucket;
            return this;
        }
        public Builder s3Bucket(@Nullable String s3Bucket) {
            this.s3Bucket = Codegen.ofNullable(s3Bucket);
            return this;
        }
        public Builder s3Key(@Nullable Output<String> s3Key) {
            this.s3Key = s3Key;
            return this;
        }
        public Builder s3Key(@Nullable String s3Key) {
            this.s3Key = Codegen.ofNullable(s3Key);
            return this;
        }
        public Builder s3ObjectVersion(@Nullable Output<String> s3ObjectVersion) {
            this.s3ObjectVersion = s3ObjectVersion;
            return this;
        }
        public Builder s3ObjectVersion(@Nullable String s3ObjectVersion) {
            this.s3ObjectVersion = Codegen.ofNullable(s3ObjectVersion);
            return this;
        }
        public Builder skipDestroy(@Nullable Output<Boolean> skipDestroy) {
            this.skipDestroy = skipDestroy;
            return this;
        }
        public Builder skipDestroy(@Nullable Boolean skipDestroy) {
            this.skipDestroy = Codegen.ofNullable(skipDestroy);
            return this;
        }
        public Builder sourceCodeHash(@Nullable Output<String> sourceCodeHash) {
            this.sourceCodeHash = sourceCodeHash;
            return this;
        }
        public Builder sourceCodeHash(@Nullable String sourceCodeHash) {
            this.sourceCodeHash = Codegen.ofNullable(sourceCodeHash);
            return this;
        }        public LayerVersionArgs build() {
            return new LayerVersionArgs(code, compatibleArchitectures, compatibleRuntimes, description, layerName, licenseInfo, s3Bucket, s3Key, s3ObjectVersion, skipDestroy, sourceCodeHash);
        }
    }
}
