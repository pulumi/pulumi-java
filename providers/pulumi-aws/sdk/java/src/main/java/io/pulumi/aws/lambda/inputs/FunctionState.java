// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package io.pulumi.aws.lambda.inputs;

import io.pulumi.aws.lambda.enums.Runtime;
import io.pulumi.aws.lambda.inputs.FunctionDeadLetterConfigGetArgs;
import io.pulumi.aws.lambda.inputs.FunctionEnvironmentGetArgs;
import io.pulumi.aws.lambda.inputs.FunctionFileSystemConfigGetArgs;
import io.pulumi.aws.lambda.inputs.FunctionImageConfigGetArgs;
import io.pulumi.aws.lambda.inputs.FunctionTracingConfigGetArgs;
import io.pulumi.aws.lambda.inputs.FunctionVpcConfigGetArgs;
import io.pulumi.core.Archive;
import io.pulumi.core.Either;
import io.pulumi.core.Output;
import io.pulumi.core.annotations.Import;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import javax.annotation.Nullable;


public final class FunctionState extends io.pulumi.resources.ResourceArgs {

    public static final FunctionState Empty = new FunctionState();

    /**
     * Instruction set architecture for your Lambda function. Valid values are `["x86_64"]` and `["arm64"]`. Default is `["x86_64"]`. Removing this attribute, function's architecture stay the same.
     * 
     */
    @Import(name="architectures")
      private final @Nullable Output<List<String>> architectures;

    public Output<List<String>> getArchitectures() {
        return this.architectures == null ? Output.empty() : this.architectures;
    }

    /**
     * Amazon Resource Name (ARN) of the Amazon EFS Access Point that provides access to the file system.
     * 
     */
    @Import(name="arn")
      private final @Nullable Output<String> arn;

    public Output<String> getArn() {
        return this.arn == null ? Output.empty() : this.arn;
    }

    /**
     * Path to the function's deployment package within the local filesystem. Conflicts with `image_uri`, `s3_bucket`, `s3_key`, and `s3_object_version`.
     * 
     */
    @Import(name="code")
      private final @Nullable Output<Archive> code;

    public Output<Archive> getCode() {
        return this.code == null ? Output.empty() : this.code;
    }

    /**
     * To enable code signing for this function, specify the ARN of a code-signing configuration. A code-signing configuration includes a set of signing profiles, which define the trusted publishers for this function.
     * 
     */
    @Import(name="codeSigningConfigArn")
      private final @Nullable Output<String> codeSigningConfigArn;

    public Output<String> getCodeSigningConfigArn() {
        return this.codeSigningConfigArn == null ? Output.empty() : this.codeSigningConfigArn;
    }

    /**
     * Configuration block. Detailed below.
     * 
     */
    @Import(name="deadLetterConfig")
      private final @Nullable Output<FunctionDeadLetterConfigGetArgs> deadLetterConfig;

    public Output<FunctionDeadLetterConfigGetArgs> getDeadLetterConfig() {
        return this.deadLetterConfig == null ? Output.empty() : this.deadLetterConfig;
    }

    /**
     * Description of what your Lambda Function does.
     * 
     */
    @Import(name="description")
      private final @Nullable Output<String> description;

    public Output<String> getDescription() {
        return this.description == null ? Output.empty() : this.description;
    }

    /**
     * Configuration block. Detailed below.
     * 
     */
    @Import(name="environment")
      private final @Nullable Output<FunctionEnvironmentGetArgs> environment;

    public Output<FunctionEnvironmentGetArgs> getEnvironment() {
        return this.environment == null ? Output.empty() : this.environment;
    }

    /**
     * Configuration block. Detailed below.
     * 
     */
    @Import(name="fileSystemConfig")
      private final @Nullable Output<FunctionFileSystemConfigGetArgs> fileSystemConfig;

    public Output<FunctionFileSystemConfigGetArgs> getFileSystemConfig() {
        return this.fileSystemConfig == null ? Output.empty() : this.fileSystemConfig;
    }

    /**
     * Function [entrypoint](https://docs.aws.amazon.com/lambda/latest/dg/walkthrough-custom-events-create-test-function.html) in your code.
     * 
     */
    @Import(name="handler")
      private final @Nullable Output<String> handler;

    public Output<String> getHandler() {
        return this.handler == null ? Output.empty() : this.handler;
    }

    /**
     * Configuration block. Detailed below.
     * 
     */
    @Import(name="imageConfig")
      private final @Nullable Output<FunctionImageConfigGetArgs> imageConfig;

    public Output<FunctionImageConfigGetArgs> getImageConfig() {
        return this.imageConfig == null ? Output.empty() : this.imageConfig;
    }

    /**
     * ECR image URI containing the function's deployment package. Conflicts with `filename`, `s3_bucket`, `s3_key`, and `s3_object_version`.
     * 
     */
    @Import(name="imageUri")
      private final @Nullable Output<String> imageUri;

    public Output<String> getImageUri() {
        return this.imageUri == null ? Output.empty() : this.imageUri;
    }

    /**
     * ARN to be used for invoking Lambda Function from API Gateway - to be used in `aws.apigateway.Integration`'s `uri`.
     * 
     */
    @Import(name="invokeArn")
      private final @Nullable Output<String> invokeArn;

    public Output<String> getInvokeArn() {
        return this.invokeArn == null ? Output.empty() : this.invokeArn;
    }

    /**
     * Amazon Resource Name (ARN) of the AWS Key Management Service (KMS) key that is used to encrypt environment variables. If this configuration is not provided when environment variables are in use, AWS Lambda uses a default service key. If this configuration is provided when environment variables are not in use, the AWS Lambda API does not save this configuration and the provider will show a perpetual difference of adding the key. To fix the perpetual difference, remove this configuration.
     * 
     */
    @Import(name="kmsKeyArn")
      private final @Nullable Output<String> kmsKeyArn;

    public Output<String> getKmsKeyArn() {
        return this.kmsKeyArn == null ? Output.empty() : this.kmsKeyArn;
    }

    /**
     * Date this resource was last modified.
     * 
     */
    @Import(name="lastModified")
      private final @Nullable Output<String> lastModified;

    public Output<String> getLastModified() {
        return this.lastModified == null ? Output.empty() : this.lastModified;
    }

    /**
     * List of Lambda Layer Version ARNs (maximum of 5) to attach to your Lambda Function. See [Lambda Layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html)
     * 
     */
    @Import(name="layers")
      private final @Nullable Output<List<String>> layers;

    public Output<List<String>> getLayers() {
        return this.layers == null ? Output.empty() : this.layers;
    }

    /**
     * Amount of memory in MB your Lambda Function can use at runtime. Defaults to `128`. See [Limits](https://docs.aws.amazon.com/lambda/latest/dg/limits.html)
     * 
     */
    @Import(name="memorySize")
      private final @Nullable Output<Integer> memorySize;

    public Output<Integer> getMemorySize() {
        return this.memorySize == null ? Output.empty() : this.memorySize;
    }

    /**
     * Unique name for your Lambda Function.
     * 
     */
    @Import(name="name")
      private final @Nullable Output<String> name;

    public Output<String> getName() {
        return this.name == null ? Output.empty() : this.name;
    }

    /**
     * Lambda deployment package type. Valid values are `Zip` and `Image`. Defaults to `Zip`.
     * 
     */
    @Import(name="packageType")
      private final @Nullable Output<String> packageType;

    public Output<String> getPackageType() {
        return this.packageType == null ? Output.empty() : this.packageType;
    }

    /**
     * Whether to publish creation/change as new Lambda Function Version. Defaults to `false`.
     * 
     */
    @Import(name="publish")
      private final @Nullable Output<Boolean> publish;

    public Output<Boolean> getPublish() {
        return this.publish == null ? Output.empty() : this.publish;
    }

    /**
     * ARN identifying your Lambda Function Version (if versioning is enabled via `publish = true`).
     * 
     */
    @Import(name="qualifiedArn")
      private final @Nullable Output<String> qualifiedArn;

    public Output<String> getQualifiedArn() {
        return this.qualifiedArn == null ? Output.empty() : this.qualifiedArn;
    }

    /**
     * Amount of reserved concurrent executions for this lambda function. A value of `0` disables lambda from being triggered and `-1` removes any concurrency limitations. Defaults to Unreserved Concurrency Limits `-1`. See [Managing Concurrency](https://docs.aws.amazon.com/lambda/latest/dg/concurrent-executions.html)
     * 
     */
    @Import(name="reservedConcurrentExecutions")
      private final @Nullable Output<Integer> reservedConcurrentExecutions;

    public Output<Integer> getReservedConcurrentExecutions() {
        return this.reservedConcurrentExecutions == null ? Output.empty() : this.reservedConcurrentExecutions;
    }

    /**
     * Amazon Resource Name (ARN) of the function's execution role. The role provides the function's identity and access to AWS services and resources.
     * 
     */
    @Import(name="role")
      private final @Nullable Output<String> role;

    public Output<String> getRole() {
        return this.role == null ? Output.empty() : this.role;
    }

    /**
     * Identifier of the function's runtime. See [Runtimes](https://docs.aws.amazon.com/lambda/latest/dg/API_CreateFunction.html#SSS-CreateFunction-request-Runtime) for valid values.
     * 
     */
    @Import(name="runtime")
      private final @Nullable Output<Either<String,Runtime>> runtime;

    public Output<Either<String,Runtime>> getRuntime() {
        return this.runtime == null ? Output.empty() : this.runtime;
    }

    /**
     * S3 bucket location containing the function's deployment package. Conflicts with `filename` and `image_uri`. This bucket must reside in the same AWS region where you are creating the Lambda function.
     * 
     */
    @Import(name="s3Bucket")
      private final @Nullable Output<String> s3Bucket;

    public Output<String> getS3Bucket() {
        return this.s3Bucket == null ? Output.empty() : this.s3Bucket;
    }

    /**
     * S3 key of an object containing the function's deployment package. Conflicts with `filename` and `image_uri`.
     * 
     */
    @Import(name="s3Key")
      private final @Nullable Output<String> s3Key;

    public Output<String> getS3Key() {
        return this.s3Key == null ? Output.empty() : this.s3Key;
    }

    /**
     * Object version containing the function's deployment package. Conflicts with `filename` and `image_uri`.
     * 
     */
    @Import(name="s3ObjectVersion")
      private final @Nullable Output<String> s3ObjectVersion;

    public Output<String> getS3ObjectVersion() {
        return this.s3ObjectVersion == null ? Output.empty() : this.s3ObjectVersion;
    }

    /**
     * ARN of the signing job.
     * 
     */
    @Import(name="signingJobArn")
      private final @Nullable Output<String> signingJobArn;

    public Output<String> getSigningJobArn() {
        return this.signingJobArn == null ? Output.empty() : this.signingJobArn;
    }

    /**
     * ARN of the signing profile version.
     * 
     */
    @Import(name="signingProfileVersionArn")
      private final @Nullable Output<String> signingProfileVersionArn;

    public Output<String> getSigningProfileVersionArn() {
        return this.signingProfileVersionArn == null ? Output.empty() : this.signingProfileVersionArn;
    }

    /**
     * Used to trigger updates. Must be set to a base64-encoded SHA256 hash of the package file specified with either `filename` or `s3_key`. The usual way to set this is `filebase64sha256("file.zip")`, where "file.zip" is the local filename of the lambda function source archive.
     * 
     */
    @Import(name="sourceCodeHash")
      private final @Nullable Output<String> sourceCodeHash;

    public Output<String> getSourceCodeHash() {
        return this.sourceCodeHash == null ? Output.empty() : this.sourceCodeHash;
    }

    /**
     * Size in bytes of the function .zip file.
     * 
     */
    @Import(name="sourceCodeSize")
      private final @Nullable Output<Integer> sourceCodeSize;

    public Output<Integer> getSourceCodeSize() {
        return this.sourceCodeSize == null ? Output.empty() : this.sourceCodeSize;
    }

    /**
     * Map of tags to assign to the object.
     * 
     */
    @Import(name="tags")
      private final @Nullable Output<Map<String,String>> tags;

    public Output<Map<String,String>> getTags() {
        return this.tags == null ? Output.empty() : this.tags;
    }

    /**
     * A map of tags assigned to the resource, including those inherited from the provider .
     * 
     */
    @Import(name="tagsAll")
      private final @Nullable Output<Map<String,String>> tagsAll;

    public Output<Map<String,String>> getTagsAll() {
        return this.tagsAll == null ? Output.empty() : this.tagsAll;
    }

    /**
     * Amount of time your Lambda Function has to run in seconds. Defaults to `3`. See [Limits](https://docs.aws.amazon.com/lambda/latest/dg/limits.html).
     * 
     */
    @Import(name="timeout")
      private final @Nullable Output<Integer> timeout;

    public Output<Integer> getTimeout() {
        return this.timeout == null ? Output.empty() : this.timeout;
    }

    /**
     * Configuration block. Detailed below.
     * 
     */
    @Import(name="tracingConfig")
      private final @Nullable Output<FunctionTracingConfigGetArgs> tracingConfig;

    public Output<FunctionTracingConfigGetArgs> getTracingConfig() {
        return this.tracingConfig == null ? Output.empty() : this.tracingConfig;
    }

    /**
     * Latest published version of your Lambda Function.
     * * `vpc_config.vpc_id` - ID of the VPC.
     * 
     */
    @Import(name="version")
      private final @Nullable Output<String> version;

    public Output<String> getVersion() {
        return this.version == null ? Output.empty() : this.version;
    }

    /**
     * Configuration block. Detailed below.
     * 
     */
    @Import(name="vpcConfig")
      private final @Nullable Output<FunctionVpcConfigGetArgs> vpcConfig;

    public Output<FunctionVpcConfigGetArgs> getVpcConfig() {
        return this.vpcConfig == null ? Output.empty() : this.vpcConfig;
    }

    public FunctionState(
        @Nullable Output<List<String>> architectures,
        @Nullable Output<String> arn,
        @Nullable Output<Archive> code,
        @Nullable Output<String> codeSigningConfigArn,
        @Nullable Output<FunctionDeadLetterConfigGetArgs> deadLetterConfig,
        @Nullable Output<String> description,
        @Nullable Output<FunctionEnvironmentGetArgs> environment,
        @Nullable Output<FunctionFileSystemConfigGetArgs> fileSystemConfig,
        @Nullable Output<String> handler,
        @Nullable Output<FunctionImageConfigGetArgs> imageConfig,
        @Nullable Output<String> imageUri,
        @Nullable Output<String> invokeArn,
        @Nullable Output<String> kmsKeyArn,
        @Nullable Output<String> lastModified,
        @Nullable Output<List<String>> layers,
        @Nullable Output<Integer> memorySize,
        @Nullable Output<String> name,
        @Nullable Output<String> packageType,
        @Nullable Output<Boolean> publish,
        @Nullable Output<String> qualifiedArn,
        @Nullable Output<Integer> reservedConcurrentExecutions,
        @Nullable Output<String> role,
        @Nullable Output<Either<String,Runtime>> runtime,
        @Nullable Output<String> s3Bucket,
        @Nullable Output<String> s3Key,
        @Nullable Output<String> s3ObjectVersion,
        @Nullable Output<String> signingJobArn,
        @Nullable Output<String> signingProfileVersionArn,
        @Nullable Output<String> sourceCodeHash,
        @Nullable Output<Integer> sourceCodeSize,
        @Nullable Output<Map<String,String>> tags,
        @Nullable Output<Map<String,String>> tagsAll,
        @Nullable Output<Integer> timeout,
        @Nullable Output<FunctionTracingConfigGetArgs> tracingConfig,
        @Nullable Output<String> version,
        @Nullable Output<FunctionVpcConfigGetArgs> vpcConfig) {
        this.architectures = architectures;
        this.arn = arn;
        this.code = code;
        this.codeSigningConfigArn = codeSigningConfigArn;
        this.deadLetterConfig = deadLetterConfig;
        this.description = description;
        this.environment = environment;
        this.fileSystemConfig = fileSystemConfig;
        this.handler = handler;
        this.imageConfig = imageConfig;
        this.imageUri = imageUri;
        this.invokeArn = invokeArn;
        this.kmsKeyArn = kmsKeyArn;
        this.lastModified = lastModified;
        this.layers = layers;
        this.memorySize = memorySize;
        this.name = name;
        this.packageType = packageType;
        this.publish = publish;
        this.qualifiedArn = qualifiedArn;
        this.reservedConcurrentExecutions = reservedConcurrentExecutions;
        this.role = role;
        this.runtime = runtime;
        this.s3Bucket = s3Bucket;
        this.s3Key = s3Key;
        this.s3ObjectVersion = s3ObjectVersion;
        this.signingJobArn = signingJobArn;
        this.signingProfileVersionArn = signingProfileVersionArn;
        this.sourceCodeHash = sourceCodeHash;
        this.sourceCodeSize = sourceCodeSize;
        this.tags = tags;
        this.tagsAll = tagsAll;
        this.timeout = timeout;
        this.tracingConfig = tracingConfig;
        this.version = version;
        this.vpcConfig = vpcConfig;
    }

    private FunctionState() {
        this.architectures = Output.empty();
        this.arn = Output.empty();
        this.code = Output.empty();
        this.codeSigningConfigArn = Output.empty();
        this.deadLetterConfig = Output.empty();
        this.description = Output.empty();
        this.environment = Output.empty();
        this.fileSystemConfig = Output.empty();
        this.handler = Output.empty();
        this.imageConfig = Output.empty();
        this.imageUri = Output.empty();
        this.invokeArn = Output.empty();
        this.kmsKeyArn = Output.empty();
        this.lastModified = Output.empty();
        this.layers = Output.empty();
        this.memorySize = Output.empty();
        this.name = Output.empty();
        this.packageType = Output.empty();
        this.publish = Output.empty();
        this.qualifiedArn = Output.empty();
        this.reservedConcurrentExecutions = Output.empty();
        this.role = Output.empty();
        this.runtime = Output.empty();
        this.s3Bucket = Output.empty();
        this.s3Key = Output.empty();
        this.s3ObjectVersion = Output.empty();
        this.signingJobArn = Output.empty();
        this.signingProfileVersionArn = Output.empty();
        this.sourceCodeHash = Output.empty();
        this.sourceCodeSize = Output.empty();
        this.tags = Output.empty();
        this.tagsAll = Output.empty();
        this.timeout = Output.empty();
        this.tracingConfig = Output.empty();
        this.version = Output.empty();
        this.vpcConfig = Output.empty();
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(FunctionState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private @Nullable Output<List<String>> architectures;
        private @Nullable Output<String> arn;
        private @Nullable Output<Archive> code;
        private @Nullable Output<String> codeSigningConfigArn;
        private @Nullable Output<FunctionDeadLetterConfigGetArgs> deadLetterConfig;
        private @Nullable Output<String> description;
        private @Nullable Output<FunctionEnvironmentGetArgs> environment;
        private @Nullable Output<FunctionFileSystemConfigGetArgs> fileSystemConfig;
        private @Nullable Output<String> handler;
        private @Nullable Output<FunctionImageConfigGetArgs> imageConfig;
        private @Nullable Output<String> imageUri;
        private @Nullable Output<String> invokeArn;
        private @Nullable Output<String> kmsKeyArn;
        private @Nullable Output<String> lastModified;
        private @Nullable Output<List<String>> layers;
        private @Nullable Output<Integer> memorySize;
        private @Nullable Output<String> name;
        private @Nullable Output<String> packageType;
        private @Nullable Output<Boolean> publish;
        private @Nullable Output<String> qualifiedArn;
        private @Nullable Output<Integer> reservedConcurrentExecutions;
        private @Nullable Output<String> role;
        private @Nullable Output<Either<String,Runtime>> runtime;
        private @Nullable Output<String> s3Bucket;
        private @Nullable Output<String> s3Key;
        private @Nullable Output<String> s3ObjectVersion;
        private @Nullable Output<String> signingJobArn;
        private @Nullable Output<String> signingProfileVersionArn;
        private @Nullable Output<String> sourceCodeHash;
        private @Nullable Output<Integer> sourceCodeSize;
        private @Nullable Output<Map<String,String>> tags;
        private @Nullable Output<Map<String,String>> tagsAll;
        private @Nullable Output<Integer> timeout;
        private @Nullable Output<FunctionTracingConfigGetArgs> tracingConfig;
        private @Nullable Output<String> version;
        private @Nullable Output<FunctionVpcConfigGetArgs> vpcConfig;

        public Builder() {
    	      // Empty
        }

        public Builder(FunctionState defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.architectures = defaults.architectures;
    	      this.arn = defaults.arn;
    	      this.code = defaults.code;
    	      this.codeSigningConfigArn = defaults.codeSigningConfigArn;
    	      this.deadLetterConfig = defaults.deadLetterConfig;
    	      this.description = defaults.description;
    	      this.environment = defaults.environment;
    	      this.fileSystemConfig = defaults.fileSystemConfig;
    	      this.handler = defaults.handler;
    	      this.imageConfig = defaults.imageConfig;
    	      this.imageUri = defaults.imageUri;
    	      this.invokeArn = defaults.invokeArn;
    	      this.kmsKeyArn = defaults.kmsKeyArn;
    	      this.lastModified = defaults.lastModified;
    	      this.layers = defaults.layers;
    	      this.memorySize = defaults.memorySize;
    	      this.name = defaults.name;
    	      this.packageType = defaults.packageType;
    	      this.publish = defaults.publish;
    	      this.qualifiedArn = defaults.qualifiedArn;
    	      this.reservedConcurrentExecutions = defaults.reservedConcurrentExecutions;
    	      this.role = defaults.role;
    	      this.runtime = defaults.runtime;
    	      this.s3Bucket = defaults.s3Bucket;
    	      this.s3Key = defaults.s3Key;
    	      this.s3ObjectVersion = defaults.s3ObjectVersion;
    	      this.signingJobArn = defaults.signingJobArn;
    	      this.signingProfileVersionArn = defaults.signingProfileVersionArn;
    	      this.sourceCodeHash = defaults.sourceCodeHash;
    	      this.sourceCodeSize = defaults.sourceCodeSize;
    	      this.tags = defaults.tags;
    	      this.tagsAll = defaults.tagsAll;
    	      this.timeout = defaults.timeout;
    	      this.tracingConfig = defaults.tracingConfig;
    	      this.version = defaults.version;
    	      this.vpcConfig = defaults.vpcConfig;
        }

        public Builder architectures(@Nullable Output<List<String>> architectures) {
            this.architectures = architectures;
            return this;
        }
        public Builder architectures(@Nullable List<String> architectures) {
            this.architectures = Output.ofNullable(architectures);
            return this;
        }
        public Builder architectures(String... architectures) {
            return architectures(List.of(architectures));
        }
        public Builder arn(@Nullable Output<String> arn) {
            this.arn = arn;
            return this;
        }
        public Builder arn(@Nullable String arn) {
            this.arn = Output.ofNullable(arn);
            return this;
        }
        public Builder code(@Nullable Output<Archive> code) {
            this.code = code;
            return this;
        }
        public Builder code(@Nullable Archive code) {
            this.code = Output.ofNullable(code);
            return this;
        }
        public Builder codeSigningConfigArn(@Nullable Output<String> codeSigningConfigArn) {
            this.codeSigningConfigArn = codeSigningConfigArn;
            return this;
        }
        public Builder codeSigningConfigArn(@Nullable String codeSigningConfigArn) {
            this.codeSigningConfigArn = Output.ofNullable(codeSigningConfigArn);
            return this;
        }
        public Builder deadLetterConfig(@Nullable Output<FunctionDeadLetterConfigGetArgs> deadLetterConfig) {
            this.deadLetterConfig = deadLetterConfig;
            return this;
        }
        public Builder deadLetterConfig(@Nullable FunctionDeadLetterConfigGetArgs deadLetterConfig) {
            this.deadLetterConfig = Output.ofNullable(deadLetterConfig);
            return this;
        }
        public Builder description(@Nullable Output<String> description) {
            this.description = description;
            return this;
        }
        public Builder description(@Nullable String description) {
            this.description = Output.ofNullable(description);
            return this;
        }
        public Builder environment(@Nullable Output<FunctionEnvironmentGetArgs> environment) {
            this.environment = environment;
            return this;
        }
        public Builder environment(@Nullable FunctionEnvironmentGetArgs environment) {
            this.environment = Output.ofNullable(environment);
            return this;
        }
        public Builder fileSystemConfig(@Nullable Output<FunctionFileSystemConfigGetArgs> fileSystemConfig) {
            this.fileSystemConfig = fileSystemConfig;
            return this;
        }
        public Builder fileSystemConfig(@Nullable FunctionFileSystemConfigGetArgs fileSystemConfig) {
            this.fileSystemConfig = Output.ofNullable(fileSystemConfig);
            return this;
        }
        public Builder handler(@Nullable Output<String> handler) {
            this.handler = handler;
            return this;
        }
        public Builder handler(@Nullable String handler) {
            this.handler = Output.ofNullable(handler);
            return this;
        }
        public Builder imageConfig(@Nullable Output<FunctionImageConfigGetArgs> imageConfig) {
            this.imageConfig = imageConfig;
            return this;
        }
        public Builder imageConfig(@Nullable FunctionImageConfigGetArgs imageConfig) {
            this.imageConfig = Output.ofNullable(imageConfig);
            return this;
        }
        public Builder imageUri(@Nullable Output<String> imageUri) {
            this.imageUri = imageUri;
            return this;
        }
        public Builder imageUri(@Nullable String imageUri) {
            this.imageUri = Output.ofNullable(imageUri);
            return this;
        }
        public Builder invokeArn(@Nullable Output<String> invokeArn) {
            this.invokeArn = invokeArn;
            return this;
        }
        public Builder invokeArn(@Nullable String invokeArn) {
            this.invokeArn = Output.ofNullable(invokeArn);
            return this;
        }
        public Builder kmsKeyArn(@Nullable Output<String> kmsKeyArn) {
            this.kmsKeyArn = kmsKeyArn;
            return this;
        }
        public Builder kmsKeyArn(@Nullable String kmsKeyArn) {
            this.kmsKeyArn = Output.ofNullable(kmsKeyArn);
            return this;
        }
        public Builder lastModified(@Nullable Output<String> lastModified) {
            this.lastModified = lastModified;
            return this;
        }
        public Builder lastModified(@Nullable String lastModified) {
            this.lastModified = Output.ofNullable(lastModified);
            return this;
        }
        public Builder layers(@Nullable Output<List<String>> layers) {
            this.layers = layers;
            return this;
        }
        public Builder layers(@Nullable List<String> layers) {
            this.layers = Output.ofNullable(layers);
            return this;
        }
        public Builder layers(String... layers) {
            return layers(List.of(layers));
        }
        public Builder memorySize(@Nullable Output<Integer> memorySize) {
            this.memorySize = memorySize;
            return this;
        }
        public Builder memorySize(@Nullable Integer memorySize) {
            this.memorySize = Output.ofNullable(memorySize);
            return this;
        }
        public Builder name(@Nullable Output<String> name) {
            this.name = name;
            return this;
        }
        public Builder name(@Nullable String name) {
            this.name = Output.ofNullable(name);
            return this;
        }
        public Builder packageType(@Nullable Output<String> packageType) {
            this.packageType = packageType;
            return this;
        }
        public Builder packageType(@Nullable String packageType) {
            this.packageType = Output.ofNullable(packageType);
            return this;
        }
        public Builder publish(@Nullable Output<Boolean> publish) {
            this.publish = publish;
            return this;
        }
        public Builder publish(@Nullable Boolean publish) {
            this.publish = Output.ofNullable(publish);
            return this;
        }
        public Builder qualifiedArn(@Nullable Output<String> qualifiedArn) {
            this.qualifiedArn = qualifiedArn;
            return this;
        }
        public Builder qualifiedArn(@Nullable String qualifiedArn) {
            this.qualifiedArn = Output.ofNullable(qualifiedArn);
            return this;
        }
        public Builder reservedConcurrentExecutions(@Nullable Output<Integer> reservedConcurrentExecutions) {
            this.reservedConcurrentExecutions = reservedConcurrentExecutions;
            return this;
        }
        public Builder reservedConcurrentExecutions(@Nullable Integer reservedConcurrentExecutions) {
            this.reservedConcurrentExecutions = Output.ofNullable(reservedConcurrentExecutions);
            return this;
        }
        public Builder role(@Nullable Output<String> role) {
            this.role = role;
            return this;
        }
        public Builder role(@Nullable String role) {
            this.role = Output.ofNullable(role);
            return this;
        }
        public Builder runtime(@Nullable Output<Either<String,Runtime>> runtime) {
            this.runtime = runtime;
            return this;
        }
        public Builder runtime(@Nullable Either<String,Runtime> runtime) {
            this.runtime = Output.ofNullable(runtime);
            return this;
        }
        public Builder s3Bucket(@Nullable Output<String> s3Bucket) {
            this.s3Bucket = s3Bucket;
            return this;
        }
        public Builder s3Bucket(@Nullable String s3Bucket) {
            this.s3Bucket = Output.ofNullable(s3Bucket);
            return this;
        }
        public Builder s3Key(@Nullable Output<String> s3Key) {
            this.s3Key = s3Key;
            return this;
        }
        public Builder s3Key(@Nullable String s3Key) {
            this.s3Key = Output.ofNullable(s3Key);
            return this;
        }
        public Builder s3ObjectVersion(@Nullable Output<String> s3ObjectVersion) {
            this.s3ObjectVersion = s3ObjectVersion;
            return this;
        }
        public Builder s3ObjectVersion(@Nullable String s3ObjectVersion) {
            this.s3ObjectVersion = Output.ofNullable(s3ObjectVersion);
            return this;
        }
        public Builder signingJobArn(@Nullable Output<String> signingJobArn) {
            this.signingJobArn = signingJobArn;
            return this;
        }
        public Builder signingJobArn(@Nullable String signingJobArn) {
            this.signingJobArn = Output.ofNullable(signingJobArn);
            return this;
        }
        public Builder signingProfileVersionArn(@Nullable Output<String> signingProfileVersionArn) {
            this.signingProfileVersionArn = signingProfileVersionArn;
            return this;
        }
        public Builder signingProfileVersionArn(@Nullable String signingProfileVersionArn) {
            this.signingProfileVersionArn = Output.ofNullable(signingProfileVersionArn);
            return this;
        }
        public Builder sourceCodeHash(@Nullable Output<String> sourceCodeHash) {
            this.sourceCodeHash = sourceCodeHash;
            return this;
        }
        public Builder sourceCodeHash(@Nullable String sourceCodeHash) {
            this.sourceCodeHash = Output.ofNullable(sourceCodeHash);
            return this;
        }
        public Builder sourceCodeSize(@Nullable Output<Integer> sourceCodeSize) {
            this.sourceCodeSize = sourceCodeSize;
            return this;
        }
        public Builder sourceCodeSize(@Nullable Integer sourceCodeSize) {
            this.sourceCodeSize = Output.ofNullable(sourceCodeSize);
            return this;
        }
        public Builder tags(@Nullable Output<Map<String,String>> tags) {
            this.tags = tags;
            return this;
        }
        public Builder tags(@Nullable Map<String,String> tags) {
            this.tags = Output.ofNullable(tags);
            return this;
        }
        public Builder tagsAll(@Nullable Output<Map<String,String>> tagsAll) {
            this.tagsAll = tagsAll;
            return this;
        }
        public Builder tagsAll(@Nullable Map<String,String> tagsAll) {
            this.tagsAll = Output.ofNullable(tagsAll);
            return this;
        }
        public Builder timeout(@Nullable Output<Integer> timeout) {
            this.timeout = timeout;
            return this;
        }
        public Builder timeout(@Nullable Integer timeout) {
            this.timeout = Output.ofNullable(timeout);
            return this;
        }
        public Builder tracingConfig(@Nullable Output<FunctionTracingConfigGetArgs> tracingConfig) {
            this.tracingConfig = tracingConfig;
            return this;
        }
        public Builder tracingConfig(@Nullable FunctionTracingConfigGetArgs tracingConfig) {
            this.tracingConfig = Output.ofNullable(tracingConfig);
            return this;
        }
        public Builder version(@Nullable Output<String> version) {
            this.version = version;
            return this;
        }
        public Builder version(@Nullable String version) {
            this.version = Output.ofNullable(version);
            return this;
        }
        public Builder vpcConfig(@Nullable Output<FunctionVpcConfigGetArgs> vpcConfig) {
            this.vpcConfig = vpcConfig;
            return this;
        }
        public Builder vpcConfig(@Nullable FunctionVpcConfigGetArgs vpcConfig) {
            this.vpcConfig = Output.ofNullable(vpcConfig);
            return this;
        }        public FunctionState build() {
            return new FunctionState(architectures, arn, code, codeSigningConfigArn, deadLetterConfig, description, environment, fileSystemConfig, handler, imageConfig, imageUri, invokeArn, kmsKeyArn, lastModified, layers, memorySize, name, packageType, publish, qualifiedArn, reservedConcurrentExecutions, role, runtime, s3Bucket, s3Key, s3ObjectVersion, signingJobArn, signingProfileVersionArn, sourceCodeHash, sourceCodeSize, tags, tagsAll, timeout, tracingConfig, version, vpcConfig);
        }
    }
}
