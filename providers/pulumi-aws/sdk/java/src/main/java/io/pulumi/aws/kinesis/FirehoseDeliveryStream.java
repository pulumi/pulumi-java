// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package io.pulumi.aws.kinesis;

import io.pulumi.aws.Utilities;
import io.pulumi.aws.kinesis.FirehoseDeliveryStreamArgs;
import io.pulumi.aws.kinesis.inputs.FirehoseDeliveryStreamState;
import io.pulumi.aws.kinesis.outputs.FirehoseDeliveryStreamElasticsearchConfiguration;
import io.pulumi.aws.kinesis.outputs.FirehoseDeliveryStreamExtendedS3Configuration;
import io.pulumi.aws.kinesis.outputs.FirehoseDeliveryStreamHttpEndpointConfiguration;
import io.pulumi.aws.kinesis.outputs.FirehoseDeliveryStreamKinesisSourceConfiguration;
import io.pulumi.aws.kinesis.outputs.FirehoseDeliveryStreamRedshiftConfiguration;
import io.pulumi.aws.kinesis.outputs.FirehoseDeliveryStreamS3Configuration;
import io.pulumi.aws.kinesis.outputs.FirehoseDeliveryStreamServerSideEncryption;
import io.pulumi.aws.kinesis.outputs.FirehoseDeliveryStreamSplunkConfiguration;
import io.pulumi.core.Output;
import io.pulumi.core.annotations.Export;
import io.pulumi.core.annotations.ResourceType;
import java.lang.String;
import java.util.Map;
import javax.annotation.Nullable;

/**
 * Provides a Kinesis Firehose Delivery Stream resource. Amazon Kinesis Firehose is a fully managed, elastic service to easily deliver real-time data streams to destinations such as Amazon S3 and Amazon Redshift.
 * 
 * For more details, see the [Amazon Kinesis Firehose Documentation](https://aws.amazon.com/documentation/firehose/).
 * 
 * {{% examples %}}
 * ## Example Usage
 * {{% example %}}
 * ### Extended S3 Destination
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 * 
 * const bucket = new aws.s3.Bucket("bucket", {acl: "private"});
 * const firehoseRole = new aws.iam.Role("firehoseRole", {assumeRolePolicy: `{
 *   "Version": "2012-10-17",
 *   "Statement": [
 *     {
 *       "Action": "sts:AssumeRole",
 *       "Principal": {
 *         "Service": "firehose.amazonaws.com"
 *       },
 *       "Effect": "Allow",
 *       "Sid": ""
 *     }
 *   ]
 * }
 * `});
 * const lambdaIam = new aws.iam.Role("lambdaIam", {assumeRolePolicy: `{
 *   "Version": "2012-10-17",
 *   "Statement": [
 *     {
 *       "Action": "sts:AssumeRole",
 *       "Principal": {
 *         "Service": "lambda.amazonaws.com"
 *       },
 *       "Effect": "Allow",
 *       "Sid": ""
 *     }
 *   ]
 * }
 * `});
 * const lambdaProcessor = new aws.lambda.Function("lambdaProcessor", {
 *     code: new pulumi.asset.FileArchive("lambda.zip"),
 *     role: lambdaIam.arn,
 *     handler: "exports.handler",
 *     runtime: "nodejs12.x",
 * });
 * const extendedS3Stream = new aws.kinesis.FirehoseDeliveryStream("extendedS3Stream", {
 *     destination: "extended_s3",
 *     extendedS3Configuration: {
 *         roleArn: firehoseRole.arn,
 *         bucketArn: bucket.arn,
 *         processingConfiguration: {
 *             enabled: "true",
 *             processors: [{
 *                 type: "Lambda",
 *                 parameters: [{
 *                     parameterName: "LambdaArn",
 *                     parameterValue: pulumi.interpolate`${lambdaProcessor.arn}:$LATEST`,
 *                 }],
 *             }],
 *         },
 *     },
 * });
 * ```
 * ```python
 * import pulumi
 * import pulumi_aws as aws
 * 
 * bucket = aws.s3.Bucket("bucket", acl="private")
 * firehose_role = aws.iam.Role("firehoseRole", assume_role_policy="""{
 *   "Version": "2012-10-17",
 *   "Statement": [
 *     {
 *       "Action": "sts:AssumeRole",
 *       "Principal": {
 *         "Service": "firehose.amazonaws.com"
 *       },
 *       "Effect": "Allow",
 *       "Sid": ""
 *     }
 *   ]
 * }
 * """)
 * lambda_iam = aws.iam.Role("lambdaIam", assume_role_policy="""{
 *   "Version": "2012-10-17",
 *   "Statement": [
 *     {
 *       "Action": "sts:AssumeRole",
 *       "Principal": {
 *         "Service": "lambda.amazonaws.com"
 *       },
 *       "Effect": "Allow",
 *       "Sid": ""
 *     }
 *   ]
 * }
 * """)
 * lambda_processor = aws.lambda_.Function("lambdaProcessor",
 *     code=pulumi.FileArchive("lambda.zip"),
 *     role=lambda_iam.arn,
 *     handler="exports.handler",
 *     runtime="nodejs12.x")
 * extended_s3_stream = aws.kinesis.FirehoseDeliveryStream("extendedS3Stream",
 *     destination="extended_s3",
 *     extended_s3_configuration=aws.kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationArgs(
 *         role_arn=firehose_role.arn,
 *         bucket_arn=bucket.arn,
 *         processing_configuration=aws.kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationProcessingConfigurationArgs(
 *             enabled=True,
 *             processors=[aws.kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationProcessingConfigurationProcessorArgs(
 *                 type="Lambda",
 *                 parameters=[aws.kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationProcessingConfigurationProcessorParameterArgs(
 *                     parameter_name="LambdaArn",
 *                     parameter_value=lambda_processor.arn.apply(lambda arn: f"{arn}:$LATEST"),
 *                 )],
 *             )],
 *         ),
 *     ))
 * ```
 * ```csharp
 * using Pulumi;
 * using Aws = Pulumi.Aws;
 * 
 * class MyStack : Stack
 * {
 *     public MyStack()
 *     {
 *         var bucket = new Aws.S3.Bucket("bucket", new Aws.S3.BucketArgs
 *         {
 *             Acl = "private",
 *         });
 *         var firehoseRole = new Aws.Iam.Role("firehoseRole", new Aws.Iam.RoleArgs
 *         {
 *             AssumeRolePolicy = @"{
 *   ""Version"": ""2012-10-17"",
 *   ""Statement"": [
 *     {
 *       ""Action"": ""sts:AssumeRole"",
 *       ""Principal"": {
 *         ""Service"": ""firehose.amazonaws.com""
 *       },
 *       ""Effect"": ""Allow"",
 *       ""Sid"": """"
 *     }
 *   ]
 * }
 * ",
 *         });
 *         var lambdaIam = new Aws.Iam.Role("lambdaIam", new Aws.Iam.RoleArgs
 *         {
 *             AssumeRolePolicy = @"{
 *   ""Version"": ""2012-10-17"",
 *   ""Statement"": [
 *     {
 *       ""Action"": ""sts:AssumeRole"",
 *       ""Principal"": {
 *         ""Service"": ""lambda.amazonaws.com""
 *       },
 *       ""Effect"": ""Allow"",
 *       ""Sid"": """"
 *     }
 *   ]
 * }
 * ",
 *         });
 *         var lambdaProcessor = new Aws.Lambda.Function("lambdaProcessor", new Aws.Lambda.FunctionArgs
 *         {
 *             Code = new FileArchive("lambda.zip"),
 *             Role = lambdaIam.Arn,
 *             Handler = "exports.handler",
 *             Runtime = "nodejs12.x",
 *         });
 *         var extendedS3Stream = new Aws.Kinesis.FirehoseDeliveryStream("extendedS3Stream", new Aws.Kinesis.FirehoseDeliveryStreamArgs
 *         {
 *             Destination = "extended_s3",
 *             ExtendedS3Configuration = new Aws.Kinesis.Inputs.FirehoseDeliveryStreamExtendedS3ConfigurationArgs
 *             {
 *                 RoleArn = firehoseRole.Arn,
 *                 BucketArn = bucket.Arn,
 *                 ProcessingConfiguration = new Aws.Kinesis.Inputs.FirehoseDeliveryStreamExtendedS3ConfigurationProcessingConfigurationArgs
 *                 {
 *                     Enabled = true,
 *                     Processors = 
 *                     {
 *                         new Aws.Kinesis.Inputs.FirehoseDeliveryStreamExtendedS3ConfigurationProcessingConfigurationProcessorArgs
 *                         {
 *                             Type = "Lambda",
 *                             Parameters = 
 *                             {
 *                                 new Aws.Kinesis.Inputs.FirehoseDeliveryStreamExtendedS3ConfigurationProcessingConfigurationProcessorParameterArgs
 *                                 {
 *                                     ParameterName = "LambdaArn",
 *                                     ParameterValue = lambdaProcessor.Arn.Apply(arn => $"{arn}:$LATEST"),
 *                                 },
 *                             },
 *                         },
 *                     },
 *                 },
 *             },
 *         });
 *     }
 * 
 * }
 * ```
 * ```go
 * package main
 * 
 * import (
 * 	"fmt"
 * 
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws"
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/iam"
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/kinesis"
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/lambda"
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/s3"
 * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
 * )
 * 
 * func main() {
 * 	pulumi.Run(func(ctx *pulumi.Context) error {
 * 		bucket, err := s3.NewBucket(ctx, "bucket", &s3.BucketArgs{
 * 			Acl: pulumi.String("private"),
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		firehoseRole, err := iam.NewRole(ctx, "firehoseRole", &iam.RoleArgs{
 * 			AssumeRolePolicy: pulumi.Any(fmt.Sprintf("%v%v%v%v%v%v%v%v%v%v%v%v%v", "{\n", "  \"Version\": \"2012-10-17\",\n", "  \"Statement\": [\n", "    {\n", "      \"Action\": \"sts:AssumeRole\",\n", "      \"Principal\": {\n", "        \"Service\": \"firehose.amazonaws.com\"\n", "      },\n", "      \"Effect\": \"Allow\",\n", "      \"Sid\": \"\"\n", "    }\n", "  ]\n", "}\n")),
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		lambdaIam, err := iam.NewRole(ctx, "lambdaIam", &iam.RoleArgs{
 * 			AssumeRolePolicy: pulumi.Any(fmt.Sprintf("%v%v%v%v%v%v%v%v%v%v%v%v%v", "{\n", "  \"Version\": \"2012-10-17\",\n", "  \"Statement\": [\n", "    {\n", "      \"Action\": \"sts:AssumeRole\",\n", "      \"Principal\": {\n", "        \"Service\": \"lambda.amazonaws.com\"\n", "      },\n", "      \"Effect\": \"Allow\",\n", "      \"Sid\": \"\"\n", "    }\n", "  ]\n", "}\n")),
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		lambdaProcessor, err := lambda.NewFunction(ctx, "lambdaProcessor", &lambda.FunctionArgs{
 * 			Code:    pulumi.NewFileArchive("lambda.zip"),
 * 			Role:    lambdaIam.Arn,
 * 			Handler: pulumi.String("exports.handler"),
 * 			Runtime: pulumi.String("nodejs12.x"),
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		_, err = kinesis.NewFirehoseDeliveryStream(ctx, "extendedS3Stream", &kinesis.FirehoseDeliveryStreamArgs{
 * 			Destination: pulumi.String("extended_s3"),
 * 			ExtendedS3Configuration: &kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationArgs{
 * 				RoleArn:   firehoseRole.Arn,
 * 				BucketArn: bucket.Arn,
 * 				ProcessingConfiguration: &kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationProcessingConfigurationArgs{
 * 					Enabled: pulumi.Bool(true),
 * 					Processors: kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationProcessingConfigurationProcessorArray{
 * 						&kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationProcessingConfigurationProcessorArgs{
 * 							Type: pulumi.String("Lambda"),
 * 							Parameters: kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationProcessingConfigurationProcessorParameterArray{
 * 								&kinesis.FirehoseDeliveryStreamExtendedS3ConfigurationProcessingConfigurationProcessorParameterArgs{
 * 									ParameterName: pulumi.String("LambdaArn"),
 * 									ParameterValue: lambdaProcessor.Arn.ApplyT(func(arn string) (string, error) {
 * 										return fmt.Sprintf("%v%v%v%v", arn, ":", "$", "LATEST"), nil
 * 									}).(pulumi.StringOutput),
 * 								},
 * 							},
 * 						},
 * 					},
 * 				},
 * 			},
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		return nil
 * 	})
 * }
 * ```
 * {{% /example %}}
 * {{% example %}}
 * ### S3 Destination (deprecated)
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 * 
 * const bucket = new aws.s3.Bucket("bucket", {acl: "private"});
 * const firehoseRole = new aws.iam.Role("firehoseRole", {assumeRolePolicy: `{
 *   "Version": "2012-10-17",
 *   "Statement": [
 *     {
 *       "Action": "sts:AssumeRole",
 *       "Principal": {
 *         "Service": "firehose.amazonaws.com"
 *       },
 *       "Effect": "Allow",
 *       "Sid": ""
 *     }
 *   ]
 * }
 * `});
 * const testStream = new aws.kinesis.FirehoseDeliveryStream("testStream", {
 *     destination: "s3",
 *     s3Configuration: {
 *         roleArn: firehoseRole.arn,
 *         bucketArn: bucket.arn,
 *     },
 * });
 * ```
 * ```python
 * import pulumi
 * import pulumi_aws as aws
 * 
 * bucket = aws.s3.Bucket("bucket", acl="private")
 * firehose_role = aws.iam.Role("firehoseRole", assume_role_policy="""{
 *   "Version": "2012-10-17",
 *   "Statement": [
 *     {
 *       "Action": "sts:AssumeRole",
 *       "Principal": {
 *         "Service": "firehose.amazonaws.com"
 *       },
 *       "Effect": "Allow",
 *       "Sid": ""
 *     }
 *   ]
 * }
 * """)
 * test_stream = aws.kinesis.FirehoseDeliveryStream("testStream",
 *     destination="s3",
 *     s3_configuration=aws.kinesis.FirehoseDeliveryStreamS3ConfigurationArgs(
 *         role_arn=firehose_role.arn,
 *         bucket_arn=bucket.arn,
 *     ))
 * ```
 * ```csharp
 * using Pulumi;
 * using Aws = Pulumi.Aws;
 * 
 * class MyStack : Stack
 * {
 *     public MyStack()
 *     {
 *         var bucket = new Aws.S3.Bucket("bucket", new Aws.S3.BucketArgs
 *         {
 *             Acl = "private",
 *         });
 *         var firehoseRole = new Aws.Iam.Role("firehoseRole", new Aws.Iam.RoleArgs
 *         {
 *             AssumeRolePolicy = @"{
 *   ""Version"": ""2012-10-17"",
 *   ""Statement"": [
 *     {
 *       ""Action"": ""sts:AssumeRole"",
 *       ""Principal"": {
 *         ""Service"": ""firehose.amazonaws.com""
 *       },
 *       ""Effect"": ""Allow"",
 *       ""Sid"": """"
 *     }
 *   ]
 * }
 * ",
 *         });
 *         var testStream = new Aws.Kinesis.FirehoseDeliveryStream("testStream", new Aws.Kinesis.FirehoseDeliveryStreamArgs
 *         {
 *             Destination = "s3",
 *             S3Configuration = new Aws.Kinesis.Inputs.FirehoseDeliveryStreamS3ConfigurationArgs
 *             {
 *                 RoleArn = firehoseRole.Arn,
 *                 BucketArn = bucket.Arn,
 *             },
 *         });
 *     }
 * 
 * }
 * ```
 * ```go
 * package main
 * 
 * import (
 * 	"fmt"
 * 
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/iam"
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/kinesis"
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/s3"
 * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
 * )
 * 
 * func main() {
 * 	pulumi.Run(func(ctx *pulumi.Context) error {
 * 		bucket, err := s3.NewBucket(ctx, "bucket", &s3.BucketArgs{
 * 			Acl: pulumi.String("private"),
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		firehoseRole, err := iam.NewRole(ctx, "firehoseRole", &iam.RoleArgs{
 * 			AssumeRolePolicy: pulumi.Any(fmt.Sprintf("%v%v%v%v%v%v%v%v%v%v%v%v%v", "{\n", "  \"Version\": \"2012-10-17\",\n", "  \"Statement\": [\n", "    {\n", "      \"Action\": \"sts:AssumeRole\",\n", "      \"Principal\": {\n", "        \"Service\": \"firehose.amazonaws.com\"\n", "      },\n", "      \"Effect\": \"Allow\",\n", "      \"Sid\": \"\"\n", "    }\n", "  ]\n", "}\n")),
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		_, err = kinesis.NewFirehoseDeliveryStream(ctx, "testStream", &kinesis.FirehoseDeliveryStreamArgs{
 * 			Destination: pulumi.String("s3"),
 * 			S3Configuration: &kinesis.FirehoseDeliveryStreamS3ConfigurationArgs{
 * 				RoleArn:   firehoseRole.Arn,
 * 				BucketArn: bucket.Arn,
 * 			},
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		return nil
 * 	})
 * }
 * ```
 * {{% /example %}}
 * {{% example %}}
 * ### Redshift Destination
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 * 
 * const testCluster = new aws.redshift.Cluster("testCluster", {
 *     clusterIdentifier: "tf-redshift-cluster",
 *     databaseName: "test",
 *     masterUsername: "testuser",
 *     masterPassword: "T3stPass",
 *     nodeType: "dc1.large",
 *     clusterType: "single-node",
 * });
 * const testStream = new aws.kinesis.FirehoseDeliveryStream("testStream", {
 *     destination: "redshift",
 *     s3Configuration: {
 *         roleArn: aws_iam_role.firehose_role.arn,
 *         bucketArn: aws_s3_bucket.bucket.arn,
 *         bufferSize: 10,
 *         bufferInterval: 400,
 *         compressionFormat: "GZIP",
 *     },
 *     redshiftConfiguration: {
 *         roleArn: aws_iam_role.firehose_role.arn,
 *         clusterJdbcurl: pulumi.interpolate`jdbc:redshift://${testCluster.endpoint}/${testCluster.databaseName}`,
 *         username: "testuser",
 *         password: "T3stPass",
 *         dataTableName: "test-table",
 *         copyOptions: "delimiter '|'",
 *         dataTableColumns: "test-col",
 *         s3BackupMode: "Enabled",
 *         s3BackupConfiguration: {
 *             roleArn: aws_iam_role.firehose_role.arn,
 *             bucketArn: aws_s3_bucket.bucket.arn,
 *             bufferSize: 15,
 *             bufferInterval: 300,
 *             compressionFormat: "GZIP",
 *         },
 *     },
 * });
 * ```
 * ```python
 * import pulumi
 * import pulumi_aws as aws
 * 
 * test_cluster = aws.redshift.Cluster("testCluster",
 *     cluster_identifier="tf-redshift-cluster",
 *     database_name="test",
 *     master_username="testuser",
 *     master_password="T3stPass",
 *     node_type="dc1.large",
 *     cluster_type="single-node")
 * test_stream = aws.kinesis.FirehoseDeliveryStream("testStream",
 *     destination="redshift",
 *     s3_configuration=aws.kinesis.FirehoseDeliveryStreamS3ConfigurationArgs(
 *         role_arn=aws_iam_role["firehose_role"]["arn"],
 *         bucket_arn=aws_s3_bucket["bucket"]["arn"],
 *         buffer_size=10,
 *         buffer_interval=400,
 *         compression_format="GZIP",
 *     ),
 *     redshift_configuration=aws.kinesis.FirehoseDeliveryStreamRedshiftConfigurationArgs(
 *         role_arn=aws_iam_role["firehose_role"]["arn"],
 *         cluster_jdbcurl=pulumi.Output.all(test_cluster.endpoint, test_cluster.database_name).apply(lambda endpoint, database_name: f"jdbc:redshift://{endpoint}/{database_name}"),
 *         username="testuser",
 *         password="T3stPass",
 *         data_table_name="test-table",
 *         copy_options="delimiter '|'",
 *         data_table_columns="test-col",
 *         s3_backup_mode="Enabled",
 *         s3_backup_configuration=aws.kinesis.FirehoseDeliveryStreamRedshiftConfigurationS3BackupConfigurationArgs(
 *             role_arn=aws_iam_role["firehose_role"]["arn"],
 *             bucket_arn=aws_s3_bucket["bucket"]["arn"],
 *             buffer_size=15,
 *             buffer_interval=300,
 *             compression_format="GZIP",
 *         ),
 *     ))
 * ```
 * ```csharp
 * using Pulumi;
 * using Aws = Pulumi.Aws;
 * 
 * class MyStack : Stack
 * {
 *     public MyStack()
 *     {
 *         var testCluster = new Aws.RedShift.Cluster("testCluster", new Aws.RedShift.ClusterArgs
 *         {
 *             ClusterIdentifier = "tf-redshift-cluster",
 *             DatabaseName = "test",
 *             MasterUsername = "testuser",
 *             MasterPassword = "T3stPass",
 *             NodeType = "dc1.large",
 *             ClusterType = "single-node",
 *         });
 *         var testStream = new Aws.Kinesis.FirehoseDeliveryStream("testStream", new Aws.Kinesis.FirehoseDeliveryStreamArgs
 *         {
 *             Destination = "redshift",
 *             S3Configuration = new Aws.Kinesis.Inputs.FirehoseDeliveryStreamS3ConfigurationArgs
 *             {
 *                 RoleArn = aws_iam_role.Firehose_role.Arn,
 *                 BucketArn = aws_s3_bucket.Bucket.Arn,
 *                 BufferSize = 10,
 *                 BufferInterval = 400,
 *                 CompressionFormat = "GZIP",
 *             },
 *             RedshiftConfiguration = new Aws.Kinesis.Inputs.FirehoseDeliveryStreamRedshiftConfigurationArgs
 *             {
 *                 RoleArn = aws_iam_role.Firehose_role.Arn,
 *                 ClusterJdbcurl = Output.Tuple(testCluster.Endpoint, testCluster.DatabaseName).Apply(values =>
 *                 {
 *                     var endpoint = values.Item1;
 *                     var databaseName = values.Item2;
 *                     return $"jdbc:redshift://{endpoint}/{databaseName}";
 *                 }),
 *                 Username = "testuser",
 *                 Password = "T3stPass",
 *                 DataTableName = "test-table",
 *                 CopyOptions = "delimiter '|'",
 *                 DataTableColumns = "test-col",
 *                 S3BackupMode = "Enabled",
 *                 S3BackupConfiguration = new Aws.Kinesis.Inputs.FirehoseDeliveryStreamRedshiftConfigurationS3BackupConfigurationArgs
 *                 {
 *                     RoleArn = aws_iam_role.Firehose_role.Arn,
 *                     BucketArn = aws_s3_bucket.Bucket.Arn,
 *                     BufferSize = 15,
 *                     BufferInterval = 300,
 *                     CompressionFormat = "GZIP",
 *                 },
 *             },
 *         });
 *     }
 * 
 * }
 * ```
 * ```go
 * package main
 * 
 * import (
 * 	"fmt"
 * 
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/kinesis"
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/redshift"
 * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
 * )
 * 
 * func main() {
 * 	pulumi.Run(func(ctx *pulumi.Context) error {
 * 		testCluster, err := redshift.NewCluster(ctx, "testCluster", &redshift.ClusterArgs{
 * 			ClusterIdentifier: pulumi.String("tf-redshift-cluster"),
 * 			DatabaseName:      pulumi.String("test"),
 * 			MasterUsername:    pulumi.String("testuser"),
 * 			MasterPassword:    pulumi.String("T3stPass"),
 * 			NodeType:          pulumi.String("dc1.large"),
 * 			ClusterType:       pulumi.String("single-node"),
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		_, err = kinesis.NewFirehoseDeliveryStream(ctx, "testStream", &kinesis.FirehoseDeliveryStreamArgs{
 * 			Destination: pulumi.String("redshift"),
 * 			S3Configuration: &kinesis.FirehoseDeliveryStreamS3ConfigurationArgs{
 * 				RoleArn:           pulumi.Any(aws_iam_role.Firehose_role.Arn),
 * 				BucketArn:         pulumi.Any(aws_s3_bucket.Bucket.Arn),
 * 				BufferSize:        pulumi.Int(10),
 * 				BufferInterval:    pulumi.Int(400),
 * 				CompressionFormat: pulumi.String("GZIP"),
 * 			},
 * 			RedshiftConfiguration: &kinesis.FirehoseDeliveryStreamRedshiftConfigurationArgs{
 * 				RoleArn: pulumi.Any(aws_iam_role.Firehose_role.Arn),
 * 				ClusterJdbcurl: pulumi.All(testCluster.Endpoint, testCluster.DatabaseName).ApplyT(func(_args []interface{}) (string, error) {
 * 					endpoint := _args[0].(string)
 * 					databaseName := _args[1].(string)
 * 					return fmt.Sprintf("%v%v%v%v", "jdbc:redshift://", endpoint, "/", databaseName), nil
 * 				}).(pulumi.StringOutput),
 * 				Username:         pulumi.String("testuser"),
 * 				Password:         pulumi.String("T3stPass"),
 * 				DataTableName:    pulumi.String("test-table"),
 * 				CopyOptions:      pulumi.String("delimiter '|'"),
 * 				DataTableColumns: pulumi.String("test-col"),
 * 				S3BackupMode:     pulumi.String("Enabled"),
 * 				S3BackupConfiguration: &kinesis.FirehoseDeliveryStreamRedshiftConfigurationS3BackupConfigurationArgs{
 * 					RoleArn:           pulumi.Any(aws_iam_role.Firehose_role.Arn),
 * 					BucketArn:         pulumi.Any(aws_s3_bucket.Bucket.Arn),
 * 					BufferSize:        pulumi.Int(15),
 * 					BufferInterval:    pulumi.Int(300),
 * 					CompressionFormat: pulumi.String("GZIP"),
 * 				},
 * 			},
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		return nil
 * 	})
 * }
 * ```
 * {{% /example %}}
 * {{% example %}}
 * ### Elasticsearch Destination
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 * 
 * const testCluster = new aws.elasticsearch.Domain("testCluster", {});
 * const testStream = new aws.kinesis.FirehoseDeliveryStream("testStream", {
 *     destination: "elasticsearch",
 *     s3Configuration: {
 *         roleArn: aws_iam_role.firehose_role.arn,
 *         bucketArn: aws_s3_bucket.bucket.arn,
 *         bufferSize: 10,
 *         bufferInterval: 400,
 *         compressionFormat: "GZIP",
 *     },
 *     elasticsearchConfiguration: {
 *         domainArn: testCluster.arn,
 *         roleArn: aws_iam_role.firehose_role.arn,
 *         indexName: "test",
 *         typeName: "test",
 *         processingConfiguration: {
 *             enabled: "true",
 *             processors: [{
 *                 type: "Lambda",
 *                 parameters: [{
 *                     parameterName: "LambdaArn",
 *                     parameterValue: `${aws_lambda_function.lambda_processor.arn}:$LATEST`,
 *                 }],
 *             }],
 *         },
 *     },
 * });
 * ```
 * ```python
 * import pulumi
 * import pulumi_aws as aws
 * 
 * test_cluster = aws.elasticsearch.Domain("testCluster")
 * test_stream = aws.kinesis.FirehoseDeliveryStream("testStream",
 *     destination="elasticsearch",
 *     s3_configuration=aws.kinesis.FirehoseDeliveryStreamS3ConfigurationArgs(
 *         role_arn=aws_iam_role["firehose_role"]["arn"],
 *         bucket_arn=aws_s3_bucket["bucket"]["arn"],
 *         buffer_size=10,
 *         buffer_interval=400,
 *         compression_format="GZIP",
 *     ),
 *     elasticsearch_configuration=aws.kinesis.FirehoseDeliveryStreamElasticsearchConfigurationArgs(
 *         domain_arn=test_cluster.arn,
 *         role_arn=aws_iam_role["firehose_role"]["arn"],
 *         index_name="test",
 *         type_name="test",
 *         processing_configuration=aws.kinesis.FirehoseDeliveryStreamElasticsearchConfigurationProcessingConfigurationArgs(
 *             enabled=True,
 *             processors=[aws.kinesis.FirehoseDeliveryStreamElasticsearchConfigurationProcessingConfigurationProcessorArgs(
 *                 type="Lambda",
 *                 parameters=[aws.kinesis.FirehoseDeliveryStreamElasticsearchConfigurationProcessingConfigurationProcessorParameterArgs(
 *                     parameter_name="LambdaArn",
 *                     parameter_value=f"{aws_lambda_function['lambda_processor']['arn']}:$LATEST",
 *                 )],
 *             )],
 *         ),
 *     ))
 * ```
 * ```csharp
 * using Pulumi;
 * using Aws = Pulumi.Aws;
 * 
 * class MyStack : Stack
 * {
 *     public MyStack()
 *     {
 *         var testCluster = new Aws.ElasticSearch.Domain("testCluster", new Aws.ElasticSearch.DomainArgs
 *         {
 *         });
 *         var testStream = new Aws.Kinesis.FirehoseDeliveryStream("testStream", new Aws.Kinesis.FirehoseDeliveryStreamArgs
 *         {
 *             Destination = "elasticsearch",
 *             S3Configuration = new Aws.Kinesis.Inputs.FirehoseDeliveryStreamS3ConfigurationArgs
 *             {
 *                 RoleArn = aws_iam_role.Firehose_role.Arn,
 *                 BucketArn = aws_s3_bucket.Bucket.Arn,
 *                 BufferSize = 10,
 *                 BufferInterval = 400,
 *                 CompressionFormat = "GZIP",
 *             },
 *             ElasticsearchConfiguration = new Aws.Kinesis.Inputs.FirehoseDeliveryStreamElasticsearchConfigurationArgs
 *             {
 *                 DomainArn = testCluster.Arn,
 *                 RoleArn = aws_iam_role.Firehose_role.Arn,
 *                 IndexName = "test",
 *                 TypeName = "test",
 *                 ProcessingConfiguration = new Aws.Kinesis.Inputs.FirehoseDeliveryStreamElasticsearchConfigurationProcessingConfigurationArgs
 *                 {
 *                     Enabled = true,
 *                     Processors = 
 *                     {
 *                         new Aws.Kinesis.Inputs.FirehoseDeliveryStreamElasticsearchConfigurationProcessingConfigurationProcessorArgs
 *                         {
 *                             Type = "Lambda",
 *                             Parameters = 
 *                             {
 *                                 new Aws.Kinesis.Inputs.FirehoseDeliveryStreamElasticsearchConfigurationProcessingConfigurationProcessorParameterArgs
 *                                 {
 *                                     ParameterName = "LambdaArn",
 *                                     ParameterValue = $"{aws_lambda_function.Lambda_processor.Arn}:$LATEST",
 *                                 },
 *                             },
 *                         },
 *                     },
 *                 },
 *             },
 *         });
 *     }
 * 
 * }
 * ```
 * ```go
 * package main
 * 
 * import (
 * 	"fmt"
 * 
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/elasticsearch"
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/kinesis"
 * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
 * )
 * 
 * func main() {
 * 	pulumi.Run(func(ctx *pulumi.Context) error {
 * 		testCluster, err := elasticsearch.NewDomain(ctx, "testCluster", nil)
 * 		if err != nil {
 * 			return err
 * 		}
 * 		_, err = kinesis.NewFirehoseDeliveryStream(ctx, "testStream", &kinesis.FirehoseDeliveryStreamArgs{
 * 			Destination: pulumi.String("elasticsearch"),
 * 			S3Configuration: &kinesis.FirehoseDeliveryStreamS3ConfigurationArgs{
 * 				RoleArn:           pulumi.Any(aws_iam_role.Firehose_role.Arn),
 * 				BucketArn:         pulumi.Any(aws_s3_bucket.Bucket.Arn),
 * 				BufferSize:        pulumi.Int(10),
 * 				BufferInterval:    pulumi.Int(400),
 * 				CompressionFormat: pulumi.String("GZIP"),
 * 			},
 * 			ElasticsearchConfiguration: &kinesis.FirehoseDeliveryStreamElasticsearchConfigurationArgs{
 * 				DomainArn: testCluster.Arn,
 * 				RoleArn:   pulumi.Any(aws_iam_role.Firehose_role.Arn),
 * 				IndexName: pulumi.String("test"),
 * 				TypeName:  pulumi.String("test"),
 * 				ProcessingConfiguration: &kinesis.FirehoseDeliveryStreamElasticsearchConfigurationProcessingConfigurationArgs{
 * 					Enabled: pulumi.Bool(true),
 * 					Processors: kinesis.FirehoseDeliveryStreamElasticsearchConfigurationProcessingConfigurationProcessorArray{
 * 						&kinesis.FirehoseDeliveryStreamElasticsearchConfigurationProcessingConfigurationProcessorArgs{
 * 							Type: pulumi.String("Lambda"),
 * 							Parameters: kinesis.FirehoseDeliveryStreamElasticsearchConfigurationProcessingConfigurationProcessorParameterArray{
 * 								&kinesis.FirehoseDeliveryStreamElasticsearchConfigurationProcessingConfigurationProcessorParameterArgs{
 * 									ParameterName:  pulumi.String("LambdaArn"),
 * 									ParameterValue: pulumi.String(fmt.Sprintf("%v%v%v%v", aws_lambda_function.Lambda_processor.Arn, ":", "$", "LATEST")),
 * 								},
 * 							},
 * 						},
 * 					},
 * 				},
 * 			},
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		return nil
 * 	})
 * }
 * ```
 * {{% /example %}}
 * {{% example %}}
 * ### Elasticsearch Destination With VPC
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 * 
 * const testCluster = new aws.elasticsearch.Domain("testCluster", {
 *     clusterConfig: {
 *         instanceCount: 2,
 *         zoneAwarenessEnabled: true,
 *         instanceType: "t2.small.elasticsearch",
 *     },
 *     ebsOptions: {
 *         ebsEnabled: true,
 *         volumeSize: 10,
 *     },
 *     vpcOptions: {
 *         securityGroupIds: [aws_security_group.first.id],
 *         subnetIds: [
 *             aws_subnet.first.id,
 *             aws_subnet.second.id,
 *         ],
 *     },
 * });
 * const firehose_elasticsearch = new aws.iam.RolePolicy("firehose-elasticsearch", {
 *     role: aws_iam_role.firehose.id,
 *     policy: pulumi.interpolate`{
 *   "Version": "2012-10-17",
 *   "Statement": [
 *     {
 *       "Effect": "Allow",
 *       "Action": [
 *         "es:*"
 *       ],
 *       "Resource": [
 *         "${testCluster.arn}",
 *         "${testCluster.arn}/*"
 *       ]
 *         },
 *         {
 *           "Effect": "Allow",
 *           "Action": [
 *             "ec2:DescribeVpcs",
 *             "ec2:DescribeVpcAttribute",
 *             "ec2:DescribeSubnets",
 *             "ec2:DescribeSecurityGroups",
 *             "ec2:DescribeNetworkInterfaces",
 *             "ec2:CreateNetworkInterface",
 *             "ec2:CreateNetworkInterfacePermission",
 *             "ec2:DeleteNetworkInterface"
 *           ],
 *           "Resource": [
 *             "*"
 *           ]
 *         }
 *   ]
 * }
 * `,
 * });
 * const test = new aws.kinesis.FirehoseDeliveryStream("test", {
 *     destination: "elasticsearch",
 *     s3Configuration: {
 *         roleArn: aws_iam_role.firehose.arn,
 *         bucketArn: aws_s3_bucket.bucket.arn,
 *     },
 *     elasticsearchConfiguration: {
 *         domainArn: testCluster.arn,
 *         roleArn: aws_iam_role.firehose.arn,
 *         indexName: "test",
 *         typeName: "test",
 *         vpcConfig: {
 *             subnetIds: [
 *                 aws_subnet.first.id,
 *                 aws_subnet.second.id,
 *             ],
 *             securityGroupIds: [aws_security_group.first.id],
 *             roleArn: aws_iam_role.firehose.arn,
 *         },
 *     },
 * }, {
 *     dependsOn: [firehose_elasticsearch],
 * });
 * ```
 * ```python
 * import pulumi
 * import pulumi_aws as aws
 * 
 * test_cluster = aws.elasticsearch.Domain("testCluster",
 *     cluster_config=aws.elasticsearch.DomainClusterConfigArgs(
 *         instance_count=2,
 *         zone_awareness_enabled=True,
 *         instance_type="t2.small.elasticsearch",
 *     ),
 *     ebs_options=aws.elasticsearch.DomainEbsOptionsArgs(
 *         ebs_enabled=True,
 *         volume_size=10,
 *     ),
 *     vpc_options=aws.elasticsearch.DomainVpcOptionsArgs(
 *         security_group_ids=[aws_security_group["first"]["id"]],
 *         subnet_ids=[
 *             aws_subnet["first"]["id"],
 *             aws_subnet["second"]["id"],
 *         ],
 *     ))
 * firehose_elasticsearch = aws.iam.RolePolicy("firehose-elasticsearch",
 *     role=aws_iam_role["firehose"]["id"],
 *     policy=pulumi.Output.all(test_cluster.arn, test_cluster.arn).apply(lambda testClusterArn, testClusterArn1: f"""{{
 *   "Version": "2012-10-17",
 *   "Statement": [
 *     {{
 *       "Effect": "Allow",
 *       "Action": [
 *         "es:*"
 *       ],
 *       "Resource": [
 *         "{test_cluster_arn}",
 *         "{test_cluster_arn1}/*"
 *       ]
 *         }},
 *         {{
 *           "Effect": "Allow",
 *           "Action": [
 *             "ec2:DescribeVpcs",
 *             "ec2:DescribeVpcAttribute",
 *             "ec2:DescribeSubnets",
 *             "ec2:DescribeSecurityGroups",
 *             "ec2:DescribeNetworkInterfaces",
 *             "ec2:CreateNetworkInterface",
 *             "ec2:CreateNetworkInterfacePermission",
 *             "ec2:DeleteNetworkInterface"
 *           ],
 *           "Resource": [
 *             "*"
 *           ]
 *         }}
 *   ]
 * }}
 * """))
 * test = aws.kinesis.FirehoseDeliveryStream("test",
 *     destination="elasticsearch",
 *     s3_configuration=aws.kinesis.FirehoseDeliveryStreamS3ConfigurationArgs(
 *         role_arn=aws_iam_role["firehose"]["arn"],
 *         bucket_arn=aws_s3_bucket["bucket"]["arn"],
 *     ),
 *     elasticsearch_configuration=aws.kinesis.FirehoseDeliveryStreamElasticsearchConfigurationArgs(
 *         domain_arn=test_cluster.arn,
 *         role_arn=aws_iam_role["firehose"]["arn"],
 *         index_name="test",
 *         type_name="test",
 *         vpc_config=aws.kinesis.FirehoseDeliveryStreamElasticsearchConfigurationVpcConfigArgs(
 *             subnet_ids=[
 *                 aws_subnet["first"]["id"],
 *                 aws_subnet["second"]["id"],
 *             ],
 *             security_group_ids=[aws_security_group["first"]["id"]],
 *             role_arn=aws_iam_role["firehose"]["arn"],
 *         ),
 *     ),
 *     opts=pulumi.ResourceOptions(depends_on=[firehose_elasticsearch]))
 * ```
 * ```csharp
 * using Pulumi;
 * using Aws = Pulumi.Aws;
 * 
 * class MyStack : Stack
 * {
 *     public MyStack()
 *     {
 *         var testCluster = new Aws.ElasticSearch.Domain("testCluster", new Aws.ElasticSearch.DomainArgs
 *         {
 *             ClusterConfig = new Aws.ElasticSearch.Inputs.DomainClusterConfigArgs
 *             {
 *                 InstanceCount = 2,
 *                 ZoneAwarenessEnabled = true,
 *                 InstanceType = "t2.small.elasticsearch",
 *             },
 *             EbsOptions = new Aws.ElasticSearch.Inputs.DomainEbsOptionsArgs
 *             {
 *                 EbsEnabled = true,
 *                 VolumeSize = 10,
 *             },
 *             VpcOptions = new Aws.ElasticSearch.Inputs.DomainVpcOptionsArgs
 *             {
 *                 SecurityGroupIds = 
 *                 {
 *                     aws_security_group.First.Id,
 *                 },
 *                 SubnetIds = 
 *                 {
 *                     aws_subnet.First.Id,
 *                     aws_subnet.Second.Id,
 *                 },
 *             },
 *         });
 *         var firehose_elasticsearch = new Aws.Iam.RolePolicy("firehose-elasticsearch", new Aws.Iam.RolePolicyArgs
 *         {
 *             Role = aws_iam_role.Firehose.Id,
 *             Policy = Output.Tuple(testCluster.Arn, testCluster.Arn).Apply(values =>
 *             {
 *                 var testClusterArn = values.Item1;
 *                 var testClusterArn1 = values.Item2;
 *                 return @$"{{
 *   ""Version"": ""2012-10-17"",
 *   ""Statement"": [
 *     {{
 *       ""Effect"": ""Allow"",
 *       ""Action"": [
 *         ""es:*""
 *       ],
 *       ""Resource"": [
 *         ""{testClusterArn}"",
 *         ""{testClusterArn1}/*""
 *       ]
 *         }},
 *         {{
 *           ""Effect"": ""Allow"",
 *           ""Action"": [
 *             ""ec2:DescribeVpcs"",
 *             ""ec2:DescribeVpcAttribute"",
 *             ""ec2:DescribeSubnets"",
 *             ""ec2:DescribeSecurityGroups"",
 *             ""ec2:DescribeNetworkInterfaces"",
 *             ""ec2:CreateNetworkInterface"",
 *             ""ec2:CreateNetworkInterfacePermission"",
 *             ""ec2:DeleteNetworkInterface""
 *           ],
 *           ""Resource"": [
 *             ""*""
 *           ]
 *         }}
 *   ]
 * }}
 * ";
 *             }),
 *         });
 *         var test = new Aws.Kinesis.FirehoseDeliveryStream("test", new Aws.Kinesis.FirehoseDeliveryStreamArgs
 *         {
 *             Destination = "elasticsearch",
 *             S3Configuration = new Aws.Kinesis.Inputs.FirehoseDeliveryStreamS3ConfigurationArgs
 *             {
 *                 RoleArn = aws_iam_role.Firehose.Arn,
 *                 BucketArn = aws_s3_bucket.Bucket.Arn,
 *             },
 *             ElasticsearchConfiguration = new Aws.Kinesis.Inputs.FirehoseDeliveryStreamElasticsearchConfigurationArgs
 *             {
 *                 DomainArn = testCluster.Arn,
 *                 RoleArn = aws_iam_role.Firehose.Arn,
 *                 IndexName = "test",
 *                 TypeName = "test",
 *                 VpcConfig = new Aws.Kinesis.Inputs.FirehoseDeliveryStreamElasticsearchConfigurationVpcConfigArgs
 *                 {
 *                     SubnetIds = 
 *                     {
 *                         aws_subnet.First.Id,
 *                         aws_subnet.Second.Id,
 *                     },
 *                     SecurityGroupIds = 
 *                     {
 *                         aws_security_group.First.Id,
 *                     },
 *                     RoleArn = aws_iam_role.Firehose.Arn,
 *                 },
 *             },
 *         }, new CustomResourceOptions
 *         {
 *             DependsOn = 
 *             {
 *                 firehose_elasticsearch,
 *             },
 *         });
 *     }
 * 
 * }
 * ```
 * ```go
 * package main
 * 
 * import (
 * 	"fmt"
 * 
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/elasticsearch"
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/iam"
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/kinesis"
 * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
 * )
 * 
 * func main() {
 * 	pulumi.Run(func(ctx *pulumi.Context) error {
 * 		testCluster, err := elasticsearch.NewDomain(ctx, "testCluster", &elasticsearch.DomainArgs{
 * 			ClusterConfig: &elasticsearch.DomainClusterConfigArgs{
 * 				InstanceCount:        pulumi.Int(2),
 * 				ZoneAwarenessEnabled: pulumi.Bool(true),
 * 				InstanceType:         pulumi.String("t2.small.elasticsearch"),
 * 			},
 * 			EbsOptions: &elasticsearch.DomainEbsOptionsArgs{
 * 				EbsEnabled: pulumi.Bool(true),
 * 				VolumeSize: pulumi.Int(10),
 * 			},
 * 			VpcOptions: &elasticsearch.DomainVpcOptionsArgs{
 * 				SecurityGroupIds: pulumi.StringArray{
 * 					pulumi.Any(aws_security_group.First.Id),
 * 				},
 * 				SubnetIds: pulumi.StringArray{
 * 					pulumi.Any(aws_subnet.First.Id),
 * 					pulumi.Any(aws_subnet.Second.Id),
 * 				},
 * 			},
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		_, err = iam.NewRolePolicy(ctx, "firehose-elasticsearch", &iam.RolePolicyArgs{
 * 			Role: pulumi.Any(aws_iam_role.Firehose.Id),
 * 			Policy: pulumi.All(testCluster.Arn, testCluster.Arn).ApplyT(func(_args []interface{}) (string, error) {
 * 				testClusterArn := _args[0].(string)
 * 				testClusterArn1 := _args[1].(string)
 * 				return fmt.Sprintf("%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v", "{\n", "  \"Version\": \"2012-10-17\",\n", "  \"Statement\": [\n", "    {\n", "      \"Effect\": \"Allow\",\n", "      \"Action\": [\n", "        \"es:*\"\n", "      ],\n", "      \"Resource\": [\n", "        \"", testClusterArn, "\",\n", "        \"", testClusterArn1, "/*\"\n", "      ]\n", "        },\n", "        {\n", "          \"Effect\": \"Allow\",\n", "          \"Action\": [\n", "            \"ec2:DescribeVpcs\",\n", "            \"ec2:DescribeVpcAttribute\",\n", "            \"ec2:DescribeSubnets\",\n", "            \"ec2:DescribeSecurityGroups\",\n", "            \"ec2:DescribeNetworkInterfaces\",\n", "            \"ec2:CreateNetworkInterface\",\n", "            \"ec2:CreateNetworkInterfacePermission\",\n", "            \"ec2:DeleteNetworkInterface\"\n", "          ],\n", "          \"Resource\": [\n", "            \"*\"\n", "          ]\n", "        }\n", "  ]\n", "}\n"), nil
 * 			}).(pulumi.StringOutput),
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		_, err = kinesis.NewFirehoseDeliveryStream(ctx, "test", &kinesis.FirehoseDeliveryStreamArgs{
 * 			Destination: pulumi.String("elasticsearch"),
 * 			S3Configuration: &kinesis.FirehoseDeliveryStreamS3ConfigurationArgs{
 * 				RoleArn:   pulumi.Any(aws_iam_role.Firehose.Arn),
 * 				BucketArn: pulumi.Any(aws_s3_bucket.Bucket.Arn),
 * 			},
 * 			ElasticsearchConfiguration: &kinesis.FirehoseDeliveryStreamElasticsearchConfigurationArgs{
 * 				DomainArn: testCluster.Arn,
 * 				RoleArn:   pulumi.Any(aws_iam_role.Firehose.Arn),
 * 				IndexName: pulumi.String("test"),
 * 				TypeName:  pulumi.String("test"),
 * 				VpcConfig: &kinesis.FirehoseDeliveryStreamElasticsearchConfigurationVpcConfigArgs{
 * 					SubnetIds: pulumi.StringArray{
 * 						pulumi.Any(aws_subnet.First.Id),
 * 						pulumi.Any(aws_subnet.Second.Id),
 * 					},
 * 					SecurityGroupIds: pulumi.StringArray{
 * 						pulumi.Any(aws_security_group.First.Id),
 * 					},
 * 					RoleArn: pulumi.Any(aws_iam_role.Firehose.Arn),
 * 				},
 * 			},
 * 		}, pulumi.DependsOn([]pulumi.Resource{
 * 			firehose_elasticsearch,
 * 		}))
 * 		if err != nil {
 * 			return err
 * 		}
 * 		return nil
 * 	})
 * }
 * ```
 * {{% /example %}}
 * {{% example %}}
 * ### Splunk Destination
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 * 
 * const testStream = new aws.kinesis.FirehoseDeliveryStream("testStream", {
 *     destination: "splunk",
 *     s3Configuration: {
 *         roleArn: aws_iam_role.firehose.arn,
 *         bucketArn: aws_s3_bucket.bucket.arn,
 *         bufferSize: 10,
 *         bufferInterval: 400,
 *         compressionFormat: "GZIP",
 *     },
 *     splunkConfiguration: {
 *         hecEndpoint: "https://http-inputs-mydomain.splunkcloud.com:443",
 *         hecToken: "51D4DA16-C61B-4F5F-8EC7-ED4301342A4A",
 *         hecAcknowledgmentTimeout: 600,
 *         hecEndpointType: "Event",
 *         s3BackupMode: "FailedEventsOnly",
 *     },
 * });
 * ```
 * ```python
 * import pulumi
 * import pulumi_aws as aws
 * 
 * test_stream = aws.kinesis.FirehoseDeliveryStream("testStream",
 *     destination="splunk",
 *     s3_configuration=aws.kinesis.FirehoseDeliveryStreamS3ConfigurationArgs(
 *         role_arn=aws_iam_role["firehose"]["arn"],
 *         bucket_arn=aws_s3_bucket["bucket"]["arn"],
 *         buffer_size=10,
 *         buffer_interval=400,
 *         compression_format="GZIP",
 *     ),
 *     splunk_configuration=aws.kinesis.FirehoseDeliveryStreamSplunkConfigurationArgs(
 *         hec_endpoint="https://http-inputs-mydomain.splunkcloud.com:443",
 *         hec_token="51D4DA16-C61B-4F5F-8EC7-ED4301342A4A",
 *         hec_acknowledgment_timeout=600,
 *         hec_endpoint_type="Event",
 *         s3_backup_mode="FailedEventsOnly",
 *     ))
 * ```
 * ```csharp
 * using Pulumi;
 * using Aws = Pulumi.Aws;
 * 
 * class MyStack : Stack
 * {
 *     public MyStack()
 *     {
 *         var testStream = new Aws.Kinesis.FirehoseDeliveryStream("testStream", new Aws.Kinesis.FirehoseDeliveryStreamArgs
 *         {
 *             Destination = "splunk",
 *             S3Configuration = new Aws.Kinesis.Inputs.FirehoseDeliveryStreamS3ConfigurationArgs
 *             {
 *                 RoleArn = aws_iam_role.Firehose.Arn,
 *                 BucketArn = aws_s3_bucket.Bucket.Arn,
 *                 BufferSize = 10,
 *                 BufferInterval = 400,
 *                 CompressionFormat = "GZIP",
 *             },
 *             SplunkConfiguration = new Aws.Kinesis.Inputs.FirehoseDeliveryStreamSplunkConfigurationArgs
 *             {
 *                 HecEndpoint = "https://http-inputs-mydomain.splunkcloud.com:443",
 *                 HecToken = "51D4DA16-C61B-4F5F-8EC7-ED4301342A4A",
 *                 HecAcknowledgmentTimeout = 600,
 *                 HecEndpointType = "Event",
 *                 S3BackupMode = "FailedEventsOnly",
 *             },
 *         });
 *     }
 * 
 * }
 * ```
 * ```go
 * package main
 * 
 * import (
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/kinesis"
 * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
 * )
 * 
 * func main() {
 * 	pulumi.Run(func(ctx *pulumi.Context) error {
 * 		_, err := kinesis.NewFirehoseDeliveryStream(ctx, "testStream", &kinesis.FirehoseDeliveryStreamArgs{
 * 			Destination: pulumi.String("splunk"),
 * 			S3Configuration: &kinesis.FirehoseDeliveryStreamS3ConfigurationArgs{
 * 				RoleArn:           pulumi.Any(aws_iam_role.Firehose.Arn),
 * 				BucketArn:         pulumi.Any(aws_s3_bucket.Bucket.Arn),
 * 				BufferSize:        pulumi.Int(10),
 * 				BufferInterval:    pulumi.Int(400),
 * 				CompressionFormat: pulumi.String("GZIP"),
 * 			},
 * 			SplunkConfiguration: &kinesis.FirehoseDeliveryStreamSplunkConfigurationArgs{
 * 				HecEndpoint:              pulumi.String("https://http-inputs-mydomain.splunkcloud.com:443"),
 * 				HecToken:                 pulumi.String("51D4DA16-C61B-4F5F-8EC7-ED4301342A4A"),
 * 				HecAcknowledgmentTimeout: pulumi.Int(600),
 * 				HecEndpointType:          pulumi.String("Event"),
 * 				S3BackupMode:             pulumi.String("FailedEventsOnly"),
 * 			},
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		return nil
 * 	})
 * }
 * ```
 * {{% /example %}}
 * {{% example %}}
 * ### HTTP Endpoint (e.g., New Relic) Destination
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 * 
 * const testStream = new aws.kinesis.FirehoseDeliveryStream("testStream", {
 *     destination: "http_endpoint",
 *     s3Configuration: {
 *         roleArn: aws_iam_role.firehose.arn,
 *         bucketArn: aws_s3_bucket.bucket.arn,
 *         bufferSize: 10,
 *         bufferInterval: 400,
 *         compressionFormat: "GZIP",
 *     },
 *     httpEndpointConfiguration: {
 *         url: "https://aws-api.newrelic.com/firehose/v1",
 *         name: "New Relic",
 *         accessKey: "my-key",
 *         bufferingSize: 15,
 *         bufferingInterval: 600,
 *         roleArn: aws_iam_role.firehose.arn,
 *         s3BackupMode: "FailedDataOnly",
 *         requestConfiguration: {
 *             contentEncoding: "GZIP",
 *             commonAttributes: [
 *                 {
 *                     name: "testname",
 *                     value: "testvalue",
 *                 },
 *                 {
 *                     name: "testname2",
 *                     value: "testvalue2",
 *                 },
 *             ],
 *         },
 *     },
 * });
 * ```
 * ```python
 * import pulumi
 * import pulumi_aws as aws
 * 
 * test_stream = aws.kinesis.FirehoseDeliveryStream("testStream",
 *     destination="http_endpoint",
 *     s3_configuration=aws.kinesis.FirehoseDeliveryStreamS3ConfigurationArgs(
 *         role_arn=aws_iam_role["firehose"]["arn"],
 *         bucket_arn=aws_s3_bucket["bucket"]["arn"],
 *         buffer_size=10,
 *         buffer_interval=400,
 *         compression_format="GZIP",
 *     ),
 *     http_endpoint_configuration=aws.kinesis.FirehoseDeliveryStreamHttpEndpointConfigurationArgs(
 *         url="https://aws-api.newrelic.com/firehose/v1",
 *         name="New Relic",
 *         access_key="my-key",
 *         buffering_size=15,
 *         buffering_interval=600,
 *         role_arn=aws_iam_role["firehose"]["arn"],
 *         s3_backup_mode="FailedDataOnly",
 *         request_configuration=aws.kinesis.FirehoseDeliveryStreamHttpEndpointConfigurationRequestConfigurationArgs(
 *             content_encoding="GZIP",
 *             common_attributes=[
 *                 aws.kinesis.FirehoseDeliveryStreamHttpEndpointConfigurationRequestConfigurationCommonAttributeArgs(
 *                     name="testname",
 *                     value="testvalue",
 *                 ),
 *                 aws.kinesis.FirehoseDeliveryStreamHttpEndpointConfigurationRequestConfigurationCommonAttributeArgs(
 *                     name="testname2",
 *                     value="testvalue2",
 *                 ),
 *             ],
 *         ),
 *     ))
 * ```
 * ```csharp
 * using Pulumi;
 * using Aws = Pulumi.Aws;
 * 
 * class MyStack : Stack
 * {
 *     public MyStack()
 *     {
 *         var testStream = new Aws.Kinesis.FirehoseDeliveryStream("testStream", new Aws.Kinesis.FirehoseDeliveryStreamArgs
 *         {
 *             Destination = "http_endpoint",
 *             S3Configuration = new Aws.Kinesis.Inputs.FirehoseDeliveryStreamS3ConfigurationArgs
 *             {
 *                 RoleArn = aws_iam_role.Firehose.Arn,
 *                 BucketArn = aws_s3_bucket.Bucket.Arn,
 *                 BufferSize = 10,
 *                 BufferInterval = 400,
 *                 CompressionFormat = "GZIP",
 *             },
 *             HttpEndpointConfiguration = new Aws.Kinesis.Inputs.FirehoseDeliveryStreamHttpEndpointConfigurationArgs
 *             {
 *                 Url = "https://aws-api.newrelic.com/firehose/v1",
 *                 Name = "New Relic",
 *                 AccessKey = "my-key",
 *                 BufferingSize = 15,
 *                 BufferingInterval = 600,
 *                 RoleArn = aws_iam_role.Firehose.Arn,
 *                 S3BackupMode = "FailedDataOnly",
 *                 RequestConfiguration = new Aws.Kinesis.Inputs.FirehoseDeliveryStreamHttpEndpointConfigurationRequestConfigurationArgs
 *                 {
 *                     ContentEncoding = "GZIP",
 *                     CommonAttributes = 
 *                     {
 *                         new Aws.Kinesis.Inputs.FirehoseDeliveryStreamHttpEndpointConfigurationRequestConfigurationCommonAttributeArgs
 *                         {
 *                             Name = "testname",
 *                             Value = "testvalue",
 *                         },
 *                         new Aws.Kinesis.Inputs.FirehoseDeliveryStreamHttpEndpointConfigurationRequestConfigurationCommonAttributeArgs
 *                         {
 *                             Name = "testname2",
 *                             Value = "testvalue2",
 *                         },
 *                     },
 *                 },
 *             },
 *         });
 *     }
 * 
 * }
 * ```
 * ```go
 * package main
 * 
 * import (
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/kinesis"
 * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
 * )
 * 
 * func main() {
 * 	pulumi.Run(func(ctx *pulumi.Context) error {
 * 		_, err := kinesis.NewFirehoseDeliveryStream(ctx, "testStream", &kinesis.FirehoseDeliveryStreamArgs{
 * 			Destination: pulumi.String("http_endpoint"),
 * 			S3Configuration: &kinesis.FirehoseDeliveryStreamS3ConfigurationArgs{
 * 				RoleArn:           pulumi.Any(aws_iam_role.Firehose.Arn),
 * 				BucketArn:         pulumi.Any(aws_s3_bucket.Bucket.Arn),
 * 				BufferSize:        pulumi.Int(10),
 * 				BufferInterval:    pulumi.Int(400),
 * 				CompressionFormat: pulumi.String("GZIP"),
 * 			},
 * 			HttpEndpointConfiguration: &kinesis.FirehoseDeliveryStreamHttpEndpointConfigurationArgs{
 * 				Url:               pulumi.String("https://aws-api.newrelic.com/firehose/v1"),
 * 				Name:              pulumi.String("New Relic"),
 * 				AccessKey:         pulumi.String("my-key"),
 * 				BufferingSize:     pulumi.Int(15),
 * 				BufferingInterval: pulumi.Int(600),
 * 				RoleArn:           pulumi.Any(aws_iam_role.Firehose.Arn),
 * 				S3BackupMode:      pulumi.String("FailedDataOnly"),
 * 				RequestConfiguration: &kinesis.FirehoseDeliveryStreamHttpEndpointConfigurationRequestConfigurationArgs{
 * 					ContentEncoding: pulumi.String("GZIP"),
 * 					CommonAttributes: kinesis.FirehoseDeliveryStreamHttpEndpointConfigurationRequestConfigurationCommonAttributeArray{
 * 						&kinesis.FirehoseDeliveryStreamHttpEndpointConfigurationRequestConfigurationCommonAttributeArgs{
 * 							Name:  pulumi.String("testname"),
 * 							Value: pulumi.String("testvalue"),
 * 						},
 * 						&kinesis.FirehoseDeliveryStreamHttpEndpointConfigurationRequestConfigurationCommonAttributeArgs{
 * 							Name:  pulumi.String("testname2"),
 * 							Value: pulumi.String("testvalue2"),
 * 						},
 * 					},
 * 				},
 * 			},
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		return nil
 * 	})
 * }
 * ```
 * {{% /example %}}
 * {{% /examples %}}
 * 
 * ## Import
 * 
 * Kinesis Firehose Delivery streams can be imported using the stream ARN, e.g.,
 * 
 * ```sh
 *  $ pulumi import aws:kinesis/firehoseDeliveryStream:FirehoseDeliveryStream foo arn:aws:firehose:us-east-1:XXX:deliverystream/example
 * ```
 * 
 *  NoteImport does not work for stream destination `s3`. Consider using `extended_s3` since `s3` destination is deprecated. 
 */
@ResourceType(type="aws:kinesis/firehoseDeliveryStream:FirehoseDeliveryStream")
public class FirehoseDeliveryStream extends io.pulumi.resources.CustomResource {
    /**
     * The Amazon Resource Name (ARN) specifying the Stream
     * 
     */
    @Export(name="arn", type=String.class, parameters={})
    private Output<String> arn;

    /**
     * @return The Amazon Resource Name (ARN) specifying the Stream
     * 
     */
    public Output<String> getArn() {
        return this.arn;
    }
    /**
     * This is the destination to where the data is delivered. The only options are `s3` (Deprecated, use `extended_s3` instead), `extended_s3`, `redshift`, `elasticsearch`, `splunk`, and `http_endpoint`.
     * 
     */
    @Export(name="destination", type=String.class, parameters={})
    private Output<String> destination;

    /**
     * @return This is the destination to where the data is delivered. The only options are `s3` (Deprecated, use `extended_s3` instead), `extended_s3`, `redshift`, `elasticsearch`, `splunk`, and `http_endpoint`.
     * 
     */
    public Output<String> getDestination() {
        return this.destination;
    }
    @Export(name="destinationId", type=String.class, parameters={})
    private Output<String> destinationId;

    public Output<String> getDestinationId() {
        return this.destinationId;
    }
    /**
     * Configuration options if elasticsearch is the destination. More details are given below.
     * 
     */
    @Export(name="elasticsearchConfiguration", type=FirehoseDeliveryStreamElasticsearchConfiguration.class, parameters={})
    private Output</* @Nullable */ FirehoseDeliveryStreamElasticsearchConfiguration> elasticsearchConfiguration;

    /**
     * @return Configuration options if elasticsearch is the destination. More details are given below.
     * 
     */
    public Output</* @Nullable */ FirehoseDeliveryStreamElasticsearchConfiguration> getElasticsearchConfiguration() {
        return this.elasticsearchConfiguration;
    }
    /**
     * Enhanced configuration options for the s3 destination. More details are given below.
     * 
     */
    @Export(name="extendedS3Configuration", type=FirehoseDeliveryStreamExtendedS3Configuration.class, parameters={})
    private Output</* @Nullable */ FirehoseDeliveryStreamExtendedS3Configuration> extendedS3Configuration;

    /**
     * @return Enhanced configuration options for the s3 destination. More details are given below.
     * 
     */
    public Output</* @Nullable */ FirehoseDeliveryStreamExtendedS3Configuration> getExtendedS3Configuration() {
        return this.extendedS3Configuration;
    }
    /**
     * Configuration options if http_endpoint is the destination. requires the user to also specify a `s3_configuration` block.  More details are given below.
     * 
     */
    @Export(name="httpEndpointConfiguration", type=FirehoseDeliveryStreamHttpEndpointConfiguration.class, parameters={})
    private Output</* @Nullable */ FirehoseDeliveryStreamHttpEndpointConfiguration> httpEndpointConfiguration;

    /**
     * @return Configuration options if http_endpoint is the destination. requires the user to also specify a `s3_configuration` block.  More details are given below.
     * 
     */
    public Output</* @Nullable */ FirehoseDeliveryStreamHttpEndpointConfiguration> getHttpEndpointConfiguration() {
        return this.httpEndpointConfiguration;
    }
    /**
     * Allows the ability to specify the kinesis stream that is used as the source of the firehose delivery stream.
     * 
     */
    @Export(name="kinesisSourceConfiguration", type=FirehoseDeliveryStreamKinesisSourceConfiguration.class, parameters={})
    private Output</* @Nullable */ FirehoseDeliveryStreamKinesisSourceConfiguration> kinesisSourceConfiguration;

    /**
     * @return Allows the ability to specify the kinesis stream that is used as the source of the firehose delivery stream.
     * 
     */
    public Output</* @Nullable */ FirehoseDeliveryStreamKinesisSourceConfiguration> getKinesisSourceConfiguration() {
        return this.kinesisSourceConfiguration;
    }
    /**
     * A name to identify the stream. This is unique to the
     * AWS account and region the Stream is created in.
     * 
     */
    @Export(name="name", type=String.class, parameters={})
    private Output<String> name;

    /**
     * @return A name to identify the stream. This is unique to the
     * AWS account and region the Stream is created in.
     * 
     */
    public Output<String> getName() {
        return this.name;
    }
    /**
     * Configuration options if redshift is the destination.
     * Using `redshift_configuration` requires the user to also specify a
     * `s3_configuration` block. More details are given below.
     * 
     */
    @Export(name="redshiftConfiguration", type=FirehoseDeliveryStreamRedshiftConfiguration.class, parameters={})
    private Output</* @Nullable */ FirehoseDeliveryStreamRedshiftConfiguration> redshiftConfiguration;

    /**
     * @return Configuration options if redshift is the destination.
     * Using `redshift_configuration` requires the user to also specify a
     * `s3_configuration` block. More details are given below.
     * 
     */
    public Output</* @Nullable */ FirehoseDeliveryStreamRedshiftConfiguration> getRedshiftConfiguration() {
        return this.redshiftConfiguration;
    }
    /**
     * Required for non-S3 destinations. For S3 destination, use `extended_s3_configuration` instead. Configuration options for the s3 destination (or the intermediate bucket if the destination
     * is redshift). More details are given below.
     * 
     */
    @Export(name="s3Configuration", type=FirehoseDeliveryStreamS3Configuration.class, parameters={})
    private Output</* @Nullable */ FirehoseDeliveryStreamS3Configuration> s3Configuration;

    /**
     * @return Required for non-S3 destinations. For S3 destination, use `extended_s3_configuration` instead. Configuration options for the s3 destination (or the intermediate bucket if the destination
     * is redshift). More details are given below.
     * 
     */
    public Output</* @Nullable */ FirehoseDeliveryStreamS3Configuration> getS3Configuration() {
        return this.s3Configuration;
    }
    /**
     * Encrypt at rest options.
     * Server-side encryption should not be enabled when a kinesis stream is configured as the source of the firehose delivery stream.
     * 
     */
    @Export(name="serverSideEncryption", type=FirehoseDeliveryStreamServerSideEncryption.class, parameters={})
    private Output</* @Nullable */ FirehoseDeliveryStreamServerSideEncryption> serverSideEncryption;

    /**
     * @return Encrypt at rest options.
     * Server-side encryption should not be enabled when a kinesis stream is configured as the source of the firehose delivery stream.
     * 
     */
    public Output</* @Nullable */ FirehoseDeliveryStreamServerSideEncryption> getServerSideEncryption() {
        return this.serverSideEncryption;
    }
    /**
     * Configuration options if splunk is the destination. More details are given below.
     * 
     */
    @Export(name="splunkConfiguration", type=FirehoseDeliveryStreamSplunkConfiguration.class, parameters={})
    private Output</* @Nullable */ FirehoseDeliveryStreamSplunkConfiguration> splunkConfiguration;

    /**
     * @return Configuration options if splunk is the destination. More details are given below.
     * 
     */
    public Output</* @Nullable */ FirehoseDeliveryStreamSplunkConfiguration> getSplunkConfiguration() {
        return this.splunkConfiguration;
    }
    /**
     * A map of tags to assign to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
     * 
     */
    @Export(name="tags", type=Map.class, parameters={String.class, String.class})
    private Output</* @Nullable */ Map<String,String>> tags;

    /**
     * @return A map of tags to assign to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
     * 
     */
    public Output</* @Nullable */ Map<String,String>> getTags() {
        return this.tags;
    }
    /**
     * A map of tags assigned to the resource, including those inherited from the provider `default_tags` configuration block.
     * 
     */
    @Export(name="tagsAll", type=Map.class, parameters={String.class, String.class})
    private Output<Map<String,String>> tagsAll;

    /**
     * @return A map of tags assigned to the resource, including those inherited from the provider `default_tags` configuration block.
     * 
     */
    public Output<Map<String,String>> getTagsAll() {
        return this.tagsAll;
    }
    /**
     * Specifies the table version for the output data schema. Defaults to `LATEST`.
     * 
     */
    @Export(name="versionId", type=String.class, parameters={})
    private Output<String> versionId;

    /**
     * @return Specifies the table version for the output data schema. Defaults to `LATEST`.
     * 
     */
    public Output<String> getVersionId() {
        return this.versionId;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public FirehoseDeliveryStream(String name) {
        this(name, FirehoseDeliveryStreamArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public FirehoseDeliveryStream(String name, FirehoseDeliveryStreamArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public FirehoseDeliveryStream(String name, FirehoseDeliveryStreamArgs args, @Nullable io.pulumi.resources.CustomResourceOptions options) {
        super("aws:kinesis/firehoseDeliveryStream:FirehoseDeliveryStream", name, args == null ? FirehoseDeliveryStreamArgs.Empty : args, makeResourceOptions(options, Output.empty()));
    }

    private FirehoseDeliveryStream(String name, Output<String> id, @Nullable FirehoseDeliveryStreamState state, @Nullable io.pulumi.resources.CustomResourceOptions options) {
        super("aws:kinesis/firehoseDeliveryStream:FirehoseDeliveryStream", name, state, makeResourceOptions(options, id));
    }

    private static io.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable io.pulumi.resources.CustomResourceOptions options, @Nullable Output<String> id) {
        var defaultOptions = io.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return io.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static FirehoseDeliveryStream get(String name, Output<String> id, @Nullable FirehoseDeliveryStreamState state, @Nullable io.pulumi.resources.CustomResourceOptions options) {
        return new FirehoseDeliveryStream(name, id, state, options);
    }
}
