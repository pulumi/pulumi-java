// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package io.pulumi.aws.redshift;

import io.pulumi.aws.redshift.inputs.ClusterLoggingArgs;
import io.pulumi.aws.redshift.inputs.ClusterSnapshotCopyArgs;
import io.pulumi.core.Input;
import io.pulumi.core.internal.annotations.InputImport;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import javax.annotation.Nullable;


public final class ClusterArgs extends io.pulumi.resources.ResourceArgs {

    public static final ClusterArgs Empty = new ClusterArgs();

    /**
     * If true , major version upgrades can be applied during the maintenance window to the Amazon Redshift engine that is running on the cluster. Default is true
     * 
     */
    @InputImport(name="allowVersionUpgrade")
    private final @Nullable Input<Boolean> allowVersionUpgrade;

    public Input<Boolean> getAllowVersionUpgrade() {
        return this.allowVersionUpgrade == null ? Input.empty() : this.allowVersionUpgrade;
    }

    /**
     * The number of days that automated snapshots are retained. If the value is 0, automated snapshots are disabled. Even if automated snapshots are disabled, you can still create manual snapshots when you want with create-cluster-snapshot. Default is 1.
     * 
     */
    @InputImport(name="automatedSnapshotRetentionPeriod")
    private final @Nullable Input<Integer> automatedSnapshotRetentionPeriod;

    public Input<Integer> getAutomatedSnapshotRetentionPeriod() {
        return this.automatedSnapshotRetentionPeriod == null ? Input.empty() : this.automatedSnapshotRetentionPeriod;
    }

    /**
     * The EC2 Availability Zone (AZ) in which you want Amazon Redshift to provision the cluster. For example, if you have several EC2 instances running in a specific Availability Zone, then you might want the cluster to be provisioned in the same zone in order to decrease network latency.
     * 
     */
    @InputImport(name="availabilityZone")
    private final @Nullable Input<String> availabilityZone;

    public Input<String> getAvailabilityZone() {
        return this.availabilityZone == null ? Input.empty() : this.availabilityZone;
    }

    /**
     * The Cluster Identifier. Must be a lower case
     * string.
     * 
     */
    @InputImport(name="clusterIdentifier", required=true)
    private final Input<String> clusterIdentifier;

    public Input<String> getClusterIdentifier() {
        return this.clusterIdentifier;
    }

    /**
     * The name of the parameter group to be associated with this cluster.
     * 
     */
    @InputImport(name="clusterParameterGroupName")
    private final @Nullable Input<String> clusterParameterGroupName;

    public Input<String> getClusterParameterGroupName() {
        return this.clusterParameterGroupName == null ? Input.empty() : this.clusterParameterGroupName;
    }

    /**
     * The public key for the cluster
     * 
     */
    @InputImport(name="clusterPublicKey")
    private final @Nullable Input<String> clusterPublicKey;

    public Input<String> getClusterPublicKey() {
        return this.clusterPublicKey == null ? Input.empty() : this.clusterPublicKey;
    }

    /**
     * The specific revision number of the database in the cluster
     * 
     */
    @InputImport(name="clusterRevisionNumber")
    private final @Nullable Input<String> clusterRevisionNumber;

    public Input<String> getClusterRevisionNumber() {
        return this.clusterRevisionNumber == null ? Input.empty() : this.clusterRevisionNumber;
    }

    /**
     * A list of security groups to be associated with this cluster.
     * 
     */
    @InputImport(name="clusterSecurityGroups")
    private final @Nullable Input<List<String>> clusterSecurityGroups;

    public Input<List<String>> getClusterSecurityGroups() {
        return this.clusterSecurityGroups == null ? Input.empty() : this.clusterSecurityGroups;
    }

    /**
     * The name of a cluster subnet group to be associated with this cluster. If this parameter is not provided the resulting cluster will be deployed outside virtual private cloud (VPC).
     * 
     */
    @InputImport(name="clusterSubnetGroupName")
    private final @Nullable Input<String> clusterSubnetGroupName;

    public Input<String> getClusterSubnetGroupName() {
        return this.clusterSubnetGroupName == null ? Input.empty() : this.clusterSubnetGroupName;
    }

    /**
     * The cluster type to use. Either `single-node` or `multi-node`.
     * 
     */
    @InputImport(name="clusterType")
    private final @Nullable Input<String> clusterType;

    public Input<String> getClusterType() {
        return this.clusterType == null ? Input.empty() : this.clusterType;
    }

    /**
     * The version of the Amazon Redshift engine software that you want to deploy on the cluster.
     * The version selected runs on all the nodes in the cluster.
     * 
     */
    @InputImport(name="clusterVersion")
    private final @Nullable Input<String> clusterVersion;

    public Input<String> getClusterVersion() {
        return this.clusterVersion == null ? Input.empty() : this.clusterVersion;
    }

    /**
     * The name of the first database to be created when the cluster is created.
     * If you do not provide a name, Amazon Redshift will create a default database called `dev`.
     * 
     */
    @InputImport(name="databaseName")
    private final @Nullable Input<String> databaseName;

    public Input<String> getDatabaseName() {
        return this.databaseName == null ? Input.empty() : this.databaseName;
    }

    /**
     * The Elastic IP (EIP) address for the cluster.
     * 
     */
    @InputImport(name="elasticIp")
    private final @Nullable Input<String> elasticIp;

    public Input<String> getElasticIp() {
        return this.elasticIp == null ? Input.empty() : this.elasticIp;
    }

    /**
     * If true , the data in the cluster is encrypted at rest.
     * 
     */
    @InputImport(name="encrypted")
    private final @Nullable Input<Boolean> encrypted;

    public Input<Boolean> getEncrypted() {
        return this.encrypted == null ? Input.empty() : this.encrypted;
    }

    /**
     * The connection endpoint
     * 
     */
    @InputImport(name="endpoint")
    private final @Nullable Input<String> endpoint;

    public Input<String> getEndpoint() {
        return this.endpoint == null ? Input.empty() : this.endpoint;
    }

    /**
     * If true , enhanced VPC routing is enabled.
     * 
     */
    @InputImport(name="enhancedVpcRouting")
    private final @Nullable Input<Boolean> enhancedVpcRouting;

    public Input<Boolean> getEnhancedVpcRouting() {
        return this.enhancedVpcRouting == null ? Input.empty() : this.enhancedVpcRouting;
    }

    /**
     * The identifier of the final snapshot that is to be created immediately before deleting the cluster. If this parameter is provided, `skip_final_snapshot` must be false.
     * 
     */
    @InputImport(name="finalSnapshotIdentifier")
    private final @Nullable Input<String> finalSnapshotIdentifier;

    public Input<String> getFinalSnapshotIdentifier() {
        return this.finalSnapshotIdentifier == null ? Input.empty() : this.finalSnapshotIdentifier;
    }

    /**
     * A list of IAM Role ARNs to associate with the cluster. A Maximum of 10 can be associated to the cluster at any time.
     * 
     */
    @InputImport(name="iamRoles")
    private final @Nullable Input<List<String>> iamRoles;

    public Input<List<String>> getIamRoles() {
        return this.iamRoles == null ? Input.empty() : this.iamRoles;
    }

    /**
     * The ARN for the KMS encryption key. When specifying `kms_key_id`, `encrypted` needs to be set to true.
     * 
     */
    @InputImport(name="kmsKeyId")
    private final @Nullable Input<String> kmsKeyId;

    public Input<String> getKmsKeyId() {
        return this.kmsKeyId == null ? Input.empty() : this.kmsKeyId;
    }

    /**
     * Logging, documented below.
     * 
     */
    @InputImport(name="logging")
    private final @Nullable Input<ClusterLoggingArgs> logging;

    public Input<ClusterLoggingArgs> getLogging() {
        return this.logging == null ? Input.empty() : this.logging;
    }

    /**
     * Password for the master DB user.
     * Note that this may show up in logs, and it will be stored in the state file. Password must contain at least 8 chars and
     * contain at least one uppercase letter, one lowercase letter, and one number.
     * 
     */
    @InputImport(name="masterPassword")
    private final @Nullable Input<String> masterPassword;

    public Input<String> getMasterPassword() {
        return this.masterPassword == null ? Input.empty() : this.masterPassword;
    }

    /**
     * Username for the master DB user.
     * 
     */
    @InputImport(name="masterUsername")
    private final @Nullable Input<String> masterUsername;

    public Input<String> getMasterUsername() {
        return this.masterUsername == null ? Input.empty() : this.masterUsername;
    }

    /**
     * The node type to be provisioned for the cluster.
     * 
     */
    @InputImport(name="nodeType", required=true)
    private final Input<String> nodeType;

    public Input<String> getNodeType() {
        return this.nodeType;
    }

    /**
     * The number of compute nodes in the cluster. This parameter is required when the ClusterType parameter is specified as multi-node. Default is 1.
     * 
     */
    @InputImport(name="numberOfNodes")
    private final @Nullable Input<Integer> numberOfNodes;

    public Input<Integer> getNumberOfNodes() {
        return this.numberOfNodes == null ? Input.empty() : this.numberOfNodes;
    }

    /**
     * The AWS customer account used to create or copy the snapshot. Required if you are restoring a snapshot you do not own, optional if you own the snapshot.
     * 
     */
    @InputImport(name="ownerAccount")
    private final @Nullable Input<String> ownerAccount;

    public Input<String> getOwnerAccount() {
        return this.ownerAccount == null ? Input.empty() : this.ownerAccount;
    }

    /**
     * The port number on which the cluster accepts incoming connections.
     * The cluster is accessible only via the JDBC and ODBC connection strings. Part of the connection string requires the port on which the cluster will listen for incoming connections. Default port is 5439.
     * 
     */
    @InputImport(name="port")
    private final @Nullable Input<Integer> port;

    public Input<Integer> getPort() {
        return this.port == null ? Input.empty() : this.port;
    }

    /**
     * The weekly time range (in UTC) during which automated cluster maintenance can occur.
     * Format: ddd:hh24:mi-ddd:hh24:mi
     * 
     */
    @InputImport(name="preferredMaintenanceWindow")
    private final @Nullable Input<String> preferredMaintenanceWindow;

    public Input<String> getPreferredMaintenanceWindow() {
        return this.preferredMaintenanceWindow == null ? Input.empty() : this.preferredMaintenanceWindow;
    }

    /**
     * If true, the cluster can be accessed from a public network. Default is `true`.
     * 
     */
    @InputImport(name="publiclyAccessible")
    private final @Nullable Input<Boolean> publiclyAccessible;

    public Input<Boolean> getPubliclyAccessible() {
        return this.publiclyAccessible == null ? Input.empty() : this.publiclyAccessible;
    }

    /**
     * Determines whether a final snapshot of the cluster is created before Amazon Redshift deletes the cluster. If true , a final cluster snapshot is not created. If false , a final cluster snapshot is created before the cluster is deleted. Default is false.
     * 
     */
    @InputImport(name="skipFinalSnapshot")
    private final @Nullable Input<Boolean> skipFinalSnapshot;

    public Input<Boolean> getSkipFinalSnapshot() {
        return this.skipFinalSnapshot == null ? Input.empty() : this.skipFinalSnapshot;
    }

    /**
     * The name of the cluster the source snapshot was created from.
     * 
     */
    @InputImport(name="snapshotClusterIdentifier")
    private final @Nullable Input<String> snapshotClusterIdentifier;

    public Input<String> getSnapshotClusterIdentifier() {
        return this.snapshotClusterIdentifier == null ? Input.empty() : this.snapshotClusterIdentifier;
    }

    /**
     * Configuration of automatic copy of snapshots from one region to another. Documented below.
     * 
     */
    @InputImport(name="snapshotCopy")
    private final @Nullable Input<ClusterSnapshotCopyArgs> snapshotCopy;

    public Input<ClusterSnapshotCopyArgs> getSnapshotCopy() {
        return this.snapshotCopy == null ? Input.empty() : this.snapshotCopy;
    }

    /**
     * The name of the snapshot from which to create the new cluster.
     * 
     */
    @InputImport(name="snapshotIdentifier")
    private final @Nullable Input<String> snapshotIdentifier;

    public Input<String> getSnapshotIdentifier() {
        return this.snapshotIdentifier == null ? Input.empty() : this.snapshotIdentifier;
    }

    /**
     * A map of tags to assign to the resource. .If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
     * 
     */
    @InputImport(name="tags")
    private final @Nullable Input<Map<String,String>> tags;

    public Input<Map<String,String>> getTags() {
        return this.tags == null ? Input.empty() : this.tags;
    }

    /**
     * A list of Virtual Private Cloud (VPC) security groups to be associated with the cluster.
     * 
     */
    @InputImport(name="vpcSecurityGroupIds")
    private final @Nullable Input<List<String>> vpcSecurityGroupIds;

    public Input<List<String>> getVpcSecurityGroupIds() {
        return this.vpcSecurityGroupIds == null ? Input.empty() : this.vpcSecurityGroupIds;
    }

    public ClusterArgs(
        @Nullable Input<Boolean> allowVersionUpgrade,
        @Nullable Input<Integer> automatedSnapshotRetentionPeriod,
        @Nullable Input<String> availabilityZone,
        Input<String> clusterIdentifier,
        @Nullable Input<String> clusterParameterGroupName,
        @Nullable Input<String> clusterPublicKey,
        @Nullable Input<String> clusterRevisionNumber,
        @Nullable Input<List<String>> clusterSecurityGroups,
        @Nullable Input<String> clusterSubnetGroupName,
        @Nullable Input<String> clusterType,
        @Nullable Input<String> clusterVersion,
        @Nullable Input<String> databaseName,
        @Nullable Input<String> elasticIp,
        @Nullable Input<Boolean> encrypted,
        @Nullable Input<String> endpoint,
        @Nullable Input<Boolean> enhancedVpcRouting,
        @Nullable Input<String> finalSnapshotIdentifier,
        @Nullable Input<List<String>> iamRoles,
        @Nullable Input<String> kmsKeyId,
        @Nullable Input<ClusterLoggingArgs> logging,
        @Nullable Input<String> masterPassword,
        @Nullable Input<String> masterUsername,
        Input<String> nodeType,
        @Nullable Input<Integer> numberOfNodes,
        @Nullable Input<String> ownerAccount,
        @Nullable Input<Integer> port,
        @Nullable Input<String> preferredMaintenanceWindow,
        @Nullable Input<Boolean> publiclyAccessible,
        @Nullable Input<Boolean> skipFinalSnapshot,
        @Nullable Input<String> snapshotClusterIdentifier,
        @Nullable Input<ClusterSnapshotCopyArgs> snapshotCopy,
        @Nullable Input<String> snapshotIdentifier,
        @Nullable Input<Map<String,String>> tags,
        @Nullable Input<List<String>> vpcSecurityGroupIds) {
        this.allowVersionUpgrade = allowVersionUpgrade;
        this.automatedSnapshotRetentionPeriod = automatedSnapshotRetentionPeriod;
        this.availabilityZone = availabilityZone;
        this.clusterIdentifier = Objects.requireNonNull(clusterIdentifier, "expected parameter 'clusterIdentifier' to be non-null");
        this.clusterParameterGroupName = clusterParameterGroupName;
        this.clusterPublicKey = clusterPublicKey;
        this.clusterRevisionNumber = clusterRevisionNumber;
        this.clusterSecurityGroups = clusterSecurityGroups;
        this.clusterSubnetGroupName = clusterSubnetGroupName;
        this.clusterType = clusterType;
        this.clusterVersion = clusterVersion;
        this.databaseName = databaseName;
        this.elasticIp = elasticIp;
        this.encrypted = encrypted;
        this.endpoint = endpoint;
        this.enhancedVpcRouting = enhancedVpcRouting;
        this.finalSnapshotIdentifier = finalSnapshotIdentifier;
        this.iamRoles = iamRoles;
        this.kmsKeyId = kmsKeyId;
        this.logging = logging;
        this.masterPassword = masterPassword;
        this.masterUsername = masterUsername;
        this.nodeType = Objects.requireNonNull(nodeType, "expected parameter 'nodeType' to be non-null");
        this.numberOfNodes = numberOfNodes;
        this.ownerAccount = ownerAccount;
        this.port = port;
        this.preferredMaintenanceWindow = preferredMaintenanceWindow;
        this.publiclyAccessible = publiclyAccessible;
        this.skipFinalSnapshot = skipFinalSnapshot;
        this.snapshotClusterIdentifier = snapshotClusterIdentifier;
        this.snapshotCopy = snapshotCopy;
        this.snapshotIdentifier = snapshotIdentifier;
        this.tags = tags;
        this.vpcSecurityGroupIds = vpcSecurityGroupIds;
    }

    private ClusterArgs() {
        this.allowVersionUpgrade = Input.empty();
        this.automatedSnapshotRetentionPeriod = Input.empty();
        this.availabilityZone = Input.empty();
        this.clusterIdentifier = Input.empty();
        this.clusterParameterGroupName = Input.empty();
        this.clusterPublicKey = Input.empty();
        this.clusterRevisionNumber = Input.empty();
        this.clusterSecurityGroups = Input.empty();
        this.clusterSubnetGroupName = Input.empty();
        this.clusterType = Input.empty();
        this.clusterVersion = Input.empty();
        this.databaseName = Input.empty();
        this.elasticIp = Input.empty();
        this.encrypted = Input.empty();
        this.endpoint = Input.empty();
        this.enhancedVpcRouting = Input.empty();
        this.finalSnapshotIdentifier = Input.empty();
        this.iamRoles = Input.empty();
        this.kmsKeyId = Input.empty();
        this.logging = Input.empty();
        this.masterPassword = Input.empty();
        this.masterUsername = Input.empty();
        this.nodeType = Input.empty();
        this.numberOfNodes = Input.empty();
        this.ownerAccount = Input.empty();
        this.port = Input.empty();
        this.preferredMaintenanceWindow = Input.empty();
        this.publiclyAccessible = Input.empty();
        this.skipFinalSnapshot = Input.empty();
        this.snapshotClusterIdentifier = Input.empty();
        this.snapshotCopy = Input.empty();
        this.snapshotIdentifier = Input.empty();
        this.tags = Input.empty();
        this.vpcSecurityGroupIds = Input.empty();
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(ClusterArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private @Nullable Input<Boolean> allowVersionUpgrade;
        private @Nullable Input<Integer> automatedSnapshotRetentionPeriod;
        private @Nullable Input<String> availabilityZone;
        private Input<String> clusterIdentifier;
        private @Nullable Input<String> clusterParameterGroupName;
        private @Nullable Input<String> clusterPublicKey;
        private @Nullable Input<String> clusterRevisionNumber;
        private @Nullable Input<List<String>> clusterSecurityGroups;
        private @Nullable Input<String> clusterSubnetGroupName;
        private @Nullable Input<String> clusterType;
        private @Nullable Input<String> clusterVersion;
        private @Nullable Input<String> databaseName;
        private @Nullable Input<String> elasticIp;
        private @Nullable Input<Boolean> encrypted;
        private @Nullable Input<String> endpoint;
        private @Nullable Input<Boolean> enhancedVpcRouting;
        private @Nullable Input<String> finalSnapshotIdentifier;
        private @Nullable Input<List<String>> iamRoles;
        private @Nullable Input<String> kmsKeyId;
        private @Nullable Input<ClusterLoggingArgs> logging;
        private @Nullable Input<String> masterPassword;
        private @Nullable Input<String> masterUsername;
        private Input<String> nodeType;
        private @Nullable Input<Integer> numberOfNodes;
        private @Nullable Input<String> ownerAccount;
        private @Nullable Input<Integer> port;
        private @Nullable Input<String> preferredMaintenanceWindow;
        private @Nullable Input<Boolean> publiclyAccessible;
        private @Nullable Input<Boolean> skipFinalSnapshot;
        private @Nullable Input<String> snapshotClusterIdentifier;
        private @Nullable Input<ClusterSnapshotCopyArgs> snapshotCopy;
        private @Nullable Input<String> snapshotIdentifier;
        private @Nullable Input<Map<String,String>> tags;
        private @Nullable Input<List<String>> vpcSecurityGroupIds;

        public Builder() {
    	      // Empty
        }

        public Builder(ClusterArgs defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.allowVersionUpgrade = defaults.allowVersionUpgrade;
    	      this.automatedSnapshotRetentionPeriod = defaults.automatedSnapshotRetentionPeriod;
    	      this.availabilityZone = defaults.availabilityZone;
    	      this.clusterIdentifier = defaults.clusterIdentifier;
    	      this.clusterParameterGroupName = defaults.clusterParameterGroupName;
    	      this.clusterPublicKey = defaults.clusterPublicKey;
    	      this.clusterRevisionNumber = defaults.clusterRevisionNumber;
    	      this.clusterSecurityGroups = defaults.clusterSecurityGroups;
    	      this.clusterSubnetGroupName = defaults.clusterSubnetGroupName;
    	      this.clusterType = defaults.clusterType;
    	      this.clusterVersion = defaults.clusterVersion;
    	      this.databaseName = defaults.databaseName;
    	      this.elasticIp = defaults.elasticIp;
    	      this.encrypted = defaults.encrypted;
    	      this.endpoint = defaults.endpoint;
    	      this.enhancedVpcRouting = defaults.enhancedVpcRouting;
    	      this.finalSnapshotIdentifier = defaults.finalSnapshotIdentifier;
    	      this.iamRoles = defaults.iamRoles;
    	      this.kmsKeyId = defaults.kmsKeyId;
    	      this.logging = defaults.logging;
    	      this.masterPassword = defaults.masterPassword;
    	      this.masterUsername = defaults.masterUsername;
    	      this.nodeType = defaults.nodeType;
    	      this.numberOfNodes = defaults.numberOfNodes;
    	      this.ownerAccount = defaults.ownerAccount;
    	      this.port = defaults.port;
    	      this.preferredMaintenanceWindow = defaults.preferredMaintenanceWindow;
    	      this.publiclyAccessible = defaults.publiclyAccessible;
    	      this.skipFinalSnapshot = defaults.skipFinalSnapshot;
    	      this.snapshotClusterIdentifier = defaults.snapshotClusterIdentifier;
    	      this.snapshotCopy = defaults.snapshotCopy;
    	      this.snapshotIdentifier = defaults.snapshotIdentifier;
    	      this.tags = defaults.tags;
    	      this.vpcSecurityGroupIds = defaults.vpcSecurityGroupIds;
        }

        public Builder setAllowVersionUpgrade(@Nullable Input<Boolean> allowVersionUpgrade) {
            this.allowVersionUpgrade = allowVersionUpgrade;
            return this;
        }

        public Builder setAllowVersionUpgrade(@Nullable Boolean allowVersionUpgrade) {
            this.allowVersionUpgrade = Input.ofNullable(allowVersionUpgrade);
            return this;
        }

        public Builder setAutomatedSnapshotRetentionPeriod(@Nullable Input<Integer> automatedSnapshotRetentionPeriod) {
            this.automatedSnapshotRetentionPeriod = automatedSnapshotRetentionPeriod;
            return this;
        }

        public Builder setAutomatedSnapshotRetentionPeriod(@Nullable Integer automatedSnapshotRetentionPeriod) {
            this.automatedSnapshotRetentionPeriod = Input.ofNullable(automatedSnapshotRetentionPeriod);
            return this;
        }

        public Builder setAvailabilityZone(@Nullable Input<String> availabilityZone) {
            this.availabilityZone = availabilityZone;
            return this;
        }

        public Builder setAvailabilityZone(@Nullable String availabilityZone) {
            this.availabilityZone = Input.ofNullable(availabilityZone);
            return this;
        }

        public Builder setClusterIdentifier(Input<String> clusterIdentifier) {
            this.clusterIdentifier = Objects.requireNonNull(clusterIdentifier);
            return this;
        }

        public Builder setClusterIdentifier(String clusterIdentifier) {
            this.clusterIdentifier = Input.of(Objects.requireNonNull(clusterIdentifier));
            return this;
        }

        public Builder setClusterParameterGroupName(@Nullable Input<String> clusterParameterGroupName) {
            this.clusterParameterGroupName = clusterParameterGroupName;
            return this;
        }

        public Builder setClusterParameterGroupName(@Nullable String clusterParameterGroupName) {
            this.clusterParameterGroupName = Input.ofNullable(clusterParameterGroupName);
            return this;
        }

        public Builder setClusterPublicKey(@Nullable Input<String> clusterPublicKey) {
            this.clusterPublicKey = clusterPublicKey;
            return this;
        }

        public Builder setClusterPublicKey(@Nullable String clusterPublicKey) {
            this.clusterPublicKey = Input.ofNullable(clusterPublicKey);
            return this;
        }

        public Builder setClusterRevisionNumber(@Nullable Input<String> clusterRevisionNumber) {
            this.clusterRevisionNumber = clusterRevisionNumber;
            return this;
        }

        public Builder setClusterRevisionNumber(@Nullable String clusterRevisionNumber) {
            this.clusterRevisionNumber = Input.ofNullable(clusterRevisionNumber);
            return this;
        }

        public Builder setClusterSecurityGroups(@Nullable Input<List<String>> clusterSecurityGroups) {
            this.clusterSecurityGroups = clusterSecurityGroups;
            return this;
        }

        public Builder setClusterSecurityGroups(@Nullable List<String> clusterSecurityGroups) {
            this.clusterSecurityGroups = Input.ofNullable(clusterSecurityGroups);
            return this;
        }

        public Builder setClusterSubnetGroupName(@Nullable Input<String> clusterSubnetGroupName) {
            this.clusterSubnetGroupName = clusterSubnetGroupName;
            return this;
        }

        public Builder setClusterSubnetGroupName(@Nullable String clusterSubnetGroupName) {
            this.clusterSubnetGroupName = Input.ofNullable(clusterSubnetGroupName);
            return this;
        }

        public Builder setClusterType(@Nullable Input<String> clusterType) {
            this.clusterType = clusterType;
            return this;
        }

        public Builder setClusterType(@Nullable String clusterType) {
            this.clusterType = Input.ofNullable(clusterType);
            return this;
        }

        public Builder setClusterVersion(@Nullable Input<String> clusterVersion) {
            this.clusterVersion = clusterVersion;
            return this;
        }

        public Builder setClusterVersion(@Nullable String clusterVersion) {
            this.clusterVersion = Input.ofNullable(clusterVersion);
            return this;
        }

        public Builder setDatabaseName(@Nullable Input<String> databaseName) {
            this.databaseName = databaseName;
            return this;
        }

        public Builder setDatabaseName(@Nullable String databaseName) {
            this.databaseName = Input.ofNullable(databaseName);
            return this;
        }

        public Builder setElasticIp(@Nullable Input<String> elasticIp) {
            this.elasticIp = elasticIp;
            return this;
        }

        public Builder setElasticIp(@Nullable String elasticIp) {
            this.elasticIp = Input.ofNullable(elasticIp);
            return this;
        }

        public Builder setEncrypted(@Nullable Input<Boolean> encrypted) {
            this.encrypted = encrypted;
            return this;
        }

        public Builder setEncrypted(@Nullable Boolean encrypted) {
            this.encrypted = Input.ofNullable(encrypted);
            return this;
        }

        public Builder setEndpoint(@Nullable Input<String> endpoint) {
            this.endpoint = endpoint;
            return this;
        }

        public Builder setEndpoint(@Nullable String endpoint) {
            this.endpoint = Input.ofNullable(endpoint);
            return this;
        }

        public Builder setEnhancedVpcRouting(@Nullable Input<Boolean> enhancedVpcRouting) {
            this.enhancedVpcRouting = enhancedVpcRouting;
            return this;
        }

        public Builder setEnhancedVpcRouting(@Nullable Boolean enhancedVpcRouting) {
            this.enhancedVpcRouting = Input.ofNullable(enhancedVpcRouting);
            return this;
        }

        public Builder setFinalSnapshotIdentifier(@Nullable Input<String> finalSnapshotIdentifier) {
            this.finalSnapshotIdentifier = finalSnapshotIdentifier;
            return this;
        }

        public Builder setFinalSnapshotIdentifier(@Nullable String finalSnapshotIdentifier) {
            this.finalSnapshotIdentifier = Input.ofNullable(finalSnapshotIdentifier);
            return this;
        }

        public Builder setIamRoles(@Nullable Input<List<String>> iamRoles) {
            this.iamRoles = iamRoles;
            return this;
        }

        public Builder setIamRoles(@Nullable List<String> iamRoles) {
            this.iamRoles = Input.ofNullable(iamRoles);
            return this;
        }

        public Builder setKmsKeyId(@Nullable Input<String> kmsKeyId) {
            this.kmsKeyId = kmsKeyId;
            return this;
        }

        public Builder setKmsKeyId(@Nullable String kmsKeyId) {
            this.kmsKeyId = Input.ofNullable(kmsKeyId);
            return this;
        }

        public Builder setLogging(@Nullable Input<ClusterLoggingArgs> logging) {
            this.logging = logging;
            return this;
        }

        public Builder setLogging(@Nullable ClusterLoggingArgs logging) {
            this.logging = Input.ofNullable(logging);
            return this;
        }

        public Builder setMasterPassword(@Nullable Input<String> masterPassword) {
            this.masterPassword = masterPassword;
            return this;
        }

        public Builder setMasterPassword(@Nullable String masterPassword) {
            this.masterPassword = Input.ofNullable(masterPassword);
            return this;
        }

        public Builder setMasterUsername(@Nullable Input<String> masterUsername) {
            this.masterUsername = masterUsername;
            return this;
        }

        public Builder setMasterUsername(@Nullable String masterUsername) {
            this.masterUsername = Input.ofNullable(masterUsername);
            return this;
        }

        public Builder setNodeType(Input<String> nodeType) {
            this.nodeType = Objects.requireNonNull(nodeType);
            return this;
        }

        public Builder setNodeType(String nodeType) {
            this.nodeType = Input.of(Objects.requireNonNull(nodeType));
            return this;
        }

        public Builder setNumberOfNodes(@Nullable Input<Integer> numberOfNodes) {
            this.numberOfNodes = numberOfNodes;
            return this;
        }

        public Builder setNumberOfNodes(@Nullable Integer numberOfNodes) {
            this.numberOfNodes = Input.ofNullable(numberOfNodes);
            return this;
        }

        public Builder setOwnerAccount(@Nullable Input<String> ownerAccount) {
            this.ownerAccount = ownerAccount;
            return this;
        }

        public Builder setOwnerAccount(@Nullable String ownerAccount) {
            this.ownerAccount = Input.ofNullable(ownerAccount);
            return this;
        }

        public Builder setPort(@Nullable Input<Integer> port) {
            this.port = port;
            return this;
        }

        public Builder setPort(@Nullable Integer port) {
            this.port = Input.ofNullable(port);
            return this;
        }

        public Builder setPreferredMaintenanceWindow(@Nullable Input<String> preferredMaintenanceWindow) {
            this.preferredMaintenanceWindow = preferredMaintenanceWindow;
            return this;
        }

        public Builder setPreferredMaintenanceWindow(@Nullable String preferredMaintenanceWindow) {
            this.preferredMaintenanceWindow = Input.ofNullable(preferredMaintenanceWindow);
            return this;
        }

        public Builder setPubliclyAccessible(@Nullable Input<Boolean> publiclyAccessible) {
            this.publiclyAccessible = publiclyAccessible;
            return this;
        }

        public Builder setPubliclyAccessible(@Nullable Boolean publiclyAccessible) {
            this.publiclyAccessible = Input.ofNullable(publiclyAccessible);
            return this;
        }

        public Builder setSkipFinalSnapshot(@Nullable Input<Boolean> skipFinalSnapshot) {
            this.skipFinalSnapshot = skipFinalSnapshot;
            return this;
        }

        public Builder setSkipFinalSnapshot(@Nullable Boolean skipFinalSnapshot) {
            this.skipFinalSnapshot = Input.ofNullable(skipFinalSnapshot);
            return this;
        }

        public Builder setSnapshotClusterIdentifier(@Nullable Input<String> snapshotClusterIdentifier) {
            this.snapshotClusterIdentifier = snapshotClusterIdentifier;
            return this;
        }

        public Builder setSnapshotClusterIdentifier(@Nullable String snapshotClusterIdentifier) {
            this.snapshotClusterIdentifier = Input.ofNullable(snapshotClusterIdentifier);
            return this;
        }

        public Builder setSnapshotCopy(@Nullable Input<ClusterSnapshotCopyArgs> snapshotCopy) {
            this.snapshotCopy = snapshotCopy;
            return this;
        }

        public Builder setSnapshotCopy(@Nullable ClusterSnapshotCopyArgs snapshotCopy) {
            this.snapshotCopy = Input.ofNullable(snapshotCopy);
            return this;
        }

        public Builder setSnapshotIdentifier(@Nullable Input<String> snapshotIdentifier) {
            this.snapshotIdentifier = snapshotIdentifier;
            return this;
        }

        public Builder setSnapshotIdentifier(@Nullable String snapshotIdentifier) {
            this.snapshotIdentifier = Input.ofNullable(snapshotIdentifier);
            return this;
        }

        public Builder setTags(@Nullable Input<Map<String,String>> tags) {
            this.tags = tags;
            return this;
        }

        public Builder setTags(@Nullable Map<String,String> tags) {
            this.tags = Input.ofNullable(tags);
            return this;
        }

        public Builder setVpcSecurityGroupIds(@Nullable Input<List<String>> vpcSecurityGroupIds) {
            this.vpcSecurityGroupIds = vpcSecurityGroupIds;
            return this;
        }

        public Builder setVpcSecurityGroupIds(@Nullable List<String> vpcSecurityGroupIds) {
            this.vpcSecurityGroupIds = Input.ofNullable(vpcSecurityGroupIds);
            return this;
        }
        public ClusterArgs build() {
            return new ClusterArgs(allowVersionUpgrade, automatedSnapshotRetentionPeriod, availabilityZone, clusterIdentifier, clusterParameterGroupName, clusterPublicKey, clusterRevisionNumber, clusterSecurityGroups, clusterSubnetGroupName, clusterType, clusterVersion, databaseName, elasticIp, encrypted, endpoint, enhancedVpcRouting, finalSnapshotIdentifier, iamRoles, kmsKeyId, logging, masterPassword, masterUsername, nodeType, numberOfNodes, ownerAccount, port, preferredMaintenanceWindow, publiclyAccessible, skipFinalSnapshot, snapshotClusterIdentifier, snapshotCopy, snapshotIdentifier, tags, vpcSecurityGroupIds);
        }
    }
}
