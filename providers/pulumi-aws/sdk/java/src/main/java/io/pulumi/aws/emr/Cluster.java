// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package io.pulumi.aws.emr;

import io.pulumi.aws.Utilities;
import io.pulumi.aws.emr.ClusterArgs;
import io.pulumi.aws.emr.inputs.ClusterState;
import io.pulumi.aws.emr.outputs.ClusterAutoTerminationPolicy;
import io.pulumi.aws.emr.outputs.ClusterBootstrapAction;
import io.pulumi.aws.emr.outputs.ClusterCoreInstanceFleet;
import io.pulumi.aws.emr.outputs.ClusterCoreInstanceGroup;
import io.pulumi.aws.emr.outputs.ClusterEc2Attributes;
import io.pulumi.aws.emr.outputs.ClusterKerberosAttributes;
import io.pulumi.aws.emr.outputs.ClusterMasterInstanceFleet;
import io.pulumi.aws.emr.outputs.ClusterMasterInstanceGroup;
import io.pulumi.aws.emr.outputs.ClusterStep;
import io.pulumi.core.Output;
import io.pulumi.core.annotations.Export;
import io.pulumi.core.annotations.ResourceType;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import javax.annotation.Nullable;

/**
 * Provides an Elastic MapReduce Cluster, a web service that makes it easy to process large amounts of data efficiently. See [Amazon Elastic MapReduce Documentation](https://aws.amazon.com/documentation/elastic-mapreduce/) for more information.
 * 
 * To configure [Instance Groups](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-instance-group-configuration.html#emr-plan-instance-groups) for [task nodes](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-master-core-task-nodes.html#emr-plan-task), see the `aws.emr.InstanceGroup` resource.
 * 
 * {{% examples %}}
 * ## Example Usage
 * {{% example %}}
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 * 
 * const cluster = new aws.emr.Cluster("cluster", {
 *     releaseLabel: "emr-4.6.0",
 *     applications: ["Spark"],
 *     additionalInfo: `{
 *   "instanceAwsClientConfiguration": {
 *     "proxyPort": 8099,
 *     "proxyHost": "myproxy.example.com"
 *   }
 * }
 * `,
 *     terminationProtection: false,
 *     keepJobFlowAliveWhenNoSteps: true,
 *     ec2Attributes: {
 *         subnetId: aws_subnet.main.id,
 *         emrManagedMasterSecurityGroup: aws_security_group.sg.id,
 *         emrManagedSlaveSecurityGroup: aws_security_group.sg.id,
 *         instanceProfile: aws_iam_instance_profile.emr_profile.arn,
 *     },
 *     masterInstanceGroup: {
 *         instanceType: "m4.large",
 *     },
 *     coreInstanceGroup: {
 *         instanceType: "c4.large",
 *         instanceCount: 1,
 *         ebsConfigs: [{
 *             size: "40",
 *             type: "gp2",
 *             volumesPerInstance: 1,
 *         }],
 *         bidPrice: "0.30",
 *         autoscalingPolicy: `{
 * "Constraints": {
 *   "MinCapacity": 1,
 *   "MaxCapacity": 2
 * },
 * "Rules": [
 *   {
 *     "Name": "ScaleOutMemoryPercentage",
 *     "Description": "Scale out if YARNMemoryAvailablePercentage is less than 15",
 *     "Action": {
 *       "SimpleScalingPolicyConfiguration": {
 *         "AdjustmentType": "CHANGE_IN_CAPACITY",
 *         "ScalingAdjustment": 1,
 *         "CoolDown": 300
 *       }
 *     },
 *     "Trigger": {
 *       "CloudWatchAlarmDefinition": {
 *         "ComparisonOperator": "LESS_THAN",
 *         "EvaluationPeriods": 1,
 *         "MetricName": "YARNMemoryAvailablePercentage",
 *         "Namespace": "AWS/ElasticMapReduce",
 *         "Period": 300,
 *         "Statistic": "AVERAGE",
 *         "Threshold": 15.0,
 *         "Unit": "PERCENT"
 *       }
 *     }
 *   }
 * ]
 * }
 * `,
 *     },
 *     ebsRootVolumeSize: 100,
 *     tags: {
 *         role: "rolename",
 *         env: "env",
 *     },
 *     bootstrapActions: [{
 *         path: "s3://elasticmapreduce/bootstrap-actions/run-if",
 *         name: "runif",
 *         args: [
 *             "instance.isMaster=true",
 *             "echo running on master node",
 *         ],
 *     }],
 *     configurationsJson: `  [
 *     {
 *       "Classification": "hadoop-env",
 *       "Configurations": [
 *         {
 *           "Classification": "export",
 *           "Properties": {
 *             "JAVA_HOME": "/usr/lib/jvm/java-1.8.0"
 *           }
 *         }
 *       ],
 *       "Properties": {}
 *     },
 *     {
 *       "Classification": "spark-env",
 *       "Configurations": [
 *         {
 *           "Classification": "export",
 *           "Properties": {
 *             "JAVA_HOME": "/usr/lib/jvm/java-1.8.0"
 *           }
 *         }
 *       ],
 *       "Properties": {}
 *     }
 *   ]
 * `,
 *     serviceRole: aws_iam_role.iam_emr_service_role.arn,
 * });
 * ```
 * ```python
 * import pulumi
 * import pulumi_aws as aws
 * 
 * cluster = aws.emr.Cluster("cluster",
 *     release_label="emr-4.6.0",
 *     applications=["Spark"],
 *     additional_info="""{
 *   "instanceAwsClientConfiguration": {
 *     "proxyPort": 8099,
 *     "proxyHost": "myproxy.example.com"
 *   }
 * }
 * """,
 *     termination_protection=False,
 *     keep_job_flow_alive_when_no_steps=True,
 *     ec2_attributes=aws.emr.ClusterEc2AttributesArgs(
 *         subnet_id=aws_subnet["main"]["id"],
 *         emr_managed_master_security_group=aws_security_group["sg"]["id"],
 *         emr_managed_slave_security_group=aws_security_group["sg"]["id"],
 *         instance_profile=aws_iam_instance_profile["emr_profile"]["arn"],
 *     ),
 *     master_instance_group=aws.emr.ClusterMasterInstanceGroupArgs(
 *         instance_type="m4.large",
 *     ),
 *     core_instance_group=aws.emr.ClusterCoreInstanceGroupArgs(
 *         instance_type="c4.large",
 *         instance_count=1,
 *         ebs_configs=[aws.emr.ClusterCoreInstanceGroupEbsConfigArgs(
 *             size=40,
 *             type="gp2",
 *             volumes_per_instance=1,
 *         )],
 *         bid_price="0.30",
 *         autoscaling_policy="""{
 * "Constraints": {
 *   "MinCapacity": 1,
 *   "MaxCapacity": 2
 * },
 * "Rules": [
 *   {
 *     "Name": "ScaleOutMemoryPercentage",
 *     "Description": "Scale out if YARNMemoryAvailablePercentage is less than 15",
 *     "Action": {
 *       "SimpleScalingPolicyConfiguration": {
 *         "AdjustmentType": "CHANGE_IN_CAPACITY",
 *         "ScalingAdjustment": 1,
 *         "CoolDown": 300
 *       }
 *     },
 *     "Trigger": {
 *       "CloudWatchAlarmDefinition": {
 *         "ComparisonOperator": "LESS_THAN",
 *         "EvaluationPeriods": 1,
 *         "MetricName": "YARNMemoryAvailablePercentage",
 *         "Namespace": "AWS/ElasticMapReduce",
 *         "Period": 300,
 *         "Statistic": "AVERAGE",
 *         "Threshold": 15.0,
 *         "Unit": "PERCENT"
 *       }
 *     }
 *   }
 * ]
 * }
 * """,
 *     ),
 *     ebs_root_volume_size=100,
 *     tags={
 *         "role": "rolename",
 *         "env": "env",
 *     },
 *     bootstrap_actions=[aws.emr.ClusterBootstrapActionArgs(
 *         path="s3://elasticmapreduce/bootstrap-actions/run-if",
 *         name="runif",
 *         args=[
 *             "instance.isMaster=true",
 *             "echo running on master node",
 *         ],
 *     )],
 *     configurations_json="""  [
 *     {
 *       "Classification": "hadoop-env",
 *       "Configurations": [
 *         {
 *           "Classification": "export",
 *           "Properties": {
 *             "JAVA_HOME": "/usr/lib/jvm/java-1.8.0"
 *           }
 *         }
 *       ],
 *       "Properties": {}
 *     },
 *     {
 *       "Classification": "spark-env",
 *       "Configurations": [
 *         {
 *           "Classification": "export",
 *           "Properties": {
 *             "JAVA_HOME": "/usr/lib/jvm/java-1.8.0"
 *           }
 *         }
 *       ],
 *       "Properties": {}
 *     }
 *   ]
 * """,
 *     service_role=aws_iam_role["iam_emr_service_role"]["arn"])
 * ```
 * ```csharp
 * using Pulumi;
 * using Aws = Pulumi.Aws;
 * 
 * class MyStack : Stack
 * {
 *     public MyStack()
 *     {
 *         var cluster = new Aws.Emr.Cluster("cluster", new Aws.Emr.ClusterArgs
 *         {
 *             ReleaseLabel = "emr-4.6.0",
 *             Applications = 
 *             {
 *                 "Spark",
 *             },
 *             AdditionalInfo = @"{
 *   ""instanceAwsClientConfiguration"": {
 *     ""proxyPort"": 8099,
 *     ""proxyHost"": ""myproxy.example.com""
 *   }
 * }
 * ",
 *             TerminationProtection = false,
 *             KeepJobFlowAliveWhenNoSteps = true,
 *             Ec2Attributes = new Aws.Emr.Inputs.ClusterEc2AttributesArgs
 *             {
 *                 SubnetId = aws_subnet.Main.Id,
 *                 EmrManagedMasterSecurityGroup = aws_security_group.Sg.Id,
 *                 EmrManagedSlaveSecurityGroup = aws_security_group.Sg.Id,
 *                 InstanceProfile = aws_iam_instance_profile.Emr_profile.Arn,
 *             },
 *             MasterInstanceGroup = new Aws.Emr.Inputs.ClusterMasterInstanceGroupArgs
 *             {
 *                 InstanceType = "m4.large",
 *             },
 *             CoreInstanceGroup = new Aws.Emr.Inputs.ClusterCoreInstanceGroupArgs
 *             {
 *                 InstanceType = "c4.large",
 *                 InstanceCount = 1,
 *                 EbsConfigs = 
 *                 {
 *                     new Aws.Emr.Inputs.ClusterCoreInstanceGroupEbsConfigArgs
 *                     {
 *                         Size = 40,
 *                         Type = "gp2",
 *                         VolumesPerInstance = 1,
 *                     },
 *                 },
 *                 BidPrice = "0.30",
 *                 AutoscalingPolicy = @"{
 * ""Constraints"": {
 *   ""MinCapacity"": 1,
 *   ""MaxCapacity"": 2
 * },
 * ""Rules"": [
 *   {
 *     ""Name"": ""ScaleOutMemoryPercentage"",
 *     ""Description"": ""Scale out if YARNMemoryAvailablePercentage is less than 15"",
 *     ""Action"": {
 *       ""SimpleScalingPolicyConfiguration"": {
 *         ""AdjustmentType"": ""CHANGE_IN_CAPACITY"",
 *         ""ScalingAdjustment"": 1,
 *         ""CoolDown"": 300
 *       }
 *     },
 *     ""Trigger"": {
 *       ""CloudWatchAlarmDefinition"": {
 *         ""ComparisonOperator"": ""LESS_THAN"",
 *         ""EvaluationPeriods"": 1,
 *         ""MetricName"": ""YARNMemoryAvailablePercentage"",
 *         ""Namespace"": ""AWS/ElasticMapReduce"",
 *         ""Period"": 300,
 *         ""Statistic"": ""AVERAGE"",
 *         ""Threshold"": 15.0,
 *         ""Unit"": ""PERCENT""
 *       }
 *     }
 *   }
 * ]
 * }
 * ",
 *             },
 *             EbsRootVolumeSize = 100,
 *             Tags = 
 *             {
 *                 { "role", "rolename" },
 *                 { "env", "env" },
 *             },
 *             BootstrapActions = 
 *             {
 *                 new Aws.Emr.Inputs.ClusterBootstrapActionArgs
 *                 {
 *                     Path = "s3://elasticmapreduce/bootstrap-actions/run-if",
 *                     Name = "runif",
 *                     Args = 
 *                     {
 *                         "instance.isMaster=true",
 *                         "echo running on master node",
 *                     },
 *                 },
 *             },
 *             ConfigurationsJson = @"  [
 *     {
 *       ""Classification"": ""hadoop-env"",
 *       ""Configurations"": [
 *         {
 *           ""Classification"": ""export"",
 *           ""Properties"": {
 *             ""JAVA_HOME"": ""/usr/lib/jvm/java-1.8.0""
 *           }
 *         }
 *       ],
 *       ""Properties"": {}
 *     },
 *     {
 *       ""Classification"": ""spark-env"",
 *       ""Configurations"": [
 *         {
 *           ""Classification"": ""export"",
 *           ""Properties"": {
 *             ""JAVA_HOME"": ""/usr/lib/jvm/java-1.8.0""
 *           }
 *         }
 *       ],
 *       ""Properties"": {}
 *     }
 *   ]
 * ",
 *             ServiceRole = aws_iam_role.Iam_emr_service_role.Arn,
 *         });
 *     }
 * 
 * }
 * ```
 * ```go
 * package main
 * 
 * import (
 * 	"fmt"
 * 
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/emr"
 * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
 * )
 * 
 * func main() {
 * 	pulumi.Run(func(ctx *pulumi.Context) error {
 * 		_, err := emr.NewCluster(ctx, "cluster", &emr.ClusterArgs{
 * 			ReleaseLabel: pulumi.String("emr-4.6.0"),
 * 			Applications: pulumi.StringArray{
 * 				pulumi.String("Spark"),
 * 			},
 * 			AdditionalInfo:              pulumi.String(fmt.Sprintf("%v%v%v%v%v%v", "{\n", "  \"instanceAwsClientConfiguration\": {\n", "    \"proxyPort\": 8099,\n", "    \"proxyHost\": \"myproxy.example.com\"\n", "  }\n", "}\n")),
 * 			TerminationProtection:       pulumi.Bool(false),
 * 			KeepJobFlowAliveWhenNoSteps: pulumi.Bool(true),
 * 			Ec2Attributes: &emr.ClusterEc2AttributesArgs{
 * 				SubnetId:                      pulumi.Any(aws_subnet.Main.Id),
 * 				EmrManagedMasterSecurityGroup: pulumi.Any(aws_security_group.Sg.Id),
 * 				EmrManagedSlaveSecurityGroup:  pulumi.Any(aws_security_group.Sg.Id),
 * 				InstanceProfile:               pulumi.Any(aws_iam_instance_profile.Emr_profile.Arn),
 * 			},
 * 			MasterInstanceGroup: &emr.ClusterMasterInstanceGroupArgs{
 * 				InstanceType: pulumi.String("m4.large"),
 * 			},
 * 			CoreInstanceGroup: &emr.ClusterCoreInstanceGroupArgs{
 * 				InstanceType:  pulumi.String("c4.large"),
 * 				InstanceCount: pulumi.Int(1),
 * 				EbsConfigs: emr.ClusterCoreInstanceGroupEbsConfigArray{
 * 					&emr.ClusterCoreInstanceGroupEbsConfigArgs{
 * 						Size:               pulumi.Int(40),
 * 						Type:               pulumi.String("gp2"),
 * 						VolumesPerInstance: pulumi.Int(1),
 * 					},
 * 				},
 * 				BidPrice:          pulumi.String("0.30"),
 * 				AutoscalingPolicy: pulumi.String(fmt.Sprintf("%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v", "{\n", "\"Constraints\": {\n", "  \"MinCapacity\": 1,\n", "  \"MaxCapacity\": 2\n", "},\n", "\"Rules\": [\n", "  {\n", "    \"Name\": \"ScaleOutMemoryPercentage\",\n", "    \"Description\": \"Scale out if YARNMemoryAvailablePercentage is less than 15\",\n", "    \"Action\": {\n", "      \"SimpleScalingPolicyConfiguration\": {\n", "        \"AdjustmentType\": \"CHANGE_IN_CAPACITY\",\n", "        \"ScalingAdjustment\": 1,\n", "        \"CoolDown\": 300\n", "      }\n", "    },\n", "    \"Trigger\": {\n", "      \"CloudWatchAlarmDefinition\": {\n", "        \"ComparisonOperator\": \"LESS_THAN\",\n", "        \"EvaluationPeriods\": 1,\n", "        \"MetricName\": \"YARNMemoryAvailablePercentage\",\n", "        \"Namespace\": \"AWS/ElasticMapReduce\",\n", "        \"Period\": 300,\n", "        \"Statistic\": \"AVERAGE\",\n", "        \"Threshold\": 15.0,\n", "        \"Unit\": \"PERCENT\"\n", "      }\n", "    }\n", "  }\n", "]\n", "}\n")),
 * 			},
 * 			EbsRootVolumeSize: pulumi.Int(100),
 * 			Tags: pulumi.StringMap{
 * 				"role": pulumi.String("rolename"),
 * 				"env":  pulumi.String("env"),
 * 			},
 * 			BootstrapActions: emr.ClusterBootstrapActionArray{
 * 				&emr.ClusterBootstrapActionArgs{
 * 					Path: pulumi.String("s3://elasticmapreduce/bootstrap-actions/run-if"),
 * 					Name: pulumi.String("runif"),
 * 					Args: pulumi.StringArray{
 * 						pulumi.String("instance.isMaster=true"),
 * 						pulumi.String("echo running on master node"),
 * 					},
 * 				},
 * 			},
 * 			ConfigurationsJson: pulumi.String(fmt.Sprintf("%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v", "  [\n", "    {\n", "      \"Classification\": \"hadoop-env\",\n", "      \"Configurations\": [\n", "        {\n", "          \"Classification\": \"export\",\n", "          \"Properties\": {\n", "            \"JAVA_HOME\": \"/usr/lib/jvm/java-1.8.0\"\n", "          }\n", "        }\n", "      ],\n", "      \"Properties\": {}\n", "    },\n", "    {\n", "      \"Classification\": \"spark-env\",\n", "      \"Configurations\": [\n", "        {\n", "          \"Classification\": \"export\",\n", "          \"Properties\": {\n", "            \"JAVA_HOME\": \"/usr/lib/jvm/java-1.8.0\"\n", "          }\n", "        }\n", "      ],\n", "      \"Properties\": {}\n", "    }\n", "  ]\n")),
 * 			ServiceRole:        pulumi.Any(aws_iam_role.Iam_emr_service_role.Arn),
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		return nil
 * 	})
 * }
 * ```
 * 
 * The `aws.emr.Cluster` resource typically requires two IAM roles, one for the EMR Cluster to use as a service, and another to place on your Cluster Instances to interact with AWS from those instances. The suggested role policy template for the EMR service is `AmazonElasticMapReduceRole`, and `AmazonElasticMapReduceforEC2Role` for the EC2 profile. See the [Getting Started](https://docs.aws.amazon.com/ElasticMapReduce/latest/ManagementGuide/emr-gs-launch-sample-cluster.html) guide for more information on these IAM roles.
 * {{% /example %}}
 * {{% example %}}
 * ### Instance Fleet
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 * 
 * const example = new aws.emr.Cluster("example", {
 *     masterInstanceFleet: {
 *         instanceTypeConfigs: [{
 *             instanceType: "m4.xlarge",
 *         }],
 *         targetOnDemandCapacity: 1,
 *     },
 *     coreInstanceFleet: {
 *         instanceTypeConfigs: [
 *             {
 *                 bidPriceAsPercentageOfOnDemandPrice: 80,
 *                 ebsConfigs: [{
 *                     size: 100,
 *                     type: "gp2",
 *                     volumesPerInstance: 1,
 *                 }],
 *                 instanceType: "m3.xlarge",
 *                 weightedCapacity: 1,
 *             },
 *             {
 *                 bidPriceAsPercentageOfOnDemandPrice: 100,
 *                 ebsConfigs: [{
 *                     size: 100,
 *                     type: "gp2",
 *                     volumesPerInstance: 1,
 *                 }],
 *                 instanceType: "m4.xlarge",
 *                 weightedCapacity: 1,
 *             },
 *             {
 *                 bidPriceAsPercentageOfOnDemandPrice: 100,
 *                 ebsConfigs: [{
 *                     size: 100,
 *                     type: "gp2",
 *                     volumesPerInstance: 1,
 *                 }],
 *                 instanceType: "m4.2xlarge",
 *                 weightedCapacity: 2,
 *             },
 *         ],
 *         launchSpecifications: {
 *             spotSpecifications: [{
 *                 allocationStrategy: "capacity-optimized",
 *                 blockDurationMinutes: 0,
 *                 timeoutAction: "SWITCH_TO_ON_DEMAND",
 *                 timeoutDurationMinutes: 10,
 *             }],
 *         },
 *         name: "core fleet",
 *         targetOnDemandCapacity: 2,
 *         targetSpotCapacity: 2,
 *     },
 * });
 * const task = new aws.emr.InstanceFleet("task", {
 *     clusterId: example.id,
 *     instanceTypeConfigs: [
 *         {
 *             bidPriceAsPercentageOfOnDemandPrice: 100,
 *             ebsConfigs: [{
 *                 size: 100,
 *                 type: "gp2",
 *                 volumesPerInstance: 1,
 *             }],
 *             instanceType: "m4.xlarge",
 *             weightedCapacity: 1,
 *         },
 *         {
 *             bidPriceAsPercentageOfOnDemandPrice: 100,
 *             ebsConfigs: [{
 *                 size: 100,
 *                 type: "gp2",
 *                 volumesPerInstance: 1,
 *             }],
 *             instanceType: "m4.2xlarge",
 *             weightedCapacity: 2,
 *         },
 *     ],
 *     launchSpecifications: {
 *         spotSpecifications: [{
 *             allocationStrategy: "capacity-optimized",
 *             blockDurationMinutes: 0,
 *             timeoutAction: "TERMINATE_CLUSTER",
 *             timeoutDurationMinutes: 10,
 *         }],
 *     },
 *     targetOnDemandCapacity: 1,
 *     targetSpotCapacity: 1,
 * });
 * ```
 * ```python
 * import pulumi
 * import pulumi_aws as aws
 * 
 * example = aws.emr.Cluster("example",
 *     master_instance_fleet=aws.emr.ClusterMasterInstanceFleetArgs(
 *         instance_type_configs=[aws.emr.ClusterMasterInstanceFleetInstanceTypeConfigArgs(
 *             instance_type="m4.xlarge",
 *         )],
 *         target_on_demand_capacity=1,
 *     ),
 *     core_instance_fleet=aws.emr.ClusterCoreInstanceFleetArgs(
 *         instance_type_configs=[
 *             aws.emr.ClusterCoreInstanceFleetInstanceTypeConfigArgs(
 *                 bid_price_as_percentage_of_on_demand_price=80,
 *                 ebs_configs=[aws.emr.ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArgs(
 *                     size=100,
 *                     type="gp2",
 *                     volumes_per_instance=1,
 *                 )],
 *                 instance_type="m3.xlarge",
 *                 weighted_capacity=1,
 *             ),
 *             aws.emr.ClusterCoreInstanceFleetInstanceTypeConfigArgs(
 *                 bid_price_as_percentage_of_on_demand_price=100,
 *                 ebs_configs=[aws.emr.ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArgs(
 *                     size=100,
 *                     type="gp2",
 *                     volumes_per_instance=1,
 *                 )],
 *                 instance_type="m4.xlarge",
 *                 weighted_capacity=1,
 *             ),
 *             aws.emr.ClusterCoreInstanceFleetInstanceTypeConfigArgs(
 *                 bid_price_as_percentage_of_on_demand_price=100,
 *                 ebs_configs=[aws.emr.ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArgs(
 *                     size=100,
 *                     type="gp2",
 *                     volumes_per_instance=1,
 *                 )],
 *                 instance_type="m4.2xlarge",
 *                 weighted_capacity=2,
 *             ),
 *         ],
 *         launch_specifications=aws.emr.ClusterCoreInstanceFleetLaunchSpecificationsArgs(
 *             spot_specifications=[aws.emr.ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArgs(
 *                 allocation_strategy="capacity-optimized",
 *                 block_duration_minutes=0,
 *                 timeout_action="SWITCH_TO_ON_DEMAND",
 *                 timeout_duration_minutes=10,
 *             )],
 *         ),
 *         name="core fleet",
 *         target_on_demand_capacity=2,
 *         target_spot_capacity=2,
 *     ))
 * task = aws.emr.InstanceFleet("task",
 *     cluster_id=example.id,
 *     instance_type_configs=[
 *         aws.emr.InstanceFleetInstanceTypeConfigArgs(
 *             bid_price_as_percentage_of_on_demand_price=100,
 *             ebs_configs=[aws.emr.InstanceFleetInstanceTypeConfigEbsConfigArgs(
 *                 size=100,
 *                 type="gp2",
 *                 volumes_per_instance=1,
 *             )],
 *             instance_type="m4.xlarge",
 *             weighted_capacity=1,
 *         ),
 *         aws.emr.InstanceFleetInstanceTypeConfigArgs(
 *             bid_price_as_percentage_of_on_demand_price=100,
 *             ebs_configs=[aws.emr.InstanceFleetInstanceTypeConfigEbsConfigArgs(
 *                 size=100,
 *                 type="gp2",
 *                 volumes_per_instance=1,
 *             )],
 *             instance_type="m4.2xlarge",
 *             weighted_capacity=2,
 *         ),
 *     ],
 *     launch_specifications=aws.emr.InstanceFleetLaunchSpecificationsArgs(
 *         spot_specifications=[aws.emr.InstanceFleetLaunchSpecificationsSpotSpecificationArgs(
 *             allocation_strategy="capacity-optimized",
 *             block_duration_minutes=0,
 *             timeout_action="TERMINATE_CLUSTER",
 *             timeout_duration_minutes=10,
 *         )],
 *     ),
 *     target_on_demand_capacity=1,
 *     target_spot_capacity=1)
 * ```
 * ```csharp
 * using Pulumi;
 * using Aws = Pulumi.Aws;
 * 
 * class MyStack : Stack
 * {
 *     public MyStack()
 *     {
 *         var example = new Aws.Emr.Cluster("example", new Aws.Emr.ClusterArgs
 *         {
 *             MasterInstanceFleet = new Aws.Emr.Inputs.ClusterMasterInstanceFleetArgs
 *             {
 *                 InstanceTypeConfigs = 
 *                 {
 *                     new Aws.Emr.Inputs.ClusterMasterInstanceFleetInstanceTypeConfigArgs
 *                     {
 *                         InstanceType = "m4.xlarge",
 *                     },
 *                 },
 *                 TargetOnDemandCapacity = 1,
 *             },
 *             CoreInstanceFleet = new Aws.Emr.Inputs.ClusterCoreInstanceFleetArgs
 *             {
 *                 InstanceTypeConfigs = 
 *                 {
 *                     new Aws.Emr.Inputs.ClusterCoreInstanceFleetInstanceTypeConfigArgs
 *                     {
 *                         BidPriceAsPercentageOfOnDemandPrice = 80,
 *                         EbsConfigs = 
 *                         {
 *                             new Aws.Emr.Inputs.ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArgs
 *                             {
 *                                 Size = 100,
 *                                 Type = "gp2",
 *                                 VolumesPerInstance = 1,
 *                             },
 *                         },
 *                         InstanceType = "m3.xlarge",
 *                         WeightedCapacity = 1,
 *                     },
 *                     new Aws.Emr.Inputs.ClusterCoreInstanceFleetInstanceTypeConfigArgs
 *                     {
 *                         BidPriceAsPercentageOfOnDemandPrice = 100,
 *                         EbsConfigs = 
 *                         {
 *                             new Aws.Emr.Inputs.ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArgs
 *                             {
 *                                 Size = 100,
 *                                 Type = "gp2",
 *                                 VolumesPerInstance = 1,
 *                             },
 *                         },
 *                         InstanceType = "m4.xlarge",
 *                         WeightedCapacity = 1,
 *                     },
 *                     new Aws.Emr.Inputs.ClusterCoreInstanceFleetInstanceTypeConfigArgs
 *                     {
 *                         BidPriceAsPercentageOfOnDemandPrice = 100,
 *                         EbsConfigs = 
 *                         {
 *                             new Aws.Emr.Inputs.ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArgs
 *                             {
 *                                 Size = 100,
 *                                 Type = "gp2",
 *                                 VolumesPerInstance = 1,
 *                             },
 *                         },
 *                         InstanceType = "m4.2xlarge",
 *                         WeightedCapacity = 2,
 *                     },
 *                 },
 *                 LaunchSpecifications = new Aws.Emr.Inputs.ClusterCoreInstanceFleetLaunchSpecificationsArgs
 *                 {
 *                     SpotSpecifications = 
 *                     {
 *                         new Aws.Emr.Inputs.ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArgs
 *                         {
 *                             AllocationStrategy = "capacity-optimized",
 *                             BlockDurationMinutes = 0,
 *                             TimeoutAction = "SWITCH_TO_ON_DEMAND",
 *                             TimeoutDurationMinutes = 10,
 *                         },
 *                     },
 *                 },
 *                 Name = "core fleet",
 *                 TargetOnDemandCapacity = 2,
 *                 TargetSpotCapacity = 2,
 *             },
 *         });
 *         var task = new Aws.Emr.InstanceFleet("task", new Aws.Emr.InstanceFleetArgs
 *         {
 *             ClusterId = example.Id,
 *             InstanceTypeConfigs = 
 *             {
 *                 new Aws.Emr.Inputs.InstanceFleetInstanceTypeConfigArgs
 *                 {
 *                     BidPriceAsPercentageOfOnDemandPrice = 100,
 *                     EbsConfigs = 
 *                     {
 *                         new Aws.Emr.Inputs.InstanceFleetInstanceTypeConfigEbsConfigArgs
 *                         {
 *                             Size = 100,
 *                             Type = "gp2",
 *                             VolumesPerInstance = 1,
 *                         },
 *                     },
 *                     InstanceType = "m4.xlarge",
 *                     WeightedCapacity = 1,
 *                 },
 *                 new Aws.Emr.Inputs.InstanceFleetInstanceTypeConfigArgs
 *                 {
 *                     BidPriceAsPercentageOfOnDemandPrice = 100,
 *                     EbsConfigs = 
 *                     {
 *                         new Aws.Emr.Inputs.InstanceFleetInstanceTypeConfigEbsConfigArgs
 *                         {
 *                             Size = 100,
 *                             Type = "gp2",
 *                             VolumesPerInstance = 1,
 *                         },
 *                     },
 *                     InstanceType = "m4.2xlarge",
 *                     WeightedCapacity = 2,
 *                 },
 *             },
 *             LaunchSpecifications = new Aws.Emr.Inputs.InstanceFleetLaunchSpecificationsArgs
 *             {
 *                 SpotSpecifications = 
 *                 {
 *                     new Aws.Emr.Inputs.InstanceFleetLaunchSpecificationsSpotSpecificationArgs
 *                     {
 *                         AllocationStrategy = "capacity-optimized",
 *                         BlockDurationMinutes = 0,
 *                         TimeoutAction = "TERMINATE_CLUSTER",
 *                         TimeoutDurationMinutes = 10,
 *                     },
 *                 },
 *             },
 *             TargetOnDemandCapacity = 1,
 *             TargetSpotCapacity = 1,
 *         });
 *     }
 * 
 * }
 * ```
 * ```go
 * package main
 * 
 * import (
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/emr"
 * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
 * )
 * 
 * func main() {
 * 	pulumi.Run(func(ctx *pulumi.Context) error {
 * 		example, err := emr.NewCluster(ctx, "example", &emr.ClusterArgs{
 * 			MasterInstanceFleet: &emr.ClusterMasterInstanceFleetArgs{
 * 				InstanceTypeConfigs: emr.ClusterMasterInstanceFleetInstanceTypeConfigArray{
 * 					&emr.ClusterMasterInstanceFleetInstanceTypeConfigArgs{
 * 						InstanceType: pulumi.String("m4.xlarge"),
 * 					},
 * 				},
 * 				TargetOnDemandCapacity: pulumi.Int(1),
 * 			},
 * 			CoreInstanceFleet: &emr.ClusterCoreInstanceFleetArgs{
 * 				InstanceTypeConfigs: emr.ClusterCoreInstanceFleetInstanceTypeConfigArray{
 * 					&emr.ClusterCoreInstanceFleetInstanceTypeConfigArgs{
 * 						BidPriceAsPercentageOfOnDemandPrice: pulumi.Float64(80),
 * 						EbsConfigs: emr.ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArray{
 * 							&emr.ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArgs{
 * 								Size:               pulumi.Int(100),
 * 								Type:               pulumi.String("gp2"),
 * 								VolumesPerInstance: pulumi.Int(1),
 * 							},
 * 						},
 * 						InstanceType:     pulumi.String("m3.xlarge"),
 * 						WeightedCapacity: pulumi.Int(1),
 * 					},
 * 					&emr.ClusterCoreInstanceFleetInstanceTypeConfigArgs{
 * 						BidPriceAsPercentageOfOnDemandPrice: pulumi.Float64(100),
 * 						EbsConfigs: emr.ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArray{
 * 							&emr.ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArgs{
 * 								Size:               pulumi.Int(100),
 * 								Type:               pulumi.String("gp2"),
 * 								VolumesPerInstance: pulumi.Int(1),
 * 							},
 * 						},
 * 						InstanceType:     pulumi.String("m4.xlarge"),
 * 						WeightedCapacity: pulumi.Int(1),
 * 					},
 * 					&emr.ClusterCoreInstanceFleetInstanceTypeConfigArgs{
 * 						BidPriceAsPercentageOfOnDemandPrice: pulumi.Float64(100),
 * 						EbsConfigs: emr.ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArray{
 * 							&emr.ClusterCoreInstanceFleetInstanceTypeConfigEbsConfigArgs{
 * 								Size:               pulumi.Int(100),
 * 								Type:               pulumi.String("gp2"),
 * 								VolumesPerInstance: pulumi.Int(1),
 * 							},
 * 						},
 * 						InstanceType:     pulumi.String("m4.2xlarge"),
 * 						WeightedCapacity: pulumi.Int(2),
 * 					},
 * 				},
 * 				LaunchSpecifications: &emr.ClusterCoreInstanceFleetLaunchSpecificationsArgs{
 * 					SpotSpecifications: emr.ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArray{
 * 						&emr.ClusterCoreInstanceFleetLaunchSpecificationsSpotSpecificationArgs{
 * 							AllocationStrategy:     pulumi.String("capacity-optimized"),
 * 							BlockDurationMinutes:   pulumi.Int(0),
 * 							TimeoutAction:          pulumi.String("SWITCH_TO_ON_DEMAND"),
 * 							TimeoutDurationMinutes: pulumi.Int(10),
 * 						},
 * 					},
 * 				},
 * 				Name:                   pulumi.String("core fleet"),
 * 				TargetOnDemandCapacity: pulumi.Int(2),
 * 				TargetSpotCapacity:     pulumi.Int(2),
 * 			},
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		_, err = emr.NewInstanceFleet(ctx, "task", &emr.InstanceFleetArgs{
 * 			ClusterId: example.ID(),
 * 			InstanceTypeConfigs: emr.InstanceFleetInstanceTypeConfigArray{
 * 				&emr.InstanceFleetInstanceTypeConfigArgs{
 * 					BidPriceAsPercentageOfOnDemandPrice: pulumi.Float64(100),
 * 					EbsConfigs: emr.InstanceFleetInstanceTypeConfigEbsConfigArray{
 * 						&emr.InstanceFleetInstanceTypeConfigEbsConfigArgs{
 * 							Size:               pulumi.Int(100),
 * 							Type:               pulumi.String("gp2"),
 * 							VolumesPerInstance: pulumi.Int(1),
 * 						},
 * 					},
 * 					InstanceType:     pulumi.String("m4.xlarge"),
 * 					WeightedCapacity: pulumi.Int(1),
 * 				},
 * 				&emr.InstanceFleetInstanceTypeConfigArgs{
 * 					BidPriceAsPercentageOfOnDemandPrice: pulumi.Float64(100),
 * 					EbsConfigs: emr.InstanceFleetInstanceTypeConfigEbsConfigArray{
 * 						&emr.InstanceFleetInstanceTypeConfigEbsConfigArgs{
 * 							Size:               pulumi.Int(100),
 * 							Type:               pulumi.String("gp2"),
 * 							VolumesPerInstance: pulumi.Int(1),
 * 						},
 * 					},
 * 					InstanceType:     pulumi.String("m4.2xlarge"),
 * 					WeightedCapacity: pulumi.Int(2),
 * 				},
 * 			},
 * 			LaunchSpecifications: &emr.InstanceFleetLaunchSpecificationsArgs{
 * 				SpotSpecifications: emr.InstanceFleetLaunchSpecificationsSpotSpecificationArray{
 * 					&emr.InstanceFleetLaunchSpecificationsSpotSpecificationArgs{
 * 						AllocationStrategy:     pulumi.String("capacity-optimized"),
 * 						BlockDurationMinutes:   pulumi.Int(0),
 * 						TimeoutAction:          pulumi.String("TERMINATE_CLUSTER"),
 * 						TimeoutDurationMinutes: pulumi.Int(10),
 * 					},
 * 				},
 * 			},
 * 			TargetOnDemandCapacity: pulumi.Int(1),
 * 			TargetSpotCapacity:     pulumi.Int(1),
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		return nil
 * 	})
 * }
 * ```
 * {{% /example %}}
 * {{% example %}}
 * ### Enable Debug Logging
 * 
 * [Debug logging in EMR](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-plan-debugging.html) is implemented as a step. It is highly recommended that you utilize the resource options configuration with `ignoreChanges` if other steps are being managed outside of this provider.
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 * 
 * // ... other configuration ...
 * const example = new aws.emr.Cluster("example", {steps: [{
 *     actionOnFailure: "TERMINATE_CLUSTER",
 *     name: "Setup Hadoop Debugging",
 *     hadoopJarStep: {
 *         jar: "command-runner.jar",
 *         args: ["state-pusher-script"],
 *     },
 * }]});
 * ```
 * ```python
 * import pulumi
 * import pulumi_aws as aws
 * 
 * # ... other configuration ...
 * example = aws.emr.Cluster("example", steps=[aws.emr.ClusterStepArgs(
 *     action_on_failure="TERMINATE_CLUSTER",
 *     name="Setup Hadoop Debugging",
 *     hadoop_jar_step=aws.emr.ClusterStepHadoopJarStepArgs(
 *         jar="command-runner.jar",
 *         args=["state-pusher-script"],
 *     ),
 * )])
 * ```
 * ```csharp
 * using Pulumi;
 * using Aws = Pulumi.Aws;
 * 
 * class MyStack : Stack
 * {
 *     public MyStack()
 *     {
 *         // ... other configuration ...
 *         var example = new Aws.Emr.Cluster("example", new Aws.Emr.ClusterArgs
 *         {
 *             Steps = 
 *             {
 *                 new Aws.Emr.Inputs.ClusterStepArgs
 *                 {
 *                     ActionOnFailure = "TERMINATE_CLUSTER",
 *                     Name = "Setup Hadoop Debugging",
 *                     HadoopJarStep = new Aws.Emr.Inputs.ClusterStepHadoopJarStepArgs
 *                     {
 *                         Jar = "command-runner.jar",
 *                         Args = 
 *                         {
 *                             "state-pusher-script",
 *                         },
 *                     },
 *                 },
 *             },
 *         });
 *     }
 * 
 * }
 * ```
 * ```go
 * package main
 * 
 * import (
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/emr"
 * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
 * )
 * 
 * func main() {
 * 	pulumi.Run(func(ctx *pulumi.Context) error {
 * 		_, err := emr.NewCluster(ctx, "example", &emr.ClusterArgs{
 * 			Steps: emr.ClusterStepArray{
 * 				&emr.ClusterStepArgs{
 * 					ActionOnFailure: pulumi.String("TERMINATE_CLUSTER"),
 * 					Name:            pulumi.String("Setup Hadoop Debugging"),
 * 					HadoopJarStep: &emr.ClusterStepHadoopJarStepArgs{
 * 						Jar: pulumi.String("command-runner.jar"),
 * 						Args: pulumi.StringArray{
 * 							pulumi.String("state-pusher-script"),
 * 						},
 * 					},
 * 				},
 * 			},
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		return nil
 * 	})
 * }
 * ```
 * {{% /example %}}
 * {{% example %}}
 * ### Multiple Node Master Instance Group
 * 
 * Available in EMR version 5.23.0 and later, an EMR Cluster can be launched with three master nodes for high availability. Additional information about this functionality and its requirements can be found in the [EMR Management Guide](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-plan-ha.html).
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 * 
 * // This configuration is for illustrative purposes and highlights
 * // only relevant configurations for working with this functionality.
 * // Map public IP on launch must be enabled for public (Internet accessible) subnets
 * // ... other configuration ...
 * const exampleSubnet = new aws.ec2.Subnet("exampleSubnet", {mapPublicIpOnLaunch: true});
 * // ... other configuration ...
 * const exampleCluster = new aws.emr.Cluster("exampleCluster", {
 *     releaseLabel: "emr-5.24.1",
 *     terminationProtection: true,
 *     ec2Attributes: {
 *         subnetId: exampleSubnet.id,
 *     },
 *     masterInstanceGroup: {
 *         instanceCount: 3,
 *     },
 *     coreInstanceGroup: {},
 * });
 * ```
 * ```python
 * import pulumi
 * import pulumi_aws as aws
 * 
 * # This configuration is for illustrative purposes and highlights
 * # only relevant configurations for working with this functionality.
 * # Map public IP on launch must be enabled for public (Internet accessible) subnets
 * # ... other configuration ...
 * example_subnet = aws.ec2.Subnet("exampleSubnet", map_public_ip_on_launch=True)
 * # ... other configuration ...
 * example_cluster = aws.emr.Cluster("exampleCluster",
 *     release_label="emr-5.24.1",
 *     termination_protection=True,
 *     ec2_attributes=aws.emr.ClusterEc2AttributesArgs(
 *         subnet_id=example_subnet.id,
 *     ),
 *     master_instance_group=aws.emr.ClusterMasterInstanceGroupArgs(
 *         instance_count=3,
 *     ),
 *     core_instance_group=aws.emr.ClusterCoreInstanceGroupArgs())
 * ```
 * ```csharp
 * using Pulumi;
 * using Aws = Pulumi.Aws;
 * 
 * class MyStack : Stack
 * {
 *     public MyStack()
 *     {
 *         // This configuration is for illustrative purposes and highlights
 *         // only relevant configurations for working with this functionality.
 *         // Map public IP on launch must be enabled for public (Internet accessible) subnets
 *         // ... other configuration ...
 *         var exampleSubnet = new Aws.Ec2.Subnet("exampleSubnet", new Aws.Ec2.SubnetArgs
 *         {
 *             MapPublicIpOnLaunch = true,
 *         });
 *         // ... other configuration ...
 *         var exampleCluster = new Aws.Emr.Cluster("exampleCluster", new Aws.Emr.ClusterArgs
 *         {
 *             ReleaseLabel = "emr-5.24.1",
 *             TerminationProtection = true,
 *             Ec2Attributes = new Aws.Emr.Inputs.ClusterEc2AttributesArgs
 *             {
 *                 SubnetId = exampleSubnet.Id,
 *             },
 *             MasterInstanceGroup = new Aws.Emr.Inputs.ClusterMasterInstanceGroupArgs
 *             {
 *                 InstanceCount = 3,
 *             },
 *             CoreInstanceGroup = ,
 *         });
 *     }
 * 
 * }
 * ```
 * ```go
 * package main
 * 
 * import (
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/ec2"
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/emr"
 * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
 * )
 * 
 * func main() {
 * 	pulumi.Run(func(ctx *pulumi.Context) error {
 * 		exampleSubnet, err := ec2.NewSubnet(ctx, "exampleSubnet", &ec2.SubnetArgs{
 * 			MapPublicIpOnLaunch: pulumi.Bool(true),
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		_, err = emr.NewCluster(ctx, "exampleCluster", &emr.ClusterArgs{
 * 			ReleaseLabel:          pulumi.String("emr-5.24.1"),
 * 			TerminationProtection: pulumi.Bool(true),
 * 			Ec2Attributes: &emr.ClusterEc2AttributesArgs{
 * 				SubnetId: exampleSubnet.ID(),
 * 			},
 * 			MasterInstanceGroup: &emr.ClusterMasterInstanceGroupArgs{
 * 				InstanceCount: pulumi.Int(3),
 * 			},
 * 			CoreInstanceGroup: nil,
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		return nil
 * 	})
 * }
 * ```
 * {{% /example %}}
 * {{% example %}}
 * ### Bootable Cluster
 * 
 * **NOTE:** This configuration demonstrates a minimal configuration needed to boot an example EMR Cluster. It is not meant to display best practices. As with all examples, use at your own risk.
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 * 
 * const mainVpc = new aws.ec2.Vpc("mainVpc", {
 *     cidrBlock: "168.31.0.0/16",
 *     enableDnsHostnames: true,
 *     tags: {
 *         name: "emr_test",
 *     },
 * });
 * const mainSubnet = new aws.ec2.Subnet("mainSubnet", {
 *     vpcId: mainVpc.id,
 *     cidrBlock: "168.31.0.0/20",
 *     tags: {
 *         name: "emr_test",
 *     },
 * });
 * // IAM role for EMR Service
 * const iamEmrServiceRole = new aws.iam.Role("iamEmrServiceRole", {assumeRolePolicy: `{
 *   "Version": "2008-10-17",
 *   "Statement": [
 *     {
 *       "Sid": "",
 *       "Effect": "Allow",
 *       "Principal": {
 *         "Service": "elasticmapreduce.amazonaws.com"
 *       },
 *       "Action": "sts:AssumeRole"
 *     }
 *   ]
 * }
 * `});
 * // IAM Role for EC2 Instance Profile
 * const iamEmrProfileRole = new aws.iam.Role("iamEmrProfileRole", {assumeRolePolicy: `{
 *   "Version": "2008-10-17",
 *   "Statement": [
 *     {
 *       "Sid": "",
 *       "Effect": "Allow",
 *       "Principal": {
 *         "Service": "ec2.amazonaws.com"
 *       },
 *       "Action": "sts:AssumeRole"
 *     }
 *   ]
 * }
 * `});
 * const emrProfile = new aws.iam.InstanceProfile("emrProfile", {role: iamEmrProfileRole.name});
 * const cluster = new aws.emr.Cluster("cluster", {
 *     releaseLabel: "emr-4.6.0",
 *     applications: ["Spark"],
 *     ec2Attributes: {
 *         subnetId: mainSubnet.id,
 *         emrManagedMasterSecurityGroup: aws_security_group.allow_all.id,
 *         emrManagedSlaveSecurityGroup: aws_security_group.allow_all.id,
 *         instanceProfile: emrProfile.arn,
 *     },
 *     masterInstanceGroup: {
 *         instanceType: "m5.xlarge",
 *     },
 *     coreInstanceGroup: {
 *         instanceCount: 1,
 *         instanceType: "m5.xlarge",
 *     },
 *     tags: {
 *         role: "rolename",
 *         dns_zone: "env_zone",
 *         env: "env",
 *         name: "name-env",
 *     },
 *     bootstrapActions: [{
 *         path: "s3://elasticmapreduce/bootstrap-actions/run-if",
 *         name: "runif",
 *         args: [
 *             "instance.isMaster=true",
 *             "echo running on master node",
 *         ],
 *     }],
 *     configurationsJson: `  [
 *     {
 *       "Classification": "hadoop-env",
 *       "Configurations": [
 *         {
 *           "Classification": "export",
 *           "Properties": {
 *             "JAVA_HOME": "/usr/lib/jvm/java-1.8.0"
 *           }
 *         }
 *       ],
 *       "Properties": {}
 *     },
 *     {
 *       "Classification": "spark-env",
 *       "Configurations": [
 *         {
 *           "Classification": "export",
 *           "Properties": {
 *             "JAVA_HOME": "/usr/lib/jvm/java-1.8.0"
 *           }
 *         }
 *       ],
 *       "Properties": {}
 *     }
 *   ]
 * `,
 *     serviceRole: iamEmrServiceRole.arn,
 * });
 * const allowAccess = new aws.ec2.SecurityGroup("allowAccess", {
 *     description: "Allow inbound traffic",
 *     vpcId: mainVpc.id,
 *     ingress: [{
 *         fromPort: 0,
 *         toPort: 0,
 *         protocol: "-1",
 *         cidrBlocks: mainVpc.cidrBlock,
 *     }],
 *     egress: [{
 *         fromPort: 0,
 *         toPort: 0,
 *         protocol: "-1",
 *         cidrBlocks: ["0.0.0.0/0"],
 *     }],
 *     tags: {
 *         name: "emr_test",
 *     },
 * }, {
 *     dependsOn: [mainSubnet],
 * });
 * const gw = new aws.ec2.InternetGateway("gw", {vpcId: mainVpc.id});
 * const routeTable = new aws.ec2.RouteTable("routeTable", {
 *     vpcId: mainVpc.id,
 *     routes: [{
 *         cidrBlock: "0.0.0.0/0",
 *         gatewayId: gw.id,
 *     }],
 * });
 * const mainRouteTableAssociation = new aws.ec2.MainRouteTableAssociation("mainRouteTableAssociation", {
 *     vpcId: mainVpc.id,
 *     routeTableId: routeTable.id,
 * });
 * //##
 * const iamEmrServicePolicy = new aws.iam.RolePolicy("iamEmrServicePolicy", {
 *     role: iamEmrServiceRole.id,
 *     policy: `{
 *     "Version": "2012-10-17",
 *     "Statement": [{
 *         "Effect": "Allow",
 *         "Resource": "*",
 *         "Action": [
 *             "ec2:AuthorizeSecurityGroupEgress",
 *             "ec2:AuthorizeSecurityGroupIngress",
 *             "ec2:CancelSpotInstanceRequests",
 *             "ec2:CreateNetworkInterface",
 *             "ec2:CreateSecurityGroup",
 *             "ec2:CreateTags",
 *             "ec2:DeleteNetworkInterface",
 *             "ec2:DeleteSecurityGroup",
 *             "ec2:DeleteTags",
 *             "ec2:DescribeAvailabilityZones",
 *             "ec2:DescribeAccountAttributes",
 *             "ec2:DescribeDhcpOptions",
 *             "ec2:DescribeInstanceStatus",
 *             "ec2:DescribeInstances",
 *             "ec2:DescribeKeyPairs",
 *             "ec2:DescribeNetworkAcls",
 *             "ec2:DescribeNetworkInterfaces",
 *             "ec2:DescribePrefixLists",
 *             "ec2:DescribeRouteTables",
 *             "ec2:DescribeSecurityGroups",
 *             "ec2:DescribeSpotInstanceRequests",
 *             "ec2:DescribeSpotPriceHistory",
 *             "ec2:DescribeSubnets",
 *             "ec2:DescribeVpcAttribute",
 *             "ec2:DescribeVpcEndpoints",
 *             "ec2:DescribeVpcEndpointServices",
 *             "ec2:DescribeVpcs",
 *             "ec2:DetachNetworkInterface",
 *             "ec2:ModifyImageAttribute",
 *             "ec2:ModifyInstanceAttribute",
 *             "ec2:RequestSpotInstances",
 *             "ec2:RevokeSecurityGroupEgress",
 *             "ec2:RunInstances",
 *             "ec2:TerminateInstances",
 *             "ec2:DeleteVolume",
 *             "ec2:DescribeVolumeStatus",
 *             "ec2:DescribeVolumes",
 *             "ec2:DetachVolume",
 *             "iam:GetRole",
 *             "iam:GetRolePolicy",
 *             "iam:ListInstanceProfiles",
 *             "iam:ListRolePolicies",
 *             "iam:PassRole",
 *             "s3:CreateBucket",
 *             "s3:Get*",
 *             "s3:List*",
 *             "sdb:BatchPutAttributes",
 *             "sdb:Select",
 *             "sqs:CreateQueue",
 *             "sqs:Delete*",
 *             "sqs:GetQueue*",
 *             "sqs:PurgeQueue",
 *             "sqs:ReceiveMessage"
 *         ]
 *     }]
 * }
 * `,
 * });
 * const iamEmrProfilePolicy = new aws.iam.RolePolicy("iamEmrProfilePolicy", {
 *     role: iamEmrProfileRole.id,
 *     policy: `{
 *     "Version": "2012-10-17",
 *     "Statement": [{
 *         "Effect": "Allow",
 *         "Resource": "*",
 *         "Action": [
 *             "cloudwatch:*",
 *             "dynamodb:*",
 *             "ec2:Describe*",
 *             "elasticmapreduce:Describe*",
 *             "elasticmapreduce:ListBootstrapActions",
 *             "elasticmapreduce:ListClusters",
 *             "elasticmapreduce:ListInstanceGroups",
 *             "elasticmapreduce:ListInstances",
 *             "elasticmapreduce:ListSteps",
 *             "kinesis:CreateStream",
 *             "kinesis:DeleteStream",
 *             "kinesis:DescribeStream",
 *             "kinesis:GetRecords",
 *             "kinesis:GetShardIterator",
 *             "kinesis:MergeShards",
 *             "kinesis:PutRecord",
 *             "kinesis:SplitShard",
 *             "rds:Describe*",
 *             "s3:*",
 *             "sdb:*",
 *             "sns:*",
 *             "sqs:*"
 *         ]
 *     }]
 * }
 * `,
 * });
 * ```
 * ```python
 * import pulumi
 * import pulumi_aws as aws
 * 
 * main_vpc = aws.ec2.Vpc("mainVpc",
 *     cidr_block="168.31.0.0/16",
 *     enable_dns_hostnames=True,
 *     tags={
 *         "name": "emr_test",
 *     })
 * main_subnet = aws.ec2.Subnet("mainSubnet",
 *     vpc_id=main_vpc.id,
 *     cidr_block="168.31.0.0/20",
 *     tags={
 *         "name": "emr_test",
 *     })
 * # IAM role for EMR Service
 * iam_emr_service_role = aws.iam.Role("iamEmrServiceRole", assume_role_policy="""{
 *   "Version": "2008-10-17",
 *   "Statement": [
 *     {
 *       "Sid": "",
 *       "Effect": "Allow",
 *       "Principal": {
 *         "Service": "elasticmapreduce.amazonaws.com"
 *       },
 *       "Action": "sts:AssumeRole"
 *     }
 *   ]
 * }
 * """)
 * # IAM Role for EC2 Instance Profile
 * iam_emr_profile_role = aws.iam.Role("iamEmrProfileRole", assume_role_policy="""{
 *   "Version": "2008-10-17",
 *   "Statement": [
 *     {
 *       "Sid": "",
 *       "Effect": "Allow",
 *       "Principal": {
 *         "Service": "ec2.amazonaws.com"
 *       },
 *       "Action": "sts:AssumeRole"
 *     }
 *   ]
 * }
 * """)
 * emr_profile = aws.iam.InstanceProfile("emrProfile", role=iam_emr_profile_role.name)
 * cluster = aws.emr.Cluster("cluster",
 *     release_label="emr-4.6.0",
 *     applications=["Spark"],
 *     ec2_attributes=aws.emr.ClusterEc2AttributesArgs(
 *         subnet_id=main_subnet.id,
 *         emr_managed_master_security_group=aws_security_group["allow_all"]["id"],
 *         emr_managed_slave_security_group=aws_security_group["allow_all"]["id"],
 *         instance_profile=emr_profile.arn,
 *     ),
 *     master_instance_group=aws.emr.ClusterMasterInstanceGroupArgs(
 *         instance_type="m5.xlarge",
 *     ),
 *     core_instance_group=aws.emr.ClusterCoreInstanceGroupArgs(
 *         instance_count=1,
 *         instance_type="m5.xlarge",
 *     ),
 *     tags={
 *         "role": "rolename",
 *         "dns_zone": "env_zone",
 *         "env": "env",
 *         "name": "name-env",
 *     },
 *     bootstrap_actions=[aws.emr.ClusterBootstrapActionArgs(
 *         path="s3://elasticmapreduce/bootstrap-actions/run-if",
 *         name="runif",
 *         args=[
 *             "instance.isMaster=true",
 *             "echo running on master node",
 *         ],
 *     )],
 *     configurations_json="""  [
 *     {
 *       "Classification": "hadoop-env",
 *       "Configurations": [
 *         {
 *           "Classification": "export",
 *           "Properties": {
 *             "JAVA_HOME": "/usr/lib/jvm/java-1.8.0"
 *           }
 *         }
 *       ],
 *       "Properties": {}
 *     },
 *     {
 *       "Classification": "spark-env",
 *       "Configurations": [
 *         {
 *           "Classification": "export",
 *           "Properties": {
 *             "JAVA_HOME": "/usr/lib/jvm/java-1.8.0"
 *           }
 *         }
 *       ],
 *       "Properties": {}
 *     }
 *   ]
 * """,
 *     service_role=iam_emr_service_role.arn)
 * allow_access = aws.ec2.SecurityGroup("allowAccess",
 *     description="Allow inbound traffic",
 *     vpc_id=main_vpc.id,
 *     ingress=[aws.ec2.SecurityGroupIngressArgs(
 *         from_port=0,
 *         to_port=0,
 *         protocol="-1",
 *         cidr_blocks=main_vpc.cidr_block,
 *     )],
 *     egress=[aws.ec2.SecurityGroupEgressArgs(
 *         from_port=0,
 *         to_port=0,
 *         protocol="-1",
 *         cidr_blocks=["0.0.0.0/0"],
 *     )],
 *     tags={
 *         "name": "emr_test",
 *     },
 *     opts=pulumi.ResourceOptions(depends_on=[main_subnet]))
 * gw = aws.ec2.InternetGateway("gw", vpc_id=main_vpc.id)
 * route_table = aws.ec2.RouteTable("routeTable",
 *     vpc_id=main_vpc.id,
 *     routes=[aws.ec2.RouteTableRouteArgs(
 *         cidr_block="0.0.0.0/0",
 *         gateway_id=gw.id,
 *     )])
 * main_route_table_association = aws.ec2.MainRouteTableAssociation("mainRouteTableAssociation",
 *     vpc_id=main_vpc.id,
 *     route_table_id=route_table.id)
 * ###
 * iam_emr_service_policy = aws.iam.RolePolicy("iamEmrServicePolicy",
 *     role=iam_emr_service_role.id,
 *     policy="""{
 *     "Version": "2012-10-17",
 *     "Statement": [{
 *         "Effect": "Allow",
 *         "Resource": "*",
 *         "Action": [
 *             "ec2:AuthorizeSecurityGroupEgress",
 *             "ec2:AuthorizeSecurityGroupIngress",
 *             "ec2:CancelSpotInstanceRequests",
 *             "ec2:CreateNetworkInterface",
 *             "ec2:CreateSecurityGroup",
 *             "ec2:CreateTags",
 *             "ec2:DeleteNetworkInterface",
 *             "ec2:DeleteSecurityGroup",
 *             "ec2:DeleteTags",
 *             "ec2:DescribeAvailabilityZones",
 *             "ec2:DescribeAccountAttributes",
 *             "ec2:DescribeDhcpOptions",
 *             "ec2:DescribeInstanceStatus",
 *             "ec2:DescribeInstances",
 *             "ec2:DescribeKeyPairs",
 *             "ec2:DescribeNetworkAcls",
 *             "ec2:DescribeNetworkInterfaces",
 *             "ec2:DescribePrefixLists",
 *             "ec2:DescribeRouteTables",
 *             "ec2:DescribeSecurityGroups",
 *             "ec2:DescribeSpotInstanceRequests",
 *             "ec2:DescribeSpotPriceHistory",
 *             "ec2:DescribeSubnets",
 *             "ec2:DescribeVpcAttribute",
 *             "ec2:DescribeVpcEndpoints",
 *             "ec2:DescribeVpcEndpointServices",
 *             "ec2:DescribeVpcs",
 *             "ec2:DetachNetworkInterface",
 *             "ec2:ModifyImageAttribute",
 *             "ec2:ModifyInstanceAttribute",
 *             "ec2:RequestSpotInstances",
 *             "ec2:RevokeSecurityGroupEgress",
 *             "ec2:RunInstances",
 *             "ec2:TerminateInstances",
 *             "ec2:DeleteVolume",
 *             "ec2:DescribeVolumeStatus",
 *             "ec2:DescribeVolumes",
 *             "ec2:DetachVolume",
 *             "iam:GetRole",
 *             "iam:GetRolePolicy",
 *             "iam:ListInstanceProfiles",
 *             "iam:ListRolePolicies",
 *             "iam:PassRole",
 *             "s3:CreateBucket",
 *             "s3:Get*",
 *             "s3:List*",
 *             "sdb:BatchPutAttributes",
 *             "sdb:Select",
 *             "sqs:CreateQueue",
 *             "sqs:Delete*",
 *             "sqs:GetQueue*",
 *             "sqs:PurgeQueue",
 *             "sqs:ReceiveMessage"
 *         ]
 *     }]
 * }
 * """)
 * iam_emr_profile_policy = aws.iam.RolePolicy("iamEmrProfilePolicy",
 *     role=iam_emr_profile_role.id,
 *     policy="""{
 *     "Version": "2012-10-17",
 *     "Statement": [{
 *         "Effect": "Allow",
 *         "Resource": "*",
 *         "Action": [
 *             "cloudwatch:*",
 *             "dynamodb:*",
 *             "ec2:Describe*",
 *             "elasticmapreduce:Describe*",
 *             "elasticmapreduce:ListBootstrapActions",
 *             "elasticmapreduce:ListClusters",
 *             "elasticmapreduce:ListInstanceGroups",
 *             "elasticmapreduce:ListInstances",
 *             "elasticmapreduce:ListSteps",
 *             "kinesis:CreateStream",
 *             "kinesis:DeleteStream",
 *             "kinesis:DescribeStream",
 *             "kinesis:GetRecords",
 *             "kinesis:GetShardIterator",
 *             "kinesis:MergeShards",
 *             "kinesis:PutRecord",
 *             "kinesis:SplitShard",
 *             "rds:Describe*",
 *             "s3:*",
 *             "sdb:*",
 *             "sns:*",
 *             "sqs:*"
 *         ]
 *     }]
 * }
 * """)
 * ```
 * ```csharp
 * using Pulumi;
 * using Aws = Pulumi.Aws;
 * 
 * class MyStack : Stack
 * {
 *     public MyStack()
 *     {
 *         var mainVpc = new Aws.Ec2.Vpc("mainVpc", new Aws.Ec2.VpcArgs
 *         {
 *             CidrBlock = "168.31.0.0/16",
 *             EnableDnsHostnames = true,
 *             Tags = 
 *             {
 *                 { "name", "emr_test" },
 *             },
 *         });
 *         var mainSubnet = new Aws.Ec2.Subnet("mainSubnet", new Aws.Ec2.SubnetArgs
 *         {
 *             VpcId = mainVpc.Id,
 *             CidrBlock = "168.31.0.0/20",
 *             Tags = 
 *             {
 *                 { "name", "emr_test" },
 *             },
 *         });
 *         // IAM role for EMR Service
 *         var iamEmrServiceRole = new Aws.Iam.Role("iamEmrServiceRole", new Aws.Iam.RoleArgs
 *         {
 *             AssumeRolePolicy = @"{
 *   ""Version"": ""2008-10-17"",
 *   ""Statement"": [
 *     {
 *       ""Sid"": """",
 *       ""Effect"": ""Allow"",
 *       ""Principal"": {
 *         ""Service"": ""elasticmapreduce.amazonaws.com""
 *       },
 *       ""Action"": ""sts:AssumeRole""
 *     }
 *   ]
 * }
 * ",
 *         });
 *         // IAM Role for EC2 Instance Profile
 *         var iamEmrProfileRole = new Aws.Iam.Role("iamEmrProfileRole", new Aws.Iam.RoleArgs
 *         {
 *             AssumeRolePolicy = @"{
 *   ""Version"": ""2008-10-17"",
 *   ""Statement"": [
 *     {
 *       ""Sid"": """",
 *       ""Effect"": ""Allow"",
 *       ""Principal"": {
 *         ""Service"": ""ec2.amazonaws.com""
 *       },
 *       ""Action"": ""sts:AssumeRole""
 *     }
 *   ]
 * }
 * ",
 *         });
 *         var emrProfile = new Aws.Iam.InstanceProfile("emrProfile", new Aws.Iam.InstanceProfileArgs
 *         {
 *             Role = iamEmrProfileRole.Name,
 *         });
 *         var cluster = new Aws.Emr.Cluster("cluster", new Aws.Emr.ClusterArgs
 *         {
 *             ReleaseLabel = "emr-4.6.0",
 *             Applications = 
 *             {
 *                 "Spark",
 *             },
 *             Ec2Attributes = new Aws.Emr.Inputs.ClusterEc2AttributesArgs
 *             {
 *                 SubnetId = mainSubnet.Id,
 *                 EmrManagedMasterSecurityGroup = aws_security_group.Allow_all.Id,
 *                 EmrManagedSlaveSecurityGroup = aws_security_group.Allow_all.Id,
 *                 InstanceProfile = emrProfile.Arn,
 *             },
 *             MasterInstanceGroup = new Aws.Emr.Inputs.ClusterMasterInstanceGroupArgs
 *             {
 *                 InstanceType = "m5.xlarge",
 *             },
 *             CoreInstanceGroup = new Aws.Emr.Inputs.ClusterCoreInstanceGroupArgs
 *             {
 *                 InstanceCount = 1,
 *                 InstanceType = "m5.xlarge",
 *             },
 *             Tags = 
 *             {
 *                 { "role", "rolename" },
 *                 { "dns_zone", "env_zone" },
 *                 { "env", "env" },
 *                 { "name", "name-env" },
 *             },
 *             BootstrapActions = 
 *             {
 *                 new Aws.Emr.Inputs.ClusterBootstrapActionArgs
 *                 {
 *                     Path = "s3://elasticmapreduce/bootstrap-actions/run-if",
 *                     Name = "runif",
 *                     Args = 
 *                     {
 *                         "instance.isMaster=true",
 *                         "echo running on master node",
 *                     },
 *                 },
 *             },
 *             ConfigurationsJson = @"  [
 *     {
 *       ""Classification"": ""hadoop-env"",
 *       ""Configurations"": [
 *         {
 *           ""Classification"": ""export"",
 *           ""Properties"": {
 *             ""JAVA_HOME"": ""/usr/lib/jvm/java-1.8.0""
 *           }
 *         }
 *       ],
 *       ""Properties"": {}
 *     },
 *     {
 *       ""Classification"": ""spark-env"",
 *       ""Configurations"": [
 *         {
 *           ""Classification"": ""export"",
 *           ""Properties"": {
 *             ""JAVA_HOME"": ""/usr/lib/jvm/java-1.8.0""
 *           }
 *         }
 *       ],
 *       ""Properties"": {}
 *     }
 *   ]
 * ",
 *             ServiceRole = iamEmrServiceRole.Arn,
 *         });
 *         var allowAccess = new Aws.Ec2.SecurityGroup("allowAccess", new Aws.Ec2.SecurityGroupArgs
 *         {
 *             Description = "Allow inbound traffic",
 *             VpcId = mainVpc.Id,
 *             Ingress = 
 *             {
 *                 new Aws.Ec2.Inputs.SecurityGroupIngressArgs
 *                 {
 *                     FromPort = 0,
 *                     ToPort = 0,
 *                     Protocol = "-1",
 *                     CidrBlocks = mainVpc.CidrBlock,
 *                 },
 *             },
 *             Egress = 
 *             {
 *                 new Aws.Ec2.Inputs.SecurityGroupEgressArgs
 *                 {
 *                     FromPort = 0,
 *                     ToPort = 0,
 *                     Protocol = "-1",
 *                     CidrBlocks = 
 *                     {
 *                         "0.0.0.0/0",
 *                     },
 *                 },
 *             },
 *             Tags = 
 *             {
 *                 { "name", "emr_test" },
 *             },
 *         }, new CustomResourceOptions
 *         {
 *             DependsOn = 
 *             {
 *                 mainSubnet,
 *             },
 *         });
 *         var gw = new Aws.Ec2.InternetGateway("gw", new Aws.Ec2.InternetGatewayArgs
 *         {
 *             VpcId = mainVpc.Id,
 *         });
 *         var routeTable = new Aws.Ec2.RouteTable("routeTable", new Aws.Ec2.RouteTableArgs
 *         {
 *             VpcId = mainVpc.Id,
 *             Routes = 
 *             {
 *                 new Aws.Ec2.Inputs.RouteTableRouteArgs
 *                 {
 *                     CidrBlock = "0.0.0.0/0",
 *                     GatewayId = gw.Id,
 *                 },
 *             },
 *         });
 *         var mainRouteTableAssociation = new Aws.Ec2.MainRouteTableAssociation("mainRouteTableAssociation", new Aws.Ec2.MainRouteTableAssociationArgs
 *         {
 *             VpcId = mainVpc.Id,
 *             RouteTableId = routeTable.Id,
 *         });
 *         //##
 *         var iamEmrServicePolicy = new Aws.Iam.RolePolicy("iamEmrServicePolicy", new Aws.Iam.RolePolicyArgs
 *         {
 *             Role = iamEmrServiceRole.Id,
 *             Policy = @"{
 *     ""Version"": ""2012-10-17"",
 *     ""Statement"": [{
 *         ""Effect"": ""Allow"",
 *         ""Resource"": ""*"",
 *         ""Action"": [
 *             ""ec2:AuthorizeSecurityGroupEgress"",
 *             ""ec2:AuthorizeSecurityGroupIngress"",
 *             ""ec2:CancelSpotInstanceRequests"",
 *             ""ec2:CreateNetworkInterface"",
 *             ""ec2:CreateSecurityGroup"",
 *             ""ec2:CreateTags"",
 *             ""ec2:DeleteNetworkInterface"",
 *             ""ec2:DeleteSecurityGroup"",
 *             ""ec2:DeleteTags"",
 *             ""ec2:DescribeAvailabilityZones"",
 *             ""ec2:DescribeAccountAttributes"",
 *             ""ec2:DescribeDhcpOptions"",
 *             ""ec2:DescribeInstanceStatus"",
 *             ""ec2:DescribeInstances"",
 *             ""ec2:DescribeKeyPairs"",
 *             ""ec2:DescribeNetworkAcls"",
 *             ""ec2:DescribeNetworkInterfaces"",
 *             ""ec2:DescribePrefixLists"",
 *             ""ec2:DescribeRouteTables"",
 *             ""ec2:DescribeSecurityGroups"",
 *             ""ec2:DescribeSpotInstanceRequests"",
 *             ""ec2:DescribeSpotPriceHistory"",
 *             ""ec2:DescribeSubnets"",
 *             ""ec2:DescribeVpcAttribute"",
 *             ""ec2:DescribeVpcEndpoints"",
 *             ""ec2:DescribeVpcEndpointServices"",
 *             ""ec2:DescribeVpcs"",
 *             ""ec2:DetachNetworkInterface"",
 *             ""ec2:ModifyImageAttribute"",
 *             ""ec2:ModifyInstanceAttribute"",
 *             ""ec2:RequestSpotInstances"",
 *             ""ec2:RevokeSecurityGroupEgress"",
 *             ""ec2:RunInstances"",
 *             ""ec2:TerminateInstances"",
 *             ""ec2:DeleteVolume"",
 *             ""ec2:DescribeVolumeStatus"",
 *             ""ec2:DescribeVolumes"",
 *             ""ec2:DetachVolume"",
 *             ""iam:GetRole"",
 *             ""iam:GetRolePolicy"",
 *             ""iam:ListInstanceProfiles"",
 *             ""iam:ListRolePolicies"",
 *             ""iam:PassRole"",
 *             ""s3:CreateBucket"",
 *             ""s3:Get*"",
 *             ""s3:List*"",
 *             ""sdb:BatchPutAttributes"",
 *             ""sdb:Select"",
 *             ""sqs:CreateQueue"",
 *             ""sqs:Delete*"",
 *             ""sqs:GetQueue*"",
 *             ""sqs:PurgeQueue"",
 *             ""sqs:ReceiveMessage""
 *         ]
 *     }]
 * }
 * ",
 *         });
 *         var iamEmrProfilePolicy = new Aws.Iam.RolePolicy("iamEmrProfilePolicy", new Aws.Iam.RolePolicyArgs
 *         {
 *             Role = iamEmrProfileRole.Id,
 *             Policy = @"{
 *     ""Version"": ""2012-10-17"",
 *     ""Statement"": [{
 *         ""Effect"": ""Allow"",
 *         ""Resource"": ""*"",
 *         ""Action"": [
 *             ""cloudwatch:*"",
 *             ""dynamodb:*"",
 *             ""ec2:Describe*"",
 *             ""elasticmapreduce:Describe*"",
 *             ""elasticmapreduce:ListBootstrapActions"",
 *             ""elasticmapreduce:ListClusters"",
 *             ""elasticmapreduce:ListInstanceGroups"",
 *             ""elasticmapreduce:ListInstances"",
 *             ""elasticmapreduce:ListSteps"",
 *             ""kinesis:CreateStream"",
 *             ""kinesis:DeleteStream"",
 *             ""kinesis:DescribeStream"",
 *             ""kinesis:GetRecords"",
 *             ""kinesis:GetShardIterator"",
 *             ""kinesis:MergeShards"",
 *             ""kinesis:PutRecord"",
 *             ""kinesis:SplitShard"",
 *             ""rds:Describe*"",
 *             ""s3:*"",
 *             ""sdb:*"",
 *             ""sns:*"",
 *             ""sqs:*""
 *         ]
 *     }]
 * }
 * ",
 *         });
 *     }
 * 
 * }
 * ```
 * ```go
 * package main
 * 
 * import (
 * 	"fmt"
 * 
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/ec2"
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/emr"
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/iam"
 * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
 * )
 * 
 * func main() {
 * 	pulumi.Run(func(ctx *pulumi.Context) error {
 * 		mainVpc, err := ec2.NewVpc(ctx, "mainVpc", &ec2.VpcArgs{
 * 			CidrBlock:          pulumi.String("168.31.0.0/16"),
 * 			EnableDnsHostnames: pulumi.Bool(true),
 * 			Tags: pulumi.StringMap{
 * 				"name": pulumi.String("emr_test"),
 * 			},
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		mainSubnet, err := ec2.NewSubnet(ctx, "mainSubnet", &ec2.SubnetArgs{
 * 			VpcId:     mainVpc.ID(),
 * 			CidrBlock: pulumi.String("168.31.0.0/20"),
 * 			Tags: pulumi.StringMap{
 * 				"name": pulumi.String("emr_test"),
 * 			},
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		iamEmrServiceRole, err := iam.NewRole(ctx, "iamEmrServiceRole", &iam.RoleArgs{
 * 			AssumeRolePolicy: pulumi.Any(fmt.Sprintf("%v%v%v%v%v%v%v%v%v%v%v%v%v", "{\n", "  \"Version\": \"2008-10-17\",\n", "  \"Statement\": [\n", "    {\n", "      \"Sid\": \"\",\n", "      \"Effect\": \"Allow\",\n", "      \"Principal\": {\n", "        \"Service\": \"elasticmapreduce.amazonaws.com\"\n", "      },\n", "      \"Action\": \"sts:AssumeRole\"\n", "    }\n", "  ]\n", "}\n")),
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		iamEmrProfileRole, err := iam.NewRole(ctx, "iamEmrProfileRole", &iam.RoleArgs{
 * 			AssumeRolePolicy: pulumi.Any(fmt.Sprintf("%v%v%v%v%v%v%v%v%v%v%v%v%v", "{\n", "  \"Version\": \"2008-10-17\",\n", "  \"Statement\": [\n", "    {\n", "      \"Sid\": \"\",\n", "      \"Effect\": \"Allow\",\n", "      \"Principal\": {\n", "        \"Service\": \"ec2.amazonaws.com\"\n", "      },\n", "      \"Action\": \"sts:AssumeRole\"\n", "    }\n", "  ]\n", "}\n")),
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		emrProfile, err := iam.NewInstanceProfile(ctx, "emrProfile", &iam.InstanceProfileArgs{
 * 			Role: iamEmrProfileRole.Name,
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		_, err = emr.NewCluster(ctx, "cluster", &emr.ClusterArgs{
 * 			ReleaseLabel: pulumi.String("emr-4.6.0"),
 * 			Applications: pulumi.StringArray{
 * 				pulumi.String("Spark"),
 * 			},
 * 			Ec2Attributes: &emr.ClusterEc2AttributesArgs{
 * 				SubnetId:                      mainSubnet.ID(),
 * 				EmrManagedMasterSecurityGroup: pulumi.Any(aws_security_group.Allow_all.Id),
 * 				EmrManagedSlaveSecurityGroup:  pulumi.Any(aws_security_group.Allow_all.Id),
 * 				InstanceProfile:               emrProfile.Arn,
 * 			},
 * 			MasterInstanceGroup: &emr.ClusterMasterInstanceGroupArgs{
 * 				InstanceType: pulumi.String("m5.xlarge"),
 * 			},
 * 			CoreInstanceGroup: &emr.ClusterCoreInstanceGroupArgs{
 * 				InstanceCount: pulumi.Int(1),
 * 				InstanceType:  pulumi.String("m5.xlarge"),
 * 			},
 * 			Tags: pulumi.StringMap{
 * 				"role":     pulumi.String("rolename"),
 * 				"dns_zone": pulumi.String("env_zone"),
 * 				"env":      pulumi.String("env"),
 * 				"name":     pulumi.String("name-env"),
 * 			},
 * 			BootstrapActions: emr.ClusterBootstrapActionArray{
 * 				&emr.ClusterBootstrapActionArgs{
 * 					Path: pulumi.String("s3://elasticmapreduce/bootstrap-actions/run-if"),
 * 					Name: pulumi.String("runif"),
 * 					Args: pulumi.StringArray{
 * 						pulumi.String("instance.isMaster=true"),
 * 						pulumi.String("echo running on master node"),
 * 					},
 * 				},
 * 			},
 * 			ConfigurationsJson: pulumi.String(fmt.Sprintf("%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v", "  [\n", "    {\n", "      \"Classification\": \"hadoop-env\",\n", "      \"Configurations\": [\n", "        {\n", "          \"Classification\": \"export\",\n", "          \"Properties\": {\n", "            \"JAVA_HOME\": \"/usr/lib/jvm/java-1.8.0\"\n", "          }\n", "        }\n", "      ],\n", "      \"Properties\": {}\n", "    },\n", "    {\n", "      \"Classification\": \"spark-env\",\n", "      \"Configurations\": [\n", "        {\n", "          \"Classification\": \"export\",\n", "          \"Properties\": {\n", "            \"JAVA_HOME\": \"/usr/lib/jvm/java-1.8.0\"\n", "          }\n", "        }\n", "      ],\n", "      \"Properties\": {}\n", "    }\n", "  ]\n")),
 * 			ServiceRole:        iamEmrServiceRole.Arn,
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		_, err = ec2.NewSecurityGroup(ctx, "allowAccess", &ec2.SecurityGroupArgs{
 * 			Description: pulumi.String("Allow inbound traffic"),
 * 			VpcId:       mainVpc.ID(),
 * 			Ingress: ec2.SecurityGroupIngressArray{
 * 				&ec2.SecurityGroupIngressArgs{
 * 					FromPort:   pulumi.Int(0),
 * 					ToPort:     pulumi.Int(0),
 * 					Protocol:   pulumi.String("-1"),
 * 					CidrBlocks: mainVpc.CidrBlock,
 * 				},
 * 			},
 * 			Egress: ec2.SecurityGroupEgressArray{
 * 				&ec2.SecurityGroupEgressArgs{
 * 					FromPort: pulumi.Int(0),
 * 					ToPort:   pulumi.Int(0),
 * 					Protocol: pulumi.String("-1"),
 * 					CidrBlocks: pulumi.StringArray{
 * 						pulumi.String("0.0.0.0/0"),
 * 					},
 * 				},
 * 			},
 * 			Tags: pulumi.StringMap{
 * 				"name": pulumi.String("emr_test"),
 * 			},
 * 		}, pulumi.DependsOn([]pulumi.Resource{
 * 			mainSubnet,
 * 		}))
 * 		if err != nil {
 * 			return err
 * 		}
 * 		gw, err := ec2.NewInternetGateway(ctx, "gw", &ec2.InternetGatewayArgs{
 * 			VpcId: mainVpc.ID(),
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		routeTable, err := ec2.NewRouteTable(ctx, "routeTable", &ec2.RouteTableArgs{
 * 			VpcId: mainVpc.ID(),
 * 			Routes: ec2.RouteTableRouteArray{
 * 				&ec2.RouteTableRouteArgs{
 * 					CidrBlock: pulumi.String("0.0.0.0/0"),
 * 					GatewayId: gw.ID(),
 * 				},
 * 			},
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		_, err = ec2.NewMainRouteTableAssociation(ctx, "mainRouteTableAssociation", &ec2.MainRouteTableAssociationArgs{
 * 			VpcId:        mainVpc.ID(),
 * 			RouteTableId: routeTable.ID(),
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		_, err = iam.NewRolePolicy(ctx, "iamEmrServicePolicy", &iam.RolePolicyArgs{
 * 			Role:   iamEmrServiceRole.ID(),
 * 			Policy: pulumi.Any(fmt.Sprintf("%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v", "{\n", "    \"Version\": \"2012-10-17\",\n", "    \"Statement\": [{\n", "        \"Effect\": \"Allow\",\n", "        \"Resource\": \"*\",\n", "        \"Action\": [\n", "            \"ec2:AuthorizeSecurityGroupEgress\",\n", "            \"ec2:AuthorizeSecurityGroupIngress\",\n", "            \"ec2:CancelSpotInstanceRequests\",\n", "            \"ec2:CreateNetworkInterface\",\n", "            \"ec2:CreateSecurityGroup\",\n", "            \"ec2:CreateTags\",\n", "            \"ec2:DeleteNetworkInterface\",\n", "            \"ec2:DeleteSecurityGroup\",\n", "            \"ec2:DeleteTags\",\n", "            \"ec2:DescribeAvailabilityZones\",\n", "            \"ec2:DescribeAccountAttributes\",\n", "            \"ec2:DescribeDhcpOptions\",\n", "            \"ec2:DescribeInstanceStatus\",\n", "            \"ec2:DescribeInstances\",\n", "            \"ec2:DescribeKeyPairs\",\n", "            \"ec2:DescribeNetworkAcls\",\n", "            \"ec2:DescribeNetworkInterfaces\",\n", "            \"ec2:DescribePrefixLists\",\n", "            \"ec2:DescribeRouteTables\",\n", "            \"ec2:DescribeSecurityGroups\",\n", "            \"ec2:DescribeSpotInstanceRequests\",\n", "            \"ec2:DescribeSpotPriceHistory\",\n", "            \"ec2:DescribeSubnets\",\n", "            \"ec2:DescribeVpcAttribute\",\n", "            \"ec2:DescribeVpcEndpoints\",\n", "            \"ec2:DescribeVpcEndpointServices\",\n", "            \"ec2:DescribeVpcs\",\n", "            \"ec2:DetachNetworkInterface\",\n", "            \"ec2:ModifyImageAttribute\",\n", "            \"ec2:ModifyInstanceAttribute\",\n", "            \"ec2:RequestSpotInstances\",\n", "            \"ec2:RevokeSecurityGroupEgress\",\n", "            \"ec2:RunInstances\",\n", "            \"ec2:TerminateInstances\",\n", "            \"ec2:DeleteVolume\",\n", "            \"ec2:DescribeVolumeStatus\",\n", "            \"ec2:DescribeVolumes\",\n", "            \"ec2:DetachVolume\",\n", "            \"iam:GetRole\",\n", "            \"iam:GetRolePolicy\",\n", "            \"iam:ListInstanceProfiles\",\n", "            \"iam:ListRolePolicies\",\n", "            \"iam:PassRole\",\n", "            \"s3:CreateBucket\",\n", "            \"s3:Get*\",\n", "            \"s3:List*\",\n", "            \"sdb:BatchPutAttributes\",\n", "            \"sdb:Select\",\n", "            \"sqs:CreateQueue\",\n", "            \"sqs:Delete*\",\n", "            \"sqs:GetQueue*\",\n", "            \"sqs:PurgeQueue\",\n", "            \"sqs:ReceiveMessage\"\n", "        ]\n", "    }]\n", "}\n")),
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		_, err = iam.NewRolePolicy(ctx, "iamEmrProfilePolicy", &iam.RolePolicyArgs{
 * 			Role:   iamEmrProfileRole.ID(),
 * 			Policy: pulumi.Any(fmt.Sprintf("%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v%v", "{\n", "    \"Version\": \"2012-10-17\",\n", "    \"Statement\": [{\n", "        \"Effect\": \"Allow\",\n", "        \"Resource\": \"*\",\n", "        \"Action\": [\n", "            \"cloudwatch:*\",\n", "            \"dynamodb:*\",\n", "            \"ec2:Describe*\",\n", "            \"elasticmapreduce:Describe*\",\n", "            \"elasticmapreduce:ListBootstrapActions\",\n", "            \"elasticmapreduce:ListClusters\",\n", "            \"elasticmapreduce:ListInstanceGroups\",\n", "            \"elasticmapreduce:ListInstances\",\n", "            \"elasticmapreduce:ListSteps\",\n", "            \"kinesis:CreateStream\",\n", "            \"kinesis:DeleteStream\",\n", "            \"kinesis:DescribeStream\",\n", "            \"kinesis:GetRecords\",\n", "            \"kinesis:GetShardIterator\",\n", "            \"kinesis:MergeShards\",\n", "            \"kinesis:PutRecord\",\n", "            \"kinesis:SplitShard\",\n", "            \"rds:Describe*\",\n", "            \"s3:*\",\n", "            \"sdb:*\",\n", "            \"sns:*\",\n", "            \"sqs:*\"\n", "        ]\n", "    }]\n", "}\n")),
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		return nil
 * 	})
 * }
 * ```
 * {{% /example %}}
 * {{% /examples %}}
 * 
 * ## Import
 * 
 * EMR clusters can be imported using the `id`, e.g.,
 * 
 * ```sh
 *  $ pulumi import aws:emr/cluster:Cluster cluster j-123456ABCDEF
 * ```
 * 
 *  Since the API does not return the actual values for Kerberos configurations, environments with those configurations will need to use the resource options configuration block `ignoreChanges` argument available to all provider resources to prevent perpetual differences, e.g. terraform resource "aws_emr_cluster" "example" {
 * 
 *  # ... other configuration ...
 * 
 *  lifecycle {
 * 
 * 
 * 
 *  ignore_changes = [kerberos_attributes]
 * 
 *  } } 
 */
@ResourceType(type="aws:emr/cluster:Cluster")
public class Cluster extends io.pulumi.resources.CustomResource {
    /**
     * JSON string for selecting additional features such as adding proxy information. Note: Currently there is no API to retrieve the value of this argument after EMR cluster creation from provider, therefore this provider cannot detect drift from the actual EMR cluster if its value is changed outside this provider.
     * 
     */
    @Export(name="additionalInfo", type=String.class, parameters={})
    private Output</* @Nullable */ String> additionalInfo;

    /**
     * @return JSON string for selecting additional features such as adding proxy information. Note: Currently there is no API to retrieve the value of this argument after EMR cluster creation from provider, therefore this provider cannot detect drift from the actual EMR cluster if its value is changed outside this provider.
     * 
     */
    public Output</* @Nullable */ String> getAdditionalInfo() {
        return this.additionalInfo;
    }
    /**
     * List of applications for the cluster. Valid values are: `Flink`, `Hadoop`, `Hive`, `Mahout`, `Pig`, `Spark`, and `JupyterHub` (as of EMR 5.14.0). Case insensitive.
     * 
     */
    @Export(name="applications", type=List.class, parameters={String.class})
    private Output</* @Nullable */ List<String>> applications;

    /**
     * @return List of applications for the cluster. Valid values are: `Flink`, `Hadoop`, `Hive`, `Mahout`, `Pig`, `Spark`, and `JupyterHub` (as of EMR 5.14.0). Case insensitive.
     * 
     */
    public Output</* @Nullable */ List<String>> getApplications() {
        return this.applications;
    }
    @Export(name="arn", type=String.class, parameters={})
    private Output<String> arn;

    public Output<String> getArn() {
        return this.arn;
    }
    /**
     * An auto-termination policy for an Amazon EMR cluster. An auto-termination policy defines the amount of idle time in seconds after which a cluster automatically terminates. See Auto Termination Policy Below.
     * 
     */
    @Export(name="autoTerminationPolicy", type=ClusterAutoTerminationPolicy.class, parameters={})
    private Output</* @Nullable */ ClusterAutoTerminationPolicy> autoTerminationPolicy;

    /**
     * @return An auto-termination policy for an Amazon EMR cluster. An auto-termination policy defines the amount of idle time in seconds after which a cluster automatically terminates. See Auto Termination Policy Below.
     * 
     */
    public Output</* @Nullable */ ClusterAutoTerminationPolicy> getAutoTerminationPolicy() {
        return this.autoTerminationPolicy;
    }
    /**
     * IAM role for automatic scaling policies. The IAM role provides permissions that the automatic scaling feature requires to launch and terminate EC2 instances in an instance group.
     * 
     */
    @Export(name="autoscalingRole", type=String.class, parameters={})
    private Output</* @Nullable */ String> autoscalingRole;

    /**
     * @return IAM role for automatic scaling policies. The IAM role provides permissions that the automatic scaling feature requires to launch and terminate EC2 instances in an instance group.
     * 
     */
    public Output</* @Nullable */ String> getAutoscalingRole() {
        return this.autoscalingRole;
    }
    /**
     * Ordered list of bootstrap actions that will be run before Hadoop is started on the cluster nodes. See below.
     * 
     */
    @Export(name="bootstrapActions", type=List.class, parameters={ClusterBootstrapAction.class})
    private Output</* @Nullable */ List<ClusterBootstrapAction>> bootstrapActions;

    /**
     * @return Ordered list of bootstrap actions that will be run before Hadoop is started on the cluster nodes. See below.
     * 
     */
    public Output</* @Nullable */ List<ClusterBootstrapAction>> getBootstrapActions() {
        return this.bootstrapActions;
    }
    @Export(name="clusterState", type=String.class, parameters={})
    private Output<String> clusterState;

    public Output<String> getClusterState() {
        return this.clusterState;
    }
    /**
     * Configuration classification that applies when provisioning cluster instances, which can include configurations for applications and software that run on the cluster. List of `configuration` blocks.
     * 
     */
    @Export(name="configurations", type=String.class, parameters={})
    private Output</* @Nullable */ String> configurations;

    /**
     * @return Configuration classification that applies when provisioning cluster instances, which can include configurations for applications and software that run on the cluster. List of `configuration` blocks.
     * 
     */
    public Output</* @Nullable */ String> getConfigurations() {
        return this.configurations;
    }
    /**
     * JSON string for supplying list of configurations for the EMR cluster.
     * 
     */
    @Export(name="configurationsJson", type=String.class, parameters={})
    private Output</* @Nullable */ String> configurationsJson;

    /**
     * @return JSON string for supplying list of configurations for the EMR cluster.
     * 
     */
    public Output</* @Nullable */ String> getConfigurationsJson() {
        return this.configurationsJson;
    }
    /**
     * Configuration block to use an [Instance Fleet](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-instance-fleet.html) for the core node type. Cannot be specified if any `core_instance_group` configuration blocks are set. Detailed below.
     * 
     */
    @Export(name="coreInstanceFleet", type=ClusterCoreInstanceFleet.class, parameters={})
    private Output<ClusterCoreInstanceFleet> coreInstanceFleet;

    /**
     * @return Configuration block to use an [Instance Fleet](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-instance-fleet.html) for the core node type. Cannot be specified if any `core_instance_group` configuration blocks are set. Detailed below.
     * 
     */
    public Output<ClusterCoreInstanceFleet> getCoreInstanceFleet() {
        return this.coreInstanceFleet;
    }
    /**
     * Configuration block to use an [Instance Group](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-instance-group-configuration.html#emr-plan-instance-groups) for the [core node type](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-master-core-task-nodes.html#emr-plan-core).
     * 
     */
    @Export(name="coreInstanceGroup", type=ClusterCoreInstanceGroup.class, parameters={})
    private Output<ClusterCoreInstanceGroup> coreInstanceGroup;

    /**
     * @return Configuration block to use an [Instance Group](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-instance-group-configuration.html#emr-plan-instance-groups) for the [core node type](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-master-core-task-nodes.html#emr-plan-core).
     * 
     */
    public Output<ClusterCoreInstanceGroup> getCoreInstanceGroup() {
        return this.coreInstanceGroup;
    }
    /**
     * Custom Amazon Linux AMI for the cluster (instead of an EMR-owned AMI). Available in Amazon EMR version 5.7.0 and later.
     * 
     */
    @Export(name="customAmiId", type=String.class, parameters={})
    private Output</* @Nullable */ String> customAmiId;

    /**
     * @return Custom Amazon Linux AMI for the cluster (instead of an EMR-owned AMI). Available in Amazon EMR version 5.7.0 and later.
     * 
     */
    public Output</* @Nullable */ String> getCustomAmiId() {
        return this.customAmiId;
    }
    /**
     * Size in GiB of the EBS root device volume of the Linux AMI that is used for each EC2 instance. Available in Amazon EMR version 4.x and later.
     * 
     */
    @Export(name="ebsRootVolumeSize", type=Integer.class, parameters={})
    private Output</* @Nullable */ Integer> ebsRootVolumeSize;

    /**
     * @return Size in GiB of the EBS root device volume of the Linux AMI that is used for each EC2 instance. Available in Amazon EMR version 4.x and later.
     * 
     */
    public Output</* @Nullable */ Integer> getEbsRootVolumeSize() {
        return this.ebsRootVolumeSize;
    }
    /**
     * Attributes for the EC2 instances running the job flow. See below.
     * 
     */
    @Export(name="ec2Attributes", type=ClusterEc2Attributes.class, parameters={})
    private Output</* @Nullable */ ClusterEc2Attributes> ec2Attributes;

    /**
     * @return Attributes for the EC2 instances running the job flow. See below.
     * 
     */
    public Output</* @Nullable */ ClusterEc2Attributes> getEc2Attributes() {
        return this.ec2Attributes;
    }
    /**
     * Switch on/off run cluster with no steps or when all steps are complete (default is on)
     * 
     */
    @Export(name="keepJobFlowAliveWhenNoSteps", type=Boolean.class, parameters={})
    private Output<Boolean> keepJobFlowAliveWhenNoSteps;

    /**
     * @return Switch on/off run cluster with no steps or when all steps are complete (default is on)
     * 
     */
    public Output<Boolean> getKeepJobFlowAliveWhenNoSteps() {
        return this.keepJobFlowAliveWhenNoSteps;
    }
    /**
     * Kerberos configuration for the cluster. See below.
     * 
     */
    @Export(name="kerberosAttributes", type=ClusterKerberosAttributes.class, parameters={})
    private Output</* @Nullable */ ClusterKerberosAttributes> kerberosAttributes;

    /**
     * @return Kerberos configuration for the cluster. See below.
     * 
     */
    public Output</* @Nullable */ ClusterKerberosAttributes> getKerberosAttributes() {
        return this.kerberosAttributes;
    }
    /**
     * AWS KMS customer master key (CMK) key ID or arn used for encrypting log files. This attribute is only available with EMR version 5.30.0 and later, excluding EMR 6.0.0.
     * 
     */
    @Export(name="logEncryptionKmsKeyId", type=String.class, parameters={})
    private Output</* @Nullable */ String> logEncryptionKmsKeyId;

    /**
     * @return AWS KMS customer master key (CMK) key ID or arn used for encrypting log files. This attribute is only available with EMR version 5.30.0 and later, excluding EMR 6.0.0.
     * 
     */
    public Output</* @Nullable */ String> getLogEncryptionKmsKeyId() {
        return this.logEncryptionKmsKeyId;
    }
    /**
     * S3 bucket to write the log files of the job flow. If a value is not provided, logs are not created.
     * 
     */
    @Export(name="logUri", type=String.class, parameters={})
    private Output</* @Nullable */ String> logUri;

    /**
     * @return S3 bucket to write the log files of the job flow. If a value is not provided, logs are not created.
     * 
     */
    public Output</* @Nullable */ String> getLogUri() {
        return this.logUri;
    }
    /**
     * Configuration block to use an [Instance Fleet](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-instance-fleet.html) for the master node type. Cannot be specified if any `master_instance_group` configuration blocks are set. Detailed below.
     * 
     */
    @Export(name="masterInstanceFleet", type=ClusterMasterInstanceFleet.class, parameters={})
    private Output<ClusterMasterInstanceFleet> masterInstanceFleet;

    /**
     * @return Configuration block to use an [Instance Fleet](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-instance-fleet.html) for the master node type. Cannot be specified if any `master_instance_group` configuration blocks are set. Detailed below.
     * 
     */
    public Output<ClusterMasterInstanceFleet> getMasterInstanceFleet() {
        return this.masterInstanceFleet;
    }
    /**
     * Configuration block to use an [Instance Group](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-instance-group-configuration.html#emr-plan-instance-groups) for the [master node type](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-master-core-task-nodes.html#emr-plan-master).
     * 
     */
    @Export(name="masterInstanceGroup", type=ClusterMasterInstanceGroup.class, parameters={})
    private Output<ClusterMasterInstanceGroup> masterInstanceGroup;

    /**
     * @return Configuration block to use an [Instance Group](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-instance-group-configuration.html#emr-plan-instance-groups) for the [master node type](https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-master-core-task-nodes.html#emr-plan-master).
     * 
     */
    public Output<ClusterMasterInstanceGroup> getMasterInstanceGroup() {
        return this.masterInstanceGroup;
    }
    /**
     * The DNS name of the master node. If the cluster is on a private subnet, this is the private DNS name. On a public subnet, this is the public DNS name.
     * 
     */
    @Export(name="masterPublicDns", type=String.class, parameters={})
    private Output<String> masterPublicDns;

    /**
     * @return The DNS name of the master node. If the cluster is on a private subnet, this is the private DNS name. On a public subnet, this is the public DNS name.
     * 
     */
    public Output<String> getMasterPublicDns() {
        return this.masterPublicDns;
    }
    /**
     * Name of the step.
     * 
     */
    @Export(name="name", type=String.class, parameters={})
    private Output<String> name;

    /**
     * @return Name of the step.
     * 
     */
    public Output<String> getName() {
        return this.name;
    }
    /**
     * Release label for the Amazon EMR release.
     * 
     */
    @Export(name="releaseLabel", type=String.class, parameters={})
    private Output<String> releaseLabel;

    /**
     * @return Release label for the Amazon EMR release.
     * 
     */
    public Output<String> getReleaseLabel() {
        return this.releaseLabel;
    }
    /**
     * Way that individual Amazon EC2 instances terminate when an automatic scale-in activity occurs or an `instance group` is resized.
     * 
     */
    @Export(name="scaleDownBehavior", type=String.class, parameters={})
    private Output<String> scaleDownBehavior;

    /**
     * @return Way that individual Amazon EC2 instances terminate when an automatic scale-in activity occurs or an `instance group` is resized.
     * 
     */
    public Output<String> getScaleDownBehavior() {
        return this.scaleDownBehavior;
    }
    /**
     * Security configuration name to attach to the EMR cluster. Only valid for EMR clusters with `release_label` 4.8.0 or greater.
     * 
     */
    @Export(name="securityConfiguration", type=String.class, parameters={})
    private Output</* @Nullable */ String> securityConfiguration;

    /**
     * @return Security configuration name to attach to the EMR cluster. Only valid for EMR clusters with `release_label` 4.8.0 or greater.
     * 
     */
    public Output</* @Nullable */ String> getSecurityConfiguration() {
        return this.securityConfiguration;
    }
    /**
     * IAM role that will be assumed by the Amazon EMR service to access AWS resources.
     * 
     */
    @Export(name="serviceRole", type=String.class, parameters={})
    private Output<String> serviceRole;

    /**
     * @return IAM role that will be assumed by the Amazon EMR service to access AWS resources.
     * 
     */
    public Output<String> getServiceRole() {
        return this.serviceRole;
    }
    /**
     * Number of steps that can be executed concurrently. You can specify a maximum of 256 steps. Only valid for EMR clusters with `release_label` 5.28.0 or greater (default is 1).
     * 
     */
    @Export(name="stepConcurrencyLevel", type=Integer.class, parameters={})
    private Output</* @Nullable */ Integer> stepConcurrencyLevel;

    /**
     * @return Number of steps that can be executed concurrently. You can specify a maximum of 256 steps. Only valid for EMR clusters with `release_label` 5.28.0 or greater (default is 1).
     * 
     */
    public Output</* @Nullable */ Integer> getStepConcurrencyLevel() {
        return this.stepConcurrencyLevel;
    }
    /**
     * List of steps to run when creating the cluster. See below. It is highly recommended to utilize the lifecycle resource options block with `ignoreChanges` if other steps are being managed outside of this provider.
     * 
     */
    @Export(name="steps", type=List.class, parameters={ClusterStep.class})
    private Output<List<ClusterStep>> steps;

    /**
     * @return List of steps to run when creating the cluster. See below. It is highly recommended to utilize the lifecycle resource options block with `ignoreChanges` if other steps are being managed outside of this provider.
     * 
     */
    public Output<List<ClusterStep>> getSteps() {
        return this.steps;
    }
    /**
     * list of tags to apply to the EMR Cluster. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
     * 
     */
    @Export(name="tags", type=Map.class, parameters={String.class, String.class})
    private Output</* @Nullable */ Map<String,String>> tags;

    /**
     * @return list of tags to apply to the EMR Cluster. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
     * 
     */
    public Output</* @Nullable */ Map<String,String>> getTags() {
        return this.tags;
    }
    /**
     * Map of tags assigned to the resource, including those inherited from the provider `default_tags` configuration block.
     * 
     */
    @Export(name="tagsAll", type=Map.class, parameters={String.class, String.class})
    private Output<Map<String,String>> tagsAll;

    /**
     * @return Map of tags assigned to the resource, including those inherited from the provider `default_tags` configuration block.
     * 
     */
    public Output<Map<String,String>> getTagsAll() {
        return this.tagsAll;
    }
    /**
     * Switch on/off termination protection (default is `false`, except when using multiple master nodes). Before attempting to destroy the resource when termination protection is enabled, this configuration must be applied with its value set to `false`.
     * 
     */
    @Export(name="terminationProtection", type=Boolean.class, parameters={})
    private Output<Boolean> terminationProtection;

    /**
     * @return Switch on/off termination protection (default is `false`, except when using multiple master nodes). Before attempting to destroy the resource when termination protection is enabled, this configuration must be applied with its value set to `false`.
     * 
     */
    public Output<Boolean> getTerminationProtection() {
        return this.terminationProtection;
    }
    /**
     * Whether the job flow is visible to all IAM users of the AWS account associated with the job flow. Default value is `true`.
     * 
     */
    @Export(name="visibleToAllUsers", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> visibleToAllUsers;

    /**
     * @return Whether the job flow is visible to all IAM users of the AWS account associated with the job flow. Default value is `true`.
     * 
     */
    public Output</* @Nullable */ Boolean> getVisibleToAllUsers() {
        return this.visibleToAllUsers;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public Cluster(String name) {
        this(name, ClusterArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public Cluster(String name, ClusterArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public Cluster(String name, ClusterArgs args, @Nullable io.pulumi.resources.CustomResourceOptions options) {
        super("aws:emr/cluster:Cluster", name, args == null ? ClusterArgs.Empty : args, makeResourceOptions(options, Output.empty()));
    }

    private Cluster(String name, Output<String> id, @Nullable ClusterState state, @Nullable io.pulumi.resources.CustomResourceOptions options) {
        super("aws:emr/cluster:Cluster", name, state, makeResourceOptions(options, id));
    }

    private static io.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable io.pulumi.resources.CustomResourceOptions options, @Nullable Output<String> id) {
        var defaultOptions = io.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return io.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static Cluster get(String name, Output<String> id, @Nullable ClusterState state, @Nullable io.pulumi.resources.CustomResourceOptions options) {
        return new Cluster(name, id, state, options);
    }
}
