// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package io.pulumi.aws.lambda;

import io.pulumi.aws.Utilities;
import io.pulumi.aws.lambda.EventSourceMappingArgs;
import io.pulumi.aws.lambda.inputs.EventSourceMappingState;
import io.pulumi.aws.lambda.outputs.EventSourceMappingDestinationConfig;
import io.pulumi.aws.lambda.outputs.EventSourceMappingFilterCriteria;
import io.pulumi.aws.lambda.outputs.EventSourceMappingSelfManagedEventSource;
import io.pulumi.aws.lambda.outputs.EventSourceMappingSourceAccessConfiguration;
import io.pulumi.core.Output;
import io.pulumi.core.annotations.Export;
import io.pulumi.core.annotations.ResourceType;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import javax.annotation.Nullable;

/**
 * Provides a Lambda event source mapping. This allows Lambda functions to get events from Kinesis, DynamoDB, SQS, Amazon MQ and Managed Streaming for Apache Kafka (MSK).
 * 
 * For information about Lambda and how to use it, see [What is AWS Lambda?](http://docs.aws.amazon.com/lambda/latest/dg/welcome.html).
 * For information about event source mappings, see [CreateEventSourceMapping](http://docs.aws.amazon.com/lambda/latest/dg/API_CreateEventSourceMapping.html) in the API docs.
 * 
 * {{% examples %}}
 * ## Example Usage
 * {{% example %}}
 * ### DynamoDB
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 * 
 * const example = new aws.lambda.EventSourceMapping("example", {
 *     eventSourceArn: aws_dynamodb_table.example.stream_arn,
 *     functionName: aws_lambda_function.example.arn,
 *     startingPosition: "LATEST",
 * });
 * ```
 * ```python
 * import pulumi
 * import pulumi_aws as aws
 * 
 * example = aws.lambda_.EventSourceMapping("example",
 *     event_source_arn=aws_dynamodb_table["example"]["stream_arn"],
 *     function_name=aws_lambda_function["example"]["arn"],
 *     starting_position="LATEST")
 * ```
 * ```csharp
 * using Pulumi;
 * using Aws = Pulumi.Aws;
 * 
 * class MyStack : Stack
 * {
 *     public MyStack()
 *     {
 *         var example = new Aws.Lambda.EventSourceMapping("example", new Aws.Lambda.EventSourceMappingArgs
 *         {
 *             EventSourceArn = aws_dynamodb_table.Example.Stream_arn,
 *             FunctionName = aws_lambda_function.Example.Arn,
 *             StartingPosition = "LATEST",
 *         });
 *     }
 * 
 * }
 * ```
 * ```go
 * package main
 * 
 * import (
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/lambda"
 * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
 * )
 * 
 * func main() {
 * 	pulumi.Run(func(ctx *pulumi.Context) error {
 * 		_, err := lambda.NewEventSourceMapping(ctx, "example", &lambda.EventSourceMappingArgs{
 * 			EventSourceArn:   pulumi.Any(aws_dynamodb_table.Example.Stream_arn),
 * 			FunctionName:     pulumi.Any(aws_lambda_function.Example.Arn),
 * 			StartingPosition: pulumi.String("LATEST"),
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		return nil
 * 	})
 * }
 * ```
 * {{% /example %}}
 * {{% example %}}
 * ### Kinesis
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 * 
 * const example = new aws.lambda.EventSourceMapping("example", {
 *     eventSourceArn: aws_kinesis_stream.example.arn,
 *     functionName: aws_lambda_function.example.arn,
 *     startingPosition: "LATEST",
 * });
 * ```
 * ```python
 * import pulumi
 * import pulumi_aws as aws
 * 
 * example = aws.lambda_.EventSourceMapping("example",
 *     event_source_arn=aws_kinesis_stream["example"]["arn"],
 *     function_name=aws_lambda_function["example"]["arn"],
 *     starting_position="LATEST")
 * ```
 * ```csharp
 * using Pulumi;
 * using Aws = Pulumi.Aws;
 * 
 * class MyStack : Stack
 * {
 *     public MyStack()
 *     {
 *         var example = new Aws.Lambda.EventSourceMapping("example", new Aws.Lambda.EventSourceMappingArgs
 *         {
 *             EventSourceArn = aws_kinesis_stream.Example.Arn,
 *             FunctionName = aws_lambda_function.Example.Arn,
 *             StartingPosition = "LATEST",
 *         });
 *     }
 * 
 * }
 * ```
 * ```go
 * package main
 * 
 * import (
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/lambda"
 * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
 * )
 * 
 * func main() {
 * 	pulumi.Run(func(ctx *pulumi.Context) error {
 * 		_, err := lambda.NewEventSourceMapping(ctx, "example", &lambda.EventSourceMappingArgs{
 * 			EventSourceArn:   pulumi.Any(aws_kinesis_stream.Example.Arn),
 * 			FunctionName:     pulumi.Any(aws_lambda_function.Example.Arn),
 * 			StartingPosition: pulumi.String("LATEST"),
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		return nil
 * 	})
 * }
 * ```
 * {{% /example %}}
 * {{% example %}}
 * ### Managed Streaming for Apache Kafka (MSK)
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 * 
 * const example = new aws.lambda.EventSourceMapping("example", {
 *     eventSourceArn: aws_msk_cluster.example.arn,
 *     functionName: aws_lambda_function.example.arn,
 *     topics: ["Example"],
 *     startingPosition: "TRIM_HORIZON",
 * });
 * ```
 * ```python
 * import pulumi
 * import pulumi_aws as aws
 * 
 * example = aws.lambda_.EventSourceMapping("example",
 *     event_source_arn=aws_msk_cluster["example"]["arn"],
 *     function_name=aws_lambda_function["example"]["arn"],
 *     topics=["Example"],
 *     starting_position="TRIM_HORIZON")
 * ```
 * ```csharp
 * using Pulumi;
 * using Aws = Pulumi.Aws;
 * 
 * class MyStack : Stack
 * {
 *     public MyStack()
 *     {
 *         var example = new Aws.Lambda.EventSourceMapping("example", new Aws.Lambda.EventSourceMappingArgs
 *         {
 *             EventSourceArn = aws_msk_cluster.Example.Arn,
 *             FunctionName = aws_lambda_function.Example.Arn,
 *             Topics = 
 *             {
 *                 "Example",
 *             },
 *             StartingPosition = "TRIM_HORIZON",
 *         });
 *     }
 * 
 * }
 * ```
 * ```go
 * package main
 * 
 * import (
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/lambda"
 * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
 * )
 * 
 * func main() {
 * 	pulumi.Run(func(ctx *pulumi.Context) error {
 * 		_, err := lambda.NewEventSourceMapping(ctx, "example", &lambda.EventSourceMappingArgs{
 * 			EventSourceArn: pulumi.Any(aws_msk_cluster.Example.Arn),
 * 			FunctionName:   pulumi.Any(aws_lambda_function.Example.Arn),
 * 			Topics: pulumi.StringArray{
 * 				pulumi.String("Example"),
 * 			},
 * 			StartingPosition: pulumi.String("TRIM_HORIZON"),
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		return nil
 * 	})
 * }
 * ```
 * {{% /example %}}
 * {{% example %}}
 * ### Self Managed Apache Kafka
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 * 
 * const example = new aws.lambda.EventSourceMapping("example", {
 *     functionName: aws_lambda_function.example.arn,
 *     topics: ["Example"],
 *     startingPosition: "TRIM_HORIZON",
 *     selfManagedEventSource: {
 *         endpoints: {
 *             KAFKA_BOOTSTRAP_SERVERS: "kafka1.example.com:9092,kafka2.example.com:9092",
 *         },
 *     },
 *     sourceAccessConfigurations: [
 *         {
 *             type: "VPC_SUBNET",
 *             uri: "subnet:subnet-example1",
 *         },
 *         {
 *             type: "VPC_SUBNET",
 *             uri: "subnet:subnet-example2",
 *         },
 *         {
 *             type: "VPC_SECURITY_GROUP",
 *             uri: "security_group:sg-example",
 *         },
 *     ],
 * });
 * ```
 * ```python
 * import pulumi
 * import pulumi_aws as aws
 * 
 * example = aws.lambda_.EventSourceMapping("example",
 *     function_name=aws_lambda_function["example"]["arn"],
 *     topics=["Example"],
 *     starting_position="TRIM_HORIZON",
 *     self_managed_event_source=aws.lambda..EventSourceMappingSelfManagedEventSourceArgs(
 *         endpoints={
 *             "KAFKA_BOOTSTRAP_SERVERS": "kafka1.example.com:9092,kafka2.example.com:9092",
 *         },
 *     ),
 *     source_access_configurations=[
 *         aws.lambda..EventSourceMappingSourceAccessConfigurationArgs(
 *             type="VPC_SUBNET",
 *             uri="subnet:subnet-example1",
 *         ),
 *         aws.lambda..EventSourceMappingSourceAccessConfigurationArgs(
 *             type="VPC_SUBNET",
 *             uri="subnet:subnet-example2",
 *         ),
 *         aws.lambda..EventSourceMappingSourceAccessConfigurationArgs(
 *             type="VPC_SECURITY_GROUP",
 *             uri="security_group:sg-example",
 *         ),
 *     ])
 * ```
 * ```csharp
 * using Pulumi;
 * using Aws = Pulumi.Aws;
 * 
 * class MyStack : Stack
 * {
 *     public MyStack()
 *     {
 *         var example = new Aws.Lambda.EventSourceMapping("example", new Aws.Lambda.EventSourceMappingArgs
 *         {
 *             FunctionName = aws_lambda_function.Example.Arn,
 *             Topics = 
 *             {
 *                 "Example",
 *             },
 *             StartingPosition = "TRIM_HORIZON",
 *             SelfManagedEventSource = new Aws.Lambda.Inputs.EventSourceMappingSelfManagedEventSourceArgs
 *             {
 *                 Endpoints = 
 *                 {
 *                     { "KAFKA_BOOTSTRAP_SERVERS", "kafka1.example.com:9092,kafka2.example.com:9092" },
 *                 },
 *             },
 *             SourceAccessConfigurations = 
 *             {
 *                 new Aws.Lambda.Inputs.EventSourceMappingSourceAccessConfigurationArgs
 *                 {
 *                     Type = "VPC_SUBNET",
 *                     Uri = "subnet:subnet-example1",
 *                 },
 *                 new Aws.Lambda.Inputs.EventSourceMappingSourceAccessConfigurationArgs
 *                 {
 *                     Type = "VPC_SUBNET",
 *                     Uri = "subnet:subnet-example2",
 *                 },
 *                 new Aws.Lambda.Inputs.EventSourceMappingSourceAccessConfigurationArgs
 *                 {
 *                     Type = "VPC_SECURITY_GROUP",
 *                     Uri = "security_group:sg-example",
 *                 },
 *             },
 *         });
 *     }
 * 
 * }
 * ```
 * ```go
 * package main
 * 
 * import (
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/lambda"
 * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
 * )
 * 
 * func main() {
 * 	pulumi.Run(func(ctx *pulumi.Context) error {
 * 		_, err := lambda.NewEventSourceMapping(ctx, "example", &lambda.EventSourceMappingArgs{
 * 			FunctionName: pulumi.Any(aws_lambda_function.Example.Arn),
 * 			Topics: pulumi.StringArray{
 * 				pulumi.String("Example"),
 * 			},
 * 			StartingPosition: pulumi.String("TRIM_HORIZON"),
 * 			SelfManagedEventSource: &lambda.EventSourceMappingSelfManagedEventSourceArgs{
 * 				Endpoints: pulumi.StringMap{
 * 					"KAFKA_BOOTSTRAP_SERVERS": pulumi.String("kafka1.example.com:9092,kafka2.example.com:9092"),
 * 				},
 * 			},
 * 			SourceAccessConfigurations: lambda.EventSourceMappingSourceAccessConfigurationArray{
 * 				&lambda.EventSourceMappingSourceAccessConfigurationArgs{
 * 					Type: pulumi.String("VPC_SUBNET"),
 * 					Uri:  pulumi.String("subnet:subnet-example1"),
 * 				},
 * 				&lambda.EventSourceMappingSourceAccessConfigurationArgs{
 * 					Type: pulumi.String("VPC_SUBNET"),
 * 					Uri:  pulumi.String("subnet:subnet-example2"),
 * 				},
 * 				&lambda.EventSourceMappingSourceAccessConfigurationArgs{
 * 					Type: pulumi.String("VPC_SECURITY_GROUP"),
 * 					Uri:  pulumi.String("security_group:sg-example"),
 * 				},
 * 			},
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		return nil
 * 	})
 * }
 * ```
 * {{% /example %}}
 * {{% example %}}
 * ### SQS
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 * 
 * const example = new aws.lambda.EventSourceMapping("example", {
 *     eventSourceArn: aws_sqs_queue.sqs_queue_test.arn,
 *     functionName: aws_lambda_function.example.arn,
 * });
 * ```
 * ```python
 * import pulumi
 * import pulumi_aws as aws
 * 
 * example = aws.lambda_.EventSourceMapping("example",
 *     event_source_arn=aws_sqs_queue["sqs_queue_test"]["arn"],
 *     function_name=aws_lambda_function["example"]["arn"])
 * ```
 * ```csharp
 * using Pulumi;
 * using Aws = Pulumi.Aws;
 * 
 * class MyStack : Stack
 * {
 *     public MyStack()
 *     {
 *         var example = new Aws.Lambda.EventSourceMapping("example", new Aws.Lambda.EventSourceMappingArgs
 *         {
 *             EventSourceArn = aws_sqs_queue.Sqs_queue_test.Arn,
 *             FunctionName = aws_lambda_function.Example.Arn,
 *         });
 *     }
 * 
 * }
 * ```
 * ```go
 * package main
 * 
 * import (
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/lambda"
 * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
 * )
 * 
 * func main() {
 * 	pulumi.Run(func(ctx *pulumi.Context) error {
 * 		_, err := lambda.NewEventSourceMapping(ctx, "example", &lambda.EventSourceMappingArgs{
 * 			EventSourceArn: pulumi.Any(aws_sqs_queue.Sqs_queue_test.Arn),
 * 			FunctionName:   pulumi.Any(aws_lambda_function.Example.Arn),
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		return nil
 * 	})
 * }
 * ```
 * {{% /example %}}
 * {{% example %}}
 * ### SQS with event filter
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 * 
 * const example = new aws.lambda.EventSourceMapping("example", {
 *     eventSourceArn: aws_sqs_queue.sqs_queue_test.arn,
 *     functionName: aws_lambda_function.example.arn,
 *     filterCriteria: {
 *         filters: [{
 *             pattern: JSON.stringify({
 *                 body: {
 *                     Temperature: [{
 *                         numeric: [
 *                             ">",
 *                             0,
 *                             "<=",
 *                             100,
 *                         ],
 *                     }],
 *                     Location: ["New York"],
 *                 },
 *             }),
 *         }],
 *     },
 * });
 * ```
 * ```python
 * import pulumi
 * import json
 * import pulumi_aws as aws
 * 
 * example = aws.lambda_.EventSourceMapping("example",
 *     event_source_arn=aws_sqs_queue["sqs_queue_test"]["arn"],
 *     function_name=aws_lambda_function["example"]["arn"],
 *     filter_criteria=aws.lambda..EventSourceMappingFilterCriteriaArgs(
 *         filters=[aws.lambda..EventSourceMappingFilterCriteriaFilterArgs(
 *             pattern=json.dumps({
 *                 "body": {
 *                     "Temperature": [{
 *                         "numeric": [
 *                             ">",
 *                             0,
 *                             "<=",
 *                             100,
 *                         ],
 *                     }],
 *                     "Location": ["New York"],
 *                 },
 *             }),
 *         )],
 *     ))
 * ```
 * ```csharp
 * using System.Collections.Generic;
 * using System.Text.Json;
 * using Pulumi;
 * using Aws = Pulumi.Aws;
 * 
 * class MyStack : Stack
 * {
 *     public MyStack()
 *     {
 *         var example = new Aws.Lambda.EventSourceMapping("example", new Aws.Lambda.EventSourceMappingArgs
 *         {
 *             EventSourceArn = aws_sqs_queue.Sqs_queue_test.Arn,
 *             FunctionName = aws_lambda_function.Example.Arn,
 *             FilterCriteria = new Aws.Lambda.Inputs.EventSourceMappingFilterCriteriaArgs
 *             {
 *                 Filters = 
 *                 {
 *                     new Aws.Lambda.Inputs.EventSourceMappingFilterCriteriaFilterArgs
 *                     {
 *                         Pattern = JsonSerializer.Serialize(new Dictionary<string, object?>
 *                         {
 *                             { "body", new Dictionary<string, object?>
 *                             {
 *                                 { "Temperature", new[]
 *                                     {
 *                                         new Dictionary<string, object?>
 *                                         {
 *                                             { "numeric", new[]
 *                                                 {
 *                                                     ">",
 *                                                     0,
 *                                                     "<=",
 *                                                     100,
 *                                                 }
 *                                              },
 *                                         },
 *                                     }
 *                                  },
 *                                 { "Location", new[]
 *                                     {
 *                                         "New York",
 *                                     }
 *                                  },
 *                             } },
 *                         }),
 *                     },
 *                 },
 *             },
 *         });
 *     }
 * 
 * }
 * ```
 * ```go
 * package main
 * 
 * import (
 * 	"encoding/json"
 * 
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/lambda"
 * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
 * )
 * 
 * func main() {
 * 	pulumi.Run(func(ctx *pulumi.Context) error {
 * 		tmpJSON0, err := json.Marshal(map[string]interface{}{
 * 			"body": map[string]interface{}{
 * 				"Temperature": []map[string]interface{}{
 * 					map[string]interface{}{
 * 						"numeric": []interface{}{
 * 							">",
 * 							0,
 * 							"<=",
 * 							100,
 * 						},
 * 					},
 * 				},
 * 				"Location": []string{
 * 					"New York",
 * 				},
 * 			},
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		json0 := string(tmpJSON0)
 * 		_, err := lambda.NewEventSourceMapping(ctx, "example", &lambda.EventSourceMappingArgs{
 * 			EventSourceArn: pulumi.Any(aws_sqs_queue.Sqs_queue_test.Arn),
 * 			FunctionName:   pulumi.Any(aws_lambda_function.Example.Arn),
 * 			FilterCriteria: &lambda.EventSourceMappingFilterCriteriaArgs{
 * 				Filters: lambda.EventSourceMappingFilterCriteriaFilterArray{
 * 					&lambda.EventSourceMappingFilterCriteriaFilterArgs{
 * 						Pattern: pulumi.String(json0),
 * 					},
 * 				},
 * 			},
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		return nil
 * 	})
 * }
 * ```
 * {{% /example %}}
 * {{% example %}}
 * ### Amazon MQ (ActiveMQ)
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 * 
 * const example = new aws.lambda.EventSourceMapping("example", {
 *     batchSize: 10,
 *     eventSourceArn: aws_mq_broker.example.arn,
 *     enabled: true,
 *     functionName: aws_lambda_function.example.arn,
 *     queues: ["example"],
 *     sourceAccessConfigurations: [{
 *         type: "BASIC_AUTH",
 *         uri: aws_secretsmanager_secret_version.example.arn,
 *     }],
 * });
 * ```
 * ```python
 * import pulumi
 * import pulumi_aws as aws
 * 
 * example = aws.lambda_.EventSourceMapping("example",
 *     batch_size=10,
 *     event_source_arn=aws_mq_broker["example"]["arn"],
 *     enabled=True,
 *     function_name=aws_lambda_function["example"]["arn"],
 *     queues=["example"],
 *     source_access_configurations=[aws.lambda..EventSourceMappingSourceAccessConfigurationArgs(
 *         type="BASIC_AUTH",
 *         uri=aws_secretsmanager_secret_version["example"]["arn"],
 *     )])
 * ```
 * ```csharp
 * using Pulumi;
 * using Aws = Pulumi.Aws;
 * 
 * class MyStack : Stack
 * {
 *     public MyStack()
 *     {
 *         var example = new Aws.Lambda.EventSourceMapping("example", new Aws.Lambda.EventSourceMappingArgs
 *         {
 *             BatchSize = 10,
 *             EventSourceArn = aws_mq_broker.Example.Arn,
 *             Enabled = true,
 *             FunctionName = aws_lambda_function.Example.Arn,
 *             Queues = 
 *             {
 *                 "example",
 *             },
 *             SourceAccessConfigurations = 
 *             {
 *                 new Aws.Lambda.Inputs.EventSourceMappingSourceAccessConfigurationArgs
 *                 {
 *                     Type = "BASIC_AUTH",
 *                     Uri = aws_secretsmanager_secret_version.Example.Arn,
 *                 },
 *             },
 *         });
 *     }
 * 
 * }
 * ```
 * ```go
 * package main
 * 
 * import (
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/lambda"
 * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
 * )
 * 
 * func main() {
 * 	pulumi.Run(func(ctx *pulumi.Context) error {
 * 		_, err := lambda.NewEventSourceMapping(ctx, "example", &lambda.EventSourceMappingArgs{
 * 			BatchSize:      pulumi.Int(10),
 * 			EventSourceArn: pulumi.Any(aws_mq_broker.Example.Arn),
 * 			Enabled:        pulumi.Bool(true),
 * 			FunctionName:   pulumi.Any(aws_lambda_function.Example.Arn),
 * 			Queues: pulumi.StringArray{
 * 				pulumi.String("example"),
 * 			},
 * 			SourceAccessConfigurations: lambda.EventSourceMappingSourceAccessConfigurationArray{
 * 				&lambda.EventSourceMappingSourceAccessConfigurationArgs{
 * 					Type: pulumi.String("BASIC_AUTH"),
 * 					Uri:  pulumi.Any(aws_secretsmanager_secret_version.Example.Arn),
 * 				},
 * 			},
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		return nil
 * 	})
 * }
 * ```
 * {{% /example %}}
 * {{% example %}}
 * ### Amazon MQ (RabbitMQ)
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 * 
 * const example = new aws.lambda.EventSourceMapping("example", {
 *     batchSize: 1,
 *     eventSourceArn: aws_mq_broker.example.arn,
 *     enabled: true,
 *     functionName: aws_lambda_function.example.arn,
 *     queues: ["example"],
 *     sourceAccessConfigurations: [
 *         {
 *             type: "VIRTUAL_HOST",
 *             uri: "/example",
 *         },
 *         {
 *             type: "BASIC_AUTH",
 *             uri: aws_secretsmanager_secret_version.example.arn,
 *         },
 *     ],
 * });
 * ```
 * ```python
 * import pulumi
 * import pulumi_aws as aws
 * 
 * example = aws.lambda_.EventSourceMapping("example",
 *     batch_size=1,
 *     event_source_arn=aws_mq_broker["example"]["arn"],
 *     enabled=True,
 *     function_name=aws_lambda_function["example"]["arn"],
 *     queues=["example"],
 *     source_access_configurations=[
 *         aws.lambda..EventSourceMappingSourceAccessConfigurationArgs(
 *             type="VIRTUAL_HOST",
 *             uri="/example",
 *         ),
 *         aws.lambda..EventSourceMappingSourceAccessConfigurationArgs(
 *             type="BASIC_AUTH",
 *             uri=aws_secretsmanager_secret_version["example"]["arn"],
 *         ),
 *     ])
 * ```
 * ```csharp
 * using Pulumi;
 * using Aws = Pulumi.Aws;
 * 
 * class MyStack : Stack
 * {
 *     public MyStack()
 *     {
 *         var example = new Aws.Lambda.EventSourceMapping("example", new Aws.Lambda.EventSourceMappingArgs
 *         {
 *             BatchSize = 1,
 *             EventSourceArn = aws_mq_broker.Example.Arn,
 *             Enabled = true,
 *             FunctionName = aws_lambda_function.Example.Arn,
 *             Queues = 
 *             {
 *                 "example",
 *             },
 *             SourceAccessConfigurations = 
 *             {
 *                 new Aws.Lambda.Inputs.EventSourceMappingSourceAccessConfigurationArgs
 *                 {
 *                     Type = "VIRTUAL_HOST",
 *                     Uri = "/example",
 *                 },
 *                 new Aws.Lambda.Inputs.EventSourceMappingSourceAccessConfigurationArgs
 *                 {
 *                     Type = "BASIC_AUTH",
 *                     Uri = aws_secretsmanager_secret_version.Example.Arn,
 *                 },
 *             },
 *         });
 *     }
 * 
 * }
 * ```
 * ```go
 * package main
 * 
 * import (
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/lambda"
 * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
 * )
 * 
 * func main() {
 * 	pulumi.Run(func(ctx *pulumi.Context) error {
 * 		_, err := lambda.NewEventSourceMapping(ctx, "example", &lambda.EventSourceMappingArgs{
 * 			BatchSize:      pulumi.Int(1),
 * 			EventSourceArn: pulumi.Any(aws_mq_broker.Example.Arn),
 * 			Enabled:        pulumi.Bool(true),
 * 			FunctionName:   pulumi.Any(aws_lambda_function.Example.Arn),
 * 			Queues: pulumi.StringArray{
 * 				pulumi.String("example"),
 * 			},
 * 			SourceAccessConfigurations: lambda.EventSourceMappingSourceAccessConfigurationArray{
 * 				&lambda.EventSourceMappingSourceAccessConfigurationArgs{
 * 					Type: pulumi.String("VIRTUAL_HOST"),
 * 					Uri:  pulumi.String("/example"),
 * 				},
 * 				&lambda.EventSourceMappingSourceAccessConfigurationArgs{
 * 					Type: pulumi.String("BASIC_AUTH"),
 * 					Uri:  pulumi.Any(aws_secretsmanager_secret_version.Example.Arn),
 * 				},
 * 			},
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		return nil
 * 	})
 * }
 * ```
 * {{% /example %}}
 * {{% example %}}
 * ### Managed Streaming for Kafka (MSK)
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 * 
 * const example = new aws.lambda.EventSourceMapping("example", {
 *     eventSourceArn: aws_msk_cluster.example.arn,
 *     functionName: aws_lambda_function.example.arn,
 *     topics: ["Example"],
 *     startingPosition: "TRIM_HORIZON",
 * });
 * ```
 * ```python
 * import pulumi
 * import pulumi_aws as aws
 * 
 * example = aws.lambda_.EventSourceMapping("example",
 *     event_source_arn=aws_msk_cluster["example"]["arn"],
 *     function_name=aws_lambda_function["example"]["arn"],
 *     topics=["Example"],
 *     starting_position="TRIM_HORIZON")
 * ```
 * ```csharp
 * using Pulumi;
 * using Aws = Pulumi.Aws;
 * 
 * class MyStack : Stack
 * {
 *     public MyStack()
 *     {
 *         var example = new Aws.Lambda.EventSourceMapping("example", new Aws.Lambda.EventSourceMappingArgs
 *         {
 *             EventSourceArn = aws_msk_cluster.Example.Arn,
 *             FunctionName = aws_lambda_function.Example.Arn,
 *             Topics = 
 *             {
 *                 "Example",
 *             },
 *             StartingPosition = "TRIM_HORIZON",
 *         });
 *     }
 * 
 * }
 * ```
 * ```go
 * package main
 * 
 * import (
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/lambda"
 * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
 * )
 * 
 * func main() {
 * 	pulumi.Run(func(ctx *pulumi.Context) error {
 * 		_, err := lambda.NewEventSourceMapping(ctx, "example", &lambda.EventSourceMappingArgs{
 * 			EventSourceArn: pulumi.Any(aws_msk_cluster.Example.Arn),
 * 			FunctionName:   pulumi.Any(aws_lambda_function.Example.Arn),
 * 			Topics: pulumi.StringArray{
 * 				pulumi.String("Example"),
 * 			},
 * 			StartingPosition: pulumi.String("TRIM_HORIZON"),
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		return nil
 * 	})
 * }
 * ```
 * {{% /example %}}
 * {{% /examples %}}
 * 
 * ## Import
 * 
 * Lambda event source mappings can be imported using the `UUID` (event source mapping identifier), e.g.,
 * 
 * ```sh
 *  $ pulumi import aws:lambda/eventSourceMapping:EventSourceMapping event_source_mapping 12345kxodurf3443
 * ```
 * 
 *  
 */
@ResourceType(type="aws:lambda/eventSourceMapping:EventSourceMapping")
public class EventSourceMapping extends io.pulumi.resources.CustomResource {
    /**
     * The largest number of records that Lambda will retrieve from your event source at the time of invocation. Defaults to `100` for DynamoDB, Kinesis, MQ and MSK, `10` for SQS.
     * * `bisect_batch_on_function_error`: - (Optional) If the function returns an error, split the batch in two and retry. Only available for stream sources (DynamoDB and Kinesis). Defaults to `false`.
     * * `destination_config`: - (Optional) An Amazon SQS queue or Amazon SNS topic destination for failed records. Only available for stream sources (DynamoDB and Kinesis). Detailed below.
     * 
     */
    @Export(name="batchSize", type=Integer.class, parameters={})
    private Output</* @Nullable */ Integer> batchSize;

    /**
     * @return The largest number of records that Lambda will retrieve from your event source at the time of invocation. Defaults to `100` for DynamoDB, Kinesis, MQ and MSK, `10` for SQS.
     * * `bisect_batch_on_function_error`: - (Optional) If the function returns an error, split the batch in two and retry. Only available for stream sources (DynamoDB and Kinesis). Defaults to `false`.
     * * `destination_config`: - (Optional) An Amazon SQS queue or Amazon SNS topic destination for failed records. Only available for stream sources (DynamoDB and Kinesis). Detailed below.
     * 
     */
    public Output</* @Nullable */ Integer> getBatchSize() {
        return this.batchSize;
    }
    @Export(name="bisectBatchOnFunctionError", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> bisectBatchOnFunctionError;

    public Output</* @Nullable */ Boolean> getBisectBatchOnFunctionError() {
        return this.bisectBatchOnFunctionError;
    }
    @Export(name="destinationConfig", type=EventSourceMappingDestinationConfig.class, parameters={})
    private Output</* @Nullable */ EventSourceMappingDestinationConfig> destinationConfig;

    public Output</* @Nullable */ EventSourceMappingDestinationConfig> getDestinationConfig() {
        return this.destinationConfig;
    }
    /**
     * Determines if the mapping will be enabled on creation. Defaults to `true`.
     * 
     */
    @Export(name="enabled", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> enabled;

    /**
     * @return Determines if the mapping will be enabled on creation. Defaults to `true`.
     * 
     */
    public Output</* @Nullable */ Boolean> getEnabled() {
        return this.enabled;
    }
    /**
     * The event source ARN - this is required for Kinesis stream, DynamoDB stream, SQS queue, MQ broker or MSK cluster.  It is incompatible with a Self Managed Kafka source.
     * 
     */
    @Export(name="eventSourceArn", type=String.class, parameters={})
    private Output</* @Nullable */ String> eventSourceArn;

    /**
     * @return The event source ARN - this is required for Kinesis stream, DynamoDB stream, SQS queue, MQ broker or MSK cluster.  It is incompatible with a Self Managed Kafka source.
     * 
     */
    public Output</* @Nullable */ String> getEventSourceArn() {
        return this.eventSourceArn;
    }
    /**
     * The criteria to use for [event filtering](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html) Kinesis stream, DynamoDB stream, SQS queue event sources. Detailed below.
     * 
     */
    @Export(name="filterCriteria", type=EventSourceMappingFilterCriteria.class, parameters={})
    private Output</* @Nullable */ EventSourceMappingFilterCriteria> filterCriteria;

    /**
     * @return The criteria to use for [event filtering](https://docs.aws.amazon.com/lambda/latest/dg/invocation-eventfiltering.html) Kinesis stream, DynamoDB stream, SQS queue event sources. Detailed below.
     * 
     */
    public Output</* @Nullable */ EventSourceMappingFilterCriteria> getFilterCriteria() {
        return this.filterCriteria;
    }
    /**
     * The the ARN of the Lambda function the event source mapping is sending events to. (Note: this is a computed value that differs from `function_name` above.)
     * 
     */
    @Export(name="functionArn", type=String.class, parameters={})
    private Output<String> functionArn;

    /**
     * @return The the ARN of the Lambda function the event source mapping is sending events to. (Note: this is a computed value that differs from `function_name` above.)
     * 
     */
    public Output<String> getFunctionArn() {
        return this.functionArn;
    }
    /**
     * The name or the ARN of the Lambda function that will be subscribing to events.
     * 
     */
    @Export(name="functionName", type=String.class, parameters={})
    private Output<String> functionName;

    /**
     * @return The name or the ARN of the Lambda function that will be subscribing to events.
     * 
     */
    public Output<String> getFunctionName() {
        return this.functionName;
    }
    /**
     * A list of current response type enums applied to the event source mapping for [AWS Lambda checkpointing](https://docs.aws.amazon.com/lambda/latest/dg/with-ddb.html#services-ddb-batchfailurereporting). Only available for SQS and stream sources (DynamoDB and Kinesis). Valid values: `ReportBatchItemFailures`.
     * 
     */
    @Export(name="functionResponseTypes", type=List.class, parameters={String.class})
    private Output</* @Nullable */ List<String>> functionResponseTypes;

    /**
     * @return A list of current response type enums applied to the event source mapping for [AWS Lambda checkpointing](https://docs.aws.amazon.com/lambda/latest/dg/with-ddb.html#services-ddb-batchfailurereporting). Only available for SQS and stream sources (DynamoDB and Kinesis). Valid values: `ReportBatchItemFailures`.
     * 
     */
    public Output</* @Nullable */ List<String>> getFunctionResponseTypes() {
        return this.functionResponseTypes;
    }
    /**
     * The date this resource was last modified.
     * 
     */
    @Export(name="lastModified", type=String.class, parameters={})
    private Output<String> lastModified;

    /**
     * @return The date this resource was last modified.
     * 
     */
    public Output<String> getLastModified() {
        return this.lastModified;
    }
    /**
     * The result of the last AWS Lambda invocation of your Lambda function.
     * 
     */
    @Export(name="lastProcessingResult", type=String.class, parameters={})
    private Output<String> lastProcessingResult;

    /**
     * @return The result of the last AWS Lambda invocation of your Lambda function.
     * 
     */
    public Output<String> getLastProcessingResult() {
        return this.lastProcessingResult;
    }
    /**
     * The maximum amount of time to gather records before invoking the function, in seconds (between 0 and 300). Records will continue to buffer (or accumulate in the case of an SQS queue event source) until either `maximum_batching_window_in_seconds` expires or `batch_size` has been met. For streaming event sources, defaults to as soon as records are available in the stream. If the batch it reads from the stream/queue only has one record in it, Lambda only sends one record to the function. Only available for stream sources (DynamoDB and Kinesis) and SQS standard queues.
     * * `maximum_record_age_in_seconds`: - (Optional) The maximum age of a record that Lambda sends to a function for processing. Only available for stream sources (DynamoDB and Kinesis). Must be either -1 (forever, and the default value) or between 60 and 604800 (inclusive).
     * * `maximum_retry_attempts`: - (Optional) The maximum number of times to retry when the function returns an error. Only available for stream sources (DynamoDB and Kinesis). Minimum and default of -1 (forever), maximum of 10000.
     * * `parallelization_factor`: - (Optional) The number of batches to process from each shard concurrently. Only available for stream sources (DynamoDB and Kinesis). Minimum and default of 1, maximum of 10.
     * 
     */
    @Export(name="maximumBatchingWindowInSeconds", type=Integer.class, parameters={})
    private Output</* @Nullable */ Integer> maximumBatchingWindowInSeconds;

    /**
     * @return The maximum amount of time to gather records before invoking the function, in seconds (between 0 and 300). Records will continue to buffer (or accumulate in the case of an SQS queue event source) until either `maximum_batching_window_in_seconds` expires or `batch_size` has been met. For streaming event sources, defaults to as soon as records are available in the stream. If the batch it reads from the stream/queue only has one record in it, Lambda only sends one record to the function. Only available for stream sources (DynamoDB and Kinesis) and SQS standard queues.
     * * `maximum_record_age_in_seconds`: - (Optional) The maximum age of a record that Lambda sends to a function for processing. Only available for stream sources (DynamoDB and Kinesis). Must be either -1 (forever, and the default value) or between 60 and 604800 (inclusive).
     * * `maximum_retry_attempts`: - (Optional) The maximum number of times to retry when the function returns an error. Only available for stream sources (DynamoDB and Kinesis). Minimum and default of -1 (forever), maximum of 10000.
     * * `parallelization_factor`: - (Optional) The number of batches to process from each shard concurrently. Only available for stream sources (DynamoDB and Kinesis). Minimum and default of 1, maximum of 10.
     * 
     */
    public Output</* @Nullable */ Integer> getMaximumBatchingWindowInSeconds() {
        return this.maximumBatchingWindowInSeconds;
    }
    @Export(name="maximumRecordAgeInSeconds", type=Integer.class, parameters={})
    private Output<Integer> maximumRecordAgeInSeconds;

    public Output<Integer> getMaximumRecordAgeInSeconds() {
        return this.maximumRecordAgeInSeconds;
    }
    @Export(name="maximumRetryAttempts", type=Integer.class, parameters={})
    private Output<Integer> maximumRetryAttempts;

    public Output<Integer> getMaximumRetryAttempts() {
        return this.maximumRetryAttempts;
    }
    @Export(name="parallelizationFactor", type=Integer.class, parameters={})
    private Output<Integer> parallelizationFactor;

    public Output<Integer> getParallelizationFactor() {
        return this.parallelizationFactor;
    }
    /**
     * The name of the Amazon MQ broker destination queue to consume. Only available for MQ sources. A single queue name must be specified.
     * * `self_managed_event_source`: - (Optional) For Self Managed Kafka sources, the location of the self managed cluster. If set, configuration must also include `source_access_configuration`. Detailed below.
     * * `source_access_configuration`: (Optional) For Self Managed Kafka sources, the access configuration for the source. If set, configuration must also include `self_managed_event_source`. Detailed below.
     * 
     */
    @Export(name="queues", type=List.class, parameters={String.class})
    private Output</* @Nullable */ List<String>> queues;

    /**
     * @return The name of the Amazon MQ broker destination queue to consume. Only available for MQ sources. A single queue name must be specified.
     * * `self_managed_event_source`: - (Optional) For Self Managed Kafka sources, the location of the self managed cluster. If set, configuration must also include `source_access_configuration`. Detailed below.
     * * `source_access_configuration`: (Optional) For Self Managed Kafka sources, the access configuration for the source. If set, configuration must also include `self_managed_event_source`. Detailed below.
     * 
     */
    public Output</* @Nullable */ List<String>> getQueues() {
        return this.queues;
    }
    @Export(name="selfManagedEventSource", type=EventSourceMappingSelfManagedEventSource.class, parameters={})
    private Output</* @Nullable */ EventSourceMappingSelfManagedEventSource> selfManagedEventSource;

    public Output</* @Nullable */ EventSourceMappingSelfManagedEventSource> getSelfManagedEventSource() {
        return this.selfManagedEventSource;
    }
    @Export(name="sourceAccessConfigurations", type=List.class, parameters={EventSourceMappingSourceAccessConfiguration.class})
    private Output</* @Nullable */ List<EventSourceMappingSourceAccessConfiguration>> sourceAccessConfigurations;

    public Output</* @Nullable */ List<EventSourceMappingSourceAccessConfiguration>> getSourceAccessConfigurations() {
        return this.sourceAccessConfigurations;
    }
    /**
     * The position in the stream where AWS Lambda should start reading. Must be one of `AT_TIMESTAMP` (Kinesis only), `LATEST` or `TRIM_HORIZON` if getting events from Kinesis, DynamoDB or MSK. Must not be provided if getting events from SQS. More information about these positions can be found in the [AWS DynamoDB Streams API Reference](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_streams_GetShardIterator.html) and [AWS Kinesis API Reference](https://docs.aws.amazon.com/kinesis/latest/APIReference/API_GetShardIterator.html#Kinesis-GetShardIterator-request-ShardIteratorType).
     * 
     */
    @Export(name="startingPosition", type=String.class, parameters={})
    private Output</* @Nullable */ String> startingPosition;

    /**
     * @return The position in the stream where AWS Lambda should start reading. Must be one of `AT_TIMESTAMP` (Kinesis only), `LATEST` or `TRIM_HORIZON` if getting events from Kinesis, DynamoDB or MSK. Must not be provided if getting events from SQS. More information about these positions can be found in the [AWS DynamoDB Streams API Reference](https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_streams_GetShardIterator.html) and [AWS Kinesis API Reference](https://docs.aws.amazon.com/kinesis/latest/APIReference/API_GetShardIterator.html#Kinesis-GetShardIterator-request-ShardIteratorType).
     * 
     */
    public Output</* @Nullable */ String> getStartingPosition() {
        return this.startingPosition;
    }
    /**
     * A timestamp in [RFC3339 format](https://tools.ietf.org/html/rfc3339#section-5.8) of the data record which to start reading when using `starting_position` set to `AT_TIMESTAMP`. If a record with this exact timestamp does not exist, the next later record is chosen. If the timestamp is older than the current trim horizon, the oldest available record is chosen.
     * 
     */
    @Export(name="startingPositionTimestamp", type=String.class, parameters={})
    private Output</* @Nullable */ String> startingPositionTimestamp;

    /**
     * @return A timestamp in [RFC3339 format](https://tools.ietf.org/html/rfc3339#section-5.8) of the data record which to start reading when using `starting_position` set to `AT_TIMESTAMP`. If a record with this exact timestamp does not exist, the next later record is chosen. If the timestamp is older than the current trim horizon, the oldest available record is chosen.
     * 
     */
    public Output</* @Nullable */ String> getStartingPositionTimestamp() {
        return this.startingPositionTimestamp;
    }
    /**
     * The state of the event source mapping.
     * 
     */
    @Export(name="state", type=String.class, parameters={})
    private Output<String> state;

    /**
     * @return The state of the event source mapping.
     * 
     */
    public Output<String> getState() {
        return this.state;
    }
    /**
     * The reason the event source mapping is in its current state.
     * 
     */
    @Export(name="stateTransitionReason", type=String.class, parameters={})
    private Output<String> stateTransitionReason;

    /**
     * @return The reason the event source mapping is in its current state.
     * 
     */
    public Output<String> getStateTransitionReason() {
        return this.stateTransitionReason;
    }
    /**
     * The name of the Kafka topics. Only available for MSK sources. A single topic name must be specified.
     * 
     */
    @Export(name="topics", type=List.class, parameters={String.class})
    private Output</* @Nullable */ List<String>> topics;

    /**
     * @return The name of the Kafka topics. Only available for MSK sources. A single topic name must be specified.
     * 
     */
    public Output</* @Nullable */ List<String>> getTopics() {
        return this.topics;
    }
    /**
     * The duration in seconds of a processing window for [AWS Lambda streaming analytics](https://docs.aws.amazon.com/lambda/latest/dg/with-kinesis.html#services-kinesis-windows). The range is between 1 second up to 900 seconds. Only available for stream sources (DynamoDB and Kinesis).
     * 
     */
    @Export(name="tumblingWindowInSeconds", type=Integer.class, parameters={})
    private Output</* @Nullable */ Integer> tumblingWindowInSeconds;

    /**
     * @return The duration in seconds of a processing window for [AWS Lambda streaming analytics](https://docs.aws.amazon.com/lambda/latest/dg/with-kinesis.html#services-kinesis-windows). The range is between 1 second up to 900 seconds. Only available for stream sources (DynamoDB and Kinesis).
     * 
     */
    public Output</* @Nullable */ Integer> getTumblingWindowInSeconds() {
        return this.tumblingWindowInSeconds;
    }
    /**
     * The UUID of the created event source mapping.
     * 
     */
    @Export(name="uuid", type=String.class, parameters={})
    private Output<String> uuid;

    /**
     * @return The UUID of the created event source mapping.
     * 
     */
    public Output<String> getUuid() {
        return this.uuid;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public EventSourceMapping(String name) {
        this(name, EventSourceMappingArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public EventSourceMapping(String name, EventSourceMappingArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public EventSourceMapping(String name, EventSourceMappingArgs args, @Nullable io.pulumi.resources.CustomResourceOptions options) {
        super("aws:lambda/eventSourceMapping:EventSourceMapping", name, args == null ? EventSourceMappingArgs.Empty : args, makeResourceOptions(options, Output.empty()));
    }

    private EventSourceMapping(String name, Output<String> id, @Nullable EventSourceMappingState state, @Nullable io.pulumi.resources.CustomResourceOptions options) {
        super("aws:lambda/eventSourceMapping:EventSourceMapping", name, state, makeResourceOptions(options, id));
    }

    private static io.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable io.pulumi.resources.CustomResourceOptions options, @Nullable Output<String> id) {
        var defaultOptions = io.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return io.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static EventSourceMapping get(String name, Output<String> id, @Nullable EventSourceMappingState state, @Nullable io.pulumi.resources.CustomResourceOptions options) {
        return new EventSourceMapping(name, id, state, options);
    }
}
