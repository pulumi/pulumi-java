// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package io.pulumi.aws.networkfirewall;

import io.pulumi.aws.Utilities;
import io.pulumi.aws.networkfirewall.RuleGroupArgs;
import io.pulumi.aws.networkfirewall.inputs.RuleGroupState;
import io.pulumi.aws.networkfirewall.outputs.RuleGroupRuleGroup;
import io.pulumi.core.Output;
import io.pulumi.core.annotations.Export;
import io.pulumi.core.annotations.ResourceType;
import java.lang.Integer;
import java.lang.String;
import java.util.Map;
import javax.annotation.Nullable;

/**
 * Provides an AWS Network Firewall Rule Group Resource
 * 
 * {{% examples %}}
 * ## Example Usage
 * {{% example %}}
 * ### Stateful Inspection for denying access to a domain
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 * 
 * const example = new aws.networkfirewall.RuleGroup("example", {
 *     capacity: 100,
 *     ruleGroup: {
 *         rulesSource: {
 *             rulesSourceList: {
 *                 generatedRulesType: "DENYLIST",
 *                 targetTypes: ["HTTP_HOST"],
 *                 targets: ["test.example.com"],
 *             },
 *         },
 *     },
 *     tags: {
 *         Tag1: "Value1",
 *         Tag2: "Value2",
 *     },
 *     type: "STATEFUL",
 * });
 * ```
 * ```python
 * import pulumi
 * import pulumi_aws as aws
 * 
 * example = aws.networkfirewall.RuleGroup("example",
 *     capacity=100,
 *     rule_group=aws.networkfirewall.RuleGroupRuleGroupArgs(
 *         rules_source=aws.networkfirewall.RuleGroupRuleGroupRulesSourceArgs(
 *             rules_source_list=aws.networkfirewall.RuleGroupRuleGroupRulesSourceRulesSourceListArgs(
 *                 generated_rules_type="DENYLIST",
 *                 target_types=["HTTP_HOST"],
 *                 targets=["test.example.com"],
 *             ),
 *         ),
 *     ),
 *     tags={
 *         "Tag1": "Value1",
 *         "Tag2": "Value2",
 *     },
 *     type="STATEFUL")
 * ```
 * ```csharp
 * using Pulumi;
 * using Aws = Pulumi.Aws;
 * 
 * class MyStack : Stack
 * {
 *     public MyStack()
 *     {
 *         var example = new Aws.NetworkFirewall.RuleGroup("example", new Aws.NetworkFirewall.RuleGroupArgs
 *         {
 *             Capacity = 100,
 *             RuleGroup = new Aws.NetworkFirewall.Inputs.RuleGroupRuleGroupArgs
 *             {
 *                 RulesSource = new Aws.NetworkFirewall.Inputs.RuleGroupRuleGroupRulesSourceArgs
 *                 {
 *                     RulesSourceList = new Aws.NetworkFirewall.Inputs.RuleGroupRuleGroupRulesSourceRulesSourceListArgs
 *                     {
 *                         GeneratedRulesType = "DENYLIST",
 *                         TargetTypes = 
 *                         {
 *                             "HTTP_HOST",
 *                         },
 *                         Targets = 
 *                         {
 *                             "test.example.com",
 *                         },
 *                     },
 *                 },
 *             },
 *             Tags = 
 *             {
 *                 { "Tag1", "Value1" },
 *                 { "Tag2", "Value2" },
 *             },
 *             Type = "STATEFUL",
 *         });
 *     }
 * 
 * }
 * ```
 * ```go
 * package main
 * 
 * import (
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/networkfirewall"
 * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
 * )
 * 
 * func main() {
 * 	pulumi.Run(func(ctx *pulumi.Context) error {
 * 		_, err := networkfirewall.NewRuleGroup(ctx, "example", &networkfirewall.RuleGroupArgs{
 * 			Capacity: pulumi.Int(100),
 * 			RuleGroup: &networkfirewall.RuleGroupRuleGroupArgs{
 * 				RulesSource: &networkfirewall.RuleGroupRuleGroupRulesSourceArgs{
 * 					RulesSourceList: &networkfirewall.RuleGroupRuleGroupRulesSourceRulesSourceListArgs{
 * 						GeneratedRulesType: pulumi.String("DENYLIST"),
 * 						TargetTypes: pulumi.StringArray{
 * 							pulumi.String("HTTP_HOST"),
 * 						},
 * 						Targets: pulumi.StringArray{
 * 							pulumi.String("test.example.com"),
 * 						},
 * 					},
 * 				},
 * 			},
 * 			Tags: pulumi.StringMap{
 * 				"Tag1": pulumi.String("Value1"),
 * 				"Tag2": pulumi.String("Value2"),
 * 			},
 * 			Type: pulumi.String("STATEFUL"),
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		return nil
 * 	})
 * }
 * ```
 * {{% /example %}}
 * {{% example %}}
 * ### Stateful Inspection for permitting packets from a source IP address
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 * 
 * const ips = [
 *     "1.1.1.1/32",
 *     "1.0.0.1/32",
 * ];
 * const example = new aws.networkfirewall.RuleGroup("example", {
 *     capacity: 50,
 *     description: "Permits http traffic from source",
 *     type: "STATEFUL",
 *     ruleGroup: {
 *         rulesSource: {
 *             dynamic: [{
 *                 forEach: ips,
 *                 content: [{
 *                     action: "PASS",
 *                     header: [{
 *                         destination: "ANY",
 *                         destinationPort: "ANY",
 *                         protocol: "HTTP",
 *                         direction: "ANY",
 *                         sourcePort: "ANY",
 *                         source: stateful_rule.value,
 *                     }],
 *                     ruleOption: [{
 *                         keyword: "sid:1",
 *                     }],
 *                 }],
 *             }],
 *         },
 *     },
 *     tags: {
 *         Name: "permit HTTP from source",
 *     },
 * });
 * ```
 * ```python
 * import pulumi
 * import pulumi_aws as aws
 * 
 * ips = [
 *     "1.1.1.1/32",
 *     "1.0.0.1/32",
 * ]
 * example = aws.networkfirewall.RuleGroup("example",
 *     capacity=50,
 *     description="Permits http traffic from source",
 *     type="STATEFUL",
 *     rule_group=aws.networkfirewall.RuleGroupRuleGroupArgs(
 *         rules_source=aws.networkfirewall.RuleGroupRuleGroupRulesSourceArgs(
 *             dynamic=[{
 *                 "forEach": ips,
 *                 "content": [{
 *                     "action": "PASS",
 *                     "header": [{
 *                         "destination": "ANY",
 *                         "destinationPort": "ANY",
 *                         "protocol": "HTTP",
 *                         "direction": "ANY",
 *                         "sourcePort": "ANY",
 *                         "source": stateful_rule["value"],
 *                     }],
 *                     "ruleOption": [{
 *                         "keyword": "sid:1",
 *                     }],
 *                 }],
 *             }],
 *         ),
 *     ),
 *     tags={
 *         "Name": "permit HTTP from source",
 *     })
 * ```
 * ```csharp
 * using Pulumi;
 * using Aws = Pulumi.Aws;
 * 
 * class MyStack : Stack
 * {
 *     public MyStack()
 *     {
 *         var ips = 
 *         {
 *             "1.1.1.1/32",
 *             "1.0.0.1/32",
 *         };
 *         var example = new Aws.NetworkFirewall.RuleGroup("example", new Aws.NetworkFirewall.RuleGroupArgs
 *         {
 *             Capacity = 50,
 *             Description = "Permits http traffic from source",
 *             Type = "STATEFUL",
 *             RuleGroup = new Aws.NetworkFirewall.Inputs.RuleGroupRuleGroupArgs
 *             {
 *                 RulesSource = new Aws.NetworkFirewall.Inputs.RuleGroupRuleGroupRulesSourceArgs
 *                 {
 *                     Dynamic = 
 *                     {
 *                         
 *                         {
 *                             { "forEach", ips },
 *                             { "content", 
 *                             {
 *                                 
 *                                 {
 *                                     { "action", "PASS" },
 *                                     { "header", 
 *                                     {
 *                                         
 *                                         {
 *                                             { "destination", "ANY" },
 *                                             { "destinationPort", "ANY" },
 *                                             { "protocol", "HTTP" },
 *                                             { "direction", "ANY" },
 *                                             { "sourcePort", "ANY" },
 *                                             { "source", stateful_rule.Value },
 *                                         },
 *                                     } },
 *                                     { "ruleOption", 
 *                                     {
 *                                         
 *                                         {
 *                                             { "keyword", "sid:1" },
 *                                         },
 *                                     } },
 *                                 },
 *                             } },
 *                         },
 *                     },
 *                 },
 *             },
 *             Tags = 
 *             {
 *                 { "Name", "permit HTTP from source" },
 *             },
 *         });
 *     }
 * 
 * }
 * ```
 * ```go
 * package main
 * 
 * import (
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/networkfirewall"
 * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
 * )
 * 
 * func main() {
 * 	pulumi.Run(func(ctx *pulumi.Context) error {
 * 		ips := []string{
 * 			"1.1.1.1/32",
 * 			"1.0.0.1/32",
 * 		}
 * 		_, err := networkfirewall.NewRuleGroup(ctx, "example", &networkfirewall.RuleGroupArgs{
 * 			Capacity:    pulumi.Int(50),
 * 			Description: pulumi.String("Permits http traffic from source"),
 * 			Type:        pulumi.String("STATEFUL"),
 * 			RuleGroup: &networkfirewall.RuleGroupRuleGroupArgs{
 * 				RulesSource: &networkfirewall.RuleGroupRuleGroupRulesSourceArgs{
 * 					Dynamic: []map[string]interface{}{
 * 						map[string]interface{}{
 * 							"forEach": ips,
 * 							"content": []map[string]interface{}{
 * 								map[string]interface{}{
 * 									"action": "PASS",
 * 									"header": []map[string]interface{}{
 * 										map[string]interface{}{
 * 											"destination":     "ANY",
 * 											"destinationPort": "ANY",
 * 											"protocol":        "HTTP",
 * 											"direction":       "ANY",
 * 											"sourcePort":      "ANY",
 * 											"source":          stateful_rule.Value,
 * 										},
 * 									},
 * 									"ruleOption": []map[string]interface{}{
 * 										map[string]interface{}{
 * 											"keyword": "sid:1",
 * 										},
 * 									},
 * 								},
 * 							},
 * 						},
 * 					},
 * 				},
 * 			},
 * 			Tags: pulumi.StringMap{
 * 				"Name": pulumi.String("permit HTTP from source"),
 * 			},
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		return nil
 * 	})
 * }
 * ```
 * {{% /example %}}
 * {{% example %}}
 * ### Stateful Inspection for blocking packets from going to an intended destination
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 * 
 * const example = new aws.networkfirewall.RuleGroup("example", {
 *     capacity: 100,
 *     ruleGroup: {
 *         rulesSource: {
 *             statefulRules: [{
 *                 action: "DROP",
 *                 header: {
 *                     destination: "124.1.1.24/32",
 *                     destinationPort: "53",
 *                     direction: "ANY",
 *                     protocol: "TCP",
 *                     source: "1.2.3.4/32",
 *                     sourcePort: "53",
 *                 },
 *                 ruleOptions: [{
 *                     keyword: "sid:1",
 *                 }],
 *             }],
 *         },
 *     },
 *     tags: {
 *         Tag1: "Value1",
 *         Tag2: "Value2",
 *     },
 *     type: "STATEFUL",
 * });
 * ```
 * ```python
 * import pulumi
 * import pulumi_aws as aws
 * 
 * example = aws.networkfirewall.RuleGroup("example",
 *     capacity=100,
 *     rule_group=aws.networkfirewall.RuleGroupRuleGroupArgs(
 *         rules_source=aws.networkfirewall.RuleGroupRuleGroupRulesSourceArgs(
 *             stateful_rule=[{
 *                 "action": "DROP",
 *                 "header": {
 *                     "destination": "124.1.1.24/32",
 *                     "destinationPort": 53,
 *                     "direction": "ANY",
 *                     "protocol": "TCP",
 *                     "source": "1.2.3.4/32",
 *                     "sourcePort": 53,
 *                 },
 *                 "ruleOption": [{
 *                     "keyword": "sid:1",
 *                 }],
 *             }],
 *         ),
 *     ),
 *     tags={
 *         "Tag1": "Value1",
 *         "Tag2": "Value2",
 *     },
 *     type="STATEFUL")
 * ```
 * ```csharp
 * using Pulumi;
 * using Aws = Pulumi.Aws;
 * 
 * class MyStack : Stack
 * {
 *     public MyStack()
 *     {
 *         var example = new Aws.NetworkFirewall.RuleGroup("example", new Aws.NetworkFirewall.RuleGroupArgs
 *         {
 *             Capacity = 100,
 *             RuleGroup = new Aws.NetworkFirewall.Inputs.RuleGroupRuleGroupArgs
 *             {
 *                 RulesSource = new Aws.NetworkFirewall.Inputs.RuleGroupRuleGroupRulesSourceArgs
 *                 {
 *                     StatefulRule = 
 *                     {
 *                         
 *                         {
 *                             { "action", "DROP" },
 *                             { "header", 
 *                             {
 *                                 { "destination", "124.1.1.24/32" },
 *                                 { "destinationPort", 53 },
 *                                 { "direction", "ANY" },
 *                                 { "protocol", "TCP" },
 *                                 { "source", "1.2.3.4/32" },
 *                                 { "sourcePort", 53 },
 *                             } },
 *                             { "ruleOption", 
 *                             {
 *                                 
 *                                 {
 *                                     { "keyword", "sid:1" },
 *                                 },
 *                             } },
 *                         },
 *                     },
 *                 },
 *             },
 *             Tags = 
 *             {
 *                 { "Tag1", "Value1" },
 *                 { "Tag2", "Value2" },
 *             },
 *             Type = "STATEFUL",
 *         });
 *     }
 * 
 * }
 * ```
 * ```go
 * package main
 * 
 * import (
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/networkfirewall"
 * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
 * )
 * 
 * func main() {
 * 	pulumi.Run(func(ctx *pulumi.Context) error {
 * 		_, err := networkfirewall.NewRuleGroup(ctx, "example", &networkfirewall.RuleGroupArgs{
 * 			Capacity: pulumi.Int(100),
 * 			RuleGroup: &networkfirewall.RuleGroupRuleGroupArgs{
 * 				RulesSource: &networkfirewall.RuleGroupRuleGroupRulesSourceArgs{
 * 					StatefulRule: []map[string]interface{}{
 * 						map[string]interface{}{
 * 							"action": "DROP",
 * 							"header": map[string]interface{}{
 * 								"destination":     "124.1.1.24/32",
 * 								"destinationPort": 53,
 * 								"direction":       "ANY",
 * 								"protocol":        "TCP",
 * 								"source":          "1.2.3.4/32",
 * 								"sourcePort":      53,
 * 							},
 * 							"ruleOption": []map[string]interface{}{
 * 								map[string]interface{}{
 * 									"keyword": "sid:1",
 * 								},
 * 							},
 * 						},
 * 					},
 * 				},
 * 			},
 * 			Tags: pulumi.StringMap{
 * 				"Tag1": pulumi.String("Value1"),
 * 				"Tag2": pulumi.String("Value2"),
 * 			},
 * 			Type: pulumi.String("STATEFUL"),
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		return nil
 * 	})
 * }
 * ```
 * {{% /example %}}
 * {{% example %}}
 * ### Stateful Inspection from rules specifications defined in Suricata flat format
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 * import * from "fs";
 * 
 * const example = new aws.networkfirewall.RuleGroup("example", {
 *     capacity: 100,
 *     type: "STATEFUL",
 *     rules: fs.readFileSync("example.rules"),
 *     tags: {
 *         Tag1: "Value1",
 *         Tag2: "Value2",
 *     },
 * });
 * ```
 * ```python
 * import pulumi
 * import pulumi_aws as aws
 * 
 * example = aws.networkfirewall.RuleGroup("example",
 *     capacity=100,
 *     type="STATEFUL",
 *     rules=(lambda path: open(path).read())("example.rules"),
 *     tags={
 *         "Tag1": "Value1",
 *         "Tag2": "Value2",
 *     })
 * ```
 * ```csharp
 * using System.IO;
 * using Pulumi;
 * using Aws = Pulumi.Aws;
 * 
 * class MyStack : Stack
 * {
 *     public MyStack()
 *     {
 *         var example = new Aws.NetworkFirewall.RuleGroup("example", new Aws.NetworkFirewall.RuleGroupArgs
 *         {
 *             Capacity = 100,
 *             Type = "STATEFUL",
 *             Rules = File.ReadAllText("example.rules"),
 *             Tags = 
 *             {
 *                 { "Tag1", "Value1" },
 *                 { "Tag2", "Value2" },
 *             },
 *         });
 *     }
 * 
 * }
 * ```
 * ```go
 * package main
 * 
 * import (
 * 	"io/ioutil"
 * 
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/networkfirewall"
 * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
 * )
 * 
 * func readFileOrPanic(path string) pulumi.StringPtrInput {
 * 	data, err := ioutil.ReadFile(path)
 * 	if err != nil {
 * 		panic(err.Error())
 * 	}
 * 	return pulumi.String(string(data))
 * }
 * 
 * func main() {
 * 	pulumi.Run(func(ctx *pulumi.Context) error {
 * 		_, err := networkfirewall.NewRuleGroup(ctx, "example", &networkfirewall.RuleGroupArgs{
 * 			Capacity: pulumi.Int(100),
 * 			Type:     pulumi.String("STATEFUL"),
 * 			Rules:    readFileOrPanic("example.rules"),
 * 			Tags: pulumi.StringMap{
 * 				"Tag1": pulumi.String("Value1"),
 * 				"Tag2": pulumi.String("Value2"),
 * 			},
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		return nil
 * 	})
 * }
 * ```
 * {{% /example %}}
 * {{% example %}}
 * ### Stateful Inspection from rule group specifications using rule variables and Suricata format rules
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 * import * from "fs";
 * 
 * const example = new aws.networkfirewall.RuleGroup("example", {
 *     capacity: 100,
 *     type: "STATEFUL",
 *     ruleGroup: {
 *         ruleVariables: {
 *             ipSets: [
 *                 {
 *                     key: "WEBSERVERS_HOSTS",
 *                     ipSet: {
 *                         definitions: [
 *                             "10.0.0.0/16",
 *                             "10.0.1.0/24",
 *                             "192.168.0.0/16",
 *                         ],
 *                     },
 *                 },
 *                 {
 *                     key: "EXTERNAL_HOST",
 *                     ipSet: {
 *                         definitions: ["1.2.3.4/32"],
 *                     },
 *                 },
 *             ],
 *             portSets: [{
 *                 key: "HTTP_PORTS",
 *                 portSet: {
 *                     definitions: [
 *                         "443",
 *                         "80",
 *                     ],
 *                 },
 *             }],
 *         },
 *         rulesSource: {
 *             rulesString: fs.readFileSync("suricata_rules_file"),
 *         },
 *     },
 *     tags: {
 *         Tag1: "Value1",
 *         Tag2: "Value2",
 *     },
 * });
 * ```
 * ```python
 * import pulumi
 * import pulumi_aws as aws
 * 
 * example = aws.networkfirewall.RuleGroup("example",
 *     capacity=100,
 *     type="STATEFUL",
 *     rule_group=aws.networkfirewall.RuleGroupRuleGroupArgs(
 *         rule_variables=aws.networkfirewall.RuleGroupRuleGroupRuleVariablesArgs(
 *             ip_sets=[
 *                 aws.networkfirewall.RuleGroupRuleGroupRuleVariablesIpSetArgs(
 *                     key="WEBSERVERS_HOSTS",
 *                     ip_set=aws.networkfirewall.RuleGroupRuleGroupRuleVariablesIpSetIpSetArgs(
 *                         definitions=[
 *                             "10.0.0.0/16",
 *                             "10.0.1.0/24",
 *                             "192.168.0.0/16",
 *                         ],
 *                     ),
 *                 ),
 *                 aws.networkfirewall.RuleGroupRuleGroupRuleVariablesIpSetArgs(
 *                     key="EXTERNAL_HOST",
 *                     ip_set=aws.networkfirewall.RuleGroupRuleGroupRuleVariablesIpSetIpSetArgs(
 *                         definitions=["1.2.3.4/32"],
 *                     ),
 *                 ),
 *             ],
 *             port_sets=[aws.networkfirewall.RuleGroupRuleGroupRuleVariablesPortSetArgs(
 *                 key="HTTP_PORTS",
 *                 port_set=aws.networkfirewall.RuleGroupRuleGroupRuleVariablesPortSetPortSetArgs(
 *                     definitions=[
 *                         "443",
 *                         "80",
 *                     ],
 *                 ),
 *             )],
 *         ),
 *         rules_source=aws.networkfirewall.RuleGroupRuleGroupRulesSourceArgs(
 *             rules_string=(lambda path: open(path).read())("suricata_rules_file"),
 *         ),
 *     ),
 *     tags={
 *         "Tag1": "Value1",
 *         "Tag2": "Value2",
 *     })
 * ```
 * ```csharp
 * using System.IO;
 * using Pulumi;
 * using Aws = Pulumi.Aws;
 * 
 * class MyStack : Stack
 * {
 *     public MyStack()
 *     {
 *         var example = new Aws.NetworkFirewall.RuleGroup("example", new Aws.NetworkFirewall.RuleGroupArgs
 *         {
 *             Capacity = 100,
 *             Type = "STATEFUL",
 *             RuleGroup = new Aws.NetworkFirewall.Inputs.RuleGroupRuleGroupArgs
 *             {
 *                 RuleVariables = new Aws.NetworkFirewall.Inputs.RuleGroupRuleGroupRuleVariablesArgs
 *                 {
 *                     IpSets = 
 *                     {
 *                         new Aws.NetworkFirewall.Inputs.RuleGroupRuleGroupRuleVariablesIpSetArgs
 *                         {
 *                             Key = "WEBSERVERS_HOSTS",
 *                             IpSet = new Aws.NetworkFirewall.Inputs.RuleGroupRuleGroupRuleVariablesIpSetIpSetArgs
 *                             {
 *                                 Definitions = 
 *                                 {
 *                                     "10.0.0.0/16",
 *                                     "10.0.1.0/24",
 *                                     "192.168.0.0/16",
 *                                 },
 *                             },
 *                         },
 *                         new Aws.NetworkFirewall.Inputs.RuleGroupRuleGroupRuleVariablesIpSetArgs
 *                         {
 *                             Key = "EXTERNAL_HOST",
 *                             IpSet = new Aws.NetworkFirewall.Inputs.RuleGroupRuleGroupRuleVariablesIpSetIpSetArgs
 *                             {
 *                                 Definitions = 
 *                                 {
 *                                     "1.2.3.4/32",
 *                                 },
 *                             },
 *                         },
 *                     },
 *                     PortSets = 
 *                     {
 *                         new Aws.NetworkFirewall.Inputs.RuleGroupRuleGroupRuleVariablesPortSetArgs
 *                         {
 *                             Key = "HTTP_PORTS",
 *                             PortSet = new Aws.NetworkFirewall.Inputs.RuleGroupRuleGroupRuleVariablesPortSetPortSetArgs
 *                             {
 *                                 Definitions = 
 *                                 {
 *                                     "443",
 *                                     "80",
 *                                 },
 *                             },
 *                         },
 *                     },
 *                 },
 *                 RulesSource = new Aws.NetworkFirewall.Inputs.RuleGroupRuleGroupRulesSourceArgs
 *                 {
 *                     RulesString = File.ReadAllText("suricata_rules_file"),
 *                 },
 *             },
 *             Tags = 
 *             {
 *                 { "Tag1", "Value1" },
 *                 { "Tag2", "Value2" },
 *             },
 *         });
 *     }
 * 
 * }
 * ```
 * ```go
 * package main
 * 
 * import (
 * 	"io/ioutil"
 * 
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/networkfirewall"
 * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
 * )
 * 
 * func readFileOrPanic(path string) pulumi.StringPtrInput {
 * 	data, err := ioutil.ReadFile(path)
 * 	if err != nil {
 * 		panic(err.Error())
 * 	}
 * 	return pulumi.String(string(data))
 * }
 * 
 * func main() {
 * 	pulumi.Run(func(ctx *pulumi.Context) error {
 * 		_, err := networkfirewall.NewRuleGroup(ctx, "example", &networkfirewall.RuleGroupArgs{
 * 			Capacity: pulumi.Int(100),
 * 			Type:     pulumi.String("STATEFUL"),
 * 			RuleGroup: &networkfirewall.RuleGroupRuleGroupArgs{
 * 				RuleVariables: &networkfirewall.RuleGroupRuleGroupRuleVariablesArgs{
 * 					IpSets: networkfirewall.RuleGroupRuleGroupRuleVariablesIpSetArray{
 * 						&networkfirewall.RuleGroupRuleGroupRuleVariablesIpSetArgs{
 * 							Key: pulumi.String("WEBSERVERS_HOSTS"),
 * 							IpSet: &networkfirewall.RuleGroupRuleGroupRuleVariablesIpSetIpSetArgs{
 * 								Definitions: pulumi.StringArray{
 * 									pulumi.String("10.0.0.0/16"),
 * 									pulumi.String("10.0.1.0/24"),
 * 									pulumi.String("192.168.0.0/16"),
 * 								},
 * 							},
 * 						},
 * 						&networkfirewall.RuleGroupRuleGroupRuleVariablesIpSetArgs{
 * 							Key: pulumi.String("EXTERNAL_HOST"),
 * 							IpSet: &networkfirewall.RuleGroupRuleGroupRuleVariablesIpSetIpSetArgs{
 * 								Definitions: pulumi.StringArray{
 * 									pulumi.String("1.2.3.4/32"),
 * 								},
 * 							},
 * 						},
 * 					},
 * 					PortSets: networkfirewall.RuleGroupRuleGroupRuleVariablesPortSetArray{
 * 						&networkfirewall.RuleGroupRuleGroupRuleVariablesPortSetArgs{
 * 							Key: pulumi.String("HTTP_PORTS"),
 * 							PortSet: &networkfirewall.RuleGroupRuleGroupRuleVariablesPortSetPortSetArgs{
 * 								Definitions: pulumi.StringArray{
 * 									pulumi.String("443"),
 * 									pulumi.String("80"),
 * 								},
 * 							},
 * 						},
 * 					},
 * 				},
 * 				RulesSource: &networkfirewall.RuleGroupRuleGroupRulesSourceArgs{
 * 					RulesString: readFileOrPanic("suricata_rules_file"),
 * 				},
 * 			},
 * 			Tags: pulumi.StringMap{
 * 				"Tag1": pulumi.String("Value1"),
 * 				"Tag2": pulumi.String("Value2"),
 * 			},
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		return nil
 * 	})
 * }
 * ```
 * {{% /example %}}
 * {{% example %}}
 * ### Stateless Inspection with a Custom Action
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 * 
 * const example = new aws.networkfirewall.RuleGroup("example", {
 *     capacity: 100,
 *     description: "Stateless Rate Limiting Rule",
 *     ruleGroup: {
 *         rulesSource: {
 *             statelessRulesAndCustomActions: {
 *                 customActions: [{
 *                     actionDefinition: {
 *                         publishMetricAction: {
 *                             dimensions: [{
 *                                 value: "2",
 *                             }],
 *                         },
 *                     },
 *                     actionName: "ExampleMetricsAction",
 *                 }],
 *                 statelessRules: [{
 *                     priority: 1,
 *                     ruleDefinition: {
 *                         actions: [
 *                             "aws:pass",
 *                             "ExampleMetricsAction",
 *                         ],
 *                         matchAttributes: {
 *                             destinations: [{
 *                                 addressDefinition: "124.1.1.5/32",
 *                             }],
 *                             destinationPorts: [{
 *                                 fromPort: 443,
 *                                 toPort: 443,
 *                             }],
 *                             protocols: [6],
 *                             sources: [{
 *                                 addressDefinition: "1.2.3.4/32",
 *                             }],
 *                             sourcePorts: [{
 *                                 fromPort: 443,
 *                                 toPort: 443,
 *                             }],
 *                             tcpFlags: [{
 *                                 flags: ["SYN"],
 *                                 masks: [
 *                                     "SYN",
 *                                     "ACK",
 *                                 ],
 *                             }],
 *                         },
 *                     },
 *                 }],
 *             },
 *         },
 *     },
 *     tags: {
 *         Tag1: "Value1",
 *         Tag2: "Value2",
 *     },
 *     type: "STATELESS",
 * });
 * ```
 * ```python
 * import pulumi
 * import pulumi_aws as aws
 * 
 * example = aws.networkfirewall.RuleGroup("example",
 *     capacity=100,
 *     description="Stateless Rate Limiting Rule",
 *     rule_group=aws.networkfirewall.RuleGroupRuleGroupArgs(
 *         rules_source=aws.networkfirewall.RuleGroupRuleGroupRulesSourceArgs(
 *             stateless_rules_and_custom_actions=aws.networkfirewall.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsArgs(
 *                 custom_action=[{
 *                     "actionDefinition": {
 *                         "publishMetricAction": {
 *                             "dimension": [{
 *                                 "value": "2",
 *                             }],
 *                         },
 *                     },
 *                     "actionName": "ExampleMetricsAction",
 *                 }],
 *                 stateless_rule=[{
 *                     "priority": 1,
 *                     "ruleDefinition": {
 *                         "actions": [
 *                             "aws:pass",
 *                             "ExampleMetricsAction",
 *                         ],
 *                         "matchAttributes": {
 *                             "destination": [{
 *                                 "addressDefinition": "124.1.1.5/32",
 *                             }],
 *                             "destinationPort": [{
 *                                 "fromPort": 443,
 *                                 "toPort": 443,
 *                             }],
 *                             "protocols": [6],
 *                             "source": [{
 *                                 "addressDefinition": "1.2.3.4/32",
 *                             }],
 *                             "sourcePort": [{
 *                                 "fromPort": 443,
 *                                 "toPort": 443,
 *                             }],
 *                             "tcpFlag": [{
 *                                 "flags": ["SYN"],
 *                                 "masks": [
 *                                     "SYN",
 *                                     "ACK",
 *                                 ],
 *                             }],
 *                         },
 *                     },
 *                 }],
 *             ),
 *         ),
 *     ),
 *     tags={
 *         "Tag1": "Value1",
 *         "Tag2": "Value2",
 *     },
 *     type="STATELESS")
 * ```
 * ```csharp
 * using Pulumi;
 * using Aws = Pulumi.Aws;
 * 
 * class MyStack : Stack
 * {
 *     public MyStack()
 *     {
 *         var example = new Aws.NetworkFirewall.RuleGroup("example", new Aws.NetworkFirewall.RuleGroupArgs
 *         {
 *             Capacity = 100,
 *             Description = "Stateless Rate Limiting Rule",
 *             RuleGroup = new Aws.NetworkFirewall.Inputs.RuleGroupRuleGroupArgs
 *             {
 *                 RulesSource = new Aws.NetworkFirewall.Inputs.RuleGroupRuleGroupRulesSourceArgs
 *                 {
 *                     StatelessRulesAndCustomActions = new Aws.NetworkFirewall.Inputs.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsArgs
 *                     {
 *                         CustomAction = 
 *                         {
 *                             
 *                             {
 *                                 { "actionDefinition", 
 *                                 {
 *                                     { "publishMetricAction", 
 *                                     {
 *                                         { "dimension", 
 *                                         {
 *                                             
 *                                             {
 *                                                 { "value", "2" },
 *                                             },
 *                                         } },
 *                                     } },
 *                                 } },
 *                                 { "actionName", "ExampleMetricsAction" },
 *                             },
 *                         },
 *                         StatelessRule = 
 *                         {
 *                             
 *                             {
 *                                 { "priority", 1 },
 *                                 { "ruleDefinition", 
 *                                 {
 *                                     { "actions", 
 *                                     {
 *                                         "aws:pass",
 *                                         "ExampleMetricsAction",
 *                                     } },
 *                                     { "matchAttributes", 
 *                                     {
 *                                         { "destination", 
 *                                         {
 *                                             
 *                                             {
 *                                                 { "addressDefinition", "124.1.1.5/32" },
 *                                             },
 *                                         } },
 *                                         { "destinationPort", 
 *                                         {
 *                                             
 *                                             {
 *                                                 { "fromPort", 443 },
 *                                                 { "toPort", 443 },
 *                                             },
 *                                         } },
 *                                         { "protocols", 
 *                                         {
 *                                             6,
 *                                         } },
 *                                         { "source", 
 *                                         {
 *                                             
 *                                             {
 *                                                 { "addressDefinition", "1.2.3.4/32" },
 *                                             },
 *                                         } },
 *                                         { "sourcePort", 
 *                                         {
 *                                             
 *                                             {
 *                                                 { "fromPort", 443 },
 *                                                 { "toPort", 443 },
 *                                             },
 *                                         } },
 *                                         { "tcpFlag", 
 *                                         {
 *                                             
 *                                             {
 *                                                 { "flags", 
 *                                                 {
 *                                                     "SYN",
 *                                                 } },
 *                                                 { "masks", 
 *                                                 {
 *                                                     "SYN",
 *                                                     "ACK",
 *                                                 } },
 *                                             },
 *                                         } },
 *                                     } },
 *                                 } },
 *                             },
 *                         },
 *                     },
 *                 },
 *             },
 *             Tags = 
 *             {
 *                 { "Tag1", "Value1" },
 *                 { "Tag2", "Value2" },
 *             },
 *             Type = "STATELESS",
 *         });
 *     }
 * 
 * }
 * ```
 * ```go
 * package main
 * 
 * import (
 * 	"github.com/pulumi/pulumi-aws/sdk/v4/go/aws/networkfirewall"
 * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
 * )
 * 
 * func main() {
 * 	pulumi.Run(func(ctx *pulumi.Context) error {
 * 		_, err := networkfirewall.NewRuleGroup(ctx, "example", &networkfirewall.RuleGroupArgs{
 * 			Capacity:    pulumi.Int(100),
 * 			Description: pulumi.String("Stateless Rate Limiting Rule"),
 * 			RuleGroup: &networkfirewall.RuleGroupRuleGroupArgs{
 * 				RulesSource: &networkfirewall.RuleGroupRuleGroupRulesSourceArgs{
 * 					StatelessRulesAndCustomActions: &networkfirewall.RuleGroupRuleGroupRulesSourceStatelessRulesAndCustomActionsArgs{
 * 						CustomAction: []map[string]interface{}{
 * 							map[string]interface{}{
 * 								"actionDefinition": map[string]interface{}{
 * 									"publishMetricAction": map[string]interface{}{
 * 										"dimension": []map[string]interface{}{
 * 											map[string]interface{}{
 * 												"value": "2",
 * 											},
 * 										},
 * 									},
 * 								},
 * 								"actionName": "ExampleMetricsAction",
 * 							},
 * 						},
 * 						StatelessRule: []map[string]interface{}{
 * 							map[string]interface{}{
 * 								"priority": 1,
 * 								"ruleDefinition": map[string]interface{}{
 * 									"actions": []string{
 * 										"aws:pass",
 * 										"ExampleMetricsAction",
 * 									},
 * 									"matchAttributes": map[string]interface{}{
 * 										"destination": []map[string]interface{}{
 * 											map[string]interface{}{
 * 												"addressDefinition": "124.1.1.5/32",
 * 											},
 * 										},
 * 										"destinationPort": []map[string]interface{}{
 * 											map[string]interface{}{
 * 												"fromPort": 443,
 * 												"toPort":   443,
 * 											},
 * 										},
 * 										"protocols": []float64{
 * 											6,
 * 										},
 * 										"source": []map[string]interface{}{
 * 											map[string]interface{}{
 * 												"addressDefinition": "1.2.3.4/32",
 * 											},
 * 										},
 * 										"sourcePort": []map[string]interface{}{
 * 											map[string]interface{}{
 * 												"fromPort": 443,
 * 												"toPort":   443,
 * 											},
 * 										},
 * 										"tcpFlag": []map[string]interface{}{
 * 											map[string]interface{}{
 * 												"flags": []string{
 * 													"SYN",
 * 												},
 * 												"masks": []string{
 * 													"SYN",
 * 													"ACK",
 * 												},
 * 											},
 * 										},
 * 									},
 * 								},
 * 							},
 * 						},
 * 					},
 * 				},
 * 			},
 * 			Tags: pulumi.StringMap{
 * 				"Tag1": pulumi.String("Value1"),
 * 				"Tag2": pulumi.String("Value2"),
 * 			},
 * 			Type: pulumi.String("STATELESS"),
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		return nil
 * 	})
 * }
 * ```
 * {{% /example %}}
 * {{% /examples %}}
 * 
 * ## Import
 * 
 * Network Firewall Rule Groups can be imported using their `ARN`.
 * 
 * ```sh
 *  $ pulumi import aws:networkfirewall/ruleGroup:RuleGroup example arn:aws:network-firewall:us-west-1:123456789012:stateful-rulegroup/example
 * ```
 * 
 *  
 */
@ResourceType(type="aws:networkfirewall/ruleGroup:RuleGroup")
public class RuleGroup extends io.pulumi.resources.CustomResource {
    /**
     * The Amazon Resource Name (ARN) that identifies the rule group.
     * 
     */
    @Export(name="arn", type=String.class, parameters={})
    private Output<String> arn;

    /**
     * @return The Amazon Resource Name (ARN) that identifies the rule group.
     * 
     */
    public Output<String> getArn() {
        return this.arn;
    }
    /**
     * The maximum number of operating resources that this rule group can use. For a stateless rule group, the capacity required is the sum of the capacity requirements of the individual rules. For a stateful rule group, the minimum capacity required is the number of individual rules.
     * 
     */
    @Export(name="capacity", type=Integer.class, parameters={})
    private Output<Integer> capacity;

    /**
     * @return The maximum number of operating resources that this rule group can use. For a stateless rule group, the capacity required is the sum of the capacity requirements of the individual rules. For a stateful rule group, the minimum capacity required is the number of individual rules.
     * 
     */
    public Output<Integer> getCapacity() {
        return this.capacity;
    }
    /**
     * A friendly description of the rule group.
     * 
     */
    @Export(name="description", type=String.class, parameters={})
    private Output</* @Nullable */ String> description;

    /**
     * @return A friendly description of the rule group.
     * 
     */
    public Output</* @Nullable */ String> getDescription() {
        return this.description;
    }
    /**
     * A friendly name of the rule group.
     * 
     */
    @Export(name="name", type=String.class, parameters={})
    private Output<String> name;

    /**
     * @return A friendly name of the rule group.
     * 
     */
    public Output<String> getName() {
        return this.name;
    }
    /**
     * A configuration block that defines the rule group rules. Required unless `rules` is specified. See Rule Group below for details.
     * 
     */
    @Export(name="ruleGroup", type=RuleGroupRuleGroup.class, parameters={})
    private Output<RuleGroupRuleGroup> ruleGroup;

    /**
     * @return A configuration block that defines the rule group rules. Required unless `rules` is specified. See Rule Group below for details.
     * 
     */
    public Output<RuleGroupRuleGroup> getRuleGroup() {
        return this.ruleGroup;
    }
    /**
     * The stateful rule group rules specifications in Suricata file format, with one rule per line. Use this to import your existing Suricata compatible rule groups. Required unless `rule_group` is specified.
     * 
     */
    @Export(name="rules", type=String.class, parameters={})
    private Output</* @Nullable */ String> rules;

    /**
     * @return The stateful rule group rules specifications in Suricata file format, with one rule per line. Use this to import your existing Suricata compatible rule groups. Required unless `rule_group` is specified.
     * 
     */
    public Output</* @Nullable */ String> getRules() {
        return this.rules;
    }
    /**
     * A map of key:value pairs to associate with the resource. .If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
     * 
     */
    @Export(name="tags", type=Map.class, parameters={String.class, String.class})
    private Output</* @Nullable */ Map<String,String>> tags;

    /**
     * @return A map of key:value pairs to associate with the resource. .If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
     * 
     */
    public Output</* @Nullable */ Map<String,String>> getTags() {
        return this.tags;
    }
    /**
     * A map of tags assigned to the resource, including those inherited from the provider .
     * 
     */
    @Export(name="tagsAll", type=Map.class, parameters={String.class, String.class})
    private Output<Map<String,String>> tagsAll;

    /**
     * @return A map of tags assigned to the resource, including those inherited from the provider .
     * 
     */
    public Output<Map<String,String>> getTagsAll() {
        return this.tagsAll;
    }
    /**
     * Whether the rule group is stateless (containing stateless rules) or stateful (containing stateful rules). Valid values include: `STATEFUL` or `STATELESS`.
     * 
     */
    @Export(name="type", type=String.class, parameters={})
    private Output<String> type;

    /**
     * @return Whether the rule group is stateless (containing stateless rules) or stateful (containing stateful rules). Valid values include: `STATEFUL` or `STATELESS`.
     * 
     */
    public Output<String> getType() {
        return this.type;
    }
    /**
     * A string token used when updating the rule group.
     * 
     */
    @Export(name="updateToken", type=String.class, parameters={})
    private Output<String> updateToken;

    /**
     * @return A string token used when updating the rule group.
     * 
     */
    public Output<String> getUpdateToken() {
        return this.updateToken;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public RuleGroup(String name) {
        this(name, RuleGroupArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public RuleGroup(String name, RuleGroupArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public RuleGroup(String name, RuleGroupArgs args, @Nullable io.pulumi.resources.CustomResourceOptions options) {
        super("aws:networkfirewall/ruleGroup:RuleGroup", name, args == null ? RuleGroupArgs.Empty : args, makeResourceOptions(options, Output.empty()));
    }

    private RuleGroup(String name, Output<String> id, @Nullable RuleGroupState state, @Nullable io.pulumi.resources.CustomResourceOptions options) {
        super("aws:networkfirewall/ruleGroup:RuleGroup", name, state, makeResourceOptions(options, id));
    }

    private static io.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable io.pulumi.resources.CustomResourceOptions options, @Nullable Output<String> id) {
        var defaultOptions = io.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return io.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static RuleGroup get(String name, Output<String> id, @Nullable RuleGroupState state, @Nullable io.pulumi.resources.CustomResourceOptions options) {
        return new RuleGroup(name, id, state, options);
    }
}
