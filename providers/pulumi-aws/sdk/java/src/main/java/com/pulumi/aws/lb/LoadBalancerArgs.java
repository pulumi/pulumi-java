// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.aws.lb;

import com.pulumi.aws.lb.inputs.LoadBalancerAccessLogsArgs;
import com.pulumi.aws.lb.inputs.LoadBalancerSubnetMappingArgs;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class LoadBalancerArgs extends com.pulumi.resources.ResourceArgs {

    public static final LoadBalancerArgs Empty = new LoadBalancerArgs();

    /**
     * An Access Logs block. Access Logs documented below.
     * 
     */
    @Import(name="accessLogs")
    private @Nullable Output<LoadBalancerAccessLogsArgs> accessLogs;

    public Optional<Output<LoadBalancerAccessLogsArgs>> accessLogs() {
        return Optional.ofNullable(this.accessLogs);
    }

    /**
     * The ID of the customer owned ipv4 pool to use for this load balancer.
     * 
     */
    @Import(name="customerOwnedIpv4Pool")
    private @Nullable Output<String> customerOwnedIpv4Pool;

    public Optional<Output<String>> customerOwnedIpv4Pool() {
        return Optional.ofNullable(this.customerOwnedIpv4Pool);
    }

    /**
     * Determines how the load balancer handles requests that might pose a security risk to an application due to HTTP desync. Valid values are `monitor`, `defensive` (default), `strictest`.
     * 
     */
    @Import(name="desyncMitigationMode")
    private @Nullable Output<String> desyncMitigationMode;

    public Optional<Output<String>> desyncMitigationMode() {
        return Optional.ofNullable(this.desyncMitigationMode);
    }

    /**
     * Indicates whether HTTP headers with header fields that are not valid are removed by the load balancer (true) or routed to targets (false). The default is false. Elastic Load Balancing requires that message header names contain only alphanumeric characters and hyphens. Only valid for Load Balancers of type `application`.
     * 
     */
    @Import(name="dropInvalidHeaderFields")
    private @Nullable Output<Boolean> dropInvalidHeaderFields;

    public Optional<Output<Boolean>> dropInvalidHeaderFields() {
        return Optional.ofNullable(this.dropInvalidHeaderFields);
    }

    /**
     * If true, cross-zone load balancing of the load balancer will be enabled.
     * This is a `network` load balancer feature. Defaults to `false`.
     * 
     */
    @Import(name="enableCrossZoneLoadBalancing")
    private @Nullable Output<Boolean> enableCrossZoneLoadBalancing;

    public Optional<Output<Boolean>> enableCrossZoneLoadBalancing() {
        return Optional.ofNullable(this.enableCrossZoneLoadBalancing);
    }

    /**
     * If true, deletion of the load balancer will be disabled via
     * the AWS API. This will prevent this provider from deleting the load balancer. Defaults to `false`.
     * 
     */
    @Import(name="enableDeletionProtection")
    private @Nullable Output<Boolean> enableDeletionProtection;

    public Optional<Output<Boolean>> enableDeletionProtection() {
        return Optional.ofNullable(this.enableDeletionProtection);
    }

    /**
     * Indicates whether HTTP/2 is enabled in `application` load balancers. Defaults to `true`.
     * 
     */
    @Import(name="enableHttp2")
    private @Nullable Output<Boolean> enableHttp2;

    public Optional<Output<Boolean>> enableHttp2() {
        return Optional.ofNullable(this.enableHttp2);
    }

    /**
     * Indicates whether to allow a WAF-enabled load balancer to route requests to targets if it is unable to forward the request to AWS WAF. Defaults to `false`.
     * 
     */
    @Import(name="enableWafFailOpen")
    private @Nullable Output<Boolean> enableWafFailOpen;

    public Optional<Output<Boolean>> enableWafFailOpen() {
        return Optional.ofNullable(this.enableWafFailOpen);
    }

    /**
     * The time in seconds that the connection is allowed to be idle. Only valid for Load Balancers of type `application`. Default: 60.
     * 
     */
    @Import(name="idleTimeout")
    private @Nullable Output<Integer> idleTimeout;

    public Optional<Output<Integer>> idleTimeout() {
        return Optional.ofNullable(this.idleTimeout);
    }

    /**
     * If true, the LB will be internal.
     * 
     */
    @Import(name="internal")
    private @Nullable Output<Boolean> internal;

    public Optional<Output<Boolean>> internal() {
        return Optional.ofNullable(this.internal);
    }

    /**
     * The type of IP addresses used by the subnets for your load balancer. The possible values are `ipv4` and `dualstack`
     * 
     */
    @Import(name="ipAddressType")
    private @Nullable Output<String> ipAddressType;

    public Optional<Output<String>> ipAddressType() {
        return Optional.ofNullable(this.ipAddressType);
    }

    /**
     * The type of load balancer to create. Possible values are `application`, `gateway`, or `network`. The default value is `application`.
     * 
     */
    @Import(name="loadBalancerType")
    private @Nullable Output<String> loadBalancerType;

    public Optional<Output<String>> loadBalancerType() {
        return Optional.ofNullable(this.loadBalancerType);
    }

    /**
     * The name of the LB. This name must be unique within your AWS account, can have a maximum of 32 characters,
     * must contain only alphanumeric characters or hyphens, and must not begin or end with a hyphen. If not specified,
     * this provider will autogenerate a name beginning with `tf-lb`.
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * Creates a unique name beginning with the specified prefix. Conflicts with `name`.
     * 
     */
    @Import(name="namePrefix")
    private @Nullable Output<String> namePrefix;

    public Optional<Output<String>> namePrefix() {
        return Optional.ofNullable(this.namePrefix);
    }

    /**
     * A list of security group IDs to assign to the LB. Only valid for Load Balancers of type `application`.
     * 
     */
    @Import(name="securityGroups")
    private @Nullable Output<List<String>> securityGroups;

    public Optional<Output<List<String>>> securityGroups() {
        return Optional.ofNullable(this.securityGroups);
    }

    /**
     * A subnet mapping block as documented below.
     * 
     */
    @Import(name="subnetMappings")
    private @Nullable Output<List<LoadBalancerSubnetMappingArgs>> subnetMappings;

    public Optional<Output<List<LoadBalancerSubnetMappingArgs>>> subnetMappings() {
        return Optional.ofNullable(this.subnetMappings);
    }

    /**
     * A list of subnet IDs to attach to the LB. Subnets
     * cannot be updated for Load Balancers of type `network`. Changing this value
     * for load balancers of type `network` will force a recreation of the resource.
     * 
     */
    @Import(name="subnets")
    private @Nullable Output<List<String>> subnets;

    public Optional<Output<List<String>>> subnets() {
        return Optional.ofNullable(this.subnets);
    }

    /**
     * A map of tags to assign to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
     * 
     */
    @Import(name="tags")
    private @Nullable Output<Map<String,String>> tags;

    public Optional<Output<Map<String,String>>> tags() {
        return Optional.ofNullable(this.tags);
    }

    private LoadBalancerArgs() {}

    private LoadBalancerArgs(LoadBalancerArgs $) {
        this.accessLogs = $.accessLogs;
        this.customerOwnedIpv4Pool = $.customerOwnedIpv4Pool;
        this.desyncMitigationMode = $.desyncMitigationMode;
        this.dropInvalidHeaderFields = $.dropInvalidHeaderFields;
        this.enableCrossZoneLoadBalancing = $.enableCrossZoneLoadBalancing;
        this.enableDeletionProtection = $.enableDeletionProtection;
        this.enableHttp2 = $.enableHttp2;
        this.enableWafFailOpen = $.enableWafFailOpen;
        this.idleTimeout = $.idleTimeout;
        this.internal = $.internal;
        this.ipAddressType = $.ipAddressType;
        this.loadBalancerType = $.loadBalancerType;
        this.name = $.name;
        this.namePrefix = $.namePrefix;
        this.securityGroups = $.securityGroups;
        this.subnetMappings = $.subnetMappings;
        this.subnets = $.subnets;
        this.tags = $.tags;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(LoadBalancerArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private LoadBalancerArgs $;

        public Builder() {
            $ = new LoadBalancerArgs();
        }

        public Builder(LoadBalancerArgs defaults) {
            $ = new LoadBalancerArgs(Objects.requireNonNull(defaults));
        }

        public Builder accessLogs(@Nullable Output<LoadBalancerAccessLogsArgs> accessLogs) {
            $.accessLogs = accessLogs;
            return this;
        }

        public Builder accessLogs(LoadBalancerAccessLogsArgs accessLogs) {
            return accessLogs(Output.of(accessLogs));
        }

        public Builder customerOwnedIpv4Pool(@Nullable Output<String> customerOwnedIpv4Pool) {
            $.customerOwnedIpv4Pool = customerOwnedIpv4Pool;
            return this;
        }

        public Builder customerOwnedIpv4Pool(String customerOwnedIpv4Pool) {
            return customerOwnedIpv4Pool(Output.of(customerOwnedIpv4Pool));
        }

        public Builder desyncMitigationMode(@Nullable Output<String> desyncMitigationMode) {
            $.desyncMitigationMode = desyncMitigationMode;
            return this;
        }

        public Builder desyncMitigationMode(String desyncMitigationMode) {
            return desyncMitigationMode(Output.of(desyncMitigationMode));
        }

        public Builder dropInvalidHeaderFields(@Nullable Output<Boolean> dropInvalidHeaderFields) {
            $.dropInvalidHeaderFields = dropInvalidHeaderFields;
            return this;
        }

        public Builder dropInvalidHeaderFields(Boolean dropInvalidHeaderFields) {
            return dropInvalidHeaderFields(Output.of(dropInvalidHeaderFields));
        }

        public Builder enableCrossZoneLoadBalancing(@Nullable Output<Boolean> enableCrossZoneLoadBalancing) {
            $.enableCrossZoneLoadBalancing = enableCrossZoneLoadBalancing;
            return this;
        }

        public Builder enableCrossZoneLoadBalancing(Boolean enableCrossZoneLoadBalancing) {
            return enableCrossZoneLoadBalancing(Output.of(enableCrossZoneLoadBalancing));
        }

        public Builder enableDeletionProtection(@Nullable Output<Boolean> enableDeletionProtection) {
            $.enableDeletionProtection = enableDeletionProtection;
            return this;
        }

        public Builder enableDeletionProtection(Boolean enableDeletionProtection) {
            return enableDeletionProtection(Output.of(enableDeletionProtection));
        }

        public Builder enableHttp2(@Nullable Output<Boolean> enableHttp2) {
            $.enableHttp2 = enableHttp2;
            return this;
        }

        public Builder enableHttp2(Boolean enableHttp2) {
            return enableHttp2(Output.of(enableHttp2));
        }

        public Builder enableWafFailOpen(@Nullable Output<Boolean> enableWafFailOpen) {
            $.enableWafFailOpen = enableWafFailOpen;
            return this;
        }

        public Builder enableWafFailOpen(Boolean enableWafFailOpen) {
            return enableWafFailOpen(Output.of(enableWafFailOpen));
        }

        public Builder idleTimeout(@Nullable Output<Integer> idleTimeout) {
            $.idleTimeout = idleTimeout;
            return this;
        }

        public Builder idleTimeout(Integer idleTimeout) {
            return idleTimeout(Output.of(idleTimeout));
        }

        public Builder internal(@Nullable Output<Boolean> internal) {
            $.internal = internal;
            return this;
        }

        public Builder internal(Boolean internal) {
            return internal(Output.of(internal));
        }

        public Builder ipAddressType(@Nullable Output<String> ipAddressType) {
            $.ipAddressType = ipAddressType;
            return this;
        }

        public Builder ipAddressType(String ipAddressType) {
            return ipAddressType(Output.of(ipAddressType));
        }

        public Builder loadBalancerType(@Nullable Output<String> loadBalancerType) {
            $.loadBalancerType = loadBalancerType;
            return this;
        }

        public Builder loadBalancerType(String loadBalancerType) {
            return loadBalancerType(Output.of(loadBalancerType));
        }

        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        public Builder name(String name) {
            return name(Output.of(name));
        }

        public Builder namePrefix(@Nullable Output<String> namePrefix) {
            $.namePrefix = namePrefix;
            return this;
        }

        public Builder namePrefix(String namePrefix) {
            return namePrefix(Output.of(namePrefix));
        }

        public Builder securityGroups(@Nullable Output<List<String>> securityGroups) {
            $.securityGroups = securityGroups;
            return this;
        }

        public Builder securityGroups(List<String> securityGroups) {
            return securityGroups(Output.of(securityGroups));
        }

        public Builder securityGroups(String... securityGroups) {
            return securityGroups(List.of(securityGroups));
        }

        public Builder subnetMappings(@Nullable Output<List<LoadBalancerSubnetMappingArgs>> subnetMappings) {
            $.subnetMappings = subnetMappings;
            return this;
        }

        public Builder subnetMappings(List<LoadBalancerSubnetMappingArgs> subnetMappings) {
            return subnetMappings(Output.of(subnetMappings));
        }

        public Builder subnetMappings(LoadBalancerSubnetMappingArgs... subnetMappings) {
            return subnetMappings(List.of(subnetMappings));
        }

        public Builder subnets(@Nullable Output<List<String>> subnets) {
            $.subnets = subnets;
            return this;
        }

        public Builder subnets(List<String> subnets) {
            return subnets(Output.of(subnets));
        }

        public Builder subnets(String... subnets) {
            return subnets(List.of(subnets));
        }

        public Builder tags(@Nullable Output<Map<String,String>> tags) {
            $.tags = tags;
            return this;
        }

        public Builder tags(Map<String,String> tags) {
            return tags(Output.of(tags));
        }

        public LoadBalancerArgs build() {
            return $;
        }
    }

}
