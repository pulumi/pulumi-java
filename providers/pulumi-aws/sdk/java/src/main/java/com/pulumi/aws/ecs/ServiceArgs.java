// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.aws.ecs;

import com.pulumi.aws.ecs.inputs.ServiceCapacityProviderStrategyArgs;
import com.pulumi.aws.ecs.inputs.ServiceDeploymentCircuitBreakerArgs;
import com.pulumi.aws.ecs.inputs.ServiceDeploymentControllerArgs;
import com.pulumi.aws.ecs.inputs.ServiceLoadBalancerArgs;
import com.pulumi.aws.ecs.inputs.ServiceNetworkConfigurationArgs;
import com.pulumi.aws.ecs.inputs.ServiceOrderedPlacementStrategyArgs;
import com.pulumi.aws.ecs.inputs.ServicePlacementConstraintArgs;
import com.pulumi.aws.ecs.inputs.ServiceServiceRegistriesArgs;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class ServiceArgs extends com.pulumi.resources.ResourceArgs {

    public static final ServiceArgs Empty = new ServiceArgs();

    /**
     * Capacity provider strategies to use for the service. Can be one or more. These can be updated without destroying and recreating the service only if `force_new_deployment = true` and not changing from 0 `capacity_provider_strategy` blocks to greater than 0, or vice versa. See below.
     * 
     */
    @Import(name="capacityProviderStrategies")
    private @Nullable Output<List<ServiceCapacityProviderStrategyArgs>> capacityProviderStrategies;

    public Optional<Output<List<ServiceCapacityProviderStrategyArgs>>> capacityProviderStrategies() {
        return Optional.ofNullable(this.capacityProviderStrategies);
    }

    /**
     * ARN of an ECS cluster.
     * 
     */
    @Import(name="cluster")
    private @Nullable Output<String> cluster;

    public Optional<Output<String>> cluster() {
        return Optional.ofNullable(this.cluster);
    }

    /**
     * Configuration block for deployment circuit breaker. See below.
     * 
     */
    @Import(name="deploymentCircuitBreaker")
    private @Nullable Output<ServiceDeploymentCircuitBreakerArgs> deploymentCircuitBreaker;

    public Optional<Output<ServiceDeploymentCircuitBreakerArgs>> deploymentCircuitBreaker() {
        return Optional.ofNullable(this.deploymentCircuitBreaker);
    }

    /**
     * Configuration block for deployment controller configuration. See below.
     * 
     */
    @Import(name="deploymentController")
    private @Nullable Output<ServiceDeploymentControllerArgs> deploymentController;

    public Optional<Output<ServiceDeploymentControllerArgs>> deploymentController() {
        return Optional.ofNullable(this.deploymentController);
    }

    /**
     * Upper limit (as a percentage of the service&#39;s desiredCount) of the number of running tasks that can be running in a service during a deployment. Not valid when using the `DAEMON` scheduling strategy.
     * 
     */
    @Import(name="deploymentMaximumPercent")
    private @Nullable Output<Integer> deploymentMaximumPercent;

    public Optional<Output<Integer>> deploymentMaximumPercent() {
        return Optional.ofNullable(this.deploymentMaximumPercent);
    }

    /**
     * Lower limit (as a percentage of the service&#39;s desiredCount) of the number of running tasks that must remain running and healthy in a service during a deployment.
     * 
     */
    @Import(name="deploymentMinimumHealthyPercent")
    private @Nullable Output<Integer> deploymentMinimumHealthyPercent;

    public Optional<Output<Integer>> deploymentMinimumHealthyPercent() {
        return Optional.ofNullable(this.deploymentMinimumHealthyPercent);
    }

    /**
     * Number of instances of the task definition to place and keep running. Defaults to 0. Do not specify if using the `DAEMON` scheduling strategy.
     * 
     */
    @Import(name="desiredCount")
    private @Nullable Output<Integer> desiredCount;

    public Optional<Output<Integer>> desiredCount() {
        return Optional.ofNullable(this.desiredCount);
    }

    /**
     * Specifies whether to enable Amazon ECS managed tags for the tasks within the service.
     * 
     */
    @Import(name="enableEcsManagedTags")
    private @Nullable Output<Boolean> enableEcsManagedTags;

    public Optional<Output<Boolean>> enableEcsManagedTags() {
        return Optional.ofNullable(this.enableEcsManagedTags);
    }

    /**
     * Specifies whether to enable Amazon ECS Exec for the tasks within the service.
     * 
     */
    @Import(name="enableExecuteCommand")
    private @Nullable Output<Boolean> enableExecuteCommand;

    public Optional<Output<Boolean>> enableExecuteCommand() {
        return Optional.ofNullable(this.enableExecuteCommand);
    }

    /**
     * Enable to force a new task deployment of the service. This can be used to update tasks to use a newer Docker image with same image/tag combination (e.g., `myimage:latest`), roll Fargate tasks onto a newer platform version, or immediately deploy `ordered_placement_strategy` and `placement_constraints` updates.
     * 
     */
    @Import(name="forceNewDeployment")
    private @Nullable Output<Boolean> forceNewDeployment;

    public Optional<Output<Boolean>> forceNewDeployment() {
        return Optional.ofNullable(this.forceNewDeployment);
    }

    /**
     * Seconds to ignore failing load balancer health checks on newly instantiated tasks to prevent premature shutdown, up to 2147483647. Only valid for services configured to use load balancers.
     * 
     */
    @Import(name="healthCheckGracePeriodSeconds")
    private @Nullable Output<Integer> healthCheckGracePeriodSeconds;

    public Optional<Output<Integer>> healthCheckGracePeriodSeconds() {
        return Optional.ofNullable(this.healthCheckGracePeriodSeconds);
    }

    /**
     * ARN of the IAM role that allows Amazon ECS to make calls to your load balancer on your behalf. This parameter is required if you are using a load balancer with your service, but only if your task definition does not use the `awsvpc` network mode. If using `awsvpc` network mode, do not specify this role. If your account has already created the Amazon ECS service-linked role, that role is used by default for your service unless you specify a role here.
     * 
     */
    @Import(name="iamRole")
    private @Nullable Output<String> iamRole;

    public Optional<Output<String>> iamRole() {
        return Optional.ofNullable(this.iamRole);
    }

    /**
     * Launch type on which to run your service. The valid values are `EC2`, `FARGATE`, and `EXTERNAL`. Defaults to `EC2`.
     * 
     */
    @Import(name="launchType")
    private @Nullable Output<String> launchType;

    public Optional<Output<String>> launchType() {
        return Optional.ofNullable(this.launchType);
    }

    /**
     * Configuration block for load balancers. See below.
     * 
     */
    @Import(name="loadBalancers")
    private @Nullable Output<List<ServiceLoadBalancerArgs>> loadBalancers;

    public Optional<Output<List<ServiceLoadBalancerArgs>>> loadBalancers() {
        return Optional.ofNullable(this.loadBalancers);
    }

    /**
     * Name of the service (up to 255 letters, numbers, hyphens, and underscores)
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * Network configuration for the service. This parameter is required for task definitions that use the `awsvpc` network mode to receive their own Elastic Network Interface, and it is not supported for other network modes. See below.
     * 
     */
    @Import(name="networkConfiguration")
    private @Nullable Output<ServiceNetworkConfigurationArgs> networkConfiguration;

    public Optional<Output<ServiceNetworkConfigurationArgs>> networkConfiguration() {
        return Optional.ofNullable(this.networkConfiguration);
    }

    /**
     * Service level strategy rules that are taken into consideration during task placement. List from top to bottom in order of precedence. Updates to this configuration will take effect next task deployment unless `force_new_deployment` is enabled. The maximum number of `ordered_placement_strategy` blocks is `5`. See below.
     * 
     */
    @Import(name="orderedPlacementStrategies")
    private @Nullable Output<List<ServiceOrderedPlacementStrategyArgs>> orderedPlacementStrategies;

    public Optional<Output<List<ServiceOrderedPlacementStrategyArgs>>> orderedPlacementStrategies() {
        return Optional.ofNullable(this.orderedPlacementStrategies);
    }

    /**
     * Rules that are taken into consideration during task placement. Updates to this configuration will take effect next task deployment unless `force_new_deployment` is enabled. Maximum number of `placement_constraints` is `10`. See below.
     * 
     */
    @Import(name="placementConstraints")
    private @Nullable Output<List<ServicePlacementConstraintArgs>> placementConstraints;

    public Optional<Output<List<ServicePlacementConstraintArgs>>> placementConstraints() {
        return Optional.ofNullable(this.placementConstraints);
    }

    /**
     * Platform version on which to run your service. Only applicable for `launch_type` set to `FARGATE`. Defaults to `LATEST`. More information about Fargate platform versions can be found in the [AWS ECS User Guide](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html).
     * 
     */
    @Import(name="platformVersion")
    private @Nullable Output<String> platformVersion;

    public Optional<Output<String>> platformVersion() {
        return Optional.ofNullable(this.platformVersion);
    }

    /**
     * Specifies whether to propagate the tags from the task definition or the service to the tasks. The valid values are `SERVICE` and `TASK_DEFINITION`.
     * 
     */
    @Import(name="propagateTags")
    private @Nullable Output<String> propagateTags;

    public Optional<Output<String>> propagateTags() {
        return Optional.ofNullable(this.propagateTags);
    }

    /**
     * Scheduling strategy to use for the service. The valid values are `REPLICA` and `DAEMON`. Defaults to `REPLICA`. Note that [*Tasks using the Fargate launch type or the `CODE_DEPLOY` or `EXTERNAL` deployment controller types don&#39;t support the `DAEMON` scheduling strategy*](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_CreateService.html).
     * 
     */
    @Import(name="schedulingStrategy")
    private @Nullable Output<String> schedulingStrategy;

    public Optional<Output<String>> schedulingStrategy() {
        return Optional.ofNullable(this.schedulingStrategy);
    }

    /**
     * Service discovery registries for the service. The maximum number of `service_registries` blocks is `1`. See below.
     * 
     */
    @Import(name="serviceRegistries")
    private @Nullable Output<ServiceServiceRegistriesArgs> serviceRegistries;

    public Optional<Output<ServiceServiceRegistriesArgs>> serviceRegistries() {
        return Optional.ofNullable(this.serviceRegistries);
    }

    /**
     * Key-value map of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
     * 
     */
    @Import(name="tags")
    private @Nullable Output<Map<String,String>> tags;

    public Optional<Output<Map<String,String>>> tags() {
        return Optional.ofNullable(this.tags);
    }

    /**
     * Family and revision (`family:revision`) or full ARN of the task definition that you want to run in your service. Required unless using the `EXTERNAL` deployment controller. If a revision is not specified, the latest `ACTIVE` revision is used.
     * 
     */
    @Import(name="taskDefinition")
    private @Nullable Output<String> taskDefinition;

    public Optional<Output<String>> taskDefinition() {
        return Optional.ofNullable(this.taskDefinition);
    }

    /**
     * If `true`, this provider will wait for the service to reach a steady state (like [`aws ecs wait services-stable`](https://docs.aws.amazon.com/cli/latest/reference/ecs/wait/services-stable.html)) before continuing. Default `false`.
     * 
     */
    @Import(name="waitForSteadyState")
    private @Nullable Output<Boolean> waitForSteadyState;

    public Optional<Output<Boolean>> waitForSteadyState() {
        return Optional.ofNullable(this.waitForSteadyState);
    }

    private ServiceArgs() {}

    private ServiceArgs(ServiceArgs $) {
        this.capacityProviderStrategies = $.capacityProviderStrategies;
        this.cluster = $.cluster;
        this.deploymentCircuitBreaker = $.deploymentCircuitBreaker;
        this.deploymentController = $.deploymentController;
        this.deploymentMaximumPercent = $.deploymentMaximumPercent;
        this.deploymentMinimumHealthyPercent = $.deploymentMinimumHealthyPercent;
        this.desiredCount = $.desiredCount;
        this.enableEcsManagedTags = $.enableEcsManagedTags;
        this.enableExecuteCommand = $.enableExecuteCommand;
        this.forceNewDeployment = $.forceNewDeployment;
        this.healthCheckGracePeriodSeconds = $.healthCheckGracePeriodSeconds;
        this.iamRole = $.iamRole;
        this.launchType = $.launchType;
        this.loadBalancers = $.loadBalancers;
        this.name = $.name;
        this.networkConfiguration = $.networkConfiguration;
        this.orderedPlacementStrategies = $.orderedPlacementStrategies;
        this.placementConstraints = $.placementConstraints;
        this.platformVersion = $.platformVersion;
        this.propagateTags = $.propagateTags;
        this.schedulingStrategy = $.schedulingStrategy;
        this.serviceRegistries = $.serviceRegistries;
        this.tags = $.tags;
        this.taskDefinition = $.taskDefinition;
        this.waitForSteadyState = $.waitForSteadyState;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(ServiceArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private ServiceArgs $;

        public Builder() {
            $ = new ServiceArgs();
        }

        public Builder(ServiceArgs defaults) {
            $ = new ServiceArgs(Objects.requireNonNull(defaults));
        }

        public Builder capacityProviderStrategies(@Nullable Output<List<ServiceCapacityProviderStrategyArgs>> capacityProviderStrategies) {
            $.capacityProviderStrategies = capacityProviderStrategies;
            return this;
        }

        public Builder capacityProviderStrategies(List<ServiceCapacityProviderStrategyArgs> capacityProviderStrategies) {
            return capacityProviderStrategies(Output.of(capacityProviderStrategies));
        }

        public Builder capacityProviderStrategies(ServiceCapacityProviderStrategyArgs... capacityProviderStrategies) {
            return capacityProviderStrategies(List.of(capacityProviderStrategies));
        }

        public Builder cluster(@Nullable Output<String> cluster) {
            $.cluster = cluster;
            return this;
        }

        public Builder cluster(String cluster) {
            return cluster(Output.of(cluster));
        }

        public Builder deploymentCircuitBreaker(@Nullable Output<ServiceDeploymentCircuitBreakerArgs> deploymentCircuitBreaker) {
            $.deploymentCircuitBreaker = deploymentCircuitBreaker;
            return this;
        }

        public Builder deploymentCircuitBreaker(ServiceDeploymentCircuitBreakerArgs deploymentCircuitBreaker) {
            return deploymentCircuitBreaker(Output.of(deploymentCircuitBreaker));
        }

        public Builder deploymentController(@Nullable Output<ServiceDeploymentControllerArgs> deploymentController) {
            $.deploymentController = deploymentController;
            return this;
        }

        public Builder deploymentController(ServiceDeploymentControllerArgs deploymentController) {
            return deploymentController(Output.of(deploymentController));
        }

        public Builder deploymentMaximumPercent(@Nullable Output<Integer> deploymentMaximumPercent) {
            $.deploymentMaximumPercent = deploymentMaximumPercent;
            return this;
        }

        public Builder deploymentMaximumPercent(Integer deploymentMaximumPercent) {
            return deploymentMaximumPercent(Output.of(deploymentMaximumPercent));
        }

        public Builder deploymentMinimumHealthyPercent(@Nullable Output<Integer> deploymentMinimumHealthyPercent) {
            $.deploymentMinimumHealthyPercent = deploymentMinimumHealthyPercent;
            return this;
        }

        public Builder deploymentMinimumHealthyPercent(Integer deploymentMinimumHealthyPercent) {
            return deploymentMinimumHealthyPercent(Output.of(deploymentMinimumHealthyPercent));
        }

        public Builder desiredCount(@Nullable Output<Integer> desiredCount) {
            $.desiredCount = desiredCount;
            return this;
        }

        public Builder desiredCount(Integer desiredCount) {
            return desiredCount(Output.of(desiredCount));
        }

        public Builder enableEcsManagedTags(@Nullable Output<Boolean> enableEcsManagedTags) {
            $.enableEcsManagedTags = enableEcsManagedTags;
            return this;
        }

        public Builder enableEcsManagedTags(Boolean enableEcsManagedTags) {
            return enableEcsManagedTags(Output.of(enableEcsManagedTags));
        }

        public Builder enableExecuteCommand(@Nullable Output<Boolean> enableExecuteCommand) {
            $.enableExecuteCommand = enableExecuteCommand;
            return this;
        }

        public Builder enableExecuteCommand(Boolean enableExecuteCommand) {
            return enableExecuteCommand(Output.of(enableExecuteCommand));
        }

        public Builder forceNewDeployment(@Nullable Output<Boolean> forceNewDeployment) {
            $.forceNewDeployment = forceNewDeployment;
            return this;
        }

        public Builder forceNewDeployment(Boolean forceNewDeployment) {
            return forceNewDeployment(Output.of(forceNewDeployment));
        }

        public Builder healthCheckGracePeriodSeconds(@Nullable Output<Integer> healthCheckGracePeriodSeconds) {
            $.healthCheckGracePeriodSeconds = healthCheckGracePeriodSeconds;
            return this;
        }

        public Builder healthCheckGracePeriodSeconds(Integer healthCheckGracePeriodSeconds) {
            return healthCheckGracePeriodSeconds(Output.of(healthCheckGracePeriodSeconds));
        }

        public Builder iamRole(@Nullable Output<String> iamRole) {
            $.iamRole = iamRole;
            return this;
        }

        public Builder iamRole(String iamRole) {
            return iamRole(Output.of(iamRole));
        }

        public Builder launchType(@Nullable Output<String> launchType) {
            $.launchType = launchType;
            return this;
        }

        public Builder launchType(String launchType) {
            return launchType(Output.of(launchType));
        }

        public Builder loadBalancers(@Nullable Output<List<ServiceLoadBalancerArgs>> loadBalancers) {
            $.loadBalancers = loadBalancers;
            return this;
        }

        public Builder loadBalancers(List<ServiceLoadBalancerArgs> loadBalancers) {
            return loadBalancers(Output.of(loadBalancers));
        }

        public Builder loadBalancers(ServiceLoadBalancerArgs... loadBalancers) {
            return loadBalancers(List.of(loadBalancers));
        }

        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        public Builder name(String name) {
            return name(Output.of(name));
        }

        public Builder networkConfiguration(@Nullable Output<ServiceNetworkConfigurationArgs> networkConfiguration) {
            $.networkConfiguration = networkConfiguration;
            return this;
        }

        public Builder networkConfiguration(ServiceNetworkConfigurationArgs networkConfiguration) {
            return networkConfiguration(Output.of(networkConfiguration));
        }

        public Builder orderedPlacementStrategies(@Nullable Output<List<ServiceOrderedPlacementStrategyArgs>> orderedPlacementStrategies) {
            $.orderedPlacementStrategies = orderedPlacementStrategies;
            return this;
        }

        public Builder orderedPlacementStrategies(List<ServiceOrderedPlacementStrategyArgs> orderedPlacementStrategies) {
            return orderedPlacementStrategies(Output.of(orderedPlacementStrategies));
        }

        public Builder orderedPlacementStrategies(ServiceOrderedPlacementStrategyArgs... orderedPlacementStrategies) {
            return orderedPlacementStrategies(List.of(orderedPlacementStrategies));
        }

        public Builder placementConstraints(@Nullable Output<List<ServicePlacementConstraintArgs>> placementConstraints) {
            $.placementConstraints = placementConstraints;
            return this;
        }

        public Builder placementConstraints(List<ServicePlacementConstraintArgs> placementConstraints) {
            return placementConstraints(Output.of(placementConstraints));
        }

        public Builder placementConstraints(ServicePlacementConstraintArgs... placementConstraints) {
            return placementConstraints(List.of(placementConstraints));
        }

        public Builder platformVersion(@Nullable Output<String> platformVersion) {
            $.platformVersion = platformVersion;
            return this;
        }

        public Builder platformVersion(String platformVersion) {
            return platformVersion(Output.of(platformVersion));
        }

        public Builder propagateTags(@Nullable Output<String> propagateTags) {
            $.propagateTags = propagateTags;
            return this;
        }

        public Builder propagateTags(String propagateTags) {
            return propagateTags(Output.of(propagateTags));
        }

        public Builder schedulingStrategy(@Nullable Output<String> schedulingStrategy) {
            $.schedulingStrategy = schedulingStrategy;
            return this;
        }

        public Builder schedulingStrategy(String schedulingStrategy) {
            return schedulingStrategy(Output.of(schedulingStrategy));
        }

        public Builder serviceRegistries(@Nullable Output<ServiceServiceRegistriesArgs> serviceRegistries) {
            $.serviceRegistries = serviceRegistries;
            return this;
        }

        public Builder serviceRegistries(ServiceServiceRegistriesArgs serviceRegistries) {
            return serviceRegistries(Output.of(serviceRegistries));
        }

        public Builder tags(@Nullable Output<Map<String,String>> tags) {
            $.tags = tags;
            return this;
        }

        public Builder tags(Map<String,String> tags) {
            return tags(Output.of(tags));
        }

        public Builder taskDefinition(@Nullable Output<String> taskDefinition) {
            $.taskDefinition = taskDefinition;
            return this;
        }

        public Builder taskDefinition(String taskDefinition) {
            return taskDefinition(Output.of(taskDefinition));
        }

        public Builder waitForSteadyState(@Nullable Output<Boolean> waitForSteadyState) {
            $.waitForSteadyState = waitForSteadyState;
            return this;
        }

        public Builder waitForSteadyState(Boolean waitForSteadyState) {
            return waitForSteadyState(Output.of(waitForSteadyState));
        }

        public ServiceArgs build() {
            return $;
        }
    }

}
