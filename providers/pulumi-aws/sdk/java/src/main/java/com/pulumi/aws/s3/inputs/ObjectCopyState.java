// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.aws.s3.inputs;

import com.pulumi.aws.s3.inputs.ObjectCopyGrantGetArgs;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.core.internal.Codegen;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import javax.annotation.Nullable;


public final class ObjectCopyState extends com.pulumi.resources.ResourceArgs {

    public static final ObjectCopyState Empty = new ObjectCopyState();

    /**
     * [Canned ACL](https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl) to apply. Defaults to `private`. Valid values are `private`, `public-read`, `public-read-write`, `authenticated-read`, `aws-exec-read`, `bucket-owner-read`, and `bucket-owner-full-control`. Conflicts with `grant`.
     * 
     */
    @Import(name="acl")
      private final @Nullable Output<String> acl;

    public Output<String> acl() {
        return this.acl == null ? Codegen.empty() : this.acl;
    }

    /**
     * Name of the bucket to put the file in.
     * 
     */
    @Import(name="bucket")
      private final @Nullable Output<String> bucket;

    public Output<String> bucket() {
        return this.bucket == null ? Codegen.empty() : this.bucket;
    }

    @Import(name="bucketKeyEnabled")
      private final @Nullable Output<Boolean> bucketKeyEnabled;

    public Output<Boolean> bucketKeyEnabled() {
        return this.bucketKeyEnabled == null ? Codegen.empty() : this.bucketKeyEnabled;
    }

    /**
     * Specifies caching behavior along the request/reply chain Read [w3c cache_control](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9) for further details.
     * 
     */
    @Import(name="cacheControl")
      private final @Nullable Output<String> cacheControl;

    public Output<String> cacheControl() {
        return this.cacheControl == null ? Codegen.empty() : this.cacheControl;
    }

    /**
     * Specifies presentational information for the object. Read [w3c content_disposition](http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html#sec19.5.1) for further information.
     * 
     */
    @Import(name="contentDisposition")
      private final @Nullable Output<String> contentDisposition;

    public Output<String> contentDisposition() {
        return this.contentDisposition == null ? Codegen.empty() : this.contentDisposition;
    }

    /**
     * Specifies what content encodings have been applied to the object and thus what decoding mechanisms must be applied to obtain the media-type referenced by the Content-Type header field. Read [w3c content encoding](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11) for further information.
     * 
     */
    @Import(name="contentEncoding")
      private final @Nullable Output<String> contentEncoding;

    public Output<String> contentEncoding() {
        return this.contentEncoding == null ? Codegen.empty() : this.contentEncoding;
    }

    /**
     * Language the content is in e.g., en-US or en-GB.
     * 
     */
    @Import(name="contentLanguage")
      private final @Nullable Output<String> contentLanguage;

    public Output<String> contentLanguage() {
        return this.contentLanguage == null ? Codegen.empty() : this.contentLanguage;
    }

    /**
     * Standard MIME type describing the format of the object data, e.g., `application/octet-stream`. All Valid MIME Types are valid for this input.
     * 
     */
    @Import(name="contentType")
      private final @Nullable Output<String> contentType;

    public Output<String> contentType() {
        return this.contentType == null ? Codegen.empty() : this.contentType;
    }

    /**
     * Copies the object if its entity tag (ETag) matches the specified tag.
     * 
     */
    @Import(name="copyIfMatch")
      private final @Nullable Output<String> copyIfMatch;

    public Output<String> copyIfMatch() {
        return this.copyIfMatch == null ? Codegen.empty() : this.copyIfMatch;
    }

    /**
     * Copies the object if it has been modified since the specified time, in [RFC3339 format](https://tools.ietf.org/html/rfc3339#section-5.8).
     * 
     */
    @Import(name="copyIfModifiedSince")
      private final @Nullable Output<String> copyIfModifiedSince;

    public Output<String> copyIfModifiedSince() {
        return this.copyIfModifiedSince == null ? Codegen.empty() : this.copyIfModifiedSince;
    }

    /**
     * Copies the object if its entity tag (ETag) is different than the specified ETag.
     * 
     */
    @Import(name="copyIfNoneMatch")
      private final @Nullable Output<String> copyIfNoneMatch;

    public Output<String> copyIfNoneMatch() {
        return this.copyIfNoneMatch == null ? Codegen.empty() : this.copyIfNoneMatch;
    }

    /**
     * Copies the object if it hasn't been modified since the specified time, in [RFC3339 format](https://tools.ietf.org/html/rfc3339#section-5.8).
     * 
     */
    @Import(name="copyIfUnmodifiedSince")
      private final @Nullable Output<String> copyIfUnmodifiedSince;

    public Output<String> copyIfUnmodifiedSince() {
        return this.copyIfUnmodifiedSince == null ? Codegen.empty() : this.copyIfUnmodifiedSince;
    }

    /**
     * Specifies the algorithm to use to when encrypting the object (for example, AES256).
     * 
     */
    @Import(name="customerAlgorithm")
      private final @Nullable Output<String> customerAlgorithm;

    public Output<String> customerAlgorithm() {
        return this.customerAlgorithm == null ? Codegen.empty() : this.customerAlgorithm;
    }

    /**
     * Specifies the customer-provided encryption key for Amazon S3 to use in encrypting data. This value is used to store the object and then it is discarded; Amazon S3 does not store the encryption key. The key must be appropriate for use with the algorithm specified in the x-amz-server-side-encryption-customer-algorithm header.
     * 
     */
    @Import(name="customerKey")
      private final @Nullable Output<String> customerKey;

    public Output<String> customerKey() {
        return this.customerKey == null ? Codegen.empty() : this.customerKey;
    }

    /**
     * Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses this header for a message integrity check to ensure that the encryption key was transmitted without error.
     * 
     */
    @Import(name="customerKeyMd5")
      private final @Nullable Output<String> customerKeyMd5;

    public Output<String> customerKeyMd5() {
        return this.customerKeyMd5 == null ? Codegen.empty() : this.customerKeyMd5;
    }

    /**
     * The ETag generated for the object (an MD5 sum of the object content). For plaintext objects or objects encrypted with an AWS-managed key, the hash is an MD5 digest of the object data. For objects encrypted with a KMS key or objects created by either the Multipart Upload or Part Copy operation, the hash is not an MD5 digest, regardless of the method of encryption. More information on possible values can be found on [Common Response Headers](https://docs.aws.amazon.com/AmazonS3/latest/API/RESTCommonResponseHeaders.html).
     * 
     */
    @Import(name="etag")
      private final @Nullable Output<String> etag;

    public Output<String> etag() {
        return this.etag == null ? Codegen.empty() : this.etag;
    }

    /**
     * Account id of the expected destination bucket owner. If the destination bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
     * 
     */
    @Import(name="expectedBucketOwner")
      private final @Nullable Output<String> expectedBucketOwner;

    public Output<String> expectedBucketOwner() {
        return this.expectedBucketOwner == null ? Codegen.empty() : this.expectedBucketOwner;
    }

    /**
     * Account id of the expected source bucket owner. If the source bucket is owned by a different account, the request will fail with an HTTP 403 (Access Denied) error.
     * 
     */
    @Import(name="expectedSourceBucketOwner")
      private final @Nullable Output<String> expectedSourceBucketOwner;

    public Output<String> expectedSourceBucketOwner() {
        return this.expectedSourceBucketOwner == null ? Codegen.empty() : this.expectedSourceBucketOwner;
    }

    /**
     * If the object expiration is configured, this attribute will be set.
     * 
     */
    @Import(name="expiration")
      private final @Nullable Output<String> expiration;

    public Output<String> expiration() {
        return this.expiration == null ? Codegen.empty() : this.expiration;
    }

    /**
     * Date and time at which the object is no longer cacheable, in [RFC3339 format](https://tools.ietf.org/html/rfc3339#section-5.8).
     * 
     */
    @Import(name="expires")
      private final @Nullable Output<String> expires;

    public Output<String> expires() {
        return this.expires == null ? Codegen.empty() : this.expires;
    }

    /**
     * Allow the object to be deleted by removing any legal hold on any object version. Default is `false`. This value should be set to `true` only if the bucket has S3 object lock enabled.
     * 
     */
    @Import(name="forceDestroy")
      private final @Nullable Output<Boolean> forceDestroy;

    public Output<Boolean> forceDestroy() {
        return this.forceDestroy == null ? Codegen.empty() : this.forceDestroy;
    }

    /**
     * Configuration block for header grants. Documented below. Conflicts with `acl`.
     * 
     */
    @Import(name="grants")
      private final @Nullable Output<List<ObjectCopyGrantGetArgs>> grants;

    public Output<List<ObjectCopyGrantGetArgs>> grants() {
        return this.grants == null ? Codegen.empty() : this.grants;
    }

    /**
     * Name of the object once it is in the bucket.
     * 
     */
    @Import(name="key")
      private final @Nullable Output<String> key;

    public Output<String> key() {
        return this.key == null ? Codegen.empty() : this.key;
    }

    /**
     * Specifies the AWS KMS Encryption Context to use for object encryption. The value is a base64-encoded UTF-8 string holding JSON with the encryption context key-value pairs.
     * 
     */
    @Import(name="kmsEncryptionContext")
      private final @Nullable Output<String> kmsEncryptionContext;

    public Output<String> kmsEncryptionContext() {
        return this.kmsEncryptionContext == null ? Codegen.empty() : this.kmsEncryptionContext;
    }

    /**
     * Specifies the AWS KMS Key ARN to use for object encryption. This value is a fully qualified **ARN** of the KMS Key. If using `aws.kms.Key`, use the exported `arn` attribute: `kms_key_id = aws_kms_key.foo.arn`
     * 
     */
    @Import(name="kmsKeyId")
      private final @Nullable Output<String> kmsKeyId;

    public Output<String> kmsKeyId() {
        return this.kmsKeyId == null ? Codegen.empty() : this.kmsKeyId;
    }

    /**
     * Returns the date that the object was last modified, in [RFC3339 format](https://tools.ietf.org/html/rfc3339#section-5.8).
     * 
     */
    @Import(name="lastModified")
      private final @Nullable Output<String> lastModified;

    public Output<String> lastModified() {
        return this.lastModified == null ? Codegen.empty() : this.lastModified;
    }

    /**
     * A map of keys/values to provision metadata (will be automatically prefixed by `x-amz-meta-`, note that only lowercase label are currently supported by the AWS Go API).
     * 
     */
    @Import(name="metadata")
      private final @Nullable Output<Map<String,String>> metadata;

    public Output<Map<String,String>> metadata() {
        return this.metadata == null ? Codegen.empty() : this.metadata;
    }

    /**
     * Specifies whether the metadata is copied from the source object or replaced with metadata provided in the request. Valid values are `COPY` and `REPLACE`.
     * 
     */
    @Import(name="metadataDirective")
      private final @Nullable Output<String> metadataDirective;

    public Output<String> metadataDirective() {
        return this.metadataDirective == null ? Codegen.empty() : this.metadataDirective;
    }

    /**
     * The [legal hold](https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lock-overview.html#object-lock-legal-holds) status that you want to apply to the specified object. Valid values are `ON` and `OFF`.
     * 
     */
    @Import(name="objectLockLegalHoldStatus")
      private final @Nullable Output<String> objectLockLegalHoldStatus;

    public Output<String> objectLockLegalHoldStatus() {
        return this.objectLockLegalHoldStatus == null ? Codegen.empty() : this.objectLockLegalHoldStatus;
    }

    /**
     * The object lock [retention mode](https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lock-overview.html#object-lock-retention-modes) that you want to apply to this object. Valid values are `GOVERNANCE` and `COMPLIANCE`.
     * 
     */
    @Import(name="objectLockMode")
      private final @Nullable Output<String> objectLockMode;

    public Output<String> objectLockMode() {
        return this.objectLockMode == null ? Codegen.empty() : this.objectLockMode;
    }

    /**
     * The date and time, in [RFC3339 format](https://tools.ietf.org/html/rfc3339#section-5.8), when this object's object lock will [expire](https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lock-overview.html#object-lock-retention-periods).
     * 
     */
    @Import(name="objectLockRetainUntilDate")
      private final @Nullable Output<String> objectLockRetainUntilDate;

    public Output<String> objectLockRetainUntilDate() {
        return this.objectLockRetainUntilDate == null ? Codegen.empty() : this.objectLockRetainUntilDate;
    }

    /**
     * If present, indicates that the requester was successfully charged for the request.
     * 
     */
    @Import(name="requestCharged")
      private final @Nullable Output<Boolean> requestCharged;

    public Output<Boolean> requestCharged() {
        return this.requestCharged == null ? Codegen.empty() : this.requestCharged;
    }

    /**
     * Confirms that the requester knows that they will be charged for the request. Bucket owners need not specify this parameter in their requests. For information about downloading objects from requester pays buckets, see Downloading Objects in Requestor Pays Buckets (https://docs.aws.amazon.com/AmazonS3/latest/dev/ObjectsinRequesterPaysBuckets.html) in the Amazon S3 Developer Guide. If included, the only valid value is `requester`.
     * 
     */
    @Import(name="requestPayer")
      private final @Nullable Output<String> requestPayer;

    public Output<String> requestPayer() {
        return this.requestPayer == null ? Codegen.empty() : this.requestPayer;
    }

    /**
     * Specifies server-side encryption of the object in S3. Valid values are `AES256` and `aws:kms`.
     * 
     */
    @Import(name="serverSideEncryption")
      private final @Nullable Output<String> serverSideEncryption;

    public Output<String> serverSideEncryption() {
        return this.serverSideEncryption == null ? Codegen.empty() : this.serverSideEncryption;
    }

    /**
     * Specifies the source object for the copy operation. You specify the value in one of two formats. For objects not accessed through an access point, specify the name of the source bucket and the key of the source object, separated by a slash (`/`). For example, `testbucket/test1.json`. For objects accessed through access points, specify the Amazon Resource Name (ARN) of the object as accessed through the access point, in the format `arn:aws:s3:<Region>:<account-id>:accesspoint/<access-point-name>/object/<key>`. For example, `arn:aws:s3:us-west-2:9999912999:accesspoint/my-access-point/object/testbucket/test1.json`.
     * 
     */
    @Import(name="source")
      private final @Nullable Output<String> source;

    public Output<String> source() {
        return this.source == null ? Codegen.empty() : this.source;
    }

    /**
     * Specifies the algorithm to use when decrypting the source object (for example, AES256).
     * 
     */
    @Import(name="sourceCustomerAlgorithm")
      private final @Nullable Output<String> sourceCustomerAlgorithm;

    public Output<String> sourceCustomerAlgorithm() {
        return this.sourceCustomerAlgorithm == null ? Codegen.empty() : this.sourceCustomerAlgorithm;
    }

    /**
     * Specifies the customer-provided encryption key for Amazon S3 to use to decrypt the source object. The encryption key provided in this header must be one that was used when the source object was created.
     * 
     */
    @Import(name="sourceCustomerKey")
      private final @Nullable Output<String> sourceCustomerKey;

    public Output<String> sourceCustomerKey() {
        return this.sourceCustomerKey == null ? Codegen.empty() : this.sourceCustomerKey;
    }

    /**
     * Specifies the 128-bit MD5 digest of the encryption key according to RFC 1321. Amazon S3 uses this header for a message integrity check to ensure that the encryption key was transmitted without error.
     * 
     */
    @Import(name="sourceCustomerKeyMd5")
      private final @Nullable Output<String> sourceCustomerKeyMd5;

    public Output<String> sourceCustomerKeyMd5() {
        return this.sourceCustomerKeyMd5 == null ? Codegen.empty() : this.sourceCustomerKeyMd5;
    }

    /**
     * Version of the copied object in the source bucket.
     * 
     */
    @Import(name="sourceVersionId")
      private final @Nullable Output<String> sourceVersionId;

    public Output<String> sourceVersionId() {
        return this.sourceVersionId == null ? Codegen.empty() : this.sourceVersionId;
    }

    /**
     * Specifies the desired [storage class](https://docs.aws.amazon.com/AmazonS3/latest/API/API_CopyObject.html#AmazonS3-CopyObject-request-header-StorageClass) for the object. Defaults to `STANDARD`.
     * 
     */
    @Import(name="storageClass")
      private final @Nullable Output<String> storageClass;

    public Output<String> storageClass() {
        return this.storageClass == null ? Codegen.empty() : this.storageClass;
    }

    /**
     * Specifies whether the object tag-set are copied from the source object or replaced with tag-set provided in the request. Valid values are `COPY` and `REPLACE`.
     * 
     */
    @Import(name="taggingDirective")
      private final @Nullable Output<String> taggingDirective;

    public Output<String> taggingDirective() {
        return this.taggingDirective == null ? Codegen.empty() : this.taggingDirective;
    }

    /**
     * A map of tags to assign to the object. .If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
     * 
     */
    @Import(name="tags")
      private final @Nullable Output<Map<String,String>> tags;

    public Output<Map<String,String>> tags() {
        return this.tags == null ? Codegen.empty() : this.tags;
    }

    /**
     * A map of tags assigned to the resource, including those inherited from the provider .
     * 
     */
    @Import(name="tagsAll")
      private final @Nullable Output<Map<String,String>> tagsAll;

    public Output<Map<String,String>> tagsAll() {
        return this.tagsAll == null ? Codegen.empty() : this.tagsAll;
    }

    /**
     * Version ID of the newly created copy.
     * 
     */
    @Import(name="versionId")
      private final @Nullable Output<String> versionId;

    public Output<String> versionId() {
        return this.versionId == null ? Codegen.empty() : this.versionId;
    }

    /**
     * Specifies a target URL for [website redirect](http://docs.aws.amazon.com/AmazonS3/latest/dev/how-to-page-redirect.html).
     * 
     */
    @Import(name="websiteRedirect")
      private final @Nullable Output<String> websiteRedirect;

    public Output<String> websiteRedirect() {
        return this.websiteRedirect == null ? Codegen.empty() : this.websiteRedirect;
    }

    public ObjectCopyState(
        @Nullable Output<String> acl,
        @Nullable Output<String> bucket,
        @Nullable Output<Boolean> bucketKeyEnabled,
        @Nullable Output<String> cacheControl,
        @Nullable Output<String> contentDisposition,
        @Nullable Output<String> contentEncoding,
        @Nullable Output<String> contentLanguage,
        @Nullable Output<String> contentType,
        @Nullable Output<String> copyIfMatch,
        @Nullable Output<String> copyIfModifiedSince,
        @Nullable Output<String> copyIfNoneMatch,
        @Nullable Output<String> copyIfUnmodifiedSince,
        @Nullable Output<String> customerAlgorithm,
        @Nullable Output<String> customerKey,
        @Nullable Output<String> customerKeyMd5,
        @Nullable Output<String> etag,
        @Nullable Output<String> expectedBucketOwner,
        @Nullable Output<String> expectedSourceBucketOwner,
        @Nullable Output<String> expiration,
        @Nullable Output<String> expires,
        @Nullable Output<Boolean> forceDestroy,
        @Nullable Output<List<ObjectCopyGrantGetArgs>> grants,
        @Nullable Output<String> key,
        @Nullable Output<String> kmsEncryptionContext,
        @Nullable Output<String> kmsKeyId,
        @Nullable Output<String> lastModified,
        @Nullable Output<Map<String,String>> metadata,
        @Nullable Output<String> metadataDirective,
        @Nullable Output<String> objectLockLegalHoldStatus,
        @Nullable Output<String> objectLockMode,
        @Nullable Output<String> objectLockRetainUntilDate,
        @Nullable Output<Boolean> requestCharged,
        @Nullable Output<String> requestPayer,
        @Nullable Output<String> serverSideEncryption,
        @Nullable Output<String> source,
        @Nullable Output<String> sourceCustomerAlgorithm,
        @Nullable Output<String> sourceCustomerKey,
        @Nullable Output<String> sourceCustomerKeyMd5,
        @Nullable Output<String> sourceVersionId,
        @Nullable Output<String> storageClass,
        @Nullable Output<String> taggingDirective,
        @Nullable Output<Map<String,String>> tags,
        @Nullable Output<Map<String,String>> tagsAll,
        @Nullable Output<String> versionId,
        @Nullable Output<String> websiteRedirect) {
        this.acl = acl;
        this.bucket = bucket;
        this.bucketKeyEnabled = bucketKeyEnabled;
        this.cacheControl = cacheControl;
        this.contentDisposition = contentDisposition;
        this.contentEncoding = contentEncoding;
        this.contentLanguage = contentLanguage;
        this.contentType = contentType;
        this.copyIfMatch = copyIfMatch;
        this.copyIfModifiedSince = copyIfModifiedSince;
        this.copyIfNoneMatch = copyIfNoneMatch;
        this.copyIfUnmodifiedSince = copyIfUnmodifiedSince;
        this.customerAlgorithm = customerAlgorithm;
        this.customerKey = customerKey;
        this.customerKeyMd5 = customerKeyMd5;
        this.etag = etag;
        this.expectedBucketOwner = expectedBucketOwner;
        this.expectedSourceBucketOwner = expectedSourceBucketOwner;
        this.expiration = expiration;
        this.expires = expires;
        this.forceDestroy = forceDestroy;
        this.grants = grants;
        this.key = key;
        this.kmsEncryptionContext = kmsEncryptionContext;
        this.kmsKeyId = kmsKeyId;
        this.lastModified = lastModified;
        this.metadata = metadata;
        this.metadataDirective = metadataDirective;
        this.objectLockLegalHoldStatus = objectLockLegalHoldStatus;
        this.objectLockMode = objectLockMode;
        this.objectLockRetainUntilDate = objectLockRetainUntilDate;
        this.requestCharged = requestCharged;
        this.requestPayer = requestPayer;
        this.serverSideEncryption = serverSideEncryption;
        this.source = source;
        this.sourceCustomerAlgorithm = sourceCustomerAlgorithm;
        this.sourceCustomerKey = sourceCustomerKey;
        this.sourceCustomerKeyMd5 = sourceCustomerKeyMd5;
        this.sourceVersionId = sourceVersionId;
        this.storageClass = storageClass;
        this.taggingDirective = taggingDirective;
        this.tags = tags;
        this.tagsAll = tagsAll;
        this.versionId = versionId;
        this.websiteRedirect = websiteRedirect;
    }

    private ObjectCopyState() {
        this.acl = Codegen.empty();
        this.bucket = Codegen.empty();
        this.bucketKeyEnabled = Codegen.empty();
        this.cacheControl = Codegen.empty();
        this.contentDisposition = Codegen.empty();
        this.contentEncoding = Codegen.empty();
        this.contentLanguage = Codegen.empty();
        this.contentType = Codegen.empty();
        this.copyIfMatch = Codegen.empty();
        this.copyIfModifiedSince = Codegen.empty();
        this.copyIfNoneMatch = Codegen.empty();
        this.copyIfUnmodifiedSince = Codegen.empty();
        this.customerAlgorithm = Codegen.empty();
        this.customerKey = Codegen.empty();
        this.customerKeyMd5 = Codegen.empty();
        this.etag = Codegen.empty();
        this.expectedBucketOwner = Codegen.empty();
        this.expectedSourceBucketOwner = Codegen.empty();
        this.expiration = Codegen.empty();
        this.expires = Codegen.empty();
        this.forceDestroy = Codegen.empty();
        this.grants = Codegen.empty();
        this.key = Codegen.empty();
        this.kmsEncryptionContext = Codegen.empty();
        this.kmsKeyId = Codegen.empty();
        this.lastModified = Codegen.empty();
        this.metadata = Codegen.empty();
        this.metadataDirective = Codegen.empty();
        this.objectLockLegalHoldStatus = Codegen.empty();
        this.objectLockMode = Codegen.empty();
        this.objectLockRetainUntilDate = Codegen.empty();
        this.requestCharged = Codegen.empty();
        this.requestPayer = Codegen.empty();
        this.serverSideEncryption = Codegen.empty();
        this.source = Codegen.empty();
        this.sourceCustomerAlgorithm = Codegen.empty();
        this.sourceCustomerKey = Codegen.empty();
        this.sourceCustomerKeyMd5 = Codegen.empty();
        this.sourceVersionId = Codegen.empty();
        this.storageClass = Codegen.empty();
        this.taggingDirective = Codegen.empty();
        this.tags = Codegen.empty();
        this.tagsAll = Codegen.empty();
        this.versionId = Codegen.empty();
        this.websiteRedirect = Codegen.empty();
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(ObjectCopyState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private @Nullable Output<String> acl;
        private @Nullable Output<String> bucket;
        private @Nullable Output<Boolean> bucketKeyEnabled;
        private @Nullable Output<String> cacheControl;
        private @Nullable Output<String> contentDisposition;
        private @Nullable Output<String> contentEncoding;
        private @Nullable Output<String> contentLanguage;
        private @Nullable Output<String> contentType;
        private @Nullable Output<String> copyIfMatch;
        private @Nullable Output<String> copyIfModifiedSince;
        private @Nullable Output<String> copyIfNoneMatch;
        private @Nullable Output<String> copyIfUnmodifiedSince;
        private @Nullable Output<String> customerAlgorithm;
        private @Nullable Output<String> customerKey;
        private @Nullable Output<String> customerKeyMd5;
        private @Nullable Output<String> etag;
        private @Nullable Output<String> expectedBucketOwner;
        private @Nullable Output<String> expectedSourceBucketOwner;
        private @Nullable Output<String> expiration;
        private @Nullable Output<String> expires;
        private @Nullable Output<Boolean> forceDestroy;
        private @Nullable Output<List<ObjectCopyGrantGetArgs>> grants;
        private @Nullable Output<String> key;
        private @Nullable Output<String> kmsEncryptionContext;
        private @Nullable Output<String> kmsKeyId;
        private @Nullable Output<String> lastModified;
        private @Nullable Output<Map<String,String>> metadata;
        private @Nullable Output<String> metadataDirective;
        private @Nullable Output<String> objectLockLegalHoldStatus;
        private @Nullable Output<String> objectLockMode;
        private @Nullable Output<String> objectLockRetainUntilDate;
        private @Nullable Output<Boolean> requestCharged;
        private @Nullable Output<String> requestPayer;
        private @Nullable Output<String> serverSideEncryption;
        private @Nullable Output<String> source;
        private @Nullable Output<String> sourceCustomerAlgorithm;
        private @Nullable Output<String> sourceCustomerKey;
        private @Nullable Output<String> sourceCustomerKeyMd5;
        private @Nullable Output<String> sourceVersionId;
        private @Nullable Output<String> storageClass;
        private @Nullable Output<String> taggingDirective;
        private @Nullable Output<Map<String,String>> tags;
        private @Nullable Output<Map<String,String>> tagsAll;
        private @Nullable Output<String> versionId;
        private @Nullable Output<String> websiteRedirect;

        public Builder() {
    	      // Empty
        }

        public Builder(ObjectCopyState defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.acl = defaults.acl;
    	      this.bucket = defaults.bucket;
    	      this.bucketKeyEnabled = defaults.bucketKeyEnabled;
    	      this.cacheControl = defaults.cacheControl;
    	      this.contentDisposition = defaults.contentDisposition;
    	      this.contentEncoding = defaults.contentEncoding;
    	      this.contentLanguage = defaults.contentLanguage;
    	      this.contentType = defaults.contentType;
    	      this.copyIfMatch = defaults.copyIfMatch;
    	      this.copyIfModifiedSince = defaults.copyIfModifiedSince;
    	      this.copyIfNoneMatch = defaults.copyIfNoneMatch;
    	      this.copyIfUnmodifiedSince = defaults.copyIfUnmodifiedSince;
    	      this.customerAlgorithm = defaults.customerAlgorithm;
    	      this.customerKey = defaults.customerKey;
    	      this.customerKeyMd5 = defaults.customerKeyMd5;
    	      this.etag = defaults.etag;
    	      this.expectedBucketOwner = defaults.expectedBucketOwner;
    	      this.expectedSourceBucketOwner = defaults.expectedSourceBucketOwner;
    	      this.expiration = defaults.expiration;
    	      this.expires = defaults.expires;
    	      this.forceDestroy = defaults.forceDestroy;
    	      this.grants = defaults.grants;
    	      this.key = defaults.key;
    	      this.kmsEncryptionContext = defaults.kmsEncryptionContext;
    	      this.kmsKeyId = defaults.kmsKeyId;
    	      this.lastModified = defaults.lastModified;
    	      this.metadata = defaults.metadata;
    	      this.metadataDirective = defaults.metadataDirective;
    	      this.objectLockLegalHoldStatus = defaults.objectLockLegalHoldStatus;
    	      this.objectLockMode = defaults.objectLockMode;
    	      this.objectLockRetainUntilDate = defaults.objectLockRetainUntilDate;
    	      this.requestCharged = defaults.requestCharged;
    	      this.requestPayer = defaults.requestPayer;
    	      this.serverSideEncryption = defaults.serverSideEncryption;
    	      this.source = defaults.source;
    	      this.sourceCustomerAlgorithm = defaults.sourceCustomerAlgorithm;
    	      this.sourceCustomerKey = defaults.sourceCustomerKey;
    	      this.sourceCustomerKeyMd5 = defaults.sourceCustomerKeyMd5;
    	      this.sourceVersionId = defaults.sourceVersionId;
    	      this.storageClass = defaults.storageClass;
    	      this.taggingDirective = defaults.taggingDirective;
    	      this.tags = defaults.tags;
    	      this.tagsAll = defaults.tagsAll;
    	      this.versionId = defaults.versionId;
    	      this.websiteRedirect = defaults.websiteRedirect;
        }

        public Builder acl(@Nullable Output<String> acl) {
            this.acl = acl;
            return this;
        }
        public Builder acl(@Nullable String acl) {
            this.acl = Codegen.ofNullable(acl);
            return this;
        }
        public Builder bucket(@Nullable Output<String> bucket) {
            this.bucket = bucket;
            return this;
        }
        public Builder bucket(@Nullable String bucket) {
            this.bucket = Codegen.ofNullable(bucket);
            return this;
        }
        public Builder bucketKeyEnabled(@Nullable Output<Boolean> bucketKeyEnabled) {
            this.bucketKeyEnabled = bucketKeyEnabled;
            return this;
        }
        public Builder bucketKeyEnabled(@Nullable Boolean bucketKeyEnabled) {
            this.bucketKeyEnabled = Codegen.ofNullable(bucketKeyEnabled);
            return this;
        }
        public Builder cacheControl(@Nullable Output<String> cacheControl) {
            this.cacheControl = cacheControl;
            return this;
        }
        public Builder cacheControl(@Nullable String cacheControl) {
            this.cacheControl = Codegen.ofNullable(cacheControl);
            return this;
        }
        public Builder contentDisposition(@Nullable Output<String> contentDisposition) {
            this.contentDisposition = contentDisposition;
            return this;
        }
        public Builder contentDisposition(@Nullable String contentDisposition) {
            this.contentDisposition = Codegen.ofNullable(contentDisposition);
            return this;
        }
        public Builder contentEncoding(@Nullable Output<String> contentEncoding) {
            this.contentEncoding = contentEncoding;
            return this;
        }
        public Builder contentEncoding(@Nullable String contentEncoding) {
            this.contentEncoding = Codegen.ofNullable(contentEncoding);
            return this;
        }
        public Builder contentLanguage(@Nullable Output<String> contentLanguage) {
            this.contentLanguage = contentLanguage;
            return this;
        }
        public Builder contentLanguage(@Nullable String contentLanguage) {
            this.contentLanguage = Codegen.ofNullable(contentLanguage);
            return this;
        }
        public Builder contentType(@Nullable Output<String> contentType) {
            this.contentType = contentType;
            return this;
        }
        public Builder contentType(@Nullable String contentType) {
            this.contentType = Codegen.ofNullable(contentType);
            return this;
        }
        public Builder copyIfMatch(@Nullable Output<String> copyIfMatch) {
            this.copyIfMatch = copyIfMatch;
            return this;
        }
        public Builder copyIfMatch(@Nullable String copyIfMatch) {
            this.copyIfMatch = Codegen.ofNullable(copyIfMatch);
            return this;
        }
        public Builder copyIfModifiedSince(@Nullable Output<String> copyIfModifiedSince) {
            this.copyIfModifiedSince = copyIfModifiedSince;
            return this;
        }
        public Builder copyIfModifiedSince(@Nullable String copyIfModifiedSince) {
            this.copyIfModifiedSince = Codegen.ofNullable(copyIfModifiedSince);
            return this;
        }
        public Builder copyIfNoneMatch(@Nullable Output<String> copyIfNoneMatch) {
            this.copyIfNoneMatch = copyIfNoneMatch;
            return this;
        }
        public Builder copyIfNoneMatch(@Nullable String copyIfNoneMatch) {
            this.copyIfNoneMatch = Codegen.ofNullable(copyIfNoneMatch);
            return this;
        }
        public Builder copyIfUnmodifiedSince(@Nullable Output<String> copyIfUnmodifiedSince) {
            this.copyIfUnmodifiedSince = copyIfUnmodifiedSince;
            return this;
        }
        public Builder copyIfUnmodifiedSince(@Nullable String copyIfUnmodifiedSince) {
            this.copyIfUnmodifiedSince = Codegen.ofNullable(copyIfUnmodifiedSince);
            return this;
        }
        public Builder customerAlgorithm(@Nullable Output<String> customerAlgorithm) {
            this.customerAlgorithm = customerAlgorithm;
            return this;
        }
        public Builder customerAlgorithm(@Nullable String customerAlgorithm) {
            this.customerAlgorithm = Codegen.ofNullable(customerAlgorithm);
            return this;
        }
        public Builder customerKey(@Nullable Output<String> customerKey) {
            this.customerKey = customerKey;
            return this;
        }
        public Builder customerKey(@Nullable String customerKey) {
            this.customerKey = Codegen.ofNullable(customerKey);
            return this;
        }
        public Builder customerKeyMd5(@Nullable Output<String> customerKeyMd5) {
            this.customerKeyMd5 = customerKeyMd5;
            return this;
        }
        public Builder customerKeyMd5(@Nullable String customerKeyMd5) {
            this.customerKeyMd5 = Codegen.ofNullable(customerKeyMd5);
            return this;
        }
        public Builder etag(@Nullable Output<String> etag) {
            this.etag = etag;
            return this;
        }
        public Builder etag(@Nullable String etag) {
            this.etag = Codegen.ofNullable(etag);
            return this;
        }
        public Builder expectedBucketOwner(@Nullable Output<String> expectedBucketOwner) {
            this.expectedBucketOwner = expectedBucketOwner;
            return this;
        }
        public Builder expectedBucketOwner(@Nullable String expectedBucketOwner) {
            this.expectedBucketOwner = Codegen.ofNullable(expectedBucketOwner);
            return this;
        }
        public Builder expectedSourceBucketOwner(@Nullable Output<String> expectedSourceBucketOwner) {
            this.expectedSourceBucketOwner = expectedSourceBucketOwner;
            return this;
        }
        public Builder expectedSourceBucketOwner(@Nullable String expectedSourceBucketOwner) {
            this.expectedSourceBucketOwner = Codegen.ofNullable(expectedSourceBucketOwner);
            return this;
        }
        public Builder expiration(@Nullable Output<String> expiration) {
            this.expiration = expiration;
            return this;
        }
        public Builder expiration(@Nullable String expiration) {
            this.expiration = Codegen.ofNullable(expiration);
            return this;
        }
        public Builder expires(@Nullable Output<String> expires) {
            this.expires = expires;
            return this;
        }
        public Builder expires(@Nullable String expires) {
            this.expires = Codegen.ofNullable(expires);
            return this;
        }
        public Builder forceDestroy(@Nullable Output<Boolean> forceDestroy) {
            this.forceDestroy = forceDestroy;
            return this;
        }
        public Builder forceDestroy(@Nullable Boolean forceDestroy) {
            this.forceDestroy = Codegen.ofNullable(forceDestroy);
            return this;
        }
        public Builder grants(@Nullable Output<List<ObjectCopyGrantGetArgs>> grants) {
            this.grants = grants;
            return this;
        }
        public Builder grants(@Nullable List<ObjectCopyGrantGetArgs> grants) {
            this.grants = Codegen.ofNullable(grants);
            return this;
        }
        public Builder grants(ObjectCopyGrantGetArgs... grants) {
            return grants(List.of(grants));
        }
        public Builder key(@Nullable Output<String> key) {
            this.key = key;
            return this;
        }
        public Builder key(@Nullable String key) {
            this.key = Codegen.ofNullable(key);
            return this;
        }
        public Builder kmsEncryptionContext(@Nullable Output<String> kmsEncryptionContext) {
            this.kmsEncryptionContext = kmsEncryptionContext;
            return this;
        }
        public Builder kmsEncryptionContext(@Nullable String kmsEncryptionContext) {
            this.kmsEncryptionContext = Codegen.ofNullable(kmsEncryptionContext);
            return this;
        }
        public Builder kmsKeyId(@Nullable Output<String> kmsKeyId) {
            this.kmsKeyId = kmsKeyId;
            return this;
        }
        public Builder kmsKeyId(@Nullable String kmsKeyId) {
            this.kmsKeyId = Codegen.ofNullable(kmsKeyId);
            return this;
        }
        public Builder lastModified(@Nullable Output<String> lastModified) {
            this.lastModified = lastModified;
            return this;
        }
        public Builder lastModified(@Nullable String lastModified) {
            this.lastModified = Codegen.ofNullable(lastModified);
            return this;
        }
        public Builder metadata(@Nullable Output<Map<String,String>> metadata) {
            this.metadata = metadata;
            return this;
        }
        public Builder metadata(@Nullable Map<String,String> metadata) {
            this.metadata = Codegen.ofNullable(metadata);
            return this;
        }
        public Builder metadataDirective(@Nullable Output<String> metadataDirective) {
            this.metadataDirective = metadataDirective;
            return this;
        }
        public Builder metadataDirective(@Nullable String metadataDirective) {
            this.metadataDirective = Codegen.ofNullable(metadataDirective);
            return this;
        }
        public Builder objectLockLegalHoldStatus(@Nullable Output<String> objectLockLegalHoldStatus) {
            this.objectLockLegalHoldStatus = objectLockLegalHoldStatus;
            return this;
        }
        public Builder objectLockLegalHoldStatus(@Nullable String objectLockLegalHoldStatus) {
            this.objectLockLegalHoldStatus = Codegen.ofNullable(objectLockLegalHoldStatus);
            return this;
        }
        public Builder objectLockMode(@Nullable Output<String> objectLockMode) {
            this.objectLockMode = objectLockMode;
            return this;
        }
        public Builder objectLockMode(@Nullable String objectLockMode) {
            this.objectLockMode = Codegen.ofNullable(objectLockMode);
            return this;
        }
        public Builder objectLockRetainUntilDate(@Nullable Output<String> objectLockRetainUntilDate) {
            this.objectLockRetainUntilDate = objectLockRetainUntilDate;
            return this;
        }
        public Builder objectLockRetainUntilDate(@Nullable String objectLockRetainUntilDate) {
            this.objectLockRetainUntilDate = Codegen.ofNullable(objectLockRetainUntilDate);
            return this;
        }
        public Builder requestCharged(@Nullable Output<Boolean> requestCharged) {
            this.requestCharged = requestCharged;
            return this;
        }
        public Builder requestCharged(@Nullable Boolean requestCharged) {
            this.requestCharged = Codegen.ofNullable(requestCharged);
            return this;
        }
        public Builder requestPayer(@Nullable Output<String> requestPayer) {
            this.requestPayer = requestPayer;
            return this;
        }
        public Builder requestPayer(@Nullable String requestPayer) {
            this.requestPayer = Codegen.ofNullable(requestPayer);
            return this;
        }
        public Builder serverSideEncryption(@Nullable Output<String> serverSideEncryption) {
            this.serverSideEncryption = serverSideEncryption;
            return this;
        }
        public Builder serverSideEncryption(@Nullable String serverSideEncryption) {
            this.serverSideEncryption = Codegen.ofNullable(serverSideEncryption);
            return this;
        }
        public Builder source(@Nullable Output<String> source) {
            this.source = source;
            return this;
        }
        public Builder source(@Nullable String source) {
            this.source = Codegen.ofNullable(source);
            return this;
        }
        public Builder sourceCustomerAlgorithm(@Nullable Output<String> sourceCustomerAlgorithm) {
            this.sourceCustomerAlgorithm = sourceCustomerAlgorithm;
            return this;
        }
        public Builder sourceCustomerAlgorithm(@Nullable String sourceCustomerAlgorithm) {
            this.sourceCustomerAlgorithm = Codegen.ofNullable(sourceCustomerAlgorithm);
            return this;
        }
        public Builder sourceCustomerKey(@Nullable Output<String> sourceCustomerKey) {
            this.sourceCustomerKey = sourceCustomerKey;
            return this;
        }
        public Builder sourceCustomerKey(@Nullable String sourceCustomerKey) {
            this.sourceCustomerKey = Codegen.ofNullable(sourceCustomerKey);
            return this;
        }
        public Builder sourceCustomerKeyMd5(@Nullable Output<String> sourceCustomerKeyMd5) {
            this.sourceCustomerKeyMd5 = sourceCustomerKeyMd5;
            return this;
        }
        public Builder sourceCustomerKeyMd5(@Nullable String sourceCustomerKeyMd5) {
            this.sourceCustomerKeyMd5 = Codegen.ofNullable(sourceCustomerKeyMd5);
            return this;
        }
        public Builder sourceVersionId(@Nullable Output<String> sourceVersionId) {
            this.sourceVersionId = sourceVersionId;
            return this;
        }
        public Builder sourceVersionId(@Nullable String sourceVersionId) {
            this.sourceVersionId = Codegen.ofNullable(sourceVersionId);
            return this;
        }
        public Builder storageClass(@Nullable Output<String> storageClass) {
            this.storageClass = storageClass;
            return this;
        }
        public Builder storageClass(@Nullable String storageClass) {
            this.storageClass = Codegen.ofNullable(storageClass);
            return this;
        }
        public Builder taggingDirective(@Nullable Output<String> taggingDirective) {
            this.taggingDirective = taggingDirective;
            return this;
        }
        public Builder taggingDirective(@Nullable String taggingDirective) {
            this.taggingDirective = Codegen.ofNullable(taggingDirective);
            return this;
        }
        public Builder tags(@Nullable Output<Map<String,String>> tags) {
            this.tags = tags;
            return this;
        }
        public Builder tags(@Nullable Map<String,String> tags) {
            this.tags = Codegen.ofNullable(tags);
            return this;
        }
        public Builder tagsAll(@Nullable Output<Map<String,String>> tagsAll) {
            this.tagsAll = tagsAll;
            return this;
        }
        public Builder tagsAll(@Nullable Map<String,String> tagsAll) {
            this.tagsAll = Codegen.ofNullable(tagsAll);
            return this;
        }
        public Builder versionId(@Nullable Output<String> versionId) {
            this.versionId = versionId;
            return this;
        }
        public Builder versionId(@Nullable String versionId) {
            this.versionId = Codegen.ofNullable(versionId);
            return this;
        }
        public Builder websiteRedirect(@Nullable Output<String> websiteRedirect) {
            this.websiteRedirect = websiteRedirect;
            return this;
        }
        public Builder websiteRedirect(@Nullable String websiteRedirect) {
            this.websiteRedirect = Codegen.ofNullable(websiteRedirect);
            return this;
        }        public ObjectCopyState build() {
            return new ObjectCopyState(acl, bucket, bucketKeyEnabled, cacheControl, contentDisposition, contentEncoding, contentLanguage, contentType, copyIfMatch, copyIfModifiedSince, copyIfNoneMatch, copyIfUnmodifiedSince, customerAlgorithm, customerKey, customerKeyMd5, etag, expectedBucketOwner, expectedSourceBucketOwner, expiration, expires, forceDestroy, grants, key, kmsEncryptionContext, kmsKeyId, lastModified, metadata, metadataDirective, objectLockLegalHoldStatus, objectLockMode, objectLockRetainUntilDate, requestCharged, requestPayer, serverSideEncryption, source, sourceCustomerAlgorithm, sourceCustomerKey, sourceCustomerKeyMd5, sourceVersionId, storageClass, taggingDirective, tags, tagsAll, versionId, websiteRedirect);
        }
    }
}
