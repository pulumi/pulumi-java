// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.eks;

import com.pulumi.aws.ec2.SecurityGroup;
import com.pulumi.aws.iam.Role;
import com.pulumi.core.Either;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.core.internal.Codegen;
import com.pulumi.eks.inputs.ClusterNodeGroupOptionsArgs;
import com.pulumi.eks.inputs.CreationRoleProviderArgs;
import com.pulumi.eks.inputs.FargateProfileArgs;
import com.pulumi.eks.inputs.KubeconfigOptionsArgs;
import com.pulumi.eks.inputs.RoleMappingArgs;
import com.pulumi.eks.inputs.StorageClassArgs;
import com.pulumi.eks.inputs.UserMappingArgs;
import com.pulumi.eks.inputs.VpcCniOptionsArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import javax.annotation.Nullable;


public final class ClusterArgs extends com.pulumi.resources.ResourceArgs {

    public static final ClusterArgs Empty = new ClusterArgs();

    /**
     * The security group to use for the cluster API endpoint. If not provided, a new security group will be created with full internet egress and ingress from node groups.
     * 
     */
    @Import(name="clusterSecurityGroup")
      private final @Nullable Output<SecurityGroup> clusterSecurityGroup;

    public Output<SecurityGroup> clusterSecurityGroup() {
        return this.clusterSecurityGroup == null ? Codegen.empty() : this.clusterSecurityGroup;
    }

    /**
     * The tags to apply to the cluster security group.
     * 
     */
    @Import(name="clusterSecurityGroupTags")
      private final @Nullable Output<Map<String,String>> clusterSecurityGroupTags;

    public Output<Map<String,String>> clusterSecurityGroupTags() {
        return this.clusterSecurityGroupTags == null ? Codegen.empty() : this.clusterSecurityGroupTags;
    }

    /**
     * The tags to apply to the EKS cluster.
     * 
     */
    @Import(name="clusterTags")
      private final @Nullable Output<Map<String,String>> clusterTags;

    public Output<Map<String,String>> clusterTags() {
        return this.clusterTags == null ? Codegen.empty() : this.clusterTags;
    }

    /**
     * Indicates whether an IAM OIDC Provider is created for the EKS cluster.
     * 
     * The OIDC provider is used in the cluster in combination with k8s Service Account annotations to provide IAM roles at the k8s Pod level.
     * 
     * See for more details:
     *  - https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_create_oidc_verify-thumbprint.html
     *  - https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html
     *  - https://aws.amazon.com/blogs/opensource/introducing-fine-grained-iam-roles-service-accounts/
     *  - https://www.pulumi.com/docs/reference/pkg/nodejs/pulumi/aws/eks/#enabling-iam-roles-for-service-accounts
     * 
     */
    @Import(name="createOidcProvider")
      private final @Nullable Output<Boolean> createOidcProvider;

    public Output<Boolean> createOidcProvider() {
        return this.createOidcProvider == null ? Codegen.empty() : this.createOidcProvider;
    }

    /**
     * The IAM Role Provider used to create & authenticate against the EKS cluster. This role is given `[system:masters]` permission in K8S, See: https://docs.aws.amazon.com/eks/latest/userguide/add-user-role.html
     * 
     */
    @Import(name="creationRoleProvider")
      private final @Nullable Output<CreationRoleProviderArgs> creationRoleProvider;

    public Output<CreationRoleProviderArgs> creationRoleProvider() {
        return this.creationRoleProvider == null ? Codegen.empty() : this.creationRoleProvider;
    }

    /**
     * The number of worker nodes that should be running in the cluster. Defaults to 2.
     * 
     */
    @Import(name="desiredCapacity")
      private final @Nullable Output<Integer> desiredCapacity;

    public Output<Integer> desiredCapacity() {
        return this.desiredCapacity == null ? Codegen.empty() : this.desiredCapacity;
    }

    /**
     * Enable EKS control plane logging. This sends logs to cloudwatch. Possible list of values are: ["api", "audit", "authenticator", "controllerManager", "scheduler"]. By default it is off.
     * 
     */
    @Import(name="enabledClusterLogTypes")
      private final @Nullable Output<List<String>> enabledClusterLogTypes;

    public Output<List<String>> enabledClusterLogTypes() {
        return this.enabledClusterLogTypes == null ? Codegen.empty() : this.enabledClusterLogTypes;
    }

    /**
     * Encrypt the root block device of the nodes in the node group.
     * 
     */
    @Import(name="encryptRootBlockDevice")
      private final @Nullable Output<Boolean> encryptRootBlockDevice;

    public Output<Boolean> encryptRootBlockDevice() {
        return this.encryptRootBlockDevice == null ? Codegen.empty() : this.encryptRootBlockDevice;
    }

    /**
     * KMS Key ARN to use with the encryption configuration for the cluster.
     * 
     * Only available on Kubernetes 1.13+ clusters created after March 6, 2020.
     * See for more details:
     * - https://aws.amazon.com/about-aws/whats-new/2020/03/amazon-eks-adds-envelope-encryption-for-secrets-with-aws-kms/
     * 
     */
    @Import(name="encryptionConfigKeyArn")
      private final @Nullable Output<String> encryptionConfigKeyArn;

    public Output<String> encryptionConfigKeyArn() {
        return this.encryptionConfigKeyArn == null ? Codegen.empty() : this.encryptionConfigKeyArn;
    }

    /**
     * Indicates whether or not the Amazon EKS private API server endpoint is enabled. Default is `false`.
     * 
     */
    @Import(name="endpointPrivateAccess")
      private final @Nullable Output<Boolean> endpointPrivateAccess;

    public Output<Boolean> endpointPrivateAccess() {
        return this.endpointPrivateAccess == null ? Codegen.empty() : this.endpointPrivateAccess;
    }

    /**
     * Indicates whether or not the Amazon EKS public API server endpoint is enabled. Default is `true`.
     * 
     */
    @Import(name="endpointPublicAccess")
      private final @Nullable Output<Boolean> endpointPublicAccess;

    public Output<Boolean> endpointPublicAccess() {
        return this.endpointPublicAccess == null ? Codegen.empty() : this.endpointPublicAccess;
    }

    /**
     * Add support for launching pods in Fargate. Defaults to launching pods in the `default` namespace.  If specified, the default node group is skipped as though `skipDefaultNodeGroup: true` had been passed.
     * 
     */
    @Import(name="fargate")
      private final @Nullable Output<Either<Boolean,FargateProfileArgs>> fargate;

    public Output<Either<Boolean,FargateProfileArgs>> fargate() {
        return this.fargate == null ? Codegen.empty() : this.fargate;
    }

    /**
     * Use the latest recommended EKS Optimized Linux AMI with GPU support for the worker nodes from the AWS Systems Manager Parameter Store.
     * 
     * Defaults to false.
     * 
     * Note: `gpu` and `nodeAmiId` are mutually exclusive.
     * 
     * See for more details:
     * - https://docs.aws.amazon.com/eks/latest/userguide/eks-optimized-ami.html
     * - https://docs.aws.amazon.com/eks/latest/userguide/retrieve-ami-id.html
     * 
     */
    @Import(name="gpu")
      private final @Nullable Output<Boolean> gpu;

    public Output<Boolean> gpu() {
        return this.gpu == null ? Codegen.empty() : this.gpu;
    }

    /**
     * The default IAM InstanceProfile to use on the Worker NodeGroups, if one is not already set in the NodeGroup.
     * 
     */
    @Import(name="instanceProfileName")
      private final @Nullable Output<String> instanceProfileName;

    public Output<String> instanceProfileName() {
        return this.instanceProfileName == null ? Codegen.empty() : this.instanceProfileName;
    }

    /**
     * This enables the simple case of only registering a *single* IAM instance role with the cluster, that is required to be shared by *all* node groups in their instance profiles.
     * 
     * Note: options `instanceRole` and `instanceRoles` are mutually exclusive.
     * 
     */
    @Import(name="instanceRole")
      private final @Nullable Output<Role> instanceRole;

    public Output<Role> instanceRole() {
        return this.instanceRole == null ? Codegen.empty() : this.instanceRole;
    }

    /**
     * This enables the advanced case of registering *many* IAM instance roles with the cluster for per node group IAM, instead of the simpler, shared case of `instanceRole`.
     * 
     * Note: options `instanceRole` and `instanceRoles` are mutually exclusive.
     * 
     */
    @Import(name="instanceRoles")
      private final @Nullable Output<List<Role>> instanceRoles;

    public Output<List<Role>> instanceRoles() {
        return this.instanceRoles == null ? Codegen.empty() : this.instanceRoles;
    }

    /**
     * The instance type to use for the cluster's nodes. Defaults to "t2.medium".
     * 
     */
    @Import(name="instanceType")
      private final @Nullable Output<String> instanceType;

    public Output<String> instanceType() {
        return this.instanceType == null ? Codegen.empty() : this.instanceType;
    }

    /**
     * The CIDR block to assign Kubernetes service IP addresses from. If you don't
     * specify a block, Kubernetes assigns addresses from either the 10.100.0.0/16 or
     * 172.20.0.0/16 CIDR blocks. We recommend that you specify a block that does not overlap
     * with resources in other networks that are peered or connected to your VPC. You can only specify
     * a custom CIDR block when you create a cluster, changing this value will force a new cluster to be created.
     * 
     * The block must meet the following requirements:
     * - Within one of the following private IP address blocks: 10.0.0.0/8, 172.16.0.0.0/12, or 192.168.0.0/16.
     * - Doesn't overlap with any CIDR block assigned to the VPC that you selected for VPC.
     * - Between /24 and /12.
     * 
     */
    @Import(name="kubernetesServiceIpAddressRange")
      private final @Nullable Output<String> kubernetesServiceIpAddressRange;

    public Output<String> kubernetesServiceIpAddressRange() {
        return this.kubernetesServiceIpAddressRange == null ? Codegen.empty() : this.kubernetesServiceIpAddressRange;
    }

    /**
     * The maximum number of worker nodes running in the cluster. Defaults to 2.
     * 
     */
    @Import(name="maxSize")
      private final @Nullable Output<Integer> maxSize;

    public Output<Integer> maxSize() {
        return this.maxSize == null ? Codegen.empty() : this.maxSize;
    }

    /**
     * The minimum number of worker nodes running in the cluster. Defaults to 1.
     * 
     */
    @Import(name="minSize")
      private final @Nullable Output<Integer> minSize;

    public Output<Integer> minSize() {
        return this.minSize == null ? Codegen.empty() : this.minSize;
    }

    /**
     * The cluster's physical resource name.
     * 
     * If not specified, the default is to use auto-naming for the cluster's name, resulting in a physical name with the format `${name}-eksCluster-0123abcd`.
     * 
     * See for more details: https://www.pulumi.com/docs/intro/concepts/programming-model/#autonaming
     * 
     */
    @Import(name="name")
      private final @Nullable Output<String> name;

    public Output<String> name() {
        return this.name == null ? Codegen.empty() : this.name;
    }

    /**
     * The AMI ID to use for the worker nodes.
     * 
     * Defaults to the latest recommended EKS Optimized Linux AMI from the AWS Systems Manager Parameter Store.
     * 
     * Note: `nodeAmiId` and `gpu` are mutually exclusive.
     * 
     * See for more details:
     * - https://docs.aws.amazon.com/eks/latest/userguide/eks-optimized-ami.html.
     * 
     */
    @Import(name="nodeAmiId")
      private final @Nullable Output<String> nodeAmiId;

    public Output<String> nodeAmiId() {
        return this.nodeAmiId == null ? Codegen.empty() : this.nodeAmiId;
    }

    /**
     * Whether or not to auto-assign the EKS worker nodes public IP addresses. If this toggle is set to true, the EKS workers will be auto-assigned public IPs. If false, they will not be auto-assigned public IPs.
     * 
     */
    @Import(name="nodeAssociatePublicIpAddress")
      private final @Nullable Output<Boolean> nodeAssociatePublicIpAddress;

    public Output<Boolean> nodeAssociatePublicIpAddress() {
        return this.nodeAssociatePublicIpAddress == null ? Codegen.empty() : this.nodeAssociatePublicIpAddress;
    }

    /**
     * The common configuration settings for NodeGroups.
     * 
     */
    @Import(name="nodeGroupOptions")
      private final @Nullable Output<ClusterNodeGroupOptionsArgs> nodeGroupOptions;

    public Output<ClusterNodeGroupOptionsArgs> nodeGroupOptions() {
        return this.nodeGroupOptions == null ? Codegen.empty() : this.nodeGroupOptions;
    }

    /**
     * Public key material for SSH access to worker nodes. See allowed formats at:
     * https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html
     * If not provided, no SSH access is enabled on VMs.
     * 
     */
    @Import(name="nodePublicKey")
      private final @Nullable Output<String> nodePublicKey;

    public Output<String> nodePublicKey() {
        return this.nodePublicKey == null ? Codegen.empty() : this.nodePublicKey;
    }

    /**
     * Whether to delete a cluster node's root volume on termination. Defaults to true.
     * 
     */
    @Import(name="nodeRootVolumeDeleteOnTermination")
      private final @Nullable Output<Boolean> nodeRootVolumeDeleteOnTermination;

    public Output<Boolean> nodeRootVolumeDeleteOnTermination() {
        return this.nodeRootVolumeDeleteOnTermination == null ? Codegen.empty() : this.nodeRootVolumeDeleteOnTermination;
    }

    /**
     * Whether to encrypt a cluster node's root volume. Defaults to false.
     * 
     */
    @Import(name="nodeRootVolumeEncrypted")
      private final @Nullable Output<Boolean> nodeRootVolumeEncrypted;

    public Output<Boolean> nodeRootVolumeEncrypted() {
        return this.nodeRootVolumeEncrypted == null ? Codegen.empty() : this.nodeRootVolumeEncrypted;
    }

    /**
     * Provisioned IOPS for a cluster node's root volume. Only valid for io1 volumes.
     * 
     */
    @Import(name="nodeRootVolumeIops")
      private final @Nullable Output<Integer> nodeRootVolumeIops;

    public Output<Integer> nodeRootVolumeIops() {
        return this.nodeRootVolumeIops == null ? Codegen.empty() : this.nodeRootVolumeIops;
    }

    /**
     * The size in GiB of a cluster node's root volume. Defaults to 20.
     * 
     */
    @Import(name="nodeRootVolumeSize")
      private final @Nullable Output<Integer> nodeRootVolumeSize;

    public Output<Integer> nodeRootVolumeSize() {
        return this.nodeRootVolumeSize == null ? Codegen.empty() : this.nodeRootVolumeSize;
    }

    /**
     * Provisioned throughput performance in integer MiB/s for a cluster node's root volume. Only valid for gp3 volumes.
     * 
     */
    @Import(name="nodeRootVolumeThroughput")
      private final @Nullable Output<Integer> nodeRootVolumeThroughput;

    public Output<Integer> nodeRootVolumeThroughput() {
        return this.nodeRootVolumeThroughput == null ? Codegen.empty() : this.nodeRootVolumeThroughput;
    }

    /**
     * Configured EBS type for a cluster node's root volume. Default is gp2.
     * 
     */
    @Import(name="nodeRootVolumeType")
      private final @Nullable Output<String> nodeRootVolumeType;

    public Output<String> nodeRootVolumeType() {
        return this.nodeRootVolumeType == null ? Codegen.empty() : this.nodeRootVolumeType;
    }

    /**
     * The tags to apply to the default `nodeSecurityGroup` created by the cluster.
     * 
     * Note: The `nodeSecurityGroupTags` option and the node group option `nodeSecurityGroup` are mutually exclusive.
     * 
     */
    @Import(name="nodeSecurityGroupTags")
      private final @Nullable Output<Map<String,String>> nodeSecurityGroupTags;

    public Output<Map<String,String>> nodeSecurityGroupTags() {
        return this.nodeSecurityGroupTags == null ? Codegen.empty() : this.nodeSecurityGroupTags;
    }

    /**
     * The subnets to use for worker nodes. Defaults to the value of subnetIds.
     * 
     */
    @Import(name="nodeSubnetIds")
      private final @Nullable Output<List<String>> nodeSubnetIds;

    public Output<List<String>> nodeSubnetIds() {
        return this.nodeSubnetIds == null ? Codegen.empty() : this.nodeSubnetIds;
    }

    /**
     * Extra code to run on node startup. This code will run after the AWS EKS bootstrapping code and before the node signals its readiness to the managing CloudFormation stack. This code must be a typical user data script: critically it must begin with an interpreter directive (i.e. a `#!`).
     * 
     */
    @Import(name="nodeUserData")
      private final @Nullable Output<String> nodeUserData;

    public Output<String> nodeUserData() {
        return this.nodeUserData == null ? Codegen.empty() : this.nodeUserData;
    }

    /**
     * The set of private subnets to use for the worker node groups on the EKS cluster. These subnets are automatically tagged by EKS for Kubernetes purposes.
     * 
     * If `vpcId` is not set, the cluster will use the AWS account's default VPC subnets.
     * 
     * Worker network architecture options:
     *  - Private-only: Only set `privateSubnetIds`.
     *    - Default workers to run in a private subnet. In this setting, Kubernetes cannot create public, internet-facing load balancers for your pods.
     *  - Public-only: Only set `publicSubnetIds`.
     *    - Default workers to run in a public subnet.
     *  - Mixed (recommended): Set both `privateSubnetIds` and `publicSubnetIds`.
     *    - Default all worker nodes to run in private subnets, and use the public subnets for internet-facing load balancers.
     * 
     * See for more details: https://docs.aws.amazon.com/eks/latest/userguide/network_reqs.html.Note: The use of `subnetIds`, along with `publicSubnetIds` and/or `privateSubnetIds` is mutually exclusive. The use of `publicSubnetIds` and `privateSubnetIds` is encouraged.
     * 
     * Also consider setting `nodeAssociatePublicIpAddress: true` for fully private workers.
     * 
     */
    @Import(name="privateSubnetIds")
      private final @Nullable Output<List<String>> privateSubnetIds;

    public Output<List<String>> privateSubnetIds() {
        return this.privateSubnetIds == null ? Codegen.empty() : this.privateSubnetIds;
    }

    /**
     * The AWS provider credential options to scope the cluster's kubeconfig authentication when using a non-default credential chain.
     * 
     * This is required for certain auth scenarios. For example:
     * - Creating and using a new AWS provider instance, or
     * - Setting the AWS_PROFILE environment variable, or
     * - Using a named profile configured on the AWS provider via:
     *   `pulumi config set aws:profile <profileName>`
     * 
     * See for more details:
     * - https://www.pulumi.com/docs/reference/pkg/nodejs/pulumi/aws/#Provider
     * - https://www.pulumi.com/docs/intro/cloud-providers/aws/setup/
     * - https://www.pulumi.com/docs/intro/cloud-providers/aws/#configuration
     * - https://docs.aws.amazon.com/eks/latest/userguide/create-kubeconfig.html
     * 
     */
    @Import(name="providerCredentialOpts")
      private final @Nullable Output<KubeconfigOptionsArgs> providerCredentialOpts;

    public Output<KubeconfigOptionsArgs> providerCredentialOpts() {
        return this.providerCredentialOpts == null ? Codegen.empty() : this.providerCredentialOpts;
    }

    /**
     * The HTTP(S) proxy to use within a proxied environment.
     * 
     *  The proxy is used during cluster creation, and OIDC configuration.
     * 
     * This is an alternative option to setting the proxy environment variables: HTTP(S)_PROXY and/or http(s)_proxy.
     * 
     * This option is required iff the proxy environment variables are not set.
     * 
     * Format:      <protocol>://<host>:<port>
     * Auth Format: <protocol>://<username>:<password>@<host>:<port>
     * 
     * Ex:
     *   - "http://proxy.example.com:3128"
     *   - "https://proxy.example.com"
     *   - "http://username:password@proxy.example.com:3128"
     * 
     */
    @Import(name="proxy")
      private final @Nullable Output<String> proxy;

    public Output<String> proxy() {
        return this.proxy == null ? Codegen.empty() : this.proxy;
    }

    /**
     * Indicates which CIDR blocks can access the Amazon EKS public API server endpoint.
     * 
     */
    @Import(name="publicAccessCidrs")
      private final @Nullable Output<List<String>> publicAccessCidrs;

    public Output<List<String>> publicAccessCidrs() {
        return this.publicAccessCidrs == null ? Codegen.empty() : this.publicAccessCidrs;
    }

    /**
     * The set of public subnets to use for the worker node groups on the EKS cluster. These subnets are automatically tagged by EKS for Kubernetes purposes.
     * 
     * If `vpcId` is not set, the cluster will use the AWS account's default VPC subnets.
     * 
     * Worker network architecture options:
     *  - Private-only: Only set `privateSubnetIds`.
     *    - Default workers to run in a private subnet. In this setting, Kubernetes cannot create public, internet-facing load balancers for your pods.
     *  - Public-only: Only set `publicSubnetIds`.
     *    - Default workers to run in a public subnet.
     *  - Mixed (recommended): Set both `privateSubnetIds` and `publicSubnetIds`.
     *    - Default all worker nodes to run in private subnets, and use the public subnets for internet-facing load balancers.
     * 
     * See for more details: https://docs.aws.amazon.com/eks/latest/userguide/network_reqs.html.Note: The use of `subnetIds`, along with `publicSubnetIds` and/or `privateSubnetIds` is mutually exclusive. The use of `publicSubnetIds` and `privateSubnetIds` is encouraged.
     * 
     */
    @Import(name="publicSubnetIds")
      private final @Nullable Output<List<String>> publicSubnetIds;

    public Output<List<String>> publicSubnetIds() {
        return this.publicSubnetIds == null ? Codegen.empty() : this.publicSubnetIds;
    }

    /**
     * Optional mappings from AWS IAM roles to Kubernetes users and groups.
     * 
     */
    @Import(name="roleMappings")
      private final @Nullable Output<List<RoleMappingArgs>> roleMappings;

    public Output<List<RoleMappingArgs>> roleMappings() {
        return this.roleMappings == null ? Codegen.empty() : this.roleMappings;
    }

    /**
     * IAM Service Role for EKS to use to manage the cluster.
     * 
     */
    @Import(name="serviceRole")
      private final @Nullable Output<Role> serviceRole;

    public Output<Role> serviceRole() {
        return this.serviceRole == null ? Codegen.empty() : this.serviceRole;
    }

    /**
     * If this toggle is set to true, the EKS cluster will be created without node group attached. Defaults to false, unless `fargate` input is provided.
     * 
     */
    @Import(name="skipDefaultNodeGroup")
      private final @Nullable Output<Boolean> skipDefaultNodeGroup;

    public Output<Boolean> skipDefaultNodeGroup() {
        return this.skipDefaultNodeGroup == null ? Codegen.empty() : this.skipDefaultNodeGroup;
    }

    /**
     * An optional set of StorageClasses to enable for the cluster. If this is a single volume type rather than a map, a single StorageClass will be created for that volume type.
     * 
     * Note: As of Kubernetes v1.11+ on EKS, a default `gp2` storage class will always be created automatically for the cluster by the EKS service. See https://docs.aws.amazon.com/eks/latest/userguide/storage-classes.html
     * 
     */
    @Import(name="storageClasses")
      private final @Nullable Output<Either<String,Map<String,StorageClassArgs>>> storageClasses;

    public Output<Either<String,Map<String,StorageClassArgs>>> storageClasses() {
        return this.storageClasses == null ? Codegen.empty() : this.storageClasses;
    }

    /**
     * The set of all subnets, public and private, to use for the worker node groups on the EKS cluster. These subnets are automatically tagged by EKS for Kubernetes purposes.
     * 
     * If `vpcId` is not set, the cluster will use the AWS account's default VPC subnets.
     * 
     * If the list of subnets includes both public and private subnets, the worker nodes will only be attached to the private subnets, and the public subnets will be used for internet-facing load balancers.
     * 
     * See for more details: https://docs.aws.amazon.com/eks/latest/userguide/network_reqs.html.
     * 
     * Note: The use of `subnetIds`, along with `publicSubnetIds` and/or `privateSubnetIds` is mutually exclusive. The use of `publicSubnetIds` and `privateSubnetIds` is encouraged.
     * 
     */
    @Import(name="subnetIds")
      private final @Nullable Output<List<String>> subnetIds;

    public Output<List<String>> subnetIds() {
        return this.subnetIds == null ? Codegen.empty() : this.subnetIds;
    }

    /**
     * Key-value mapping of tags that are automatically applied to all AWS resources directly under management with this cluster, which support tagging.
     * 
     */
    @Import(name="tags")
      private final @Nullable Output<Map<String,String>> tags;

    public Output<Map<String,String>> tags() {
        return this.tags == null ? Codegen.empty() : this.tags;
    }

    /**
     * Use the default VPC CNI instead of creating a custom one. Should not be used in conjunction with `vpcCniOptions`.
     * 
     */
    @Import(name="useDefaultVpcCni")
      private final @Nullable Output<Boolean> useDefaultVpcCni;

    public Output<Boolean> useDefaultVpcCni() {
        return this.useDefaultVpcCni == null ? Codegen.empty() : this.useDefaultVpcCni;
    }

    /**
     * Optional mappings from AWS IAM users to Kubernetes users and groups.
     * 
     */
    @Import(name="userMappings")
      private final @Nullable Output<List<UserMappingArgs>> userMappings;

    public Output<List<UserMappingArgs>> userMappings() {
        return this.userMappings == null ? Codegen.empty() : this.userMappings;
    }

    /**
     * Desired Kubernetes master / control plane version. If you do not specify a value, the latest available version is used.
     * 
     */
    @Import(name="version")
      private final @Nullable Output<String> version;

    public Output<String> version() {
        return this.version == null ? Codegen.empty() : this.version;
    }

    /**
     * The configuration of the Amazon VPC CNI plugin for this instance. Defaults are described in the documentation for the VpcCniOptions type.
     * 
     */
    @Import(name="vpcCniOptions")
      private final @Nullable Output<VpcCniOptionsArgs> vpcCniOptions;

    public Output<VpcCniOptionsArgs> vpcCniOptions() {
        return this.vpcCniOptions == null ? Codegen.empty() : this.vpcCniOptions;
    }

    /**
     * The VPC in which to create the cluster and its worker nodes. If unset, the cluster will be created in the default VPC.
     * 
     */
    @Import(name="vpcId")
      private final @Nullable Output<String> vpcId;

    public Output<String> vpcId() {
        return this.vpcId == null ? Codegen.empty() : this.vpcId;
    }

    public ClusterArgs(
        @Nullable Output<SecurityGroup> clusterSecurityGroup,
        @Nullable Output<Map<String,String>> clusterSecurityGroupTags,
        @Nullable Output<Map<String,String>> clusterTags,
        @Nullable Output<Boolean> createOidcProvider,
        @Nullable Output<CreationRoleProviderArgs> creationRoleProvider,
        @Nullable Output<Integer> desiredCapacity,
        @Nullable Output<List<String>> enabledClusterLogTypes,
        @Nullable Output<Boolean> encryptRootBlockDevice,
        @Nullable Output<String> encryptionConfigKeyArn,
        @Nullable Output<Boolean> endpointPrivateAccess,
        @Nullable Output<Boolean> endpointPublicAccess,
        @Nullable Output<Either<Boolean,FargateProfileArgs>> fargate,
        @Nullable Output<Boolean> gpu,
        @Nullable Output<String> instanceProfileName,
        @Nullable Output<Role> instanceRole,
        @Nullable Output<List<Role>> instanceRoles,
        @Nullable Output<String> instanceType,
        @Nullable Output<String> kubernetesServiceIpAddressRange,
        @Nullable Output<Integer> maxSize,
        @Nullable Output<Integer> minSize,
        @Nullable Output<String> name,
        @Nullable Output<String> nodeAmiId,
        @Nullable Output<Boolean> nodeAssociatePublicIpAddress,
        @Nullable Output<ClusterNodeGroupOptionsArgs> nodeGroupOptions,
        @Nullable Output<String> nodePublicKey,
        @Nullable Output<Boolean> nodeRootVolumeDeleteOnTermination,
        @Nullable Output<Boolean> nodeRootVolumeEncrypted,
        @Nullable Output<Integer> nodeRootVolumeIops,
        @Nullable Output<Integer> nodeRootVolumeSize,
        @Nullable Output<Integer> nodeRootVolumeThroughput,
        @Nullable Output<String> nodeRootVolumeType,
        @Nullable Output<Map<String,String>> nodeSecurityGroupTags,
        @Nullable Output<List<String>> nodeSubnetIds,
        @Nullable Output<String> nodeUserData,
        @Nullable Output<List<String>> privateSubnetIds,
        @Nullable Output<KubeconfigOptionsArgs> providerCredentialOpts,
        @Nullable Output<String> proxy,
        @Nullable Output<List<String>> publicAccessCidrs,
        @Nullable Output<List<String>> publicSubnetIds,
        @Nullable Output<List<RoleMappingArgs>> roleMappings,
        @Nullable Output<Role> serviceRole,
        @Nullable Output<Boolean> skipDefaultNodeGroup,
        @Nullable Output<Either<String,Map<String,StorageClassArgs>>> storageClasses,
        @Nullable Output<List<String>> subnetIds,
        @Nullable Output<Map<String,String>> tags,
        @Nullable Output<Boolean> useDefaultVpcCni,
        @Nullable Output<List<UserMappingArgs>> userMappings,
        @Nullable Output<String> version,
        @Nullable Output<VpcCniOptionsArgs> vpcCniOptions,
        @Nullable Output<String> vpcId) {
        this.clusterSecurityGroup = clusterSecurityGroup;
        this.clusterSecurityGroupTags = clusterSecurityGroupTags;
        this.clusterTags = clusterTags;
        this.createOidcProvider = createOidcProvider;
        this.creationRoleProvider = creationRoleProvider;
        this.desiredCapacity = desiredCapacity;
        this.enabledClusterLogTypes = enabledClusterLogTypes;
        this.encryptRootBlockDevice = encryptRootBlockDevice;
        this.encryptionConfigKeyArn = encryptionConfigKeyArn;
        this.endpointPrivateAccess = endpointPrivateAccess;
        this.endpointPublicAccess = endpointPublicAccess;
        this.fargate = fargate;
        this.gpu = gpu;
        this.instanceProfileName = instanceProfileName;
        this.instanceRole = instanceRole;
        this.instanceRoles = instanceRoles;
        this.instanceType = instanceType;
        this.kubernetesServiceIpAddressRange = kubernetesServiceIpAddressRange;
        this.maxSize = maxSize;
        this.minSize = minSize;
        this.name = name;
        this.nodeAmiId = nodeAmiId;
        this.nodeAssociatePublicIpAddress = nodeAssociatePublicIpAddress;
        this.nodeGroupOptions = nodeGroupOptions;
        this.nodePublicKey = nodePublicKey;
        this.nodeRootVolumeDeleteOnTermination = nodeRootVolumeDeleteOnTermination == null ? Codegen.ofNullable(true) : nodeRootVolumeDeleteOnTermination;
        this.nodeRootVolumeEncrypted = nodeRootVolumeEncrypted == null ? Codegen.ofNullable(false) : nodeRootVolumeEncrypted;
        this.nodeRootVolumeIops = nodeRootVolumeIops;
        this.nodeRootVolumeSize = nodeRootVolumeSize == null ? Codegen.ofNullable(20) : nodeRootVolumeSize;
        this.nodeRootVolumeThroughput = nodeRootVolumeThroughput;
        this.nodeRootVolumeType = nodeRootVolumeType == null ? Codegen.ofNullable("gp2") : nodeRootVolumeType;
        this.nodeSecurityGroupTags = nodeSecurityGroupTags;
        this.nodeSubnetIds = nodeSubnetIds;
        this.nodeUserData = nodeUserData;
        this.privateSubnetIds = privateSubnetIds;
        this.providerCredentialOpts = providerCredentialOpts;
        this.proxy = proxy;
        this.publicAccessCidrs = publicAccessCidrs;
        this.publicSubnetIds = publicSubnetIds;
        this.roleMappings = roleMappings;
        this.serviceRole = serviceRole;
        this.skipDefaultNodeGroup = skipDefaultNodeGroup;
        this.storageClasses = storageClasses;
        this.subnetIds = subnetIds;
        this.tags = tags;
        this.useDefaultVpcCni = useDefaultVpcCni;
        this.userMappings = userMappings;
        this.version = version;
        this.vpcCniOptions = vpcCniOptions;
        this.vpcId = vpcId;
    }

    private ClusterArgs() {
        this.clusterSecurityGroup = Codegen.empty();
        this.clusterSecurityGroupTags = Codegen.empty();
        this.clusterTags = Codegen.empty();
        this.createOidcProvider = Codegen.empty();
        this.creationRoleProvider = Codegen.empty();
        this.desiredCapacity = Codegen.empty();
        this.enabledClusterLogTypes = Codegen.empty();
        this.encryptRootBlockDevice = Codegen.empty();
        this.encryptionConfigKeyArn = Codegen.empty();
        this.endpointPrivateAccess = Codegen.empty();
        this.endpointPublicAccess = Codegen.empty();
        this.fargate = Codegen.empty();
        this.gpu = Codegen.empty();
        this.instanceProfileName = Codegen.empty();
        this.instanceRole = Codegen.empty();
        this.instanceRoles = Codegen.empty();
        this.instanceType = Codegen.empty();
        this.kubernetesServiceIpAddressRange = Codegen.empty();
        this.maxSize = Codegen.empty();
        this.minSize = Codegen.empty();
        this.name = Codegen.empty();
        this.nodeAmiId = Codegen.empty();
        this.nodeAssociatePublicIpAddress = Codegen.empty();
        this.nodeGroupOptions = Codegen.empty();
        this.nodePublicKey = Codegen.empty();
        this.nodeRootVolumeDeleteOnTermination = Codegen.empty();
        this.nodeRootVolumeEncrypted = Codegen.empty();
        this.nodeRootVolumeIops = Codegen.empty();
        this.nodeRootVolumeSize = Codegen.empty();
        this.nodeRootVolumeThroughput = Codegen.empty();
        this.nodeRootVolumeType = Codegen.empty();
        this.nodeSecurityGroupTags = Codegen.empty();
        this.nodeSubnetIds = Codegen.empty();
        this.nodeUserData = Codegen.empty();
        this.privateSubnetIds = Codegen.empty();
        this.providerCredentialOpts = Codegen.empty();
        this.proxy = Codegen.empty();
        this.publicAccessCidrs = Codegen.empty();
        this.publicSubnetIds = Codegen.empty();
        this.roleMappings = Codegen.empty();
        this.serviceRole = Codegen.empty();
        this.skipDefaultNodeGroup = Codegen.empty();
        this.storageClasses = Codegen.empty();
        this.subnetIds = Codegen.empty();
        this.tags = Codegen.empty();
        this.useDefaultVpcCni = Codegen.empty();
        this.userMappings = Codegen.empty();
        this.version = Codegen.empty();
        this.vpcCniOptions = Codegen.empty();
        this.vpcId = Codegen.empty();
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(ClusterArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private @Nullable Output<SecurityGroup> clusterSecurityGroup;
        private @Nullable Output<Map<String,String>> clusterSecurityGroupTags;
        private @Nullable Output<Map<String,String>> clusterTags;
        private @Nullable Output<Boolean> createOidcProvider;
        private @Nullable Output<CreationRoleProviderArgs> creationRoleProvider;
        private @Nullable Output<Integer> desiredCapacity;
        private @Nullable Output<List<String>> enabledClusterLogTypes;
        private @Nullable Output<Boolean> encryptRootBlockDevice;
        private @Nullable Output<String> encryptionConfigKeyArn;
        private @Nullable Output<Boolean> endpointPrivateAccess;
        private @Nullable Output<Boolean> endpointPublicAccess;
        private @Nullable Output<Either<Boolean,FargateProfileArgs>> fargate;
        private @Nullable Output<Boolean> gpu;
        private @Nullable Output<String> instanceProfileName;
        private @Nullable Output<Role> instanceRole;
        private @Nullable Output<List<Role>> instanceRoles;
        private @Nullable Output<String> instanceType;
        private @Nullable Output<String> kubernetesServiceIpAddressRange;
        private @Nullable Output<Integer> maxSize;
        private @Nullable Output<Integer> minSize;
        private @Nullable Output<String> name;
        private @Nullable Output<String> nodeAmiId;
        private @Nullable Output<Boolean> nodeAssociatePublicIpAddress;
        private @Nullable Output<ClusterNodeGroupOptionsArgs> nodeGroupOptions;
        private @Nullable Output<String> nodePublicKey;
        private @Nullable Output<Boolean> nodeRootVolumeDeleteOnTermination;
        private @Nullable Output<Boolean> nodeRootVolumeEncrypted;
        private @Nullable Output<Integer> nodeRootVolumeIops;
        private @Nullable Output<Integer> nodeRootVolumeSize;
        private @Nullable Output<Integer> nodeRootVolumeThroughput;
        private @Nullable Output<String> nodeRootVolumeType;
        private @Nullable Output<Map<String,String>> nodeSecurityGroupTags;
        private @Nullable Output<List<String>> nodeSubnetIds;
        private @Nullable Output<String> nodeUserData;
        private @Nullable Output<List<String>> privateSubnetIds;
        private @Nullable Output<KubeconfigOptionsArgs> providerCredentialOpts;
        private @Nullable Output<String> proxy;
        private @Nullable Output<List<String>> publicAccessCidrs;
        private @Nullable Output<List<String>> publicSubnetIds;
        private @Nullable Output<List<RoleMappingArgs>> roleMappings;
        private @Nullable Output<Role> serviceRole;
        private @Nullable Output<Boolean> skipDefaultNodeGroup;
        private @Nullable Output<Either<String,Map<String,StorageClassArgs>>> storageClasses;
        private @Nullable Output<List<String>> subnetIds;
        private @Nullable Output<Map<String,String>> tags;
        private @Nullable Output<Boolean> useDefaultVpcCni;
        private @Nullable Output<List<UserMappingArgs>> userMappings;
        private @Nullable Output<String> version;
        private @Nullable Output<VpcCniOptionsArgs> vpcCniOptions;
        private @Nullable Output<String> vpcId;

        public Builder() {
    	      // Empty
        }

        public Builder(ClusterArgs defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.clusterSecurityGroup = defaults.clusterSecurityGroup;
    	      this.clusterSecurityGroupTags = defaults.clusterSecurityGroupTags;
    	      this.clusterTags = defaults.clusterTags;
    	      this.createOidcProvider = defaults.createOidcProvider;
    	      this.creationRoleProvider = defaults.creationRoleProvider;
    	      this.desiredCapacity = defaults.desiredCapacity;
    	      this.enabledClusterLogTypes = defaults.enabledClusterLogTypes;
    	      this.encryptRootBlockDevice = defaults.encryptRootBlockDevice;
    	      this.encryptionConfigKeyArn = defaults.encryptionConfigKeyArn;
    	      this.endpointPrivateAccess = defaults.endpointPrivateAccess;
    	      this.endpointPublicAccess = defaults.endpointPublicAccess;
    	      this.fargate = defaults.fargate;
    	      this.gpu = defaults.gpu;
    	      this.instanceProfileName = defaults.instanceProfileName;
    	      this.instanceRole = defaults.instanceRole;
    	      this.instanceRoles = defaults.instanceRoles;
    	      this.instanceType = defaults.instanceType;
    	      this.kubernetesServiceIpAddressRange = defaults.kubernetesServiceIpAddressRange;
    	      this.maxSize = defaults.maxSize;
    	      this.minSize = defaults.minSize;
    	      this.name = defaults.name;
    	      this.nodeAmiId = defaults.nodeAmiId;
    	      this.nodeAssociatePublicIpAddress = defaults.nodeAssociatePublicIpAddress;
    	      this.nodeGroupOptions = defaults.nodeGroupOptions;
    	      this.nodePublicKey = defaults.nodePublicKey;
    	      this.nodeRootVolumeDeleteOnTermination = defaults.nodeRootVolumeDeleteOnTermination;
    	      this.nodeRootVolumeEncrypted = defaults.nodeRootVolumeEncrypted;
    	      this.nodeRootVolumeIops = defaults.nodeRootVolumeIops;
    	      this.nodeRootVolumeSize = defaults.nodeRootVolumeSize;
    	      this.nodeRootVolumeThroughput = defaults.nodeRootVolumeThroughput;
    	      this.nodeRootVolumeType = defaults.nodeRootVolumeType;
    	      this.nodeSecurityGroupTags = defaults.nodeSecurityGroupTags;
    	      this.nodeSubnetIds = defaults.nodeSubnetIds;
    	      this.nodeUserData = defaults.nodeUserData;
    	      this.privateSubnetIds = defaults.privateSubnetIds;
    	      this.providerCredentialOpts = defaults.providerCredentialOpts;
    	      this.proxy = defaults.proxy;
    	      this.publicAccessCidrs = defaults.publicAccessCidrs;
    	      this.publicSubnetIds = defaults.publicSubnetIds;
    	      this.roleMappings = defaults.roleMappings;
    	      this.serviceRole = defaults.serviceRole;
    	      this.skipDefaultNodeGroup = defaults.skipDefaultNodeGroup;
    	      this.storageClasses = defaults.storageClasses;
    	      this.subnetIds = defaults.subnetIds;
    	      this.tags = defaults.tags;
    	      this.useDefaultVpcCni = defaults.useDefaultVpcCni;
    	      this.userMappings = defaults.userMappings;
    	      this.version = defaults.version;
    	      this.vpcCniOptions = defaults.vpcCniOptions;
    	      this.vpcId = defaults.vpcId;
        }

        public Builder clusterSecurityGroup(@Nullable Output<SecurityGroup> clusterSecurityGroup) {
            this.clusterSecurityGroup = clusterSecurityGroup;
            return this;
        }
        public Builder clusterSecurityGroup(@Nullable SecurityGroup clusterSecurityGroup) {
            this.clusterSecurityGroup = Codegen.ofNullable(clusterSecurityGroup);
            return this;
        }
        public Builder clusterSecurityGroupTags(@Nullable Output<Map<String,String>> clusterSecurityGroupTags) {
            this.clusterSecurityGroupTags = clusterSecurityGroupTags;
            return this;
        }
        public Builder clusterSecurityGroupTags(@Nullable Map<String,String> clusterSecurityGroupTags) {
            this.clusterSecurityGroupTags = Codegen.ofNullable(clusterSecurityGroupTags);
            return this;
        }
        public Builder clusterTags(@Nullable Output<Map<String,String>> clusterTags) {
            this.clusterTags = clusterTags;
            return this;
        }
        public Builder clusterTags(@Nullable Map<String,String> clusterTags) {
            this.clusterTags = Codegen.ofNullable(clusterTags);
            return this;
        }
        public Builder createOidcProvider(@Nullable Output<Boolean> createOidcProvider) {
            this.createOidcProvider = createOidcProvider;
            return this;
        }
        public Builder createOidcProvider(@Nullable Boolean createOidcProvider) {
            this.createOidcProvider = Codegen.ofNullable(createOidcProvider);
            return this;
        }
        public Builder creationRoleProvider(@Nullable Output<CreationRoleProviderArgs> creationRoleProvider) {
            this.creationRoleProvider = creationRoleProvider;
            return this;
        }
        public Builder creationRoleProvider(@Nullable CreationRoleProviderArgs creationRoleProvider) {
            this.creationRoleProvider = Codegen.ofNullable(creationRoleProvider);
            return this;
        }
        public Builder desiredCapacity(@Nullable Output<Integer> desiredCapacity) {
            this.desiredCapacity = desiredCapacity;
            return this;
        }
        public Builder desiredCapacity(@Nullable Integer desiredCapacity) {
            this.desiredCapacity = Codegen.ofNullable(desiredCapacity);
            return this;
        }
        public Builder enabledClusterLogTypes(@Nullable Output<List<String>> enabledClusterLogTypes) {
            this.enabledClusterLogTypes = enabledClusterLogTypes;
            return this;
        }
        public Builder enabledClusterLogTypes(@Nullable List<String> enabledClusterLogTypes) {
            this.enabledClusterLogTypes = Codegen.ofNullable(enabledClusterLogTypes);
            return this;
        }
        public Builder enabledClusterLogTypes(String... enabledClusterLogTypes) {
            return enabledClusterLogTypes(List.of(enabledClusterLogTypes));
        }
        public Builder encryptRootBlockDevice(@Nullable Output<Boolean> encryptRootBlockDevice) {
            this.encryptRootBlockDevice = encryptRootBlockDevice;
            return this;
        }
        public Builder encryptRootBlockDevice(@Nullable Boolean encryptRootBlockDevice) {
            this.encryptRootBlockDevice = Codegen.ofNullable(encryptRootBlockDevice);
            return this;
        }
        public Builder encryptionConfigKeyArn(@Nullable Output<String> encryptionConfigKeyArn) {
            this.encryptionConfigKeyArn = encryptionConfigKeyArn;
            return this;
        }
        public Builder encryptionConfigKeyArn(@Nullable String encryptionConfigKeyArn) {
            this.encryptionConfigKeyArn = Codegen.ofNullable(encryptionConfigKeyArn);
            return this;
        }
        public Builder endpointPrivateAccess(@Nullable Output<Boolean> endpointPrivateAccess) {
            this.endpointPrivateAccess = endpointPrivateAccess;
            return this;
        }
        public Builder endpointPrivateAccess(@Nullable Boolean endpointPrivateAccess) {
            this.endpointPrivateAccess = Codegen.ofNullable(endpointPrivateAccess);
            return this;
        }
        public Builder endpointPublicAccess(@Nullable Output<Boolean> endpointPublicAccess) {
            this.endpointPublicAccess = endpointPublicAccess;
            return this;
        }
        public Builder endpointPublicAccess(@Nullable Boolean endpointPublicAccess) {
            this.endpointPublicAccess = Codegen.ofNullable(endpointPublicAccess);
            return this;
        }
        public Builder fargate(@Nullable Output<Either<Boolean,FargateProfileArgs>> fargate) {
            this.fargate = fargate;
            return this;
        }
        public Builder fargate(@Nullable Either<Boolean,FargateProfileArgs> fargate) {
            this.fargate = Codegen.ofNullable(fargate);
            return this;
        }
        public Builder gpu(@Nullable Output<Boolean> gpu) {
            this.gpu = gpu;
            return this;
        }
        public Builder gpu(@Nullable Boolean gpu) {
            this.gpu = Codegen.ofNullable(gpu);
            return this;
        }
        public Builder instanceProfileName(@Nullable Output<String> instanceProfileName) {
            this.instanceProfileName = instanceProfileName;
            return this;
        }
        public Builder instanceProfileName(@Nullable String instanceProfileName) {
            this.instanceProfileName = Codegen.ofNullable(instanceProfileName);
            return this;
        }
        public Builder instanceRole(@Nullable Output<Role> instanceRole) {
            this.instanceRole = instanceRole;
            return this;
        }
        public Builder instanceRole(@Nullable Role instanceRole) {
            this.instanceRole = Codegen.ofNullable(instanceRole);
            return this;
        }
        public Builder instanceRoles(@Nullable Output<List<Role>> instanceRoles) {
            this.instanceRoles = instanceRoles;
            return this;
        }
        public Builder instanceRoles(@Nullable List<Role> instanceRoles) {
            this.instanceRoles = Codegen.ofNullable(instanceRoles);
            return this;
        }
        public Builder instanceRoles(Role... instanceRoles) {
            return instanceRoles(List.of(instanceRoles));
        }
        public Builder instanceType(@Nullable Output<String> instanceType) {
            this.instanceType = instanceType;
            return this;
        }
        public Builder instanceType(@Nullable String instanceType) {
            this.instanceType = Codegen.ofNullable(instanceType);
            return this;
        }
        public Builder kubernetesServiceIpAddressRange(@Nullable Output<String> kubernetesServiceIpAddressRange) {
            this.kubernetesServiceIpAddressRange = kubernetesServiceIpAddressRange;
            return this;
        }
        public Builder kubernetesServiceIpAddressRange(@Nullable String kubernetesServiceIpAddressRange) {
            this.kubernetesServiceIpAddressRange = Codegen.ofNullable(kubernetesServiceIpAddressRange);
            return this;
        }
        public Builder maxSize(@Nullable Output<Integer> maxSize) {
            this.maxSize = maxSize;
            return this;
        }
        public Builder maxSize(@Nullable Integer maxSize) {
            this.maxSize = Codegen.ofNullable(maxSize);
            return this;
        }
        public Builder minSize(@Nullable Output<Integer> minSize) {
            this.minSize = minSize;
            return this;
        }
        public Builder minSize(@Nullable Integer minSize) {
            this.minSize = Codegen.ofNullable(minSize);
            return this;
        }
        public Builder name(@Nullable Output<String> name) {
            this.name = name;
            return this;
        }
        public Builder name(@Nullable String name) {
            this.name = Codegen.ofNullable(name);
            return this;
        }
        public Builder nodeAmiId(@Nullable Output<String> nodeAmiId) {
            this.nodeAmiId = nodeAmiId;
            return this;
        }
        public Builder nodeAmiId(@Nullable String nodeAmiId) {
            this.nodeAmiId = Codegen.ofNullable(nodeAmiId);
            return this;
        }
        public Builder nodeAssociatePublicIpAddress(@Nullable Output<Boolean> nodeAssociatePublicIpAddress) {
            this.nodeAssociatePublicIpAddress = nodeAssociatePublicIpAddress;
            return this;
        }
        public Builder nodeAssociatePublicIpAddress(@Nullable Boolean nodeAssociatePublicIpAddress) {
            this.nodeAssociatePublicIpAddress = Codegen.ofNullable(nodeAssociatePublicIpAddress);
            return this;
        }
        public Builder nodeGroupOptions(@Nullable Output<ClusterNodeGroupOptionsArgs> nodeGroupOptions) {
            this.nodeGroupOptions = nodeGroupOptions;
            return this;
        }
        public Builder nodeGroupOptions(@Nullable ClusterNodeGroupOptionsArgs nodeGroupOptions) {
            this.nodeGroupOptions = Codegen.ofNullable(nodeGroupOptions);
            return this;
        }
        public Builder nodePublicKey(@Nullable Output<String> nodePublicKey) {
            this.nodePublicKey = nodePublicKey;
            return this;
        }
        public Builder nodePublicKey(@Nullable String nodePublicKey) {
            this.nodePublicKey = Codegen.ofNullable(nodePublicKey);
            return this;
        }
        public Builder nodeRootVolumeDeleteOnTermination(@Nullable Output<Boolean> nodeRootVolumeDeleteOnTermination) {
            this.nodeRootVolumeDeleteOnTermination = nodeRootVolumeDeleteOnTermination;
            return this;
        }
        public Builder nodeRootVolumeDeleteOnTermination(@Nullable Boolean nodeRootVolumeDeleteOnTermination) {
            this.nodeRootVolumeDeleteOnTermination = Codegen.ofNullable(nodeRootVolumeDeleteOnTermination);
            return this;
        }
        public Builder nodeRootVolumeEncrypted(@Nullable Output<Boolean> nodeRootVolumeEncrypted) {
            this.nodeRootVolumeEncrypted = nodeRootVolumeEncrypted;
            return this;
        }
        public Builder nodeRootVolumeEncrypted(@Nullable Boolean nodeRootVolumeEncrypted) {
            this.nodeRootVolumeEncrypted = Codegen.ofNullable(nodeRootVolumeEncrypted);
            return this;
        }
        public Builder nodeRootVolumeIops(@Nullable Output<Integer> nodeRootVolumeIops) {
            this.nodeRootVolumeIops = nodeRootVolumeIops;
            return this;
        }
        public Builder nodeRootVolumeIops(@Nullable Integer nodeRootVolumeIops) {
            this.nodeRootVolumeIops = Codegen.ofNullable(nodeRootVolumeIops);
            return this;
        }
        public Builder nodeRootVolumeSize(@Nullable Output<Integer> nodeRootVolumeSize) {
            this.nodeRootVolumeSize = nodeRootVolumeSize;
            return this;
        }
        public Builder nodeRootVolumeSize(@Nullable Integer nodeRootVolumeSize) {
            this.nodeRootVolumeSize = Codegen.ofNullable(nodeRootVolumeSize);
            return this;
        }
        public Builder nodeRootVolumeThroughput(@Nullable Output<Integer> nodeRootVolumeThroughput) {
            this.nodeRootVolumeThroughput = nodeRootVolumeThroughput;
            return this;
        }
        public Builder nodeRootVolumeThroughput(@Nullable Integer nodeRootVolumeThroughput) {
            this.nodeRootVolumeThroughput = Codegen.ofNullable(nodeRootVolumeThroughput);
            return this;
        }
        public Builder nodeRootVolumeType(@Nullable Output<String> nodeRootVolumeType) {
            this.nodeRootVolumeType = nodeRootVolumeType;
            return this;
        }
        public Builder nodeRootVolumeType(@Nullable String nodeRootVolumeType) {
            this.nodeRootVolumeType = Codegen.ofNullable(nodeRootVolumeType);
            return this;
        }
        public Builder nodeSecurityGroupTags(@Nullable Output<Map<String,String>> nodeSecurityGroupTags) {
            this.nodeSecurityGroupTags = nodeSecurityGroupTags;
            return this;
        }
        public Builder nodeSecurityGroupTags(@Nullable Map<String,String> nodeSecurityGroupTags) {
            this.nodeSecurityGroupTags = Codegen.ofNullable(nodeSecurityGroupTags);
            return this;
        }
        public Builder nodeSubnetIds(@Nullable Output<List<String>> nodeSubnetIds) {
            this.nodeSubnetIds = nodeSubnetIds;
            return this;
        }
        public Builder nodeSubnetIds(@Nullable List<String> nodeSubnetIds) {
            this.nodeSubnetIds = Codegen.ofNullable(nodeSubnetIds);
            return this;
        }
        public Builder nodeSubnetIds(String... nodeSubnetIds) {
            return nodeSubnetIds(List.of(nodeSubnetIds));
        }
        public Builder nodeUserData(@Nullable Output<String> nodeUserData) {
            this.nodeUserData = nodeUserData;
            return this;
        }
        public Builder nodeUserData(@Nullable String nodeUserData) {
            this.nodeUserData = Codegen.ofNullable(nodeUserData);
            return this;
        }
        public Builder privateSubnetIds(@Nullable Output<List<String>> privateSubnetIds) {
            this.privateSubnetIds = privateSubnetIds;
            return this;
        }
        public Builder privateSubnetIds(@Nullable List<String> privateSubnetIds) {
            this.privateSubnetIds = Codegen.ofNullable(privateSubnetIds);
            return this;
        }
        public Builder privateSubnetIds(String... privateSubnetIds) {
            return privateSubnetIds(List.of(privateSubnetIds));
        }
        public Builder providerCredentialOpts(@Nullable Output<KubeconfigOptionsArgs> providerCredentialOpts) {
            this.providerCredentialOpts = providerCredentialOpts;
            return this;
        }
        public Builder providerCredentialOpts(@Nullable KubeconfigOptionsArgs providerCredentialOpts) {
            this.providerCredentialOpts = Codegen.ofNullable(providerCredentialOpts);
            return this;
        }
        public Builder proxy(@Nullable Output<String> proxy) {
            this.proxy = proxy;
            return this;
        }
        public Builder proxy(@Nullable String proxy) {
            this.proxy = Codegen.ofNullable(proxy);
            return this;
        }
        public Builder publicAccessCidrs(@Nullable Output<List<String>> publicAccessCidrs) {
            this.publicAccessCidrs = publicAccessCidrs;
            return this;
        }
        public Builder publicAccessCidrs(@Nullable List<String> publicAccessCidrs) {
            this.publicAccessCidrs = Codegen.ofNullable(publicAccessCidrs);
            return this;
        }
        public Builder publicAccessCidrs(String... publicAccessCidrs) {
            return publicAccessCidrs(List.of(publicAccessCidrs));
        }
        public Builder publicSubnetIds(@Nullable Output<List<String>> publicSubnetIds) {
            this.publicSubnetIds = publicSubnetIds;
            return this;
        }
        public Builder publicSubnetIds(@Nullable List<String> publicSubnetIds) {
            this.publicSubnetIds = Codegen.ofNullable(publicSubnetIds);
            return this;
        }
        public Builder publicSubnetIds(String... publicSubnetIds) {
            return publicSubnetIds(List.of(publicSubnetIds));
        }
        public Builder roleMappings(@Nullable Output<List<RoleMappingArgs>> roleMappings) {
            this.roleMappings = roleMappings;
            return this;
        }
        public Builder roleMappings(@Nullable List<RoleMappingArgs> roleMappings) {
            this.roleMappings = Codegen.ofNullable(roleMappings);
            return this;
        }
        public Builder roleMappings(RoleMappingArgs... roleMappings) {
            return roleMappings(List.of(roleMappings));
        }
        public Builder serviceRole(@Nullable Output<Role> serviceRole) {
            this.serviceRole = serviceRole;
            return this;
        }
        public Builder serviceRole(@Nullable Role serviceRole) {
            this.serviceRole = Codegen.ofNullable(serviceRole);
            return this;
        }
        public Builder skipDefaultNodeGroup(@Nullable Output<Boolean> skipDefaultNodeGroup) {
            this.skipDefaultNodeGroup = skipDefaultNodeGroup;
            return this;
        }
        public Builder skipDefaultNodeGroup(@Nullable Boolean skipDefaultNodeGroup) {
            this.skipDefaultNodeGroup = Codegen.ofNullable(skipDefaultNodeGroup);
            return this;
        }
        public Builder storageClasses(@Nullable Output<Either<String,Map<String,StorageClassArgs>>> storageClasses) {
            this.storageClasses = storageClasses;
            return this;
        }
        public Builder storageClasses(@Nullable Either<String,Map<String,StorageClassArgs>> storageClasses) {
            this.storageClasses = Codegen.ofNullable(storageClasses);
            return this;
        }
        public Builder subnetIds(@Nullable Output<List<String>> subnetIds) {
            this.subnetIds = subnetIds;
            return this;
        }
        public Builder subnetIds(@Nullable List<String> subnetIds) {
            this.subnetIds = Codegen.ofNullable(subnetIds);
            return this;
        }
        public Builder subnetIds(String... subnetIds) {
            return subnetIds(List.of(subnetIds));
        }
        public Builder tags(@Nullable Output<Map<String,String>> tags) {
            this.tags = tags;
            return this;
        }
        public Builder tags(@Nullable Map<String,String> tags) {
            this.tags = Codegen.ofNullable(tags);
            return this;
        }
        public Builder useDefaultVpcCni(@Nullable Output<Boolean> useDefaultVpcCni) {
            this.useDefaultVpcCni = useDefaultVpcCni;
            return this;
        }
        public Builder useDefaultVpcCni(@Nullable Boolean useDefaultVpcCni) {
            this.useDefaultVpcCni = Codegen.ofNullable(useDefaultVpcCni);
            return this;
        }
        public Builder userMappings(@Nullable Output<List<UserMappingArgs>> userMappings) {
            this.userMappings = userMappings;
            return this;
        }
        public Builder userMappings(@Nullable List<UserMappingArgs> userMappings) {
            this.userMappings = Codegen.ofNullable(userMappings);
            return this;
        }
        public Builder userMappings(UserMappingArgs... userMappings) {
            return userMappings(List.of(userMappings));
        }
        public Builder version(@Nullable Output<String> version) {
            this.version = version;
            return this;
        }
        public Builder version(@Nullable String version) {
            this.version = Codegen.ofNullable(version);
            return this;
        }
        public Builder vpcCniOptions(@Nullable Output<VpcCniOptionsArgs> vpcCniOptions) {
            this.vpcCniOptions = vpcCniOptions;
            return this;
        }
        public Builder vpcCniOptions(@Nullable VpcCniOptionsArgs vpcCniOptions) {
            this.vpcCniOptions = Codegen.ofNullable(vpcCniOptions);
            return this;
        }
        public Builder vpcId(@Nullable Output<String> vpcId) {
            this.vpcId = vpcId;
            return this;
        }
        public Builder vpcId(@Nullable String vpcId) {
            this.vpcId = Codegen.ofNullable(vpcId);
            return this;
        }        public ClusterArgs build() {
            return new ClusterArgs(clusterSecurityGroup, clusterSecurityGroupTags, clusterTags, createOidcProvider, creationRoleProvider, desiredCapacity, enabledClusterLogTypes, encryptRootBlockDevice, encryptionConfigKeyArn, endpointPrivateAccess, endpointPublicAccess, fargate, gpu, instanceProfileName, instanceRole, instanceRoles, instanceType, kubernetesServiceIpAddressRange, maxSize, minSize, name, nodeAmiId, nodeAssociatePublicIpAddress, nodeGroupOptions, nodePublicKey, nodeRootVolumeDeleteOnTermination, nodeRootVolumeEncrypted, nodeRootVolumeIops, nodeRootVolumeSize, nodeRootVolumeThroughput, nodeRootVolumeType, nodeSecurityGroupTags, nodeSubnetIds, nodeUserData, privateSubnetIds, providerCredentialOpts, proxy, publicAccessCidrs, publicSubnetIds, roleMappings, serviceRole, skipDefaultNodeGroup, storageClasses, subnetIds, tags, useDefaultVpcCni, userMappings, version, vpcCniOptions, vpcId);
        }
    }
}
