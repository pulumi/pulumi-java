// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.eks;

import com.pulumi.aws.ec2.SecurityGroup;
import com.pulumi.aws.ec2.SecurityGroupRule;
import com.pulumi.aws.iam.InstanceProfile;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.eks.inputs.CoreDataArgs;
import com.pulumi.eks.inputs.TaintArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class NodeGroupArgs extends com.pulumi.resources.ResourceArgs {

    public static final NodeGroupArgs Empty = new NodeGroupArgs();

    /**
     * The AMI ID to use for the worker nodes.
     * 
     * Defaults to the latest recommended EKS Optimized Linux AMI from the AWS Systems Manager Parameter Store.
     * 
     * Note: `amiId` and `gpu` are mutually exclusive.
     * 
     * See for more details:
     * - https://docs.aws.amazon.com/eks/latest/userguide/eks-optimized-ami.html.
     * 
     */
    @Import(name="amiId")
    private @Nullable Output<String> amiId;

    public Optional<Output<String>> amiId() {
        return Optional.ofNullable(this.amiId);
    }

    /**
     * The tags to apply to the NodeGroup&#39;s AutoScalingGroup in the CloudFormation Stack.
     * 
     * Per AWS, all stack-level tags, including automatically created tags, and the `cloudFormationTags` option are propagated to resources that AWS CloudFormation supports, including the AutoScalingGroup. See https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html
     * 
     * Note: Given the inheritance of auto-generated CF tags and `cloudFormationTags`, you should either supply the tag in `autoScalingGroupTags` or `cloudFormationTags`, but not both.
     * 
     */
    @Import(name="autoScalingGroupTags")
    private @Nullable Output<Map<String,String>> autoScalingGroupTags;

    public Optional<Output<Map<String,String>>> autoScalingGroupTags() {
        return Optional.ofNullable(this.autoScalingGroupTags);
    }

    /**
     * Additional args to pass directly to `/etc/eks/bootstrap.sh`. For details on available options, see: https://github.com/awslabs/amazon-eks-ami/blob/master/files/bootstrap.sh. Note that the `--apiserver-endpoint`, `--b64-cluster-ca` and `--kubelet-extra-args` flags are included automatically based on other configuration parameters.
     * 
     */
    @Import(name="bootstrapExtraArgs")
    private @Nullable Output<String> bootstrapExtraArgs;

    public Optional<Output<String>> bootstrapExtraArgs() {
        return Optional.ofNullable(this.bootstrapExtraArgs);
    }

    /**
     * The tags to apply to the CloudFormation Stack of the Worker NodeGroup.
     * 
     * Note: Given the inheritance of auto-generated CF tags and `cloudFormationTags`, you should either supply the tag in `autoScalingGroupTags` or `cloudFormationTags`, but not both.
     * 
     */
    @Import(name="cloudFormationTags")
    private @Nullable Output<Map<String,String>> cloudFormationTags;

    public Optional<Output<Map<String,String>>> cloudFormationTags() {
        return Optional.ofNullable(this.cloudFormationTags);
    }

    /**
     * The target EKS cluster.
     * 
     */
    @Import(name="cluster", required=true)
    private Output<CoreDataArgs> cluster;

    public Output<CoreDataArgs> cluster() {
        return this.cluster;
    }

    /**
     * The ingress rule that gives node group access.
     * 
     */
    @Import(name="clusterIngressRule")
    private @Nullable Output<SecurityGroupRule> clusterIngressRule;

    public Optional<Output<SecurityGroupRule>> clusterIngressRule() {
        return Optional.ofNullable(this.clusterIngressRule);
    }

    /**
     * The number of worker nodes that should be running in the cluster. Defaults to 2.
     * 
     */
    @Import(name="desiredCapacity")
    private @Nullable Output<Integer> desiredCapacity;

    public Optional<Output<Integer>> desiredCapacity() {
        return Optional.ofNullable(this.desiredCapacity);
    }

    /**
     * Encrypt the root block device of the nodes in the node group.
     * 
     */
    @Import(name="encryptRootBlockDevice")
    private @Nullable Output<Boolean> encryptRootBlockDevice;

    public Optional<Output<Boolean>> encryptRootBlockDevice() {
        return Optional.ofNullable(this.encryptRootBlockDevice);
    }

    /**
     * Extra security groups to attach on all nodes in this worker node group.
     * 
     * This additional set of security groups captures any user application rules that will be needed for the nodes.
     * 
     */
    @Import(name="extraNodeSecurityGroups")
    private @Nullable Output<List<SecurityGroup>> extraNodeSecurityGroups;

    public Optional<Output<List<SecurityGroup>>> extraNodeSecurityGroups() {
        return Optional.ofNullable(this.extraNodeSecurityGroups);
    }

    /**
     * Use the latest recommended EKS Optimized Linux AMI with GPU support for the worker nodes from the AWS Systems Manager Parameter Store.
     * 
     * Defaults to false.
     * 
     * Note: `gpu` and `amiId` are mutually exclusive.
     * 
     * See for more details:
     * - https://docs.aws.amazon.com/eks/latest/userguide/eks-optimized-ami.html
     * - https://docs.aws.amazon.com/eks/latest/userguide/retrieve-ami-id.html
     * 
     */
    @Import(name="gpu")
    private @Nullable Output<Boolean> gpu;

    public Optional<Output<Boolean>> gpu() {
        return Optional.ofNullable(this.gpu);
    }

    /**
     * The ingress rule that gives node group access.
     * 
     */
    @Import(name="instanceProfile")
    private @Nullable Output<InstanceProfile> instanceProfile;

    public Optional<Output<InstanceProfile>> instanceProfile() {
        return Optional.ofNullable(this.instanceProfile);
    }

    /**
     * The instance type to use for the cluster&#39;s nodes. Defaults to &#34;t2.medium&#34;.
     * 
     */
    @Import(name="instanceType")
    private @Nullable Output<String> instanceType;

    public Optional<Output<String>> instanceType() {
        return Optional.ofNullable(this.instanceType);
    }

    /**
     * Name of the key pair to use for SSH access to worker nodes.
     * 
     */
    @Import(name="keyName")
    private @Nullable Output<String> keyName;

    public Optional<Output<String>> keyName() {
        return Optional.ofNullable(this.keyName);
    }

    /**
     * Extra args to pass to the Kubelet. Corresponds to the options passed in the `--kubeletExtraArgs` flag to `/etc/eks/bootstrap.sh`. For example, &#39;--port=10251 --address=0.0.0.0&#39;. Note that the `labels` and `taints` properties will be applied to this list (using `--node-labels` and `--register-with-taints` respectively) after to the explicit `kubeletExtraArgs`.
     * 
     */
    @Import(name="kubeletExtraArgs")
    private @Nullable Output<String> kubeletExtraArgs;

    public Optional<Output<String>> kubeletExtraArgs() {
        return Optional.ofNullable(this.kubeletExtraArgs);
    }

    /**
     * Custom k8s node labels to be attached to each worker node. Adds the given key/value pairs to the `--node-labels` kubelet argument.
     * 
     */
    @Import(name="labels")
    private @Nullable Output<Map<String,String>> labels;

    public Optional<Output<Map<String,String>>> labels() {
        return Optional.ofNullable(this.labels);
    }

    /**
     * The maximum number of worker nodes running in the cluster. Defaults to 2.
     * 
     */
    @Import(name="maxSize")
    private @Nullable Output<Integer> maxSize;

    public Optional<Output<Integer>> maxSize() {
        return Optional.ofNullable(this.maxSize);
    }

    /**
     * The minimum number of worker nodes running in the cluster. Defaults to 1.
     * 
     */
    @Import(name="minSize")
    private @Nullable Output<Integer> minSize;

    public Optional<Output<Integer>> minSize() {
        return Optional.ofNullable(this.minSize);
    }

    /**
     * Whether or not to auto-assign public IP addresses on the EKS worker nodes. If this toggle is set to true, the EKS workers will be auto-assigned public IPs. If false, they will not be auto-assigned public IPs.
     * 
     */
    @Import(name="nodeAssociatePublicIpAddress")
    private @Nullable Output<Boolean> nodeAssociatePublicIpAddress;

    public Optional<Output<Boolean>> nodeAssociatePublicIpAddress() {
        return Optional.ofNullable(this.nodeAssociatePublicIpAddress);
    }

    /**
     * Public key material for SSH access to worker nodes. See allowed formats at:
     * https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html
     * If not provided, no SSH access is enabled on VMs.
     * 
     */
    @Import(name="nodePublicKey")
    private @Nullable Output<String> nodePublicKey;

    public Optional<Output<String>> nodePublicKey() {
        return Optional.ofNullable(this.nodePublicKey);
    }

    /**
     * The size in GiB of a cluster node&#39;s root volume. Defaults to 20.
     * 
     */
    @Import(name="nodeRootVolumeSize")
    private @Nullable Output<Integer> nodeRootVolumeSize;

    public Optional<Output<Integer>> nodeRootVolumeSize() {
        return Optional.ofNullable(this.nodeRootVolumeSize);
    }

    /**
     * The security group for the worker node group to communicate with the cluster.
     * 
     * This security group requires specific inbound and outbound rules.
     * 
     * See for more details:
     * https://docs.aws.amazon.com/eks/latest/userguide/sec-group-reqs.html
     * 
     * Note: The `nodeSecurityGroup` option and the cluster option`nodeSecurityGroupTags` are mutually exclusive.
     * 
     */
    @Import(name="nodeSecurityGroup")
    private @Nullable Output<SecurityGroup> nodeSecurityGroup;

    public Optional<Output<SecurityGroup>> nodeSecurityGroup() {
        return Optional.ofNullable(this.nodeSecurityGroup);
    }

    /**
     * The set of subnets to override and use for the worker node group.
     * 
     * Setting this option overrides which subnets to use for the worker node group, regardless if the cluster&#39;s `subnetIds` is set, or if `publicSubnetIds` and/or `privateSubnetIds` were set.
     * 
     */
    @Import(name="nodeSubnetIds")
    private @Nullable Output<List<String>> nodeSubnetIds;

    public Optional<Output<List<String>>> nodeSubnetIds() {
        return Optional.ofNullable(this.nodeSubnetIds);
    }

    /**
     * Extra code to run on node startup. This code will run after the AWS EKS bootstrapping code and before the node signals its readiness to the managing CloudFormation stack. This code must be a typical user data script: critically it must begin with an interpreter directive (i.e. a `#!`).
     * 
     */
    @Import(name="nodeUserData")
    private @Nullable Output<String> nodeUserData;

    public Optional<Output<String>> nodeUserData() {
        return Optional.ofNullable(this.nodeUserData);
    }

    /**
     * User specified code to run on node startup. This code is expected to handle the full AWS EKS bootstrapping code and signal node readiness to the managing CloudFormation stack. This code must be a complete and executable user data script in bash (Linux) or powershell (Windows).
     * 
     * See for more details: https://docs.aws.amazon.com/eks/latest/userguide/worker.html
     * 
     */
    @Import(name="nodeUserDataOverride")
    private @Nullable Output<String> nodeUserDataOverride;

    public Optional<Output<String>> nodeUserDataOverride() {
        return Optional.ofNullable(this.nodeUserDataOverride);
    }

    /**
     * Bidding price for spot instance. If set, only spot instances will be added as worker node.
     * 
     */
    @Import(name="spotPrice")
    private @Nullable Output<String> spotPrice;

    public Optional<Output<String>> spotPrice() {
        return Optional.ofNullable(this.spotPrice);
    }

    /**
     * Custom k8s node taints to be attached to each worker node. Adds the given taints to the `--register-with-taints` kubelet argument
     * 
     */
    @Import(name="taints")
    private @Nullable Output<Map<String,TaintArgs>> taints;

    public Optional<Output<Map<String,TaintArgs>>> taints() {
        return Optional.ofNullable(this.taints);
    }

    /**
     * Desired Kubernetes master / control plane version. If you do not specify a value, the latest available version is used.
     * 
     */
    @Import(name="version")
    private @Nullable Output<String> version;

    public Optional<Output<String>> version() {
        return Optional.ofNullable(this.version);
    }

    private NodeGroupArgs() {}

    private NodeGroupArgs(NodeGroupArgs $) {
        this.amiId = $.amiId;
        this.autoScalingGroupTags = $.autoScalingGroupTags;
        this.bootstrapExtraArgs = $.bootstrapExtraArgs;
        this.cloudFormationTags = $.cloudFormationTags;
        this.cluster = $.cluster;
        this.clusterIngressRule = $.clusterIngressRule;
        this.desiredCapacity = $.desiredCapacity;
        this.encryptRootBlockDevice = $.encryptRootBlockDevice;
        this.extraNodeSecurityGroups = $.extraNodeSecurityGroups;
        this.gpu = $.gpu;
        this.instanceProfile = $.instanceProfile;
        this.instanceType = $.instanceType;
        this.keyName = $.keyName;
        this.kubeletExtraArgs = $.kubeletExtraArgs;
        this.labels = $.labels;
        this.maxSize = $.maxSize;
        this.minSize = $.minSize;
        this.nodeAssociatePublicIpAddress = $.nodeAssociatePublicIpAddress;
        this.nodePublicKey = $.nodePublicKey;
        this.nodeRootVolumeSize = $.nodeRootVolumeSize;
        this.nodeSecurityGroup = $.nodeSecurityGroup;
        this.nodeSubnetIds = $.nodeSubnetIds;
        this.nodeUserData = $.nodeUserData;
        this.nodeUserDataOverride = $.nodeUserDataOverride;
        this.spotPrice = $.spotPrice;
        this.taints = $.taints;
        this.version = $.version;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(NodeGroupArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private NodeGroupArgs $;

        public Builder() {
            $ = new NodeGroupArgs();
        }

        public Builder(NodeGroupArgs defaults) {
            $ = new NodeGroupArgs(Objects.requireNonNull(defaults));
        }

        public Builder amiId(@Nullable Output<String> amiId) {
            $.amiId = amiId;
            return this;
        }

        public Builder amiId(String amiId) {
            return amiId(Output.of(amiId));
        }

        public Builder autoScalingGroupTags(@Nullable Output<Map<String,String>> autoScalingGroupTags) {
            $.autoScalingGroupTags = autoScalingGroupTags;
            return this;
        }

        public Builder autoScalingGroupTags(Map<String,String> autoScalingGroupTags) {
            return autoScalingGroupTags(Output.of(autoScalingGroupTags));
        }

        public Builder bootstrapExtraArgs(@Nullable Output<String> bootstrapExtraArgs) {
            $.bootstrapExtraArgs = bootstrapExtraArgs;
            return this;
        }

        public Builder bootstrapExtraArgs(String bootstrapExtraArgs) {
            return bootstrapExtraArgs(Output.of(bootstrapExtraArgs));
        }

        public Builder cloudFormationTags(@Nullable Output<Map<String,String>> cloudFormationTags) {
            $.cloudFormationTags = cloudFormationTags;
            return this;
        }

        public Builder cloudFormationTags(Map<String,String> cloudFormationTags) {
            return cloudFormationTags(Output.of(cloudFormationTags));
        }

        public Builder cluster(Output<CoreDataArgs> cluster) {
            $.cluster = cluster;
            return this;
        }

        public Builder cluster(CoreDataArgs cluster) {
            return cluster(Output.of(cluster));
        }

        public Builder clusterIngressRule(@Nullable Output<SecurityGroupRule> clusterIngressRule) {
            $.clusterIngressRule = clusterIngressRule;
            return this;
        }

        public Builder clusterIngressRule(SecurityGroupRule clusterIngressRule) {
            return clusterIngressRule(Output.of(clusterIngressRule));
        }

        public Builder desiredCapacity(@Nullable Output<Integer> desiredCapacity) {
            $.desiredCapacity = desiredCapacity;
            return this;
        }

        public Builder desiredCapacity(Integer desiredCapacity) {
            return desiredCapacity(Output.of(desiredCapacity));
        }

        public Builder encryptRootBlockDevice(@Nullable Output<Boolean> encryptRootBlockDevice) {
            $.encryptRootBlockDevice = encryptRootBlockDevice;
            return this;
        }

        public Builder encryptRootBlockDevice(Boolean encryptRootBlockDevice) {
            return encryptRootBlockDevice(Output.of(encryptRootBlockDevice));
        }

        public Builder extraNodeSecurityGroups(@Nullable Output<List<SecurityGroup>> extraNodeSecurityGroups) {
            $.extraNodeSecurityGroups = extraNodeSecurityGroups;
            return this;
        }

        public Builder extraNodeSecurityGroups(List<SecurityGroup> extraNodeSecurityGroups) {
            return extraNodeSecurityGroups(Output.of(extraNodeSecurityGroups));
        }

        public Builder extraNodeSecurityGroups(SecurityGroup... extraNodeSecurityGroups) {
            return extraNodeSecurityGroups(List.of(extraNodeSecurityGroups));
        }

        public Builder gpu(@Nullable Output<Boolean> gpu) {
            $.gpu = gpu;
            return this;
        }

        public Builder gpu(Boolean gpu) {
            return gpu(Output.of(gpu));
        }

        public Builder instanceProfile(@Nullable Output<InstanceProfile> instanceProfile) {
            $.instanceProfile = instanceProfile;
            return this;
        }

        public Builder instanceProfile(InstanceProfile instanceProfile) {
            return instanceProfile(Output.of(instanceProfile));
        }

        public Builder instanceType(@Nullable Output<String> instanceType) {
            $.instanceType = instanceType;
            return this;
        }

        public Builder instanceType(String instanceType) {
            return instanceType(Output.of(instanceType));
        }

        public Builder keyName(@Nullable Output<String> keyName) {
            $.keyName = keyName;
            return this;
        }

        public Builder keyName(String keyName) {
            return keyName(Output.of(keyName));
        }

        public Builder kubeletExtraArgs(@Nullable Output<String> kubeletExtraArgs) {
            $.kubeletExtraArgs = kubeletExtraArgs;
            return this;
        }

        public Builder kubeletExtraArgs(String kubeletExtraArgs) {
            return kubeletExtraArgs(Output.of(kubeletExtraArgs));
        }

        public Builder labels(@Nullable Output<Map<String,String>> labels) {
            $.labels = labels;
            return this;
        }

        public Builder labels(Map<String,String> labels) {
            return labels(Output.of(labels));
        }

        public Builder maxSize(@Nullable Output<Integer> maxSize) {
            $.maxSize = maxSize;
            return this;
        }

        public Builder maxSize(Integer maxSize) {
            return maxSize(Output.of(maxSize));
        }

        public Builder minSize(@Nullable Output<Integer> minSize) {
            $.minSize = minSize;
            return this;
        }

        public Builder minSize(Integer minSize) {
            return minSize(Output.of(minSize));
        }

        public Builder nodeAssociatePublicIpAddress(@Nullable Output<Boolean> nodeAssociatePublicIpAddress) {
            $.nodeAssociatePublicIpAddress = nodeAssociatePublicIpAddress;
            return this;
        }

        public Builder nodeAssociatePublicIpAddress(Boolean nodeAssociatePublicIpAddress) {
            return nodeAssociatePublicIpAddress(Output.of(nodeAssociatePublicIpAddress));
        }

        public Builder nodePublicKey(@Nullable Output<String> nodePublicKey) {
            $.nodePublicKey = nodePublicKey;
            return this;
        }

        public Builder nodePublicKey(String nodePublicKey) {
            return nodePublicKey(Output.of(nodePublicKey));
        }

        public Builder nodeRootVolumeSize(@Nullable Output<Integer> nodeRootVolumeSize) {
            $.nodeRootVolumeSize = nodeRootVolumeSize;
            return this;
        }

        public Builder nodeRootVolumeSize(Integer nodeRootVolumeSize) {
            return nodeRootVolumeSize(Output.of(nodeRootVolumeSize));
        }

        public Builder nodeSecurityGroup(@Nullable Output<SecurityGroup> nodeSecurityGroup) {
            $.nodeSecurityGroup = nodeSecurityGroup;
            return this;
        }

        public Builder nodeSecurityGroup(SecurityGroup nodeSecurityGroup) {
            return nodeSecurityGroup(Output.of(nodeSecurityGroup));
        }

        public Builder nodeSubnetIds(@Nullable Output<List<String>> nodeSubnetIds) {
            $.nodeSubnetIds = nodeSubnetIds;
            return this;
        }

        public Builder nodeSubnetIds(List<String> nodeSubnetIds) {
            return nodeSubnetIds(Output.of(nodeSubnetIds));
        }

        public Builder nodeSubnetIds(String... nodeSubnetIds) {
            return nodeSubnetIds(List.of(nodeSubnetIds));
        }

        public Builder nodeUserData(@Nullable Output<String> nodeUserData) {
            $.nodeUserData = nodeUserData;
            return this;
        }

        public Builder nodeUserData(String nodeUserData) {
            return nodeUserData(Output.of(nodeUserData));
        }

        public Builder nodeUserDataOverride(@Nullable Output<String> nodeUserDataOverride) {
            $.nodeUserDataOverride = nodeUserDataOverride;
            return this;
        }

        public Builder nodeUserDataOverride(String nodeUserDataOverride) {
            return nodeUserDataOverride(Output.of(nodeUserDataOverride));
        }

        public Builder spotPrice(@Nullable Output<String> spotPrice) {
            $.spotPrice = spotPrice;
            return this;
        }

        public Builder spotPrice(String spotPrice) {
            return spotPrice(Output.of(spotPrice));
        }

        public Builder taints(@Nullable Output<Map<String,TaintArgs>> taints) {
            $.taints = taints;
            return this;
        }

        public Builder taints(Map<String,TaintArgs> taints) {
            return taints(Output.of(taints));
        }

        public Builder version(@Nullable Output<String> version) {
            $.version = version;
            return this;
        }

        public Builder version(String version) {
            return version(Output.of(version));
        }

        public NodeGroupArgs build() {
            $.cluster = Objects.requireNonNull($.cluster, "expected parameter 'cluster' to be non-null");
            return $;
        }
    }

}
