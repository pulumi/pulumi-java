// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.compute.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class VPNTunnelState extends com.pulumi.resources.ResourceArgs {

    public static final VPNTunnelState Empty = new VPNTunnelState();

    /**
     * Creation timestamp in RFC3339 text format.
     * 
     */
    @Import(name="creationTimestamp")
    private @Nullable Output<String> creationTimestamp;

    public Optional<Output<String>> creationTimestamp() {
        return Optional.ofNullable(this.creationTimestamp);
    }

    /**
     * An optional description of this resource.
     * 
     */
    @Import(name="description")
    private @Nullable Output<String> description;

    public Optional<Output<String>> description() {
        return Optional.ofNullable(this.description);
    }

    /**
     * Detailed status message for the VPN tunnel.
     * 
     */
    @Import(name="detailedStatus")
    private @Nullable Output<String> detailedStatus;

    public Optional<Output<String>> detailedStatus() {
        return Optional.ofNullable(this.detailedStatus);
    }

    /**
     * IKE protocol version to use when establishing the VPN tunnel with
     * peer VPN gateway.
     * Acceptable IKE versions are 1 or 2. Default version is 2.
     * 
     */
    @Import(name="ikeVersion")
    private @Nullable Output<Integer> ikeVersion;

    public Optional<Output<Integer>> ikeVersion() {
        return Optional.ofNullable(this.ikeVersion);
    }

    /**
     * The fingerprint used for optimistic locking of this resource. Used internally during updates.
     * 
     */
    @Import(name="labelFingerprint")
    private @Nullable Output<String> labelFingerprint;

    public Optional<Output<String>> labelFingerprint() {
        return Optional.ofNullable(this.labelFingerprint);
    }

    /**
     * Labels to apply to this VpnTunnel.
     * 
     */
    @Import(name="labels")
    private @Nullable Output<Map<String,String>> labels;

    public Optional<Output<Map<String,String>>> labels() {
        return Optional.ofNullable(this.labels);
    }

    /**
     * Local traffic selector to use when establishing the VPN tunnel with
     * peer VPN gateway. The value should be a CIDR formatted string,
     * for example `192.168.0.0/16`. The ranges should be disjoint.
     * Only IPv4 is supported.
     * 
     */
    @Import(name="localTrafficSelectors")
    private @Nullable Output<List<String>> localTrafficSelectors;

    public Optional<Output<List<String>>> localTrafficSelectors() {
        return Optional.ofNullable(this.localTrafficSelectors);
    }

    /**
     * Name of the resource. The name must be 1-63 characters long, and
     * comply with RFC1035. Specifically, the name must be 1-63
     * characters long and match the regular expression
     * `a-z?` which means the first character
     * must be a lowercase letter, and all following characters must
     * be a dash, lowercase letter, or digit,
     * except the last character, which cannot be a dash.
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * URL of the peer side external VPN gateway to which this VPN tunnel is connected.
     * 
     */
    @Import(name="peerExternalGateway")
    private @Nullable Output<String> peerExternalGateway;

    public Optional<Output<String>> peerExternalGateway() {
        return Optional.ofNullable(this.peerExternalGateway);
    }

    /**
     * The interface ID of the external VPN gateway to which this VPN tunnel is connected.
     * 
     */
    @Import(name="peerExternalGatewayInterface")
    private @Nullable Output<Integer> peerExternalGatewayInterface;

    public Optional<Output<Integer>> peerExternalGatewayInterface() {
        return Optional.ofNullable(this.peerExternalGatewayInterface);
    }

    /**
     * URL of the peer side HA GCP VPN gateway to which this VPN tunnel is connected.
     * If provided, the VPN tunnel will automatically use the same vpn_gateway_interface
     * ID in the peer GCP VPN gateway.
     * This field must reference a `gcp.compute.HaVpnGateway` resource.
     * 
     */
    @Import(name="peerGcpGateway")
    private @Nullable Output<String> peerGcpGateway;

    public Optional<Output<String>> peerGcpGateway() {
        return Optional.ofNullable(this.peerGcpGateway);
    }

    /**
     * IP address of the peer VPN gateway. Only IPv4 is supported.
     * 
     */
    @Import(name="peerIp")
    private @Nullable Output<String> peerIp;

    public Optional<Output<String>> peerIp() {
        return Optional.ofNullable(this.peerIp);
    }

    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    @Import(name="project")
    private @Nullable Output<String> project;

    public Optional<Output<String>> project() {
        return Optional.ofNullable(this.project);
    }

    /**
     * The region where the tunnel is located. If unset, is set to the region of `target_vpn_gateway`.
     * 
     */
    @Import(name="region")
    private @Nullable Output<String> region;

    public Optional<Output<String>> region() {
        return Optional.ofNullable(this.region);
    }

    /**
     * Remote traffic selector to use when establishing the VPN tunnel with
     * peer VPN gateway. The value should be a CIDR formatted string,
     * for example `192.168.0.0/16`. The ranges should be disjoint.
     * Only IPv4 is supported.
     * 
     */
    @Import(name="remoteTrafficSelectors")
    private @Nullable Output<List<String>> remoteTrafficSelectors;

    public Optional<Output<List<String>>> remoteTrafficSelectors() {
        return Optional.ofNullable(this.remoteTrafficSelectors);
    }

    /**
     * URL of router resource to be used for dynamic routing.
     * 
     */
    @Import(name="router")
    private @Nullable Output<String> router;

    public Optional<Output<String>> router() {
        return Optional.ofNullable(this.router);
    }

    /**
     * The URI of the created resource.
     * 
     */
    @Import(name="selfLink")
    private @Nullable Output<String> selfLink;

    public Optional<Output<String>> selfLink() {
        return Optional.ofNullable(this.selfLink);
    }

    /**
     * Shared secret used to set the secure session between the Cloud VPN
     * gateway and the peer VPN gateway.
     * **Note**: This property is sensitive and will not be displayed in the plan.
     * 
     */
    @Import(name="sharedSecret")
    private @Nullable Output<String> sharedSecret;

    public Optional<Output<String>> sharedSecret() {
        return Optional.ofNullable(this.sharedSecret);
    }

    /**
     * Hash of the shared secret.
     * 
     */
    @Import(name="sharedSecretHash")
    private @Nullable Output<String> sharedSecretHash;

    public Optional<Output<String>> sharedSecretHash() {
        return Optional.ofNullable(this.sharedSecretHash);
    }

    /**
     * URL of the Target VPN gateway with which this VPN tunnel is
     * associated.
     * 
     */
    @Import(name="targetVpnGateway")
    private @Nullable Output<String> targetVpnGateway;

    public Optional<Output<String>> targetVpnGateway() {
        return Optional.ofNullable(this.targetVpnGateway);
    }

    /**
     * The unique identifier for the resource. This identifier is defined by the server.
     * 
     */
    @Import(name="tunnelId")
    private @Nullable Output<String> tunnelId;

    public Optional<Output<String>> tunnelId() {
        return Optional.ofNullable(this.tunnelId);
    }

    /**
     * URL of the VPN gateway with which this VPN tunnel is associated.
     * This must be used if a High Availability VPN gateway resource is created.
     * This field must reference a `gcp.compute.HaVpnGateway` resource.
     * 
     */
    @Import(name="vpnGateway")
    private @Nullable Output<String> vpnGateway;

    public Optional<Output<String>> vpnGateway() {
        return Optional.ofNullable(this.vpnGateway);
    }

    /**
     * The interface ID of the VPN gateway with which this VPN tunnel is associated.
     * 
     */
    @Import(name="vpnGatewayInterface")
    private @Nullable Output<Integer> vpnGatewayInterface;

    public Optional<Output<Integer>> vpnGatewayInterface() {
        return Optional.ofNullable(this.vpnGatewayInterface);
    }

    private VPNTunnelState() {}

    private VPNTunnelState(VPNTunnelState $) {
        this.creationTimestamp = $.creationTimestamp;
        this.description = $.description;
        this.detailedStatus = $.detailedStatus;
        this.ikeVersion = $.ikeVersion;
        this.labelFingerprint = $.labelFingerprint;
        this.labels = $.labels;
        this.localTrafficSelectors = $.localTrafficSelectors;
        this.name = $.name;
        this.peerExternalGateway = $.peerExternalGateway;
        this.peerExternalGatewayInterface = $.peerExternalGatewayInterface;
        this.peerGcpGateway = $.peerGcpGateway;
        this.peerIp = $.peerIp;
        this.project = $.project;
        this.region = $.region;
        this.remoteTrafficSelectors = $.remoteTrafficSelectors;
        this.router = $.router;
        this.selfLink = $.selfLink;
        this.sharedSecret = $.sharedSecret;
        this.sharedSecretHash = $.sharedSecretHash;
        this.targetVpnGateway = $.targetVpnGateway;
        this.tunnelId = $.tunnelId;
        this.vpnGateway = $.vpnGateway;
        this.vpnGatewayInterface = $.vpnGatewayInterface;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(VPNTunnelState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private VPNTunnelState $;

        public Builder() {
            $ = new VPNTunnelState();
        }

        public Builder(VPNTunnelState defaults) {
            $ = new VPNTunnelState(Objects.requireNonNull(defaults));
        }

        public Builder creationTimestamp(@Nullable Output<String> creationTimestamp) {
            $.creationTimestamp = creationTimestamp;
            return this;
        }

        public Builder creationTimestamp(String creationTimestamp) {
            return creationTimestamp(Output.of(creationTimestamp));
        }

        public Builder description(@Nullable Output<String> description) {
            $.description = description;
            return this;
        }

        public Builder description(String description) {
            return description(Output.of(description));
        }

        public Builder detailedStatus(@Nullable Output<String> detailedStatus) {
            $.detailedStatus = detailedStatus;
            return this;
        }

        public Builder detailedStatus(String detailedStatus) {
            return detailedStatus(Output.of(detailedStatus));
        }

        public Builder ikeVersion(@Nullable Output<Integer> ikeVersion) {
            $.ikeVersion = ikeVersion;
            return this;
        }

        public Builder ikeVersion(Integer ikeVersion) {
            return ikeVersion(Output.of(ikeVersion));
        }

        public Builder labelFingerprint(@Nullable Output<String> labelFingerprint) {
            $.labelFingerprint = labelFingerprint;
            return this;
        }

        public Builder labelFingerprint(String labelFingerprint) {
            return labelFingerprint(Output.of(labelFingerprint));
        }

        public Builder labels(@Nullable Output<Map<String,String>> labels) {
            $.labels = labels;
            return this;
        }

        public Builder labels(Map<String,String> labels) {
            return labels(Output.of(labels));
        }

        public Builder localTrafficSelectors(@Nullable Output<List<String>> localTrafficSelectors) {
            $.localTrafficSelectors = localTrafficSelectors;
            return this;
        }

        public Builder localTrafficSelectors(List<String> localTrafficSelectors) {
            return localTrafficSelectors(Output.of(localTrafficSelectors));
        }

        public Builder localTrafficSelectors(String... localTrafficSelectors) {
            return localTrafficSelectors(List.of(localTrafficSelectors));
        }

        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        public Builder name(String name) {
            return name(Output.of(name));
        }

        public Builder peerExternalGateway(@Nullable Output<String> peerExternalGateway) {
            $.peerExternalGateway = peerExternalGateway;
            return this;
        }

        public Builder peerExternalGateway(String peerExternalGateway) {
            return peerExternalGateway(Output.of(peerExternalGateway));
        }

        public Builder peerExternalGatewayInterface(@Nullable Output<Integer> peerExternalGatewayInterface) {
            $.peerExternalGatewayInterface = peerExternalGatewayInterface;
            return this;
        }

        public Builder peerExternalGatewayInterface(Integer peerExternalGatewayInterface) {
            return peerExternalGatewayInterface(Output.of(peerExternalGatewayInterface));
        }

        public Builder peerGcpGateway(@Nullable Output<String> peerGcpGateway) {
            $.peerGcpGateway = peerGcpGateway;
            return this;
        }

        public Builder peerGcpGateway(String peerGcpGateway) {
            return peerGcpGateway(Output.of(peerGcpGateway));
        }

        public Builder peerIp(@Nullable Output<String> peerIp) {
            $.peerIp = peerIp;
            return this;
        }

        public Builder peerIp(String peerIp) {
            return peerIp(Output.of(peerIp));
        }

        public Builder project(@Nullable Output<String> project) {
            $.project = project;
            return this;
        }

        public Builder project(String project) {
            return project(Output.of(project));
        }

        public Builder region(@Nullable Output<String> region) {
            $.region = region;
            return this;
        }

        public Builder region(String region) {
            return region(Output.of(region));
        }

        public Builder remoteTrafficSelectors(@Nullable Output<List<String>> remoteTrafficSelectors) {
            $.remoteTrafficSelectors = remoteTrafficSelectors;
            return this;
        }

        public Builder remoteTrafficSelectors(List<String> remoteTrafficSelectors) {
            return remoteTrafficSelectors(Output.of(remoteTrafficSelectors));
        }

        public Builder remoteTrafficSelectors(String... remoteTrafficSelectors) {
            return remoteTrafficSelectors(List.of(remoteTrafficSelectors));
        }

        public Builder router(@Nullable Output<String> router) {
            $.router = router;
            return this;
        }

        public Builder router(String router) {
            return router(Output.of(router));
        }

        public Builder selfLink(@Nullable Output<String> selfLink) {
            $.selfLink = selfLink;
            return this;
        }

        public Builder selfLink(String selfLink) {
            return selfLink(Output.of(selfLink));
        }

        public Builder sharedSecret(@Nullable Output<String> sharedSecret) {
            $.sharedSecret = sharedSecret;
            return this;
        }

        public Builder sharedSecret(String sharedSecret) {
            return sharedSecret(Output.of(sharedSecret));
        }

        public Builder sharedSecretHash(@Nullable Output<String> sharedSecretHash) {
            $.sharedSecretHash = sharedSecretHash;
            return this;
        }

        public Builder sharedSecretHash(String sharedSecretHash) {
            return sharedSecretHash(Output.of(sharedSecretHash));
        }

        public Builder targetVpnGateway(@Nullable Output<String> targetVpnGateway) {
            $.targetVpnGateway = targetVpnGateway;
            return this;
        }

        public Builder targetVpnGateway(String targetVpnGateway) {
            return targetVpnGateway(Output.of(targetVpnGateway));
        }

        public Builder tunnelId(@Nullable Output<String> tunnelId) {
            $.tunnelId = tunnelId;
            return this;
        }

        public Builder tunnelId(String tunnelId) {
            return tunnelId(Output.of(tunnelId));
        }

        public Builder vpnGateway(@Nullable Output<String> vpnGateway) {
            $.vpnGateway = vpnGateway;
            return this;
        }

        public Builder vpnGateway(String vpnGateway) {
            return vpnGateway(Output.of(vpnGateway));
        }

        public Builder vpnGatewayInterface(@Nullable Output<Integer> vpnGatewayInterface) {
            $.vpnGatewayInterface = vpnGatewayInterface;
            return this;
        }

        public Builder vpnGatewayInterface(Integer vpnGatewayInterface) {
            return vpnGatewayInterface(Output.of(vpnGatewayInterface));
        }

        public VPNTunnelState build() {
            return $;
        }
    }

}
