// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.container.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.gcp.container.inputs.ClusterNodePoolNodeConfigEphemeralStorageConfigGetArgs;
import com.pulumi.gcp.container.inputs.ClusterNodePoolNodeConfigGcfsConfigGetArgs;
import com.pulumi.gcp.container.inputs.ClusterNodePoolNodeConfigGuestAcceleratorGetArgs;
import com.pulumi.gcp.container.inputs.ClusterNodePoolNodeConfigKubeletConfigGetArgs;
import com.pulumi.gcp.container.inputs.ClusterNodePoolNodeConfigLinuxNodeConfigGetArgs;
import com.pulumi.gcp.container.inputs.ClusterNodePoolNodeConfigSandboxConfigGetArgs;
import com.pulumi.gcp.container.inputs.ClusterNodePoolNodeConfigShieldedInstanceConfigGetArgs;
import com.pulumi.gcp.container.inputs.ClusterNodePoolNodeConfigTaintGetArgs;
import com.pulumi.gcp.container.inputs.ClusterNodePoolNodeConfigWorkloadMetadataConfigGetArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class ClusterNodePoolNodeConfigGetArgs extends com.pulumi.resources.ResourceArgs {

    public static final ClusterNodePoolNodeConfigGetArgs Empty = new ClusterNodePoolNodeConfigGetArgs();

    /**
     * The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool. This should be of the form projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME]. For more information about protecting resources with Cloud KMS Keys please see: &lt;https://cloud.google.com/compute/docs/disks/customer-managed-encryption&gt;
     * 
     */
    @Import(name="bootDiskKmsKey")
    private @Nullable Output<String> bootDiskKmsKey;

    public Optional<Output<String>> bootDiskKmsKey() {
        return Optional.ofNullable(this.bootDiskKmsKey);
    }

    /**
     * Size of the disk attached to each node, specified
     * in GB. The smallest allowed disk size is 10GB. Defaults to 100GB.
     * 
     */
    @Import(name="diskSizeGb")
    private @Nullable Output<Integer> diskSizeGb;

    public Optional<Output<Integer>> diskSizeGb() {
        return Optional.ofNullable(this.diskSizeGb);
    }

    /**
     * Type of the disk attached to each node
     * (e.g. &#39;pd-standard&#39;, &#39;pd-balanced&#39; or &#39;pd-ssd&#39;). If unspecified, the default disk type is &#39;pd-standard&#39;
     * 
     */
    @Import(name="diskType")
    private @Nullable Output<String> diskType;

    public Optional<Output<String>> diskType() {
        return Optional.ofNullable(this.diskType);
    }

    /**
     * Parameters for the ephemeral storage filesystem. If unspecified, ephemeral storage is backed by the boot disk. Structure is documented below.
     * 
     */
    @Import(name="ephemeralStorageConfig")
    private @Nullable Output<ClusterNodePoolNodeConfigEphemeralStorageConfigGetArgs> ephemeralStorageConfig;

    public Optional<Output<ClusterNodePoolNodeConfigEphemeralStorageConfigGetArgs>> ephemeralStorageConfig() {
        return Optional.ofNullable(this.ephemeralStorageConfig);
    }

    /**
     * Parameters for the Google Container Filesystem (GCFS).
     * If unspecified, GCFS will not be enabled on the node pool. When enabling this feature you must specify `image_type = &#34;COS_CONTAINERD&#34;` and `node_version` from GKE versions 1.19 or later to use it.
     * For GKE versions 1.19, 1.20, and 1.21, the recommended minimum `node_version` would be 1.19.15-gke.1300, 1.20.11-gke.1300, and 1.21.5-gke.1300 respectively.
     * A `machine_type` that has more than 16 GiB of memory is also recommended.
     * GCFS must be enabled in order to use [image streaming](https://cloud.google.com/kubernetes-engine/docs/how-to/image-streaming).
     * Structure is documented below.
     * 
     */
    @Import(name="gcfsConfig")
    private @Nullable Output<ClusterNodePoolNodeConfigGcfsConfigGetArgs> gcfsConfig;

    public Optional<Output<ClusterNodePoolNodeConfigGcfsConfigGetArgs>> gcfsConfig() {
        return Optional.ofNullable(this.gcfsConfig);
    }

    /**
     * List of the type and count of accelerator cards attached to the instance.
     * Structure documented below.
     * 
     */
    @Import(name="guestAccelerators")
    private @Nullable Output<List<ClusterNodePoolNodeConfigGuestAcceleratorGetArgs>> guestAccelerators;

    public Optional<Output<List<ClusterNodePoolNodeConfigGuestAcceleratorGetArgs>>> guestAccelerators() {
        return Optional.ofNullable(this.guestAccelerators);
    }

    /**
     * The image type to use for this node. Note that changing the image type
     * will delete and recreate all nodes in the node pool.
     * 
     */
    @Import(name="imageType")
    private @Nullable Output<String> imageType;

    public Optional<Output<String>> imageType() {
        return Optional.ofNullable(this.imageType);
    }

    /**
     * Kubelet configuration, currently supported attributes can be found [here](https://cloud.google.com/sdk/gcloud/reference/beta/container/node-pools/create#--system-config-from-file).
     * Structure is documented below.
     * 
     */
    @Import(name="kubeletConfig")
    private @Nullable Output<ClusterNodePoolNodeConfigKubeletConfigGetArgs> kubeletConfig;

    public Optional<Output<ClusterNodePoolNodeConfigKubeletConfigGetArgs>> kubeletConfig() {
        return Optional.ofNullable(this.kubeletConfig);
    }

    /**
     * The Kubernetes labels (key/value pairs) to be applied to each node. The kubernetes.io/ and k8s.io/ prefixes are
     * reserved by Kubernetes Core components and cannot be specified.
     * 
     */
    @Import(name="labels")
    private @Nullable Output<Map<String,String>> labels;

    public Optional<Output<Map<String,String>>> labels() {
        return Optional.ofNullable(this.labels);
    }

    /**
     * Linux node configuration, currently supported attributes can be found [here](https://cloud.google.com/sdk/gcloud/reference/beta/container/node-pools/create#--system-config-from-file).
     * Note that validations happen all server side. All attributes are optional.
     * Structure is documented below.
     * 
     */
    @Import(name="linuxNodeConfig")
    private @Nullable Output<ClusterNodePoolNodeConfigLinuxNodeConfigGetArgs> linuxNodeConfig;

    public Optional<Output<ClusterNodePoolNodeConfigLinuxNodeConfigGetArgs>> linuxNodeConfig() {
        return Optional.ofNullable(this.linuxNodeConfig);
    }

    /**
     * Number of local SSDs to use to back ephemeral storage. Uses NVMe interfaces. Each local SSD is 375 GB in size. If zero, it means to disable using local SSDs as ephemeral storage.
     * 
     */
    @Import(name="localSsdCount")
    private @Nullable Output<Integer> localSsdCount;

    public Optional<Output<Integer>> localSsdCount() {
        return Optional.ofNullable(this.localSsdCount);
    }

    /**
     * The name of a Google Compute Engine machine type.
     * Defaults to `e2-medium`. To create a custom machine type, value should be set as specified
     * [here](https://cloud.google.com/compute/docs/reference/latest/instances#machineType).
     * 
     */
    @Import(name="machineType")
    private @Nullable Output<String> machineType;

    public Optional<Output<String>> machineType() {
        return Optional.ofNullable(this.machineType);
    }

    /**
     * The metadata key/value pairs assigned to instances in
     * the cluster. From GKE `1.12` onwards, `disable-legacy-endpoints` is set to
     * `true` by the API; if `metadata` is set but that default value is not
     * included, the provider will attempt to unset the value. To avoid this, set the
     * value in your config.
     * 
     */
    @Import(name="metadata")
    private @Nullable Output<Map<String,String>> metadata;

    public Optional<Output<Map<String,String>>> metadata() {
        return Optional.ofNullable(this.metadata);
    }

    /**
     * Minimum CPU platform to be used by this instance.
     * The instance may be scheduled on the specified or newer CPU platform. Applicable
     * values are the friendly names of CPU platforms, such as `Intel Haswell`. See the
     * [official documentation](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform)
     * for more information.
     * 
     */
    @Import(name="minCpuPlatform")
    private @Nullable Output<String> minCpuPlatform;

    public Optional<Output<String>> minCpuPlatform() {
        return Optional.ofNullable(this.minCpuPlatform);
    }

    /**
     * Setting this field will assign instances of this pool to run on the specified node group. This is useful for running workloads on [sole tenant nodes](https://cloud.google.com/compute/docs/nodes/sole-tenant-nodes).
     * 
     */
    @Import(name="nodeGroup")
    private @Nullable Output<String> nodeGroup;

    public Optional<Output<String>> nodeGroup() {
        return Optional.ofNullable(this.nodeGroup);
    }

    /**
     * The set of Google API scopes to be made available
     * on all of the node VMs under the &#34;default&#34; service account.
     * Use the &#34;https://www.googleapis.com/auth/cloud-platform&#34; scope to grant access to all APIs. It is recommended that you set `service_account` to a non-default service account and grant IAM roles to that service account for only the resources that it needs.
     * 
     */
    @Import(name="oauthScopes")
    private @Nullable Output<List<String>> oauthScopes;

    public Optional<Output<List<String>>> oauthScopes() {
        return Optional.ofNullable(this.oauthScopes);
    }

    /**
     * A boolean that represents whether or not the underlying node VMs
     * are preemptible. See the [official documentation](https://cloud.google.com/container-engine/docs/preemptible-vm)
     * for more information. Defaults to false.
     * 
     */
    @Import(name="preemptible")
    private @Nullable Output<Boolean> preemptible;

    public Optional<Output<Boolean>> preemptible() {
        return Optional.ofNullable(this.preemptible);
    }

    /**
     * [GKE Sandbox](https://cloud.google.com/kubernetes-engine/docs/how-to/sandbox-pods) configuration. When enabling this feature you must specify `image_type = &#34;COS_CONTAINERD&#34;` and `node_version = &#34;1.12.7-gke.17&#34;` or later to use it.
     * Structure is documented below.
     * 
     */
    @Import(name="sandboxConfig")
    private @Nullable Output<ClusterNodePoolNodeConfigSandboxConfigGetArgs> sandboxConfig;

    public Optional<Output<ClusterNodePoolNodeConfigSandboxConfigGetArgs>> sandboxConfig() {
        return Optional.ofNullable(this.sandboxConfig);
    }

    /**
     * The service account to be used by the Node VMs.
     * If not specified, the &#34;default&#34; service account is used.
     * 
     */
    @Import(name="serviceAccount")
    private @Nullable Output<String> serviceAccount;

    public Optional<Output<String>> serviceAccount() {
        return Optional.ofNullable(this.serviceAccount);
    }

    /**
     * Shielded Instance options. Structure is documented below.
     * 
     */
    @Import(name="shieldedInstanceConfig")
    private @Nullable Output<ClusterNodePoolNodeConfigShieldedInstanceConfigGetArgs> shieldedInstanceConfig;

    public Optional<Output<ClusterNodePoolNodeConfigShieldedInstanceConfigGetArgs>> shieldedInstanceConfig() {
        return Optional.ofNullable(this.shieldedInstanceConfig);
    }

    /**
     * ) A boolean
     * that represents whether the underlying node VMs are spot. See the [official documentation](https://cloud.google.com/kubernetes-engine/docs/concepts/spot-vms)
     * for more information. Defaults to false.
     * 
     */
    @Import(name="spot")
    private @Nullable Output<Boolean> spot;

    public Optional<Output<Boolean>> spot() {
        return Optional.ofNullable(this.spot);
    }

    /**
     * The list of instance tags applied to all nodes. Tags are used to identify
     * valid sources or targets for network firewalls.
     * 
     */
    @Import(name="tags")
    private @Nullable Output<List<String>> tags;

    public Optional<Output<List<String>>> tags() {
        return Optional.ofNullable(this.tags);
    }

    /**
     * A list of [Kubernetes taints](https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/)
     * to apply to nodes. GKE&#39;s API can only set this field on cluster creation.
     * However, GKE will add taints to your nodes if you enable certain features such
     * as GPUs. If this field is set, any diffs on this field will cause the provider to
     * recreate the underlying resource. Taint values can be updated safely in
     * Kubernetes (eg. through `kubectl`), and it&#39;s recommended that you do not use
     * this field to manage taints. If you do, `lifecycle.ignore_changes` is
     * recommended. Structure is documented below.
     * 
     */
    @Import(name="taints")
    private @Nullable Output<List<ClusterNodePoolNodeConfigTaintGetArgs>> taints;

    public Optional<Output<List<ClusterNodePoolNodeConfigTaintGetArgs>>> taints() {
        return Optional.ofNullable(this.taints);
    }

    /**
     * Metadata configuration to expose to workloads on the node pool.
     * Structure is documented below.
     * 
     */
    @Import(name="workloadMetadataConfig")
    private @Nullable Output<ClusterNodePoolNodeConfigWorkloadMetadataConfigGetArgs> workloadMetadataConfig;

    public Optional<Output<ClusterNodePoolNodeConfigWorkloadMetadataConfigGetArgs>> workloadMetadataConfig() {
        return Optional.ofNullable(this.workloadMetadataConfig);
    }

    private ClusterNodePoolNodeConfigGetArgs() {}

    private ClusterNodePoolNodeConfigGetArgs(ClusterNodePoolNodeConfigGetArgs $) {
        this.bootDiskKmsKey = $.bootDiskKmsKey;
        this.diskSizeGb = $.diskSizeGb;
        this.diskType = $.diskType;
        this.ephemeralStorageConfig = $.ephemeralStorageConfig;
        this.gcfsConfig = $.gcfsConfig;
        this.guestAccelerators = $.guestAccelerators;
        this.imageType = $.imageType;
        this.kubeletConfig = $.kubeletConfig;
        this.labels = $.labels;
        this.linuxNodeConfig = $.linuxNodeConfig;
        this.localSsdCount = $.localSsdCount;
        this.machineType = $.machineType;
        this.metadata = $.metadata;
        this.minCpuPlatform = $.minCpuPlatform;
        this.nodeGroup = $.nodeGroup;
        this.oauthScopes = $.oauthScopes;
        this.preemptible = $.preemptible;
        this.sandboxConfig = $.sandboxConfig;
        this.serviceAccount = $.serviceAccount;
        this.shieldedInstanceConfig = $.shieldedInstanceConfig;
        this.spot = $.spot;
        this.tags = $.tags;
        this.taints = $.taints;
        this.workloadMetadataConfig = $.workloadMetadataConfig;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(ClusterNodePoolNodeConfigGetArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private ClusterNodePoolNodeConfigGetArgs $;

        public Builder() {
            $ = new ClusterNodePoolNodeConfigGetArgs();
        }

        public Builder(ClusterNodePoolNodeConfigGetArgs defaults) {
            $ = new ClusterNodePoolNodeConfigGetArgs(Objects.requireNonNull(defaults));
        }

        public Builder bootDiskKmsKey(@Nullable Output<String> bootDiskKmsKey) {
            $.bootDiskKmsKey = bootDiskKmsKey;
            return this;
        }

        public Builder bootDiskKmsKey(String bootDiskKmsKey) {
            return bootDiskKmsKey(Output.of(bootDiskKmsKey));
        }

        public Builder diskSizeGb(@Nullable Output<Integer> diskSizeGb) {
            $.diskSizeGb = diskSizeGb;
            return this;
        }

        public Builder diskSizeGb(Integer diskSizeGb) {
            return diskSizeGb(Output.of(diskSizeGb));
        }

        public Builder diskType(@Nullable Output<String> diskType) {
            $.diskType = diskType;
            return this;
        }

        public Builder diskType(String diskType) {
            return diskType(Output.of(diskType));
        }

        public Builder ephemeralStorageConfig(@Nullable Output<ClusterNodePoolNodeConfigEphemeralStorageConfigGetArgs> ephemeralStorageConfig) {
            $.ephemeralStorageConfig = ephemeralStorageConfig;
            return this;
        }

        public Builder ephemeralStorageConfig(ClusterNodePoolNodeConfigEphemeralStorageConfigGetArgs ephemeralStorageConfig) {
            return ephemeralStorageConfig(Output.of(ephemeralStorageConfig));
        }

        public Builder gcfsConfig(@Nullable Output<ClusterNodePoolNodeConfigGcfsConfigGetArgs> gcfsConfig) {
            $.gcfsConfig = gcfsConfig;
            return this;
        }

        public Builder gcfsConfig(ClusterNodePoolNodeConfigGcfsConfigGetArgs gcfsConfig) {
            return gcfsConfig(Output.of(gcfsConfig));
        }

        public Builder guestAccelerators(@Nullable Output<List<ClusterNodePoolNodeConfigGuestAcceleratorGetArgs>> guestAccelerators) {
            $.guestAccelerators = guestAccelerators;
            return this;
        }

        public Builder guestAccelerators(List<ClusterNodePoolNodeConfigGuestAcceleratorGetArgs> guestAccelerators) {
            return guestAccelerators(Output.of(guestAccelerators));
        }

        public Builder guestAccelerators(ClusterNodePoolNodeConfigGuestAcceleratorGetArgs... guestAccelerators) {
            return guestAccelerators(List.of(guestAccelerators));
        }

        public Builder imageType(@Nullable Output<String> imageType) {
            $.imageType = imageType;
            return this;
        }

        public Builder imageType(String imageType) {
            return imageType(Output.of(imageType));
        }

        public Builder kubeletConfig(@Nullable Output<ClusterNodePoolNodeConfigKubeletConfigGetArgs> kubeletConfig) {
            $.kubeletConfig = kubeletConfig;
            return this;
        }

        public Builder kubeletConfig(ClusterNodePoolNodeConfigKubeletConfigGetArgs kubeletConfig) {
            return kubeletConfig(Output.of(kubeletConfig));
        }

        public Builder labels(@Nullable Output<Map<String,String>> labels) {
            $.labels = labels;
            return this;
        }

        public Builder labels(Map<String,String> labels) {
            return labels(Output.of(labels));
        }

        public Builder linuxNodeConfig(@Nullable Output<ClusterNodePoolNodeConfigLinuxNodeConfigGetArgs> linuxNodeConfig) {
            $.linuxNodeConfig = linuxNodeConfig;
            return this;
        }

        public Builder linuxNodeConfig(ClusterNodePoolNodeConfigLinuxNodeConfigGetArgs linuxNodeConfig) {
            return linuxNodeConfig(Output.of(linuxNodeConfig));
        }

        public Builder localSsdCount(@Nullable Output<Integer> localSsdCount) {
            $.localSsdCount = localSsdCount;
            return this;
        }

        public Builder localSsdCount(Integer localSsdCount) {
            return localSsdCount(Output.of(localSsdCount));
        }

        public Builder machineType(@Nullable Output<String> machineType) {
            $.machineType = machineType;
            return this;
        }

        public Builder machineType(String machineType) {
            return machineType(Output.of(machineType));
        }

        public Builder metadata(@Nullable Output<Map<String,String>> metadata) {
            $.metadata = metadata;
            return this;
        }

        public Builder metadata(Map<String,String> metadata) {
            return metadata(Output.of(metadata));
        }

        public Builder minCpuPlatform(@Nullable Output<String> minCpuPlatform) {
            $.minCpuPlatform = minCpuPlatform;
            return this;
        }

        public Builder minCpuPlatform(String minCpuPlatform) {
            return minCpuPlatform(Output.of(minCpuPlatform));
        }

        public Builder nodeGroup(@Nullable Output<String> nodeGroup) {
            $.nodeGroup = nodeGroup;
            return this;
        }

        public Builder nodeGroup(String nodeGroup) {
            return nodeGroup(Output.of(nodeGroup));
        }

        public Builder oauthScopes(@Nullable Output<List<String>> oauthScopes) {
            $.oauthScopes = oauthScopes;
            return this;
        }

        public Builder oauthScopes(List<String> oauthScopes) {
            return oauthScopes(Output.of(oauthScopes));
        }

        public Builder oauthScopes(String... oauthScopes) {
            return oauthScopes(List.of(oauthScopes));
        }

        public Builder preemptible(@Nullable Output<Boolean> preemptible) {
            $.preemptible = preemptible;
            return this;
        }

        public Builder preemptible(Boolean preemptible) {
            return preemptible(Output.of(preemptible));
        }

        public Builder sandboxConfig(@Nullable Output<ClusterNodePoolNodeConfigSandboxConfigGetArgs> sandboxConfig) {
            $.sandboxConfig = sandboxConfig;
            return this;
        }

        public Builder sandboxConfig(ClusterNodePoolNodeConfigSandboxConfigGetArgs sandboxConfig) {
            return sandboxConfig(Output.of(sandboxConfig));
        }

        public Builder serviceAccount(@Nullable Output<String> serviceAccount) {
            $.serviceAccount = serviceAccount;
            return this;
        }

        public Builder serviceAccount(String serviceAccount) {
            return serviceAccount(Output.of(serviceAccount));
        }

        public Builder shieldedInstanceConfig(@Nullable Output<ClusterNodePoolNodeConfigShieldedInstanceConfigGetArgs> shieldedInstanceConfig) {
            $.shieldedInstanceConfig = shieldedInstanceConfig;
            return this;
        }

        public Builder shieldedInstanceConfig(ClusterNodePoolNodeConfigShieldedInstanceConfigGetArgs shieldedInstanceConfig) {
            return shieldedInstanceConfig(Output.of(shieldedInstanceConfig));
        }

        public Builder spot(@Nullable Output<Boolean> spot) {
            $.spot = spot;
            return this;
        }

        public Builder spot(Boolean spot) {
            return spot(Output.of(spot));
        }

        public Builder tags(@Nullable Output<List<String>> tags) {
            $.tags = tags;
            return this;
        }

        public Builder tags(List<String> tags) {
            return tags(Output.of(tags));
        }

        public Builder tags(String... tags) {
            return tags(List.of(tags));
        }

        public Builder taints(@Nullable Output<List<ClusterNodePoolNodeConfigTaintGetArgs>> taints) {
            $.taints = taints;
            return this;
        }

        public Builder taints(List<ClusterNodePoolNodeConfigTaintGetArgs> taints) {
            return taints(Output.of(taints));
        }

        public Builder taints(ClusterNodePoolNodeConfigTaintGetArgs... taints) {
            return taints(List.of(taints));
        }

        public Builder workloadMetadataConfig(@Nullable Output<ClusterNodePoolNodeConfigWorkloadMetadataConfigGetArgs> workloadMetadataConfig) {
            $.workloadMetadataConfig = workloadMetadataConfig;
            return this;
        }

        public Builder workloadMetadataConfig(ClusterNodePoolNodeConfigWorkloadMetadataConfigGetArgs workloadMetadataConfig) {
            return workloadMetadataConfig(Output.of(workloadMetadataConfig));
        }

        public ClusterNodePoolNodeConfigGetArgs build() {
            return $;
        }
    }

}
