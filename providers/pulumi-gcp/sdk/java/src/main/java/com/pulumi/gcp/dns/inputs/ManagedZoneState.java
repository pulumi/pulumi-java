// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.gcp.dns.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.core.internal.Codegen;
import com.pulumi.gcp.dns.inputs.ManagedZoneDnssecConfigGetArgs;
import com.pulumi.gcp.dns.inputs.ManagedZoneForwardingConfigGetArgs;
import com.pulumi.gcp.dns.inputs.ManagedZonePeeringConfigGetArgs;
import com.pulumi.gcp.dns.inputs.ManagedZonePrivateVisibilityConfigGetArgs;
import com.pulumi.gcp.dns.inputs.ManagedZoneServiceDirectoryConfigGetArgs;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class ManagedZoneState extends com.pulumi.resources.ResourceArgs {

    public static final ManagedZoneState Empty = new ManagedZoneState();

    /**
     * A textual description field. Defaults to &#39;Managed by Pulumi&#39;.
     * 
     */
    @Import(name="description")
    private @Nullable Output<String> description;

    public Optional<Output<String>> description() {
        return Optional.ofNullable(this.description);
    }

    /**
     * The DNS name of this managed zone, for instance &#34;example.com.&#34;.
     * 
     */
    @Import(name="dnsName")
    private @Nullable Output<String> dnsName;

    public Optional<Output<String>> dnsName() {
        return Optional.ofNullable(this.dnsName);
    }

    /**
     * DNSSEC configuration
     * Structure is documented below.
     * 
     */
    @Import(name="dnssecConfig")
    private @Nullable Output<ManagedZoneDnssecConfigGetArgs> dnssecConfig;

    public Optional<Output<ManagedZoneDnssecConfigGetArgs>> dnssecConfig() {
        return Optional.ofNullable(this.dnssecConfig);
    }

    /**
     * Set this true to delete all records in the zone.
     * 
     */
    @Import(name="forceDestroy")
    private @Nullable Output<Boolean> forceDestroy;

    public Optional<Output<Boolean>> forceDestroy() {
        return Optional.ofNullable(this.forceDestroy);
    }

    /**
     * The presence for this field indicates that outbound forwarding is enabled
     * for this zone. The value of this field contains the set of destinations
     * to forward to.
     * Structure is documented below.
     * 
     */
    @Import(name="forwardingConfig")
    private @Nullable Output<ManagedZoneForwardingConfigGetArgs> forwardingConfig;

    public Optional<Output<ManagedZoneForwardingConfigGetArgs>> forwardingConfig() {
        return Optional.ofNullable(this.forwardingConfig);
    }

    /**
     * A set of key/value label pairs to assign to this ManagedZone.
     * 
     */
    @Import(name="labels")
    private @Nullable Output<Map<String,String>> labels;

    public Optional<Output<Map<String,String>>> labels() {
        return Optional.ofNullable(this.labels);
    }

    /**
     * User assigned name for this resource.
     * Must be unique within the project.
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * Delegate your managed_zone to these virtual name servers; defined by the server
     * 
     */
    @Import(name="nameServers")
    private @Nullable Output<List<String>> nameServers;

    public Optional<Output<List<String>>> nameServers() {
        return Optional.ofNullable(this.nameServers);
    }

    /**
     * The presence of this field indicates that DNS Peering is enabled for this
     * zone. The value of this field contains the network to peer with.
     * Structure is documented below.
     * 
     */
    @Import(name="peeringConfig")
    private @Nullable Output<ManagedZonePeeringConfigGetArgs> peeringConfig;

    public Optional<Output<ManagedZonePeeringConfigGetArgs>> peeringConfig() {
        return Optional.ofNullable(this.peeringConfig);
    }

    /**
     * For privately visible zones, the set of Virtual Private Cloud
     * resources that the zone is visible from.
     * Structure is documented below.
     * 
     */
    @Import(name="privateVisibilityConfig")
    private @Nullable Output<ManagedZonePrivateVisibilityConfigGetArgs> privateVisibilityConfig;

    public Optional<Output<ManagedZonePrivateVisibilityConfigGetArgs>> privateVisibilityConfig() {
        return Optional.ofNullable(this.privateVisibilityConfig);
    }

    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    @Import(name="project")
    private @Nullable Output<String> project;

    public Optional<Output<String>> project() {
        return Optional.ofNullable(this.project);
    }

    /**
     * Specifies if this is a managed reverse lookup zone. If true, Cloud DNS will resolve reverse
     * lookup queries using automatically configured records for VPC resources. This only applies
     * to networks listed under `private_visibility_config`.
     * 
     */
    @Import(name="reverseLookup")
    private @Nullable Output<Boolean> reverseLookup;

    public Optional<Output<Boolean>> reverseLookup() {
        return Optional.ofNullable(this.reverseLookup);
    }

    /**
     * The presence of this field indicates that this zone is backed by Service Directory. The value of this field contains information related to the namespace associated with the zone.
     * Structure is documented below.
     * 
     */
    @Import(name="serviceDirectoryConfig")
    private @Nullable Output<ManagedZoneServiceDirectoryConfigGetArgs> serviceDirectoryConfig;

    public Optional<Output<ManagedZoneServiceDirectoryConfigGetArgs>> serviceDirectoryConfig() {
        return Optional.ofNullable(this.serviceDirectoryConfig);
    }

    /**
     * The zone&#39;s visibility: public zones are exposed to the Internet,
     * while private zones are visible only to Virtual Private Cloud resources.
     * Default value is `public`.
     * Possible values are `private` and `public`.
     * 
     */
    @Import(name="visibility")
    private @Nullable Output<String> visibility;

    public Optional<Output<String>> visibility() {
        return Optional.ofNullable(this.visibility);
    }

    private ManagedZoneState() {}

    private ManagedZoneState(ManagedZoneState $) {
        this.description = $.description;
        this.dnsName = $.dnsName;
        this.dnssecConfig = $.dnssecConfig;
        this.forceDestroy = $.forceDestroy;
        this.forwardingConfig = $.forwardingConfig;
        this.labels = $.labels;
        this.name = $.name;
        this.nameServers = $.nameServers;
        this.peeringConfig = $.peeringConfig;
        this.privateVisibilityConfig = $.privateVisibilityConfig;
        this.project = $.project;
        this.reverseLookup = $.reverseLookup;
        this.serviceDirectoryConfig = $.serviceDirectoryConfig;
        this.visibility = $.visibility;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(ManagedZoneState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private ManagedZoneState $;

        public Builder() {
            $ = new ManagedZoneState();
        }

        public Builder(ManagedZoneState defaults) {
            $ = new ManagedZoneState(Objects.requireNonNull(defaults));
        }

        public Builder description(@Nullable Output<String> description) {
            $.description = description;
            return this;
        }

        public Builder description(String description) {
            return description(Output.of(description));
        }

        public Builder dnsName(@Nullable Output<String> dnsName) {
            $.dnsName = dnsName;
            return this;
        }

        public Builder dnsName(String dnsName) {
            return dnsName(Output.of(dnsName));
        }

        public Builder dnssecConfig(@Nullable Output<ManagedZoneDnssecConfigGetArgs> dnssecConfig) {
            $.dnssecConfig = dnssecConfig;
            return this;
        }

        public Builder dnssecConfig(ManagedZoneDnssecConfigGetArgs dnssecConfig) {
            return dnssecConfig(Output.of(dnssecConfig));
        }

        public Builder forceDestroy(@Nullable Output<Boolean> forceDestroy) {
            $.forceDestroy = forceDestroy;
            return this;
        }

        public Builder forceDestroy(Boolean forceDestroy) {
            return forceDestroy(Output.of(forceDestroy));
        }

        public Builder forwardingConfig(@Nullable Output<ManagedZoneForwardingConfigGetArgs> forwardingConfig) {
            $.forwardingConfig = forwardingConfig;
            return this;
        }

        public Builder forwardingConfig(ManagedZoneForwardingConfigGetArgs forwardingConfig) {
            return forwardingConfig(Output.of(forwardingConfig));
        }

        public Builder labels(@Nullable Output<Map<String,String>> labels) {
            $.labels = labels;
            return this;
        }

        public Builder labels(Map<String,String> labels) {
            return labels(Output.of(labels));
        }

        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        public Builder name(String name) {
            return name(Output.of(name));
        }

        public Builder nameServers(@Nullable Output<List<String>> nameServers) {
            $.nameServers = nameServers;
            return this;
        }

        public Builder nameServers(List<String> nameServers) {
            return nameServers(Output.of(nameServers));
        }

        public Builder nameServers(String... nameServers) {
            return nameServers(List.of(nameServers));
        }

        public Builder peeringConfig(@Nullable Output<ManagedZonePeeringConfigGetArgs> peeringConfig) {
            $.peeringConfig = peeringConfig;
            return this;
        }

        public Builder peeringConfig(ManagedZonePeeringConfigGetArgs peeringConfig) {
            return peeringConfig(Output.of(peeringConfig));
        }

        public Builder privateVisibilityConfig(@Nullable Output<ManagedZonePrivateVisibilityConfigGetArgs> privateVisibilityConfig) {
            $.privateVisibilityConfig = privateVisibilityConfig;
            return this;
        }

        public Builder privateVisibilityConfig(ManagedZonePrivateVisibilityConfigGetArgs privateVisibilityConfig) {
            return privateVisibilityConfig(Output.of(privateVisibilityConfig));
        }

        public Builder project(@Nullable Output<String> project) {
            $.project = project;
            return this;
        }

        public Builder project(String project) {
            return project(Output.of(project));
        }

        public Builder reverseLookup(@Nullable Output<Boolean> reverseLookup) {
            $.reverseLookup = reverseLookup;
            return this;
        }

        public Builder reverseLookup(Boolean reverseLookup) {
            return reverseLookup(Output.of(reverseLookup));
        }

        public Builder serviceDirectoryConfig(@Nullable Output<ManagedZoneServiceDirectoryConfigGetArgs> serviceDirectoryConfig) {
            $.serviceDirectoryConfig = serviceDirectoryConfig;
            return this;
        }

        public Builder serviceDirectoryConfig(ManagedZoneServiceDirectoryConfigGetArgs serviceDirectoryConfig) {
            return serviceDirectoryConfig(Output.of(serviceDirectoryConfig));
        }

        public Builder visibility(@Nullable Output<String> visibility) {
            $.visibility = visibility;
            return this;
        }

        public Builder visibility(String visibility) {
            return visibility(Output.of(visibility));
        }

        public ManagedZoneState build() {
            $.description = Codegen.stringProp("description").output().arg($.description).def("Managed by Pulumi").getNullable();
            return $;
        }
    }

}
