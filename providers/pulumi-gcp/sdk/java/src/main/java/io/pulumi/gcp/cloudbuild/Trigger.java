// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package io.pulumi.gcp.cloudbuild;

import io.pulumi.core.Output;
import io.pulumi.core.annotations.Export;
import io.pulumi.core.annotations.ResourceType;
import io.pulumi.gcp.Utilities;
import io.pulumi.gcp.cloudbuild.TriggerArgs;
import io.pulumi.gcp.cloudbuild.inputs.TriggerState;
import io.pulumi.gcp.cloudbuild.outputs.TriggerBuild;
import io.pulumi.gcp.cloudbuild.outputs.TriggerGithub;
import io.pulumi.gcp.cloudbuild.outputs.TriggerPubsubConfig;
import io.pulumi.gcp.cloudbuild.outputs.TriggerTriggerTemplate;
import io.pulumi.gcp.cloudbuild.outputs.TriggerWebhookConfig;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Map;
import javax.annotation.Nullable;

/**
 * Configuration for an automated build in response to source repository changes.
 * 
 * 
 * To get more information about Trigger, see:
 * 
 * * [API documentation](https://cloud.google.com/cloud-build/docs/api/reference/rest/v1/projects.triggers)
 * * How-to Guides
 *     * [Automating builds using build triggers](https://cloud.google.com/cloud-build/docs/running-builds/automate-builds)
 * 
 * > **Note:** You can retrieve the email of the Cloud Build Service Account used in jobs by using the `gcp.projects.ServiceIdentity` resource.
 * 
 * {{% examples %}}
 * ## Example Usage
 * {{% example %}}
 * ### Cloudbuild Trigger Filename
 * 
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as gcp from "@pulumi/gcp";
 * 
 * const filename_trigger = new gcp.cloudbuild.Trigger("filename-trigger", {
 *     filename: "cloudbuild.yaml",
 *     substitutions: {
 *         _BAZ: "qux",
 *         _FOO: "bar",
 *     },
 *     triggerTemplate: {
 *         branchName: "master",
 *         repoName: "my-repo",
 *     },
 * });
 * ```
 * ```python
 * import pulumi
 * import pulumi_gcp as gcp
 * 
 * filename_trigger = gcp.cloudbuild.Trigger("filename-trigger",
 *     filename="cloudbuild.yaml",
 *     substitutions={
 *         "_BAZ": "qux",
 *         "_FOO": "bar",
 *     },
 *     trigger_template=gcp.cloudbuild.TriggerTriggerTemplateArgs(
 *         branch_name="master",
 *         repo_name="my-repo",
 *     ))
 * ```
 * ```csharp
 * using Pulumi;
 * using Gcp = Pulumi.Gcp;
 * 
 * class MyStack : Stack
 * {
 *     public MyStack()
 *     {
 *         var filename_trigger = new Gcp.CloudBuild.Trigger("filename-trigger", new Gcp.CloudBuild.TriggerArgs
 *         {
 *             Filename = "cloudbuild.yaml",
 *             Substitutions = 
 *             {
 *                 { "_BAZ", "qux" },
 *                 { "_FOO", "bar" },
 *             },
 *             TriggerTemplate = new Gcp.CloudBuild.Inputs.TriggerTriggerTemplateArgs
 *             {
 *                 BranchName = "master",
 *                 RepoName = "my-repo",
 *             },
 *         });
 *     }
 * 
 * }
 * ```
 * ```go
 * package main
 * 
 * import (
 * 	"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/cloudbuild"
 * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
 * )
 * 
 * func main() {
 * 	pulumi.Run(func(ctx *pulumi.Context) error {
 * 		_, err := cloudbuild.NewTrigger(ctx, "filename-trigger", &cloudbuild.TriggerArgs{
 * 			Filename: pulumi.String("cloudbuild.yaml"),
 * 			Substitutions: pulumi.StringMap{
 * 				"_BAZ": pulumi.String("qux"),
 * 				"_FOO": pulumi.String("bar"),
 * 			},
 * 			TriggerTemplate: &cloudbuild.TriggerTriggerTemplateArgs{
 * 				BranchName: pulumi.String("master"),
 * 				RepoName:   pulumi.String("my-repo"),
 * 			},
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		return nil
 * 	})
 * }
 * ```
 * {{% /example %}}
 * {{% example %}}
 * ### Cloudbuild Trigger Build
 * 
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as gcp from "@pulumi/gcp";
 * 
 * const build_trigger = new gcp.cloudbuild.Trigger("build-trigger", {
 *     build: {
 *         artifacts: {
 *             images: ["gcr.io/$PROJECT_ID/$REPO_NAME:$COMMIT_SHA"],
 *             objects: {
 *                 location: "gs://bucket/path/to/somewhere/",
 *                 paths: ["path"],
 *             },
 *         },
 *         availableSecrets: {
 *             secretManagers: [{
 *                 env: "MY_SECRET",
 *                 versionName: "projects/myProject/secrets/mySecret/versions/latest",
 *             }],
 *         },
 *         logsBucket: "gs://mybucket/logs",
 *         options: {
 *             diskSizeGb: 100,
 *             dynamicSubstitutions: true,
 *             envs: ["ekey = evalue"],
 *             logStreamingOption: "STREAM_OFF",
 *             logging: "LEGACY",
 *             machineType: "N1_HIGHCPU_8",
 *             requestedVerifyOption: "VERIFIED",
 *             secretEnvs: ["secretenv = svalue"],
 *             sourceProvenanceHashes: ["MD5"],
 *             substitutionOption: "ALLOW_LOOSE",
 *             volumes: [{
 *                 name: "v1",
 *                 path: "v1",
 *             }],
 *             workerPool: "pool",
 *         },
 *         queueTtl: "20s",
 *         secrets: [{
 *             kmsKeyName: "projects/myProject/locations/global/keyRings/keyring-name/cryptoKeys/key-name",
 *             secretEnv: {
 *                 PASSWORD: "ZW5jcnlwdGVkLXBhc3N3b3JkCg==",
 *             },
 *         }],
 *         source: {
 *             storageSource: {
 *                 bucket: "mybucket",
 *                 object: "source_code.tar.gz",
 *             },
 *         },
 *         steps: [{
 *             args: [
 *                 "cp",
 *                 "gs://mybucket/remotefile.zip",
 *                 "localfile.zip",
 *             ],
 *             name: "gcr.io/cloud-builders/gsutil",
 *             secretEnvs: ["MY_SECRET"],
 *             timeout: "120s",
 *         }],
 *         substitutions: {
 *             _BAZ: "qux",
 *             _FOO: "bar",
 *         },
 *         tags: [
 *             "build",
 *             "newFeature",
 *         ],
 *     },
 *     triggerTemplate: {
 *         branchName: "master",
 *         repoName: "my-repo",
 *     },
 * });
 * ```
 * ```python
 * import pulumi
 * import pulumi_gcp as gcp
 * 
 * build_trigger = gcp.cloudbuild.Trigger("build-trigger",
 *     build=gcp.cloudbuild.TriggerBuildArgs(
 *         artifacts=gcp.cloudbuild.TriggerBuildArtifactsArgs(
 *             images=["gcr.io/$PROJECT_ID/$REPO_NAME:$COMMIT_SHA"],
 *             objects=gcp.cloudbuild.TriggerBuildArtifactsObjectsArgs(
 *                 location="gs://bucket/path/to/somewhere/",
 *                 paths=["path"],
 *             ),
 *         ),
 *         available_secrets=gcp.cloudbuild.TriggerBuildAvailableSecretsArgs(
 *             secret_manager=[{
 *                 "env": "MY_SECRET",
 *                 "versionName": "projects/myProject/secrets/mySecret/versions/latest",
 *             }],
 *         ),
 *         logs_bucket="gs://mybucket/logs",
 *         options=gcp.cloudbuild.TriggerBuildOptionsArgs(
 *             disk_size_gb=100,
 *             dynamic_substitutions=True,
 *             env=["ekey = evalue"],
 *             log_streaming_option="STREAM_OFF",
 *             logging="LEGACY",
 *             machine_type="N1_HIGHCPU_8",
 *             requested_verify_option="VERIFIED",
 *             secret_env=["secretenv = svalue"],
 *             source_provenance_hash=["MD5"],
 *             substitution_option="ALLOW_LOOSE",
 *             volumes=[gcp.cloudbuild.TriggerBuildOptionsVolumeArgs(
 *                 name="v1",
 *                 path="v1",
 *             )],
 *             worker_pool="pool",
 *         ),
 *         queue_ttl="20s",
 *         secrets=[gcp.cloudbuild.TriggerBuildSecretArgs(
 *             kms_key_name="projects/myProject/locations/global/keyRings/keyring-name/cryptoKeys/key-name",
 *             secret_env={
 *                 "PASSWORD": "ZW5jcnlwdGVkLXBhc3N3b3JkCg==",
 *             },
 *         )],
 *         source=gcp.cloudbuild.TriggerBuildSourceArgs(
 *             storage_source=gcp.cloudbuild.TriggerBuildSourceStorageSourceArgs(
 *                 bucket="mybucket",
 *                 object="source_code.tar.gz",
 *             ),
 *         ),
 *         steps=[gcp.cloudbuild.TriggerBuildStepArgs(
 *             args=[
 *                 "cp",
 *                 "gs://mybucket/remotefile.zip",
 *                 "localfile.zip",
 *             ],
 *             name="gcr.io/cloud-builders/gsutil",
 *             secret_env=["MY_SECRET"],
 *             timeout="120s",
 *         )],
 *         substitutions={
 *             "_BAZ": "qux",
 *             "_FOO": "bar",
 *         },
 *         tags=[
 *             "build",
 *             "newFeature",
 *         ],
 *     ),
 *     trigger_template=gcp.cloudbuild.TriggerTriggerTemplateArgs(
 *         branch_name="master",
 *         repo_name="my-repo",
 *     ))
 * ```
 * ```csharp
 * using Pulumi;
 * using Gcp = Pulumi.Gcp;
 * 
 * class MyStack : Stack
 * {
 *     public MyStack()
 *     {
 *         var build_trigger = new Gcp.CloudBuild.Trigger("build-trigger", new Gcp.CloudBuild.TriggerArgs
 *         {
 *             Build = new Gcp.CloudBuild.Inputs.TriggerBuildArgs
 *             {
 *                 Artifacts = new Gcp.CloudBuild.Inputs.TriggerBuildArtifactsArgs
 *                 {
 *                     Images = 
 *                     {
 *                         "gcr.io/$PROJECT_ID/$REPO_NAME:$COMMIT_SHA",
 *                     },
 *                     Objects = new Gcp.CloudBuild.Inputs.TriggerBuildArtifactsObjectsArgs
 *                     {
 *                         Location = "gs://bucket/path/to/somewhere/",
 *                         Paths = 
 *                         {
 *                             "path",
 *                         },
 *                     },
 *                 },
 *                 AvailableSecrets = new Gcp.CloudBuild.Inputs.TriggerBuildAvailableSecretsArgs
 *                 {
 *                     SecretManager = 
 *                     {
 *                         
 *                         {
 *                             { "env", "MY_SECRET" },
 *                             { "versionName", "projects/myProject/secrets/mySecret/versions/latest" },
 *                         },
 *                     },
 *                 },
 *                 LogsBucket = "gs://mybucket/logs",
 *                 Options = new Gcp.CloudBuild.Inputs.TriggerBuildOptionsArgs
 *                 {
 *                     DiskSizeGb = 100,
 *                     DynamicSubstitutions = true,
 *                     Env = 
 *                     {
 *                         "ekey = evalue",
 *                     },
 *                     LogStreamingOption = "STREAM_OFF",
 *                     Logging = "LEGACY",
 *                     MachineType = "N1_HIGHCPU_8",
 *                     RequestedVerifyOption = "VERIFIED",
 *                     SecretEnv = 
 *                     {
 *                         "secretenv = svalue",
 *                     },
 *                     SourceProvenanceHash = 
 *                     {
 *                         "MD5",
 *                     },
 *                     SubstitutionOption = "ALLOW_LOOSE",
 *                     Volumes = 
 *                     {
 *                         new Gcp.CloudBuild.Inputs.TriggerBuildOptionsVolumeArgs
 *                         {
 *                             Name = "v1",
 *                             Path = "v1",
 *                         },
 *                     },
 *                     WorkerPool = "pool",
 *                 },
 *                 QueueTtl = "20s",
 *                 Secrets = 
 *                 {
 *                     new Gcp.CloudBuild.Inputs.TriggerBuildSecretArgs
 *                     {
 *                         KmsKeyName = "projects/myProject/locations/global/keyRings/keyring-name/cryptoKeys/key-name",
 *                         SecretEnv = 
 *                         {
 *                             { "PASSWORD", "ZW5jcnlwdGVkLXBhc3N3b3JkCg==" },
 *                         },
 *                     },
 *                 },
 *                 Source = new Gcp.CloudBuild.Inputs.TriggerBuildSourceArgs
 *                 {
 *                     StorageSource = new Gcp.CloudBuild.Inputs.TriggerBuildSourceStorageSourceArgs
 *                     {
 *                         Bucket = "mybucket",
 *                         Object = "source_code.tar.gz",
 *                     },
 *                 },
 *                 Steps = 
 *                 {
 *                     new Gcp.CloudBuild.Inputs.TriggerBuildStepArgs
 *                     {
 *                         Args = 
 *                         {
 *                             "cp",
 *                             "gs://mybucket/remotefile.zip",
 *                             "localfile.zip",
 *                         },
 *                         Name = "gcr.io/cloud-builders/gsutil",
 *                         SecretEnv = 
 *                         {
 *                             "MY_SECRET",
 *                         },
 *                         Timeout = "120s",
 *                     },
 *                 },
 *                 Substitutions = 
 *                 {
 *                     { "_BAZ", "qux" },
 *                     { "_FOO", "bar" },
 *                 },
 *                 Tags = 
 *                 {
 *                     "build",
 *                     "newFeature",
 *                 },
 *             },
 *             TriggerTemplate = new Gcp.CloudBuild.Inputs.TriggerTriggerTemplateArgs
 *             {
 *                 BranchName = "master",
 *                 RepoName = "my-repo",
 *             },
 *         });
 *     }
 * 
 * }
 * ```
 * ```go
 * package main
 * 
 * import (
 * 	"fmt"
 * 
 * 	"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/cloudbuild"
 * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
 * )
 * 
 * func main() {
 * 	pulumi.Run(func(ctx *pulumi.Context) error {
 * 		_, err := cloudbuild.NewTrigger(ctx, "build-trigger", &cloudbuild.TriggerArgs{
 * 			Build: &cloudbuild.TriggerBuildArgs{
 * 				Artifacts: &cloudbuild.TriggerBuildArtifactsArgs{
 * 					Images: pulumi.StringArray{
 * 						pulumi.String(fmt.Sprintf("%v%v%v%v%v%v%v", "gcr.io/", "$", "PROJECT_ID/", "$", "REPO_NAME:", "$", "COMMIT_SHA")),
 * 					},
 * 					Objects: &cloudbuild.TriggerBuildArtifactsObjectsArgs{
 * 						Location: pulumi.String("gs://bucket/path/to/somewhere/"),
 * 						Paths: pulumi.StringArray{
 * 							pulumi.String("path"),
 * 						},
 * 					},
 * 				},
 * 				AvailableSecrets: &cloudbuild.TriggerBuildAvailableSecretsArgs{
 * 					SecretManager: []map[string]interface{}{
 * 						map[string]interface{}{
 * 							"env":         "MY_SECRET",
 * 							"versionName": "projects/myProject/secrets/mySecret/versions/latest",
 * 						},
 * 					},
 * 				},
 * 				LogsBucket: pulumi.String("gs://mybucket/logs"),
 * 				Options: &cloudbuild.TriggerBuildOptionsArgs{
 * 					DiskSizeGb:           pulumi.Int(100),
 * 					DynamicSubstitutions: pulumi.Bool(true),
 * 					Env: []string{
 * 						"ekey = evalue",
 * 					},
 * 					LogStreamingOption:    pulumi.String("STREAM_OFF"),
 * 					Logging:               pulumi.String("LEGACY"),
 * 					MachineType:           pulumi.String("N1_HIGHCPU_8"),
 * 					RequestedVerifyOption: pulumi.String("VERIFIED"),
 * 					SecretEnv: []string{
 * 						"secretenv = svalue",
 * 					},
 * 					SourceProvenanceHash: []string{
 * 						"MD5",
 * 					},
 * 					SubstitutionOption: pulumi.String("ALLOW_LOOSE"),
 * 					Volumes: cloudbuild.TriggerBuildOptionsVolumeArray{
 * 						&cloudbuild.TriggerBuildOptionsVolumeArgs{
 * 							Name: pulumi.String("v1"),
 * 							Path: pulumi.String("v1"),
 * 						},
 * 					},
 * 					WorkerPool: pulumi.String("pool"),
 * 				},
 * 				QueueTtl: pulumi.String("20s"),
 * 				Secrets: cloudbuild.TriggerBuildSecretArray{
 * 					&cloudbuild.TriggerBuildSecretArgs{
 * 						KmsKeyName: pulumi.String("projects/myProject/locations/global/keyRings/keyring-name/cryptoKeys/key-name"),
 * 						SecretEnv: pulumi.StringMap{
 * 							"PASSWORD": pulumi.String("ZW5jcnlwdGVkLXBhc3N3b3JkCg=="),
 * 						},
 * 					},
 * 				},
 * 				Source: &cloudbuild.TriggerBuildSourceArgs{
 * 					StorageSource: &cloudbuild.TriggerBuildSourceStorageSourceArgs{
 * 						Bucket: pulumi.String("mybucket"),
 * 						Object: pulumi.String("source_code.tar.gz"),
 * 					},
 * 				},
 * 				Steps: cloudbuild.TriggerBuildStepArray{
 * 					&cloudbuild.TriggerBuildStepArgs{
 * 						Args: pulumi.StringArray{
 * 							pulumi.String("cp"),
 * 							pulumi.String("gs://mybucket/remotefile.zip"),
 * 							pulumi.String("localfile.zip"),
 * 						},
 * 						Name: pulumi.String("gcr.io/cloud-builders/gsutil"),
 * 						SecretEnv: []string{
 * 							"MY_SECRET",
 * 						},
 * 						Timeout: pulumi.String("120s"),
 * 					},
 * 				},
 * 				Substitutions: pulumi.StringMap{
 * 					"_BAZ": pulumi.String("qux"),
 * 					"_FOO": pulumi.String("bar"),
 * 				},
 * 				Tags: pulumi.StringArray{
 * 					pulumi.String("build"),
 * 					pulumi.String("newFeature"),
 * 				},
 * 			},
 * 			TriggerTemplate: &cloudbuild.TriggerTriggerTemplateArgs{
 * 				BranchName: pulumi.String("master"),
 * 				RepoName:   pulumi.String("my-repo"),
 * 			},
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		return nil
 * 	})
 * }
 * ```
 * {{% /example %}}
 * {{% example %}}
 * ### Cloudbuild Trigger Service Account
 * 
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as gcp from "@pulumi/gcp";
 * 
 * const project = gcp.organizations.getProject({});
 * const cloudbuildServiceAccount = new gcp.serviceaccount.Account("cloudbuildServiceAccount", {accountId: "my-service-account"});
 * const actAs = new gcp.projects.IAMMember("actAs", {
 *     project: project.then(project => project.projectId),
 *     role: "roles/iam.serviceAccountUser",
 *     member: pulumi.interpolate`serviceAccount:${cloudbuildServiceAccount.email}`,
 * });
 * const logsWriter = new gcp.projects.IAMMember("logsWriter", {
 *     project: project.then(project => project.projectId),
 *     role: "roles/logging.logWriter",
 *     member: pulumi.interpolate`serviceAccount:${cloudbuildServiceAccount.email}`,
 * });
 * const service_account_trigger = new gcp.cloudbuild.Trigger("service-account-trigger", {
 *     triggerTemplate: {
 *         branchName: "master",
 *         repoName: "my-repo",
 *     },
 *     serviceAccount: cloudbuildServiceAccount.id,
 *     filename: "cloudbuild.yaml",
 * }, {
 *     dependsOn: [
 *         actAs,
 *         logsWriter,
 *     ],
 * });
 * ```
 * ```python
 * import pulumi
 * import pulumi_gcp as gcp
 * 
 * project = gcp.organizations.get_project()
 * cloudbuild_service_account = gcp.service_account.Account("cloudbuildServiceAccount", account_id="my-service-account")
 * act_as = gcp.projects.IAMMember("actAs",
 *     project=project.project_id,
 *     role="roles/iam.serviceAccountUser",
 *     member=cloudbuild_service_account.email.apply(lambda email: f"serviceAccount:{email}"))
 * logs_writer = gcp.projects.IAMMember("logsWriter",
 *     project=project.project_id,
 *     role="roles/logging.logWriter",
 *     member=cloudbuild_service_account.email.apply(lambda email: f"serviceAccount:{email}"))
 * service_account_trigger = gcp.cloudbuild.Trigger("service-account-trigger",
 *     trigger_template=gcp.cloudbuild.TriggerTriggerTemplateArgs(
 *         branch_name="master",
 *         repo_name="my-repo",
 *     ),
 *     service_account=cloudbuild_service_account.id,
 *     filename="cloudbuild.yaml",
 *     opts=pulumi.ResourceOptions(depends_on=[
 *             act_as,
 *             logs_writer,
 *         ]))
 * ```
 * ```csharp
 * using Pulumi;
 * using Gcp = Pulumi.Gcp;
 * 
 * class MyStack : Stack
 * {
 *     public MyStack()
 *     {
 *         var project = Output.Create(Gcp.Organizations.GetProject.InvokeAsync());
 *         var cloudbuildServiceAccount = new Gcp.ServiceAccount.Account("cloudbuildServiceAccount", new Gcp.ServiceAccount.AccountArgs
 *         {
 *             AccountId = "my-service-account",
 *         });
 *         var actAs = new Gcp.Projects.IAMMember("actAs", new Gcp.Projects.IAMMemberArgs
 *         {
 *             Project = project.Apply(project => project.ProjectId),
 *             Role = "roles/iam.serviceAccountUser",
 *             Member = cloudbuildServiceAccount.Email.Apply(email => $"serviceAccount:{email}"),
 *         });
 *         var logsWriter = new Gcp.Projects.IAMMember("logsWriter", new Gcp.Projects.IAMMemberArgs
 *         {
 *             Project = project.Apply(project => project.ProjectId),
 *             Role = "roles/logging.logWriter",
 *             Member = cloudbuildServiceAccount.Email.Apply(email => $"serviceAccount:{email}"),
 *         });
 *         var service_account_trigger = new Gcp.CloudBuild.Trigger("service-account-trigger", new Gcp.CloudBuild.TriggerArgs
 *         {
 *             TriggerTemplate = new Gcp.CloudBuild.Inputs.TriggerTriggerTemplateArgs
 *             {
 *                 BranchName = "master",
 *                 RepoName = "my-repo",
 *             },
 *             ServiceAccount = cloudbuildServiceAccount.Id,
 *             Filename = "cloudbuild.yaml",
 *         }, new CustomResourceOptions
 *         {
 *             DependsOn = 
 *             {
 *                 actAs,
 *                 logsWriter,
 *             },
 *         });
 *     }
 * 
 * }
 * ```
 * ```go
 * package main
 * 
 * import (
 * 	"fmt"
 * 
 * 	"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/cloudbuild"
 * 	"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/organizations"
 * 	"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/projects"
 * 	"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/serviceAccount"
 * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
 * )
 * 
 * func main() {
 * 	pulumi.Run(func(ctx *pulumi.Context) error {
 * 		project, err := organizations.LookupProject(ctx, nil, nil)
 * 		if err != nil {
 * 			return err
 * 		}
 * 		cloudbuildServiceAccount, err := serviceAccount.NewAccount(ctx, "cloudbuildServiceAccount", &serviceAccount.AccountArgs{
 * 			AccountId: pulumi.String("my-service-account"),
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		actAs, err := projects.NewIAMMember(ctx, "actAs", &projects.IAMMemberArgs{
 * 			Project: pulumi.String(project.ProjectId),
 * 			Role:    pulumi.String("roles/iam.serviceAccountUser"),
 * 			Member: cloudbuildServiceAccount.Email.ApplyT(func(email string) (string, error) {
 * 				return fmt.Sprintf("%v%v", "serviceAccount:", email), nil
 * 			}).(pulumi.StringOutput),
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		logsWriter, err := projects.NewIAMMember(ctx, "logsWriter", &projects.IAMMemberArgs{
 * 			Project: pulumi.String(project.ProjectId),
 * 			Role:    pulumi.String("roles/logging.logWriter"),
 * 			Member: cloudbuildServiceAccount.Email.ApplyT(func(email string) (string, error) {
 * 				return fmt.Sprintf("%v%v", "serviceAccount:", email), nil
 * 			}).(pulumi.StringOutput),
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		_, err = cloudbuild.NewTrigger(ctx, "service-account-trigger", &cloudbuild.TriggerArgs{
 * 			TriggerTemplate: &cloudbuild.TriggerTriggerTemplateArgs{
 * 				BranchName: pulumi.String("master"),
 * 				RepoName:   pulumi.String("my-repo"),
 * 			},
 * 			ServiceAccount: cloudbuildServiceAccount.ID(),
 * 			Filename:       pulumi.String("cloudbuild.yaml"),
 * 		}, pulumi.DependsOn([]pulumi.Resource{
 * 			actAs,
 * 			logsWriter,
 * 		}))
 * 		if err != nil {
 * 			return err
 * 		}
 * 		return nil
 * 	})
 * }
 * ```
 * {{% /example %}}
 * {{% /examples %}}
 * 
 * ## Import
 * 
 * Trigger can be imported using any of these accepted formats
 * 
 * ```sh
 *  $ pulumi import gcp:cloudbuild/trigger:Trigger default projects/{{project}}/triggers/{{trigger_id}}
 * ```
 * 
 * 
 * 
 * ```sh
 *  $ pulumi import gcp:cloudbuild/trigger:Trigger default {{project}}/{{trigger_id}}
 * ```
 * 
 * 
 * 
 * ```sh
 *  $ pulumi import gcp:cloudbuild/trigger:Trigger default {{trigger_id}}
 * ```
 * 
 *  
 */
@ResourceType(type="gcp:cloudbuild/trigger:Trigger")
public class Trigger extends io.pulumi.resources.CustomResource {
    /**
     * Contents of the build template. Either a filename or build template must be provided.
     * Structure is documented below.
     * 
     */
    @Export(name="build", type=TriggerBuild.class, parameters={})
    private Output</* @Nullable */ TriggerBuild> build;

    /**
     * @return Contents of the build template. Either a filename or build template must be provided.
     * Structure is documented below.
     * 
     */
    public Output</* @Nullable */ TriggerBuild> getBuild() {
        return this.build;
    }
    /**
     * Time when the trigger was created.
     * 
     */
    @Export(name="createTime", type=String.class, parameters={})
    private Output<String> createTime;

    /**
     * @return Time when the trigger was created.
     * 
     */
    public Output<String> getCreateTime() {
        return this.createTime;
    }
    /**
     * Human-readable description of the trigger.
     * 
     */
    @Export(name="description", type=String.class, parameters={})
    private Output</* @Nullable */ String> description;

    /**
     * @return Human-readable description of the trigger.
     * 
     */
    public Output</* @Nullable */ String> getDescription() {
        return this.description;
    }
    /**
     * Whether the trigger is disabled or not. If true, the trigger will never result in a build.
     * 
     */
    @Export(name="disabled", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> disabled;

    /**
     * @return Whether the trigger is disabled or not. If true, the trigger will never result in a build.
     * 
     */
    public Output</* @Nullable */ Boolean> getDisabled() {
        return this.disabled;
    }
    /**
     * Path, from the source root, to a file whose contents is used for the template. Either a filename or build template must be provided.
     * 
     */
    @Export(name="filename", type=String.class, parameters={})
    private Output</* @Nullable */ String> filename;

    /**
     * @return Path, from the source root, to a file whose contents is used for the template. Either a filename or build template must be provided.
     * 
     */
    public Output</* @Nullable */ String> getFilename() {
        return this.filename;
    }
    /**
     * Describes the configuration of a trigger that creates a build whenever a GitHub event is received.
     * One of `trigger_template`, `github`, `pubsub_config` or `webhook_config` must be provided.
     * Structure is documented below.
     * 
     */
    @Export(name="github", type=TriggerGithub.class, parameters={})
    private Output</* @Nullable */ TriggerGithub> github;

    /**
     * @return Describes the configuration of a trigger that creates a build whenever a GitHub event is received.
     * One of `trigger_template`, `github`, `pubsub_config` or `webhook_config` must be provided.
     * Structure is documented below.
     * 
     */
    public Output</* @Nullable */ TriggerGithub> getGithub() {
        return this.github;
    }
    /**
     * ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
     * extended with support for `**`.
     * If ignoredFiles and changed files are both empty, then they are not
     * used to determine whether or not to trigger a build.
     * If ignoredFiles is not empty, then we ignore any files that match any
     * of the ignored_file globs. If the change has no files that are outside
     * of the ignoredFiles globs, then we do not trigger a build.
     * 
     */
    @Export(name="ignoredFiles", type=List.class, parameters={String.class})
    private Output</* @Nullable */ List<String>> ignoredFiles;

    /**
     * @return ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
     * extended with support for `**`.
     * If ignoredFiles and changed files are both empty, then they are not
     * used to determine whether or not to trigger a build.
     * If ignoredFiles is not empty, then we ignore any files that match any
     * of the ignored_file globs. If the change has no files that are outside
     * of the ignoredFiles globs, then we do not trigger a build.
     * 
     */
    public Output</* @Nullable */ List<String>> getIgnoredFiles() {
        return this.ignoredFiles;
    }
    /**
     * ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
     * extended with support for `**`.
     * If any of the files altered in the commit pass the ignoredFiles filter
     * and includedFiles is empty, then as far as this filter is concerned, we
     * should trigger the build.
     * If any of the files altered in the commit pass the ignoredFiles filter
     * and includedFiles is not empty, then we make sure that at least one of
     * those files matches a includedFiles glob. If not, then we do not trigger
     * a build.
     * 
     */
    @Export(name="includedFiles", type=List.class, parameters={String.class})
    private Output</* @Nullable */ List<String>> includedFiles;

    /**
     * @return ignoredFiles and includedFiles are file glob matches using https://golang.org/pkg/path/filepath/#Match
     * extended with support for `**`.
     * If any of the files altered in the commit pass the ignoredFiles filter
     * and includedFiles is empty, then as far as this filter is concerned, we
     * should trigger the build.
     * If any of the files altered in the commit pass the ignoredFiles filter
     * and includedFiles is not empty, then we make sure that at least one of
     * those files matches a includedFiles glob. If not, then we do not trigger
     * a build.
     * 
     */
    public Output</* @Nullable */ List<String>> getIncludedFiles() {
        return this.includedFiles;
    }
    /**
     * Name of the volume to mount.
     * Volume names must be unique per build step and must be valid names for Docker volumes.
     * Each named volume must be used by at least two build steps.
     * 
     */
    @Export(name="name", type=String.class, parameters={})
    private Output<String> name;

    /**
     * @return Name of the volume to mount.
     * Volume names must be unique per build step and must be valid names for Docker volumes.
     * Each named volume must be used by at least two build steps.
     * 
     */
    public Output<String> getName() {
        return this.name;
    }
    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    @Export(name="project", type=String.class, parameters={})
    private Output<String> project;

    /**
     * @return The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    public Output<String> getProject() {
        return this.project;
    }
    /**
     * PubsubConfig describes the configuration of a trigger that creates
     * a build whenever a Pub/Sub message is published.
     * One of `trigger_template`, `github`, `pubsub_config` or `webhook_config` must be provided.
     * Structure is documented below.
     * 
     */
    @Export(name="pubsubConfig", type=TriggerPubsubConfig.class, parameters={})
    private Output</* @Nullable */ TriggerPubsubConfig> pubsubConfig;

    /**
     * @return PubsubConfig describes the configuration of a trigger that creates
     * a build whenever a Pub/Sub message is published.
     * One of `trigger_template`, `github`, `pubsub_config` or `webhook_config` must be provided.
     * Structure is documented below.
     * 
     */
    public Output</* @Nullable */ TriggerPubsubConfig> getPubsubConfig() {
        return this.pubsubConfig;
    }
    /**
     * The service account used for all user-controlled operations including
     * triggers.patch, triggers.run, builds.create, and builds.cancel.
     * If no service account is set, then the standard Cloud Build service account
     * ([PROJECT_NUM]@system.gserviceaccount.com) will be used instead.
     * Format: projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT_ID_OR_EMAIL}
     * 
     */
    @Export(name="serviceAccount", type=String.class, parameters={})
    private Output</* @Nullable */ String> serviceAccount;

    /**
     * @return The service account used for all user-controlled operations including
     * triggers.patch, triggers.run, builds.create, and builds.cancel.
     * If no service account is set, then the standard Cloud Build service account
     * ([PROJECT_NUM]@system.gserviceaccount.com) will be used instead.
     * Format: projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT_ID_OR_EMAIL}
     * 
     */
    public Output</* @Nullable */ String> getServiceAccount() {
        return this.serviceAccount;
    }
    /**
     * Substitutions to use in a triggered build. Should only be used with triggers.run
     * 
     */
    @Export(name="substitutions", type=Map.class, parameters={String.class, String.class})
    private Output</* @Nullable */ Map<String,String>> substitutions;

    /**
     * @return Substitutions to use in a triggered build. Should only be used with triggers.run
     * 
     */
    public Output</* @Nullable */ Map<String,String>> getSubstitutions() {
        return this.substitutions;
    }
    /**
     * Tags for annotation of a Build. These are not docker tags.
     * 
     */
    @Export(name="tags", type=List.class, parameters={String.class})
    private Output</* @Nullable */ List<String>> tags;

    /**
     * @return Tags for annotation of a Build. These are not docker tags.
     * 
     */
    public Output</* @Nullable */ List<String>> getTags() {
        return this.tags;
    }
    /**
     * The unique identifier for the trigger.
     * 
     */
    @Export(name="triggerId", type=String.class, parameters={})
    private Output<String> triggerId;

    /**
     * @return The unique identifier for the trigger.
     * 
     */
    public Output<String> getTriggerId() {
        return this.triggerId;
    }
    /**
     * Template describing the types of source changes to trigger a build.
     * Branch and tag names in trigger templates are interpreted as regular
     * expressions. Any branch or tag change that matches that regular
     * expression will trigger a build.
     * One of `trigger_template`, `github`, `pubsub_config` or `webhook_config` must be provided.
     * Structure is documented below.
     * 
     */
    @Export(name="triggerTemplate", type=TriggerTriggerTemplate.class, parameters={})
    private Output</* @Nullable */ TriggerTriggerTemplate> triggerTemplate;

    /**
     * @return Template describing the types of source changes to trigger a build.
     * Branch and tag names in trigger templates are interpreted as regular
     * expressions. Any branch or tag change that matches that regular
     * expression will trigger a build.
     * One of `trigger_template`, `github`, `pubsub_config` or `webhook_config` must be provided.
     * Structure is documented below.
     * 
     */
    public Output</* @Nullable */ TriggerTriggerTemplate> getTriggerTemplate() {
        return this.triggerTemplate;
    }
    /**
     * WebhookConfig describes the configuration of a trigger that creates
     * a build whenever a webhook is sent to a trigger's webhook URL.
     * One of `trigger_template`, `github`, `pubsub_config` or `webhook_config` must be provided.
     * Structure is documented below.
     * 
     */
    @Export(name="webhookConfig", type=TriggerWebhookConfig.class, parameters={})
    private Output</* @Nullable */ TriggerWebhookConfig> webhookConfig;

    /**
     * @return WebhookConfig describes the configuration of a trigger that creates
     * a build whenever a webhook is sent to a trigger's webhook URL.
     * One of `trigger_template`, `github`, `pubsub_config` or `webhook_config` must be provided.
     * Structure is documented below.
     * 
     */
    public Output</* @Nullable */ TriggerWebhookConfig> getWebhookConfig() {
        return this.webhookConfig;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public Trigger(String name) {
        this(name, TriggerArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public Trigger(String name, @Nullable TriggerArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public Trigger(String name, @Nullable TriggerArgs args, @Nullable io.pulumi.resources.CustomResourceOptions options) {
        super("gcp:cloudbuild/trigger:Trigger", name, args == null ? TriggerArgs.Empty : args, makeResourceOptions(options, Output.empty()));
    }

    private Trigger(String name, Output<String> id, @Nullable TriggerState state, @Nullable io.pulumi.resources.CustomResourceOptions options) {
        super("gcp:cloudbuild/trigger:Trigger", name, state, makeResourceOptions(options, id));
    }

    private static io.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable io.pulumi.resources.CustomResourceOptions options, @Nullable Output<String> id) {
        var defaultOptions = io.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return io.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static Trigger get(String name, Output<String> id, @Nullable TriggerState state, @Nullable io.pulumi.resources.CustomResourceOptions options) {
        return new Trigger(name, id, state, options);
    }
}
