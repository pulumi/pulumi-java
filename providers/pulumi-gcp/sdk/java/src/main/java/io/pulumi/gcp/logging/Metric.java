// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package io.pulumi.gcp.logging;

import io.pulumi.core.Output;
import io.pulumi.core.annotations.Export;
import io.pulumi.core.annotations.ResourceType;
import io.pulumi.gcp.Utilities;
import io.pulumi.gcp.logging.MetricArgs;
import io.pulumi.gcp.logging.inputs.MetricState;
import io.pulumi.gcp.logging.outputs.MetricBucketOptions;
import io.pulumi.gcp.logging.outputs.MetricMetricDescriptor;
import java.lang.String;
import java.util.Map;
import javax.annotation.Nullable;

/**
 * Logs-based metric can also be used to extract values from logs and create a a distribution
 * of the values. The distribution records the statistics of the extracted values along with
 * an optional histogram of the values as specified by the bucket options.
 * 
 * 
 * To get more information about Metric, see:
 * 
 * * [API documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/projects.metrics/create)
 * * How-to Guides
 *     * [Official Documentation](https://cloud.google.com/logging/docs/apis)
 * 
 * {{% examples %}}
 * ## Example Usage
 * {{% example %}}
 * ### Logging Metric Basic
 * 
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as gcp from "@pulumi/gcp";
 * 
 * const loggingMetric = new gcp.logging.Metric("logging_metric", {
 *     bucketOptions: {
 *         linearBuckets: {
 *             numFiniteBuckets: 3,
 *             offset: 1,
 *             width: 1,
 *         },
 *     },
 *     filter: "resource.type=gae_app AND severity>=ERROR",
 *     labelExtractors: {
 *         mass: "EXTRACT(jsonPayload.request)",
 *         sku: "EXTRACT(jsonPayload.id)",
 *     },
 *     metricDescriptor: {
 *         displayName: "My metric",
 *         labels: [
 *             {
 *                 description: "amount of matter",
 *                 key: "mass",
 *                 valueType: "STRING",
 *             },
 *             {
 *                 description: "Identifying number for item",
 *                 key: "sku",
 *                 valueType: "INT64",
 *             },
 *         ],
 *         metricKind: "DELTA",
 *         unit: "1",
 *         valueType: "DISTRIBUTION",
 *     },
 *     valueExtractor: "EXTRACT(jsonPayload.request)",
 * });
 * ```
 * ```python
 * import pulumi
 * import pulumi_gcp as gcp
 * 
 * logging_metric = gcp.logging.Metric("loggingMetric",
 *     bucket_options=gcp.logging.MetricBucketOptionsArgs(
 *         linear_buckets=gcp.logging.MetricBucketOptionsLinearBucketsArgs(
 *             num_finite_buckets=3,
 *             offset=1,
 *             width=1,
 *         ),
 *     ),
 *     filter="resource.type=gae_app AND severity>=ERROR",
 *     label_extractors={
 *         "mass": "EXTRACT(jsonPayload.request)",
 *         "sku": "EXTRACT(jsonPayload.id)",
 *     },
 *     metric_descriptor=gcp.logging.MetricMetricDescriptorArgs(
 *         display_name="My metric",
 *         labels=[
 *             gcp.logging.MetricMetricDescriptorLabelArgs(
 *                 description="amount of matter",
 *                 key="mass",
 *                 value_type="STRING",
 *             ),
 *             gcp.logging.MetricMetricDescriptorLabelArgs(
 *                 description="Identifying number for item",
 *                 key="sku",
 *                 value_type="INT64",
 *             ),
 *         ],
 *         metric_kind="DELTA",
 *         unit="1",
 *         value_type="DISTRIBUTION",
 *     ),
 *     value_extractor="EXTRACT(jsonPayload.request)")
 * ```
 * ```csharp
 * using Pulumi;
 * using Gcp = Pulumi.Gcp;
 * 
 * class MyStack : Stack
 * {
 *     public MyStack()
 *     {
 *         var loggingMetric = new Gcp.Logging.Metric("loggingMetric", new Gcp.Logging.MetricArgs
 *         {
 *             BucketOptions = new Gcp.Logging.Inputs.MetricBucketOptionsArgs
 *             {
 *                 LinearBuckets = new Gcp.Logging.Inputs.MetricBucketOptionsLinearBucketsArgs
 *                 {
 *                     NumFiniteBuckets = 3,
 *                     Offset = 1,
 *                     Width = 1,
 *                 },
 *             },
 *             Filter = "resource.type=gae_app AND severity>=ERROR",
 *             LabelExtractors = 
 *             {
 *                 { "mass", "EXTRACT(jsonPayload.request)" },
 *                 { "sku", "EXTRACT(jsonPayload.id)" },
 *             },
 *             MetricDescriptor = new Gcp.Logging.Inputs.MetricMetricDescriptorArgs
 *             {
 *                 DisplayName = "My metric",
 *                 Labels = 
 *                 {
 *                     new Gcp.Logging.Inputs.MetricMetricDescriptorLabelArgs
 *                     {
 *                         Description = "amount of matter",
 *                         Key = "mass",
 *                         ValueType = "STRING",
 *                     },
 *                     new Gcp.Logging.Inputs.MetricMetricDescriptorLabelArgs
 *                     {
 *                         Description = "Identifying number for item",
 *                         Key = "sku",
 *                         ValueType = "INT64",
 *                     },
 *                 },
 *                 MetricKind = "DELTA",
 *                 Unit = "1",
 *                 ValueType = "DISTRIBUTION",
 *             },
 *             ValueExtractor = "EXTRACT(jsonPayload.request)",
 *         });
 *     }
 * 
 * }
 * ```
 * ```go
 * package main
 * 
 * import (
 * 	"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/logging"
 * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
 * )
 * 
 * func main() {
 * 	pulumi.Run(func(ctx *pulumi.Context) error {
 * 		_, err := logging.NewMetric(ctx, "loggingMetric", &logging.MetricArgs{
 * 			BucketOptions: &logging.MetricBucketOptionsArgs{
 * 				LinearBuckets: &logging.MetricBucketOptionsLinearBucketsArgs{
 * 					NumFiniteBuckets: pulumi.Int(3),
 * 					Offset:           pulumi.Float64(1),
 * 					Width:            pulumi.Float64(1),
 * 				},
 * 			},
 * 			Filter: pulumi.String("resource.type=gae_app AND severity>=ERROR"),
 * 			LabelExtractors: pulumi.StringMap{
 * 				"mass": pulumi.String("EXTRACT(jsonPayload.request)"),
 * 				"sku":  pulumi.String("EXTRACT(jsonPayload.id)"),
 * 			},
 * 			MetricDescriptor: &logging.MetricMetricDescriptorArgs{
 * 				DisplayName: pulumi.String("My metric"),
 * 				Labels: logging.MetricMetricDescriptorLabelArray{
 * 					&logging.MetricMetricDescriptorLabelArgs{
 * 						Description: pulumi.String("amount of matter"),
 * 						Key:         pulumi.String("mass"),
 * 						ValueType:   pulumi.String("STRING"),
 * 					},
 * 					&logging.MetricMetricDescriptorLabelArgs{
 * 						Description: pulumi.String("Identifying number for item"),
 * 						Key:         pulumi.String("sku"),
 * 						ValueType:   pulumi.String("INT64"),
 * 					},
 * 				},
 * 				MetricKind: pulumi.String("DELTA"),
 * 				Unit:       pulumi.String("1"),
 * 				ValueType:  pulumi.String("DISTRIBUTION"),
 * 			},
 * 			ValueExtractor: pulumi.String("EXTRACT(jsonPayload.request)"),
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		return nil
 * 	})
 * }
 * ```
 * {{% /example %}}
 * {{% example %}}
 * ### Logging Metric Counter Basic
 * 
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as gcp from "@pulumi/gcp";
 * 
 * const loggingMetric = new gcp.logging.Metric("logging_metric", {
 *     filter: "resource.type=gae_app AND severity>=ERROR",
 *     metricDescriptor: {
 *         metricKind: "DELTA",
 *         valueType: "INT64",
 *     },
 * });
 * ```
 * ```python
 * import pulumi
 * import pulumi_gcp as gcp
 * 
 * logging_metric = gcp.logging.Metric("loggingMetric",
 *     filter="resource.type=gae_app AND severity>=ERROR",
 *     metric_descriptor=gcp.logging.MetricMetricDescriptorArgs(
 *         metric_kind="DELTA",
 *         value_type="INT64",
 *     ))
 * ```
 * ```csharp
 * using Pulumi;
 * using Gcp = Pulumi.Gcp;
 * 
 * class MyStack : Stack
 * {
 *     public MyStack()
 *     {
 *         var loggingMetric = new Gcp.Logging.Metric("loggingMetric", new Gcp.Logging.MetricArgs
 *         {
 *             Filter = "resource.type=gae_app AND severity>=ERROR",
 *             MetricDescriptor = new Gcp.Logging.Inputs.MetricMetricDescriptorArgs
 *             {
 *                 MetricKind = "DELTA",
 *                 ValueType = "INT64",
 *             },
 *         });
 *     }
 * 
 * }
 * ```
 * ```go
 * package main
 * 
 * import (
 * 	"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/logging"
 * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
 * )
 * 
 * func main() {
 * 	pulumi.Run(func(ctx *pulumi.Context) error {
 * 		_, err := logging.NewMetric(ctx, "loggingMetric", &logging.MetricArgs{
 * 			Filter: pulumi.String("resource.type=gae_app AND severity>=ERROR"),
 * 			MetricDescriptor: &logging.MetricMetricDescriptorArgs{
 * 				MetricKind: pulumi.String("DELTA"),
 * 				ValueType:  pulumi.String("INT64"),
 * 			},
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		return nil
 * 	})
 * }
 * ```
 * {{% /example %}}
 * {{% example %}}
 * ### Logging Metric Counter Labels
 * 
 * 
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as gcp from "@pulumi/gcp";
 * 
 * const loggingMetric = new gcp.logging.Metric("logging_metric", {
 *     filter: "resource.type=gae_app AND severity>=ERROR",
 *     labelExtractors: {
 *         mass: "EXTRACT(jsonPayload.request)",
 *     },
 *     metricDescriptor: {
 *         labels: [{
 *             description: "amount of matter",
 *             key: "mass",
 *             valueType: "STRING",
 *         }],
 *         metricKind: "DELTA",
 *         valueType: "INT64",
 *     },
 * });
 * ```
 * ```python
 * import pulumi
 * import pulumi_gcp as gcp
 * 
 * logging_metric = gcp.logging.Metric("loggingMetric",
 *     filter="resource.type=gae_app AND severity>=ERROR",
 *     label_extractors={
 *         "mass": "EXTRACT(jsonPayload.request)",
 *     },
 *     metric_descriptor=gcp.logging.MetricMetricDescriptorArgs(
 *         labels=[gcp.logging.MetricMetricDescriptorLabelArgs(
 *             description="amount of matter",
 *             key="mass",
 *             value_type="STRING",
 *         )],
 *         metric_kind="DELTA",
 *         value_type="INT64",
 *     ))
 * ```
 * ```csharp
 * using Pulumi;
 * using Gcp = Pulumi.Gcp;
 * 
 * class MyStack : Stack
 * {
 *     public MyStack()
 *     {
 *         var loggingMetric = new Gcp.Logging.Metric("loggingMetric", new Gcp.Logging.MetricArgs
 *         {
 *             Filter = "resource.type=gae_app AND severity>=ERROR",
 *             LabelExtractors = 
 *             {
 *                 { "mass", "EXTRACT(jsonPayload.request)" },
 *             },
 *             MetricDescriptor = new Gcp.Logging.Inputs.MetricMetricDescriptorArgs
 *             {
 *                 Labels = 
 *                 {
 *                     new Gcp.Logging.Inputs.MetricMetricDescriptorLabelArgs
 *                     {
 *                         Description = "amount of matter",
 *                         Key = "mass",
 *                         ValueType = "STRING",
 *                     },
 *                 },
 *                 MetricKind = "DELTA",
 *                 ValueType = "INT64",
 *             },
 *         });
 *     }
 * 
 * }
 * ```
 * ```go
 * package main
 * 
 * import (
 * 	"github.com/pulumi/pulumi-gcp/sdk/v6/go/gcp/logging"
 * 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
 * )
 * 
 * func main() {
 * 	pulumi.Run(func(ctx *pulumi.Context) error {
 * 		_, err := logging.NewMetric(ctx, "loggingMetric", &logging.MetricArgs{
 * 			Filter: pulumi.String("resource.type=gae_app AND severity>=ERROR"),
 * 			LabelExtractors: pulumi.StringMap{
 * 				"mass": pulumi.String("EXTRACT(jsonPayload.request)"),
 * 			},
 * 			MetricDescriptor: &logging.MetricMetricDescriptorArgs{
 * 				Labels: logging.MetricMetricDescriptorLabelArray{
 * 					&logging.MetricMetricDescriptorLabelArgs{
 * 						Description: pulumi.String("amount of matter"),
 * 						Key:         pulumi.String("mass"),
 * 						ValueType:   pulumi.String("STRING"),
 * 					},
 * 				},
 * 				MetricKind: pulumi.String("DELTA"),
 * 				ValueType:  pulumi.String("INT64"),
 * 			},
 * 		})
 * 		if err != nil {
 * 			return err
 * 		}
 * 		return nil
 * 	})
 * }
 * ```
 * {{% /example %}}
 * {{% /examples %}}
 * 
 * ## Import
 * 
 * Metric can be imported using any of these accepted formats
 * 
 * ```sh
 *  $ pulumi import gcp:logging/metric:Metric default {{project}} {{name}}
 * ```
 * 
 * 
 * 
 * ```sh
 *  $ pulumi import gcp:logging/metric:Metric default {{name}}
 * ```
 * 
 *  
 */
@ResourceType(type="gcp:logging/metric:Metric")
public class Metric extends io.pulumi.resources.CustomResource {
    /**
     * The bucketOptions are required when the logs-based metric is using a DISTRIBUTION value type and it
     * describes the bucket boundaries used to create a histogram of the extracted values.
     * Structure is documented below.
     * 
     */
    @Export(name="bucketOptions", type=MetricBucketOptions.class, parameters={})
    private Output</* @Nullable */ MetricBucketOptions> bucketOptions;

    /**
     * @return The bucketOptions are required when the logs-based metric is using a DISTRIBUTION value type and it
     * describes the bucket boundaries used to create a histogram of the extracted values.
     * Structure is documented below.
     * 
     */
    public Output</* @Nullable */ MetricBucketOptions> getBucketOptions() {
        return this.bucketOptions;
    }
    /**
     * A description of this metric, which is used in documentation. The maximum length of the
     * description is 8000 characters.
     * 
     */
    @Export(name="description", type=String.class, parameters={})
    private Output</* @Nullable */ String> description;

    /**
     * @return A description of this metric, which is used in documentation. The maximum length of the
     * description is 8000 characters.
     * 
     */
    public Output</* @Nullable */ String> getDescription() {
        return this.description;
    }
    /**
     * An advanced logs filter (https://cloud.google.com/logging/docs/view/advanced-filters) which
     * is used to match log entries.
     * 
     */
    @Export(name="filter", type=String.class, parameters={})
    private Output<String> filter;

    /**
     * @return An advanced logs filter (https://cloud.google.com/logging/docs/view/advanced-filters) which
     * is used to match log entries.
     * 
     */
    public Output<String> getFilter() {
        return this.filter;
    }
    /**
     * A map from a label key string to an extractor expression which is used to extract data from a log
     * entry field and assign as the label value. Each label key specified in the LabelDescriptor must
     * have an associated extractor expression in this map. The syntax of the extractor expression is
     * the same as for the valueExtractor field.
     * 
     */
    @Export(name="labelExtractors", type=Map.class, parameters={String.class, String.class})
    private Output</* @Nullable */ Map<String,String>> labelExtractors;

    /**
     * @return A map from a label key string to an extractor expression which is used to extract data from a log
     * entry field and assign as the label value. Each label key specified in the LabelDescriptor must
     * have an associated extractor expression in this map. The syntax of the extractor expression is
     * the same as for the valueExtractor field.
     * 
     */
    public Output</* @Nullable */ Map<String,String>> getLabelExtractors() {
        return this.labelExtractors;
    }
    /**
     * The metric descriptor associated with the logs-based metric.
     * Structure is documented below.
     * 
     */
    @Export(name="metricDescriptor", type=MetricMetricDescriptor.class, parameters={})
    private Output<MetricMetricDescriptor> metricDescriptor;

    /**
     * @return The metric descriptor associated with the logs-based metric.
     * Structure is documented below.
     * 
     */
    public Output<MetricMetricDescriptor> getMetricDescriptor() {
        return this.metricDescriptor;
    }
    /**
     * The client-assigned metric identifier. Examples - "error_count", "nginx/requests".
     * Metric identifiers are limited to 100 characters and can include only the following
     * characters A-Z, a-z, 0-9, and the special characters _-.,+!*',()%/. The forward-slash
     * character (/) denotes a hierarchy of name pieces, and it cannot be the first character
     * of the name.
     * 
     */
    @Export(name="name", type=String.class, parameters={})
    private Output<String> name;

    /**
     * @return The client-assigned metric identifier. Examples - "error_count", "nginx/requests".
     * Metric identifiers are limited to 100 characters and can include only the following
     * characters A-Z, a-z, 0-9, and the special characters _-.,+!*',()%/. The forward-slash
     * character (/) denotes a hierarchy of name pieces, and it cannot be the first character
     * of the name.
     * 
     */
    public Output<String> getName() {
        return this.name;
    }
    /**
     * The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    @Export(name="project", type=String.class, parameters={})
    private Output<String> project;

    /**
     * @return The ID of the project in which the resource belongs.
     * If it is not provided, the provider project is used.
     * 
     */
    public Output<String> getProject() {
        return this.project;
    }
    /**
     * A valueExtractor is required when using a distribution logs-based metric to extract the values to
     * record from a log entry. Two functions are supported for value extraction - EXTRACT(field) or
     * REGEXP_EXTRACT(field, regex). The argument are 1. field - The name of the log entry field from which
     * the value is to be extracted. 2. regex - A regular expression using the Google RE2 syntax
     * (https://github.com/google/re2/wiki/Syntax) with a single capture group to extract data from the specified
     * log entry field. The value of the field is converted to a string before applying the regex. It is an
     * error to specify a regex that does not include exactly one capture group.
     * 
     */
    @Export(name="valueExtractor", type=String.class, parameters={})
    private Output</* @Nullable */ String> valueExtractor;

    /**
     * @return A valueExtractor is required when using a distribution logs-based metric to extract the values to
     * record from a log entry. Two functions are supported for value extraction - EXTRACT(field) or
     * REGEXP_EXTRACT(field, regex). The argument are 1. field - The name of the log entry field from which
     * the value is to be extracted. 2. regex - A regular expression using the Google RE2 syntax
     * (https://github.com/google/re2/wiki/Syntax) with a single capture group to extract data from the specified
     * log entry field. The value of the field is converted to a string before applying the regex. It is an
     * error to specify a regex that does not include exactly one capture group.
     * 
     */
    public Output</* @Nullable */ String> getValueExtractor() {
        return this.valueExtractor;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public Metric(String name) {
        this(name, MetricArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public Metric(String name, MetricArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public Metric(String name, MetricArgs args, @Nullable io.pulumi.resources.CustomResourceOptions options) {
        super("gcp:logging/metric:Metric", name, args == null ? MetricArgs.Empty : args, makeResourceOptions(options, Output.empty()));
    }

    private Metric(String name, Output<String> id, @Nullable MetricState state, @Nullable io.pulumi.resources.CustomResourceOptions options) {
        super("gcp:logging/metric:Metric", name, state, makeResourceOptions(options, id));
    }

    private static io.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable io.pulumi.resources.CustomResourceOptions options, @Nullable Output<String> id) {
        var defaultOptions = io.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return io.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static Metric get(String name, Output<String> id, @Nullable MetricState state, @Nullable io.pulumi.resources.CustomResourceOptions options) {
        return new Metric(name, id, state, options);
    }
}
