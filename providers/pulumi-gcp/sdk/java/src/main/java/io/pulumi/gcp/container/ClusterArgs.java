// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package io.pulumi.gcp.container;

import io.pulumi.core.Output;
import io.pulumi.core.annotations.Import;
import io.pulumi.core.internal.Codegen;
import io.pulumi.gcp.container.inputs.ClusterAddonsConfigArgs;
import io.pulumi.gcp.container.inputs.ClusterAuthenticatorGroupsConfigArgs;
import io.pulumi.gcp.container.inputs.ClusterClusterAutoscalingArgs;
import io.pulumi.gcp.container.inputs.ClusterClusterTelemetryArgs;
import io.pulumi.gcp.container.inputs.ClusterConfidentialNodesArgs;
import io.pulumi.gcp.container.inputs.ClusterDatabaseEncryptionArgs;
import io.pulumi.gcp.container.inputs.ClusterDefaultSnatStatusArgs;
import io.pulumi.gcp.container.inputs.ClusterDnsConfigArgs;
import io.pulumi.gcp.container.inputs.ClusterIdentityServiceConfigArgs;
import io.pulumi.gcp.container.inputs.ClusterIpAllocationPolicyArgs;
import io.pulumi.gcp.container.inputs.ClusterLoggingConfigArgs;
import io.pulumi.gcp.container.inputs.ClusterMaintenancePolicyArgs;
import io.pulumi.gcp.container.inputs.ClusterMasterAuthArgs;
import io.pulumi.gcp.container.inputs.ClusterMasterAuthorizedNetworksConfigArgs;
import io.pulumi.gcp.container.inputs.ClusterMonitoringConfigArgs;
import io.pulumi.gcp.container.inputs.ClusterNetworkPolicyArgs;
import io.pulumi.gcp.container.inputs.ClusterNodeConfigArgs;
import io.pulumi.gcp.container.inputs.ClusterNodePoolArgs;
import io.pulumi.gcp.container.inputs.ClusterNotificationConfigArgs;
import io.pulumi.gcp.container.inputs.ClusterPodSecurityPolicyConfigArgs;
import io.pulumi.gcp.container.inputs.ClusterPrivateClusterConfigArgs;
import io.pulumi.gcp.container.inputs.ClusterReleaseChannelArgs;
import io.pulumi.gcp.container.inputs.ClusterResourceUsageExportConfigArgs;
import io.pulumi.gcp.container.inputs.ClusterVerticalPodAutoscalingArgs;
import io.pulumi.gcp.container.inputs.ClusterWorkloadIdentityConfigArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import javax.annotation.Nullable;


public final class ClusterArgs extends io.pulumi.resources.ResourceArgs {

    public static final ClusterArgs Empty = new ClusterArgs();

    /**
     * The configuration for addons supported by GKE.
     * Structure is documented below.
     * 
     */
    @Import(name="addonsConfig")
      private final @Nullable Output<ClusterAddonsConfigArgs> addonsConfig;

    public Output<ClusterAddonsConfigArgs> addonsConfig() {
        return this.addonsConfig == null ? Codegen.empty() : this.addonsConfig;
    }

    /**
     * Configuration for the
     * [Google Groups for GKE](https://cloud.google.com/kubernetes-engine/docs/how-to/role-based-access-control#groups-setup-gsuite) feature.
     * Structure is documented below.
     * 
     */
    @Import(name="authenticatorGroupsConfig")
      private final @Nullable Output<ClusterAuthenticatorGroupsConfigArgs> authenticatorGroupsConfig;

    public Output<ClusterAuthenticatorGroupsConfigArgs> authenticatorGroupsConfig() {
        return this.authenticatorGroupsConfig == null ? Codegen.empty() : this.authenticatorGroupsConfig;
    }

    /**
     * Per-cluster configuration of Node Auto-Provisioning with Cluster Autoscaler to
     * automatically adjust the size of the cluster and create/delete node pools based
     * on the current needs of the cluster's workload. See the
     * [guide to using Node Auto-Provisioning](https://cloud.google.com/kubernetes-engine/docs/how-to/node-auto-provisioning)
     * for more details. Structure is documented below.
     * 
     */
    @Import(name="clusterAutoscaling")
      private final @Nullable Output<ClusterClusterAutoscalingArgs> clusterAutoscaling;

    public Output<ClusterClusterAutoscalingArgs> clusterAutoscaling() {
        return this.clusterAutoscaling == null ? Codegen.empty() : this.clusterAutoscaling;
    }

    /**
     * The IP address range of the Kubernetes pods
     * in this cluster in CIDR notation (e.g. `10.96.0.0/14`). Leave blank to have one
     * automatically chosen or specify a `/14` block in `10.0.0.0/8`. This field will
     * only work for routes-based clusters, where `ip_allocation_policy` is not defined.
     * 
     */
    @Import(name="clusterIpv4Cidr")
      private final @Nullable Output<String> clusterIpv4Cidr;

    public Output<String> clusterIpv4Cidr() {
        return this.clusterIpv4Cidr == null ? Codegen.empty() : this.clusterIpv4Cidr;
    }

    /**
     * Configuration for
     * [ClusterTelemetry](https://cloud.google.com/monitoring/kubernetes-engine/installing#controlling_the_collection_of_application_logs) feature,
     * Structure is documented below.
     * 
     */
    @Import(name="clusterTelemetry")
      private final @Nullable Output<ClusterClusterTelemetryArgs> clusterTelemetry;

    public Output<ClusterClusterTelemetryArgs> clusterTelemetry() {
        return this.clusterTelemetry == null ? Codegen.empty() : this.clusterTelemetry;
    }

    /**
     * Configuration for [Confidential Nodes](https://cloud.google.com/kubernetes-engine/docs/how-to/confidential-gke-nodes) feature. Structure is documented below documented below.
     * 
     */
    @Import(name="confidentialNodes")
      private final @Nullable Output<ClusterConfidentialNodesArgs> confidentialNodes;

    public Output<ClusterConfidentialNodesArgs> confidentialNodes() {
        return this.confidentialNodes == null ? Codegen.empty() : this.confidentialNodes;
    }

    /**
     * Structure is documented below.
     * 
     */
    @Import(name="databaseEncryption")
      private final @Nullable Output<ClusterDatabaseEncryptionArgs> databaseEncryption;

    public Output<ClusterDatabaseEncryptionArgs> databaseEncryption() {
        return this.databaseEncryption == null ? Codegen.empty() : this.databaseEncryption;
    }

    /**
     * The desired datapath provider for this cluster. By default, uses the IPTables-based kube-proxy implementation.
     * 
     */
    @Import(name="datapathProvider")
      private final @Nullable Output<String> datapathProvider;

    public Output<String> datapathProvider() {
        return this.datapathProvider == null ? Codegen.empty() : this.datapathProvider;
    }

    /**
     * The default maximum number of pods
     * per node in this cluster. This doesn't work on "routes-based" clusters, clusters
     * that don't have IP Aliasing enabled. See the [official documentation](https://cloud.google.com/kubernetes-engine/docs/how-to/flexible-pod-cidr)
     * for more information.
     * 
     */
    @Import(name="defaultMaxPodsPerNode")
      private final @Nullable Output<Integer> defaultMaxPodsPerNode;

    public Output<Integer> defaultMaxPodsPerNode() {
        return this.defaultMaxPodsPerNode == null ? Codegen.empty() : this.defaultMaxPodsPerNode;
    }

    /**
     * [GKE SNAT](https://cloud.google.com/kubernetes-engine/docs/how-to/ip-masquerade-agent#how_ipmasq_works) DefaultSnatStatus contains the desired state of whether default sNAT should be disabled on the cluster, [API doc](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1beta1/projects.locations.clusters#networkconfig). Structure is documented below
     * 
     */
    @Import(name="defaultSnatStatus")
      private final @Nullable Output<ClusterDefaultSnatStatusArgs> defaultSnatStatus;

    public Output<ClusterDefaultSnatStatusArgs> defaultSnatStatus() {
        return this.defaultSnatStatus == null ? Codegen.empty() : this.defaultSnatStatus;
    }

    /**
     * Description of the cluster.
     * 
     */
    @Import(name="description")
      private final @Nullable Output<String> description;

    public Output<String> description() {
        return this.description == null ? Codegen.empty() : this.description;
    }

    /**
     * Configuration for [Using Cloud DNS for GKE](https://cloud.google.com/kubernetes-engine/docs/how-to/cloud-dns). Structure is documented below.
     * 
     */
    @Import(name="dnsConfig")
      private final @Nullable Output<ClusterDnsConfigArgs> dnsConfig;

    public Output<ClusterDnsConfigArgs> dnsConfig() {
        return this.dnsConfig == null ? Codegen.empty() : this.dnsConfig;
    }

    /**
     * Enable Autopilot for this cluster. Defaults to `false`.
     * Note that when this option is enabled, certain features of Standard GKE are not available.
     * See the [official documentation](https://cloud.google.com/kubernetes-engine/docs/concepts/autopilot-overview#comparison)
     * for available features.
     * 
     */
    @Import(name="enableAutopilot")
      private final @Nullable Output<Boolean> enableAutopilot;

    public Output<Boolean> enableAutopilot() {
        return this.enableAutopilot == null ? Codegen.empty() : this.enableAutopilot;
    }

    /**
     * Enable Binary Authorization for this cluster.
     * If enabled, all container images will be validated by Google Binary Authorization.
     * 
     */
    @Import(name="enableBinaryAuthorization")
      private final @Nullable Output<Boolean> enableBinaryAuthorization;

    public Output<Boolean> enableBinaryAuthorization() {
        return this.enableBinaryAuthorization == null ? Codegen.empty() : this.enableBinaryAuthorization;
    }

    /**
     * Whether Intra-node visibility is enabled for this cluster. This makes same node pod to pod traffic visible for VPC network.
     * 
     */
    @Import(name="enableIntranodeVisibility")
      private final @Nullable Output<Boolean> enableIntranodeVisibility;

    public Output<Boolean> enableIntranodeVisibility() {
        return this.enableIntranodeVisibility == null ? Codegen.empty() : this.enableIntranodeVisibility;
    }

    /**
     * Whether to enable Kubernetes Alpha features for
     * this cluster. Note that when this option is enabled, the cluster cannot be upgraded
     * and will be automatically deleted after 30 days.
     * 
     */
    @Import(name="enableKubernetesAlpha")
      private final @Nullable Output<Boolean> enableKubernetesAlpha;

    public Output<Boolean> enableKubernetesAlpha() {
        return this.enableKubernetesAlpha == null ? Codegen.empty() : this.enableKubernetesAlpha;
    }

    /**
     * Whether L4ILB Subsetting is enabled for this cluster.
     * 
     */
    @Import(name="enableL4IlbSubsetting")
      private final @Nullable Output<Boolean> enableL4IlbSubsetting;

    public Output<Boolean> enableL4IlbSubsetting() {
        return this.enableL4IlbSubsetting == null ? Codegen.empty() : this.enableL4IlbSubsetting;
    }

    /**
     * Whether the ABAC authorizer is enabled for this cluster.
     * When enabled, identities in the system, including service accounts, nodes, and controllers,
     * will have statically granted permissions beyond those provided by the RBAC configuration or IAM.
     * Defaults to `false`
     * 
     */
    @Import(name="enableLegacyAbac")
      private final @Nullable Output<Boolean> enableLegacyAbac;

    public Output<Boolean> enableLegacyAbac() {
        return this.enableLegacyAbac == null ? Codegen.empty() : this.enableLegacyAbac;
    }

    /**
     * Enable Shielded Nodes features on all nodes in this cluster.  Defaults to `true`.
     * 
     */
    @Import(name="enableShieldedNodes")
      private final @Nullable Output<Boolean> enableShieldedNodes;

    public Output<Boolean> enableShieldedNodes() {
        return this.enableShieldedNodes == null ? Codegen.empty() : this.enableShieldedNodes;
    }

    /**
     * Whether to enable Cloud TPU resources in this cluster.
     * See the [official documentation](https://cloud.google.com/tpu/docs/kubernetes-engine-setup).
     * 
     */
    @Import(name="enableTpu")
      private final @Nullable Output<Boolean> enableTpu;

    public Output<Boolean> enableTpu() {
        return this.enableTpu == null ? Codegen.empty() : this.enableTpu;
    }

    /**
     * . Structure is documented below.
     * 
     */
    @Import(name="identityServiceConfig")
      private final @Nullable Output<ClusterIdentityServiceConfigArgs> identityServiceConfig;

    public Output<ClusterIdentityServiceConfigArgs> identityServiceConfig() {
        return this.identityServiceConfig == null ? Codegen.empty() : this.identityServiceConfig;
    }

    /**
     * The number of nodes to create in this
     * cluster's default node pool. In regional or multi-zonal clusters, this is the
     * number of nodes per zone. Must be set if `node_pool` is not set. If you're using
     * `gcp.container.NodePool` objects with no default node pool, you'll need to
     * set this to a value of at least `1`, alongside setting
     * `remove_default_node_pool` to `true`.
     * 
     */
    @Import(name="initialNodeCount")
      private final @Nullable Output<Integer> initialNodeCount;

    public Output<Integer> initialNodeCount() {
        return this.initialNodeCount == null ? Codegen.empty() : this.initialNodeCount;
    }

    /**
     * Configuration of cluster IP allocation for
     * VPC-native clusters. Adding this block enables [IP aliasing](https://cloud.google.com/kubernetes-engine/docs/how-to/ip-aliases),
     * making the cluster VPC-native instead of routes-based. Structure is documented
     * below.
     * 
     */
    @Import(name="ipAllocationPolicy")
      private final @Nullable Output<ClusterIpAllocationPolicyArgs> ipAllocationPolicy;

    public Output<ClusterIpAllocationPolicyArgs> ipAllocationPolicy() {
        return this.ipAllocationPolicy == null ? Codegen.empty() : this.ipAllocationPolicy;
    }

    /**
     * The location (region or zone) in which the cluster
     * master will be created, as well as the default node location. If you specify a
     * zone (such as `us-central1-a`), the cluster will be a zonal cluster with a
     * single cluster master. If you specify a region (such as `us-west1`), the
     * cluster will be a regional cluster with multiple masters spread across zones in
     * the region, and with default node locations in those zones as well
     * 
     */
    @Import(name="location")
      private final @Nullable Output<String> location;

    public Output<String> location() {
        return this.location == null ? Codegen.empty() : this.location;
    }

    /**
     * Logging configuration for the cluster.
     * Structure is documented below.
     * 
     */
    @Import(name="loggingConfig")
      private final @Nullable Output<ClusterLoggingConfigArgs> loggingConfig;

    public Output<ClusterLoggingConfigArgs> loggingConfig() {
        return this.loggingConfig == null ? Codegen.empty() : this.loggingConfig;
    }

    /**
     * The logging service that the cluster should
     * write logs to. Available options include `logging.googleapis.com`(Legacy Stackdriver),
     * `logging.googleapis.com/kubernetes`(Stackdriver Kubernetes Engine Logging), and `none`. Defaults to `logging.googleapis.com/kubernetes`
     * 
     */
    @Import(name="loggingService")
      private final @Nullable Output<String> loggingService;

    public Output<String> loggingService() {
        return this.loggingService == null ? Codegen.empty() : this.loggingService;
    }

    /**
     * The maintenance policy to use for the cluster. Structure is
     * documented below.
     * 
     */
    @Import(name="maintenancePolicy")
      private final @Nullable Output<ClusterMaintenancePolicyArgs> maintenancePolicy;

    public Output<ClusterMaintenancePolicyArgs> maintenancePolicy() {
        return this.maintenancePolicy == null ? Codegen.empty() : this.maintenancePolicy;
    }

    /**
     * The authentication information for accessing the
     * Kubernetes master. Some values in this block are only returned by the API if
     * your service account has permission to get credentials for your GKE cluster. If
     * you see an unexpected diff unsetting your client cert, ensure you have the
     * `container.clusters.getCredentials` permission.
     * Structure is documented below.
     * 
     */
    @Import(name="masterAuth")
      private final @Nullable Output<ClusterMasterAuthArgs> masterAuth;

    public Output<ClusterMasterAuthArgs> masterAuth() {
        return this.masterAuth == null ? Codegen.empty() : this.masterAuth;
    }

    /**
     * The desired
     * configuration options for master authorized networks. Omit the
     * nested `cidr_blocks` attribute to disallow external access (except
     * the cluster node IPs, which GKE automatically whitelists).
     * Structure is documented below.
     * 
     */
    @Import(name="masterAuthorizedNetworksConfig")
      private final @Nullable Output<ClusterMasterAuthorizedNetworksConfigArgs> masterAuthorizedNetworksConfig;

    public Output<ClusterMasterAuthorizedNetworksConfigArgs> masterAuthorizedNetworksConfig() {
        return this.masterAuthorizedNetworksConfig == null ? Codegen.empty() : this.masterAuthorizedNetworksConfig;
    }

    /**
     * The minimum version of the master. GKE
     * will auto-update the master to new versions, so this does not guarantee the
     * current master version--use the read-only `master_version` field to obtain that.
     * If unset, the cluster's version will be set by GKE to the version of the most recent
     * official release (which is not necessarily the latest version).  Most users will find
     * the `gcp.container.getEngineVersions` data source useful - it indicates which versions
     * are available. If you intend to specify versions manually,
     * [the docs](https://cloud.google.com/kubernetes-engine/versioning-and-upgrades#specifying_cluster_version)
     * describe the various acceptable formats for this field.
     * 
     */
    @Import(name="minMasterVersion")
      private final @Nullable Output<String> minMasterVersion;

    public Output<String> minMasterVersion() {
        return this.minMasterVersion == null ? Codegen.empty() : this.minMasterVersion;
    }

    /**
     * Monitoring configuration for the cluster.
     * Structure is documented below.
     * 
     */
    @Import(name="monitoringConfig")
      private final @Nullable Output<ClusterMonitoringConfigArgs> monitoringConfig;

    public Output<ClusterMonitoringConfigArgs> monitoringConfig() {
        return this.monitoringConfig == null ? Codegen.empty() : this.monitoringConfig;
    }

    /**
     * The monitoring service that the cluster
     * should write metrics to.
     * Automatically send metrics from pods in the cluster to the Google Cloud Monitoring API.
     * VM metrics will be collected by Google Compute Engine regardless of this setting
     * Available options include
     * `monitoring.googleapis.com`(Legacy Stackdriver), `monitoring.googleapis.com/kubernetes`(Stackdriver Kubernetes Engine Monitoring), and `none`.
     * Defaults to `monitoring.googleapis.com/kubernetes`
     * 
     */
    @Import(name="monitoringService")
      private final @Nullable Output<String> monitoringService;

    public Output<String> monitoringService() {
        return this.monitoringService == null ? Codegen.empty() : this.monitoringService;
    }

    /**
     * The name of the cluster, unique within the project and
     * location.
     * 
     */
    @Import(name="name")
      private final @Nullable Output<String> name;

    public Output<String> name() {
        return this.name == null ? Codegen.empty() : this.name;
    }

    /**
     * The name or self_link of the Google Compute Engine
     * network to which the cluster is connected. For Shared VPC, set this to the self link of the
     * shared network.
     * 
     */
    @Import(name="network")
      private final @Nullable Output<String> network;

    public Output<String> network() {
        return this.network == null ? Codegen.empty() : this.network;
    }

    /**
     * Configuration options for the
     * [NetworkPolicy](https://kubernetes.io/docs/concepts/services-networking/networkpolicies/)
     * feature. Structure is documented below.
     * 
     */
    @Import(name="networkPolicy")
      private final @Nullable Output<ClusterNetworkPolicyArgs> networkPolicy;

    public Output<ClusterNetworkPolicyArgs> networkPolicy() {
        return this.networkPolicy == null ? Codegen.empty() : this.networkPolicy;
    }

    /**
     * Determines whether alias IPs or routes will be used for pod IPs in the cluster.
     * Options are `VPC_NATIVE` or `ROUTES`. `VPC_NATIVE` enables [IP aliasing](https://cloud.google.com/kubernetes-engine/docs/how-to/ip-aliases),
     * and requires the `ip_allocation_policy` block to be defined. By default when this field is unspecified, GKE will create a `ROUTES`-based cluster.
     * 
     */
    @Import(name="networkingMode")
      private final @Nullable Output<String> networkingMode;

    public Output<String> networkingMode() {
        return this.networkingMode == null ? Codegen.empty() : this.networkingMode;
    }

    /**
     * Parameters used in creating the default node pool.
     * Generally, this field should not be used at the same time as a
     * `gcp.container.NodePool` or a `node_pool` block; this configuration
     * manages the default node pool, which isn't recommended to be used.
     * Structure is documented below.
     * 
     */
    @Import(name="nodeConfig")
      private final @Nullable Output<ClusterNodeConfigArgs> nodeConfig;

    public Output<ClusterNodeConfigArgs> nodeConfig() {
        return this.nodeConfig == null ? Codegen.empty() : this.nodeConfig;
    }

    /**
     * The list of zones in which the cluster's nodes
     * are located. Nodes must be in the region of their regional cluster or in the
     * same region as their cluster's zone for zonal clusters. If this is specified for
     * a zonal cluster, omit the cluster's zone.
     * 
     */
    @Import(name="nodeLocations")
      private final @Nullable Output<List<String>> nodeLocations;

    public Output<List<String>> nodeLocations() {
        return this.nodeLocations == null ? Codegen.empty() : this.nodeLocations;
    }

    /**
     * List of node pools associated with this cluster.
     * See gcp.container.NodePool for schema.
     * **Warning:** node pools defined inside a cluster can't be changed (or added/removed) after
     * cluster creation without deleting and recreating the entire cluster. Unless you absolutely need the ability
     * to say "these are the _only_ node pools associated with this cluster", use the
     * gcp.container.NodePool resource instead of this property.
     * 
     */
    @Import(name="nodePools")
      private final @Nullable Output<List<ClusterNodePoolArgs>> nodePools;

    public Output<List<ClusterNodePoolArgs>> nodePools() {
        return this.nodePools == null ? Codegen.empty() : this.nodePools;
    }

    /**
     * The Kubernetes version on the nodes. Must either be unset
     * or set to the same value as `min_master_version` on create. Defaults to the default
     * version set by GKE which is not necessarily the latest version. This only affects
     * nodes in the default node pool. While a fuzzy version can be specified, it's
     * recommended that you specify explicit versions as the provider will see spurious diffs
     * when fuzzy versions are used. See the `gcp.container.getEngineVersions` data source's
     * `version_prefix` field to approximate fuzzy versions.
     * To update nodes in other node pools, use the `version` attribute on the node pool.
     * 
     */
    @Import(name="nodeVersion")
      private final @Nullable Output<String> nodeVersion;

    public Output<String> nodeVersion() {
        return this.nodeVersion == null ? Codegen.empty() : this.nodeVersion;
    }

    /**
     * Configuration for the [cluster upgrade notifications](https://cloud.google.com/kubernetes-engine/docs/how-to/cluster-upgrade-notifications) feature. Structure is documented below.
     * 
     */
    @Import(name="notificationConfig")
      private final @Nullable Output<ClusterNotificationConfigArgs> notificationConfig;

    public Output<ClusterNotificationConfigArgs> notificationConfig() {
        return this.notificationConfig == null ? Codegen.empty() : this.notificationConfig;
    }

    /**
     * ) Configuration for the
     * [PodSecurityPolicy](https://cloud.google.com/kubernetes-engine/docs/how-to/pod-security-policies) feature.
     * Structure is documented below.
     * 
     */
    @Import(name="podSecurityPolicyConfig")
      private final @Nullable Output<ClusterPodSecurityPolicyConfigArgs> podSecurityPolicyConfig;

    public Output<ClusterPodSecurityPolicyConfigArgs> podSecurityPolicyConfig() {
        return this.podSecurityPolicyConfig == null ? Codegen.empty() : this.podSecurityPolicyConfig;
    }

    /**
     * Configuration for [private clusters](https://cloud.google.com/kubernetes-engine/docs/how-to/private-clusters),
     * clusters with private nodes. Structure is documented below.
     * 
     */
    @Import(name="privateClusterConfig")
      private final @Nullable Output<ClusterPrivateClusterConfigArgs> privateClusterConfig;

    public Output<ClusterPrivateClusterConfigArgs> privateClusterConfig() {
        return this.privateClusterConfig == null ? Codegen.empty() : this.privateClusterConfig;
    }

    /**
     * The desired state of IPv6 connectivity to Google Services. By default, no private IPv6 access to or from Google Services (all access will be via IPv4).
     * 
     */
    @Import(name="privateIpv6GoogleAccess")
      private final @Nullable Output<String> privateIpv6GoogleAccess;

    public Output<String> privateIpv6GoogleAccess() {
        return this.privateIpv6GoogleAccess == null ? Codegen.empty() : this.privateIpv6GoogleAccess;
    }

    /**
     * The ID of the project in which the resource belongs. If it
     * is not provided, the provider project is used.
     * 
     */
    @Import(name="project")
      private final @Nullable Output<String> project;

    public Output<String> project() {
        return this.project == null ? Codegen.empty() : this.project;
    }

    /**
     * Configuration options for the [Release channel](https://cloud.google.com/kubernetes-engine/docs/concepts/release-channels)
     * feature, which provide more control over automatic upgrades of your GKE clusters.
     * When updating this field, GKE imposes specific version requirements. See
     * [Selecting a new release channel](https://cloud.google.com/kubernetes-engine/docs/concepts/release-channels#selecting_a_new_release_channel)
     * for more details; the `gcp.container.getEngineVersions` datasource can provide
     * the default version for a channel. Note that removing the `release_channel`
     * field from your config will cause the provider to stop managing your cluster's
     * release channel, but will not unenroll it. Instead, use the `"UNSPECIFIED"`
     * channel. Structure is documented below.
     * 
     */
    @Import(name="releaseChannel")
      private final @Nullable Output<ClusterReleaseChannelArgs> releaseChannel;

    public Output<ClusterReleaseChannelArgs> releaseChannel() {
        return this.releaseChannel == null ? Codegen.empty() : this.releaseChannel;
    }

    /**
     * If `true`, deletes the default node
     * pool upon cluster creation. If you're using `gcp.container.NodePool`
     * resources with no default node pool, this should be set to `true`, alongside
     * setting `initial_node_count` to at least `1`.
     * 
     */
    @Import(name="removeDefaultNodePool")
      private final @Nullable Output<Boolean> removeDefaultNodePool;

    public Output<Boolean> removeDefaultNodePool() {
        return this.removeDefaultNodePool == null ? Codegen.empty() : this.removeDefaultNodePool;
    }

    /**
     * The GCE resource labels (a map of key/value pairs) to be applied to the cluster.
     * 
     */
    @Import(name="resourceLabels")
      private final @Nullable Output<Map<String,String>> resourceLabels;

    public Output<Map<String,String>> resourceLabels() {
        return this.resourceLabels == null ? Codegen.empty() : this.resourceLabels;
    }

    /**
     * Configuration for the
     * [ResourceUsageExportConfig](https://cloud.google.com/kubernetes-engine/docs/how-to/cluster-usage-metering) feature.
     * Structure is documented below.
     * 
     */
    @Import(name="resourceUsageExportConfig")
      private final @Nullable Output<ClusterResourceUsageExportConfigArgs> resourceUsageExportConfig;

    public Output<ClusterResourceUsageExportConfigArgs> resourceUsageExportConfig() {
        return this.resourceUsageExportConfig == null ? Codegen.empty() : this.resourceUsageExportConfig;
    }

    /**
     * The name or self_link of the Google Compute Engine
     * subnetwork in which the cluster's instances are launched.
     * 
     */
    @Import(name="subnetwork")
      private final @Nullable Output<String> subnetwork;

    public Output<String> subnetwork() {
        return this.subnetwork == null ? Codegen.empty() : this.subnetwork;
    }

    /**
     * Vertical Pod Autoscaling automatically adjusts the resources of pods controlled by it.
     * Structure is documented below.
     * 
     */
    @Import(name="verticalPodAutoscaling")
      private final @Nullable Output<ClusterVerticalPodAutoscalingArgs> verticalPodAutoscaling;

    public Output<ClusterVerticalPodAutoscalingArgs> verticalPodAutoscaling() {
        return this.verticalPodAutoscaling == null ? Codegen.empty() : this.verticalPodAutoscaling;
    }

    /**
     * Workload Identity allows Kubernetes service accounts to act as a user-managed
     * [Google IAM Service Account](https://cloud.google.com/iam/docs/service-accounts#user-managed_service_accounts).
     * Structure is documented below.
     * 
     */
    @Import(name="workloadIdentityConfig")
      private final @Nullable Output<ClusterWorkloadIdentityConfigArgs> workloadIdentityConfig;

    public Output<ClusterWorkloadIdentityConfigArgs> workloadIdentityConfig() {
        return this.workloadIdentityConfig == null ? Codegen.empty() : this.workloadIdentityConfig;
    }

    public ClusterArgs(
        @Nullable Output<ClusterAddonsConfigArgs> addonsConfig,
        @Nullable Output<ClusterAuthenticatorGroupsConfigArgs> authenticatorGroupsConfig,
        @Nullable Output<ClusterClusterAutoscalingArgs> clusterAutoscaling,
        @Nullable Output<String> clusterIpv4Cidr,
        @Nullable Output<ClusterClusterTelemetryArgs> clusterTelemetry,
        @Nullable Output<ClusterConfidentialNodesArgs> confidentialNodes,
        @Nullable Output<ClusterDatabaseEncryptionArgs> databaseEncryption,
        @Nullable Output<String> datapathProvider,
        @Nullable Output<Integer> defaultMaxPodsPerNode,
        @Nullable Output<ClusterDefaultSnatStatusArgs> defaultSnatStatus,
        @Nullable Output<String> description,
        @Nullable Output<ClusterDnsConfigArgs> dnsConfig,
        @Nullable Output<Boolean> enableAutopilot,
        @Nullable Output<Boolean> enableBinaryAuthorization,
        @Nullable Output<Boolean> enableIntranodeVisibility,
        @Nullable Output<Boolean> enableKubernetesAlpha,
        @Nullable Output<Boolean> enableL4IlbSubsetting,
        @Nullable Output<Boolean> enableLegacyAbac,
        @Nullable Output<Boolean> enableShieldedNodes,
        @Nullable Output<Boolean> enableTpu,
        @Nullable Output<ClusterIdentityServiceConfigArgs> identityServiceConfig,
        @Nullable Output<Integer> initialNodeCount,
        @Nullable Output<ClusterIpAllocationPolicyArgs> ipAllocationPolicy,
        @Nullable Output<String> location,
        @Nullable Output<ClusterLoggingConfigArgs> loggingConfig,
        @Nullable Output<String> loggingService,
        @Nullable Output<ClusterMaintenancePolicyArgs> maintenancePolicy,
        @Nullable Output<ClusterMasterAuthArgs> masterAuth,
        @Nullable Output<ClusterMasterAuthorizedNetworksConfigArgs> masterAuthorizedNetworksConfig,
        @Nullable Output<String> minMasterVersion,
        @Nullable Output<ClusterMonitoringConfigArgs> monitoringConfig,
        @Nullable Output<String> monitoringService,
        @Nullable Output<String> name,
        @Nullable Output<String> network,
        @Nullable Output<ClusterNetworkPolicyArgs> networkPolicy,
        @Nullable Output<String> networkingMode,
        @Nullable Output<ClusterNodeConfigArgs> nodeConfig,
        @Nullable Output<List<String>> nodeLocations,
        @Nullable Output<List<ClusterNodePoolArgs>> nodePools,
        @Nullable Output<String> nodeVersion,
        @Nullable Output<ClusterNotificationConfigArgs> notificationConfig,
        @Nullable Output<ClusterPodSecurityPolicyConfigArgs> podSecurityPolicyConfig,
        @Nullable Output<ClusterPrivateClusterConfigArgs> privateClusterConfig,
        @Nullable Output<String> privateIpv6GoogleAccess,
        @Nullable Output<String> project,
        @Nullable Output<ClusterReleaseChannelArgs> releaseChannel,
        @Nullable Output<Boolean> removeDefaultNodePool,
        @Nullable Output<Map<String,String>> resourceLabels,
        @Nullable Output<ClusterResourceUsageExportConfigArgs> resourceUsageExportConfig,
        @Nullable Output<String> subnetwork,
        @Nullable Output<ClusterVerticalPodAutoscalingArgs> verticalPodAutoscaling,
        @Nullable Output<ClusterWorkloadIdentityConfigArgs> workloadIdentityConfig) {
        this.addonsConfig = addonsConfig;
        this.authenticatorGroupsConfig = authenticatorGroupsConfig;
        this.clusterAutoscaling = clusterAutoscaling;
        this.clusterIpv4Cidr = clusterIpv4Cidr;
        this.clusterTelemetry = clusterTelemetry;
        this.confidentialNodes = confidentialNodes;
        this.databaseEncryption = databaseEncryption;
        this.datapathProvider = datapathProvider;
        this.defaultMaxPodsPerNode = defaultMaxPodsPerNode;
        this.defaultSnatStatus = defaultSnatStatus;
        this.description = description;
        this.dnsConfig = dnsConfig;
        this.enableAutopilot = enableAutopilot;
        this.enableBinaryAuthorization = enableBinaryAuthorization;
        this.enableIntranodeVisibility = enableIntranodeVisibility;
        this.enableKubernetesAlpha = enableKubernetesAlpha;
        this.enableL4IlbSubsetting = enableL4IlbSubsetting;
        this.enableLegacyAbac = enableLegacyAbac;
        this.enableShieldedNodes = enableShieldedNodes;
        this.enableTpu = enableTpu;
        this.identityServiceConfig = identityServiceConfig;
        this.initialNodeCount = initialNodeCount;
        this.ipAllocationPolicy = ipAllocationPolicy;
        this.location = location;
        this.loggingConfig = loggingConfig;
        this.loggingService = loggingService;
        this.maintenancePolicy = maintenancePolicy;
        this.masterAuth = masterAuth;
        this.masterAuthorizedNetworksConfig = masterAuthorizedNetworksConfig;
        this.minMasterVersion = minMasterVersion;
        this.monitoringConfig = monitoringConfig;
        this.monitoringService = monitoringService;
        this.name = name;
        this.network = network;
        this.networkPolicy = networkPolicy;
        this.networkingMode = networkingMode;
        this.nodeConfig = nodeConfig;
        this.nodeLocations = nodeLocations;
        this.nodePools = nodePools;
        this.nodeVersion = nodeVersion;
        this.notificationConfig = notificationConfig;
        this.podSecurityPolicyConfig = podSecurityPolicyConfig;
        this.privateClusterConfig = privateClusterConfig;
        this.privateIpv6GoogleAccess = privateIpv6GoogleAccess;
        this.project = project;
        this.releaseChannel = releaseChannel;
        this.removeDefaultNodePool = removeDefaultNodePool;
        this.resourceLabels = resourceLabels;
        this.resourceUsageExportConfig = resourceUsageExportConfig;
        this.subnetwork = subnetwork;
        this.verticalPodAutoscaling = verticalPodAutoscaling;
        this.workloadIdentityConfig = workloadIdentityConfig;
    }

    private ClusterArgs() {
        this.addonsConfig = Codegen.empty();
        this.authenticatorGroupsConfig = Codegen.empty();
        this.clusterAutoscaling = Codegen.empty();
        this.clusterIpv4Cidr = Codegen.empty();
        this.clusterTelemetry = Codegen.empty();
        this.confidentialNodes = Codegen.empty();
        this.databaseEncryption = Codegen.empty();
        this.datapathProvider = Codegen.empty();
        this.defaultMaxPodsPerNode = Codegen.empty();
        this.defaultSnatStatus = Codegen.empty();
        this.description = Codegen.empty();
        this.dnsConfig = Codegen.empty();
        this.enableAutopilot = Codegen.empty();
        this.enableBinaryAuthorization = Codegen.empty();
        this.enableIntranodeVisibility = Codegen.empty();
        this.enableKubernetesAlpha = Codegen.empty();
        this.enableL4IlbSubsetting = Codegen.empty();
        this.enableLegacyAbac = Codegen.empty();
        this.enableShieldedNodes = Codegen.empty();
        this.enableTpu = Codegen.empty();
        this.identityServiceConfig = Codegen.empty();
        this.initialNodeCount = Codegen.empty();
        this.ipAllocationPolicy = Codegen.empty();
        this.location = Codegen.empty();
        this.loggingConfig = Codegen.empty();
        this.loggingService = Codegen.empty();
        this.maintenancePolicy = Codegen.empty();
        this.masterAuth = Codegen.empty();
        this.masterAuthorizedNetworksConfig = Codegen.empty();
        this.minMasterVersion = Codegen.empty();
        this.monitoringConfig = Codegen.empty();
        this.monitoringService = Codegen.empty();
        this.name = Codegen.empty();
        this.network = Codegen.empty();
        this.networkPolicy = Codegen.empty();
        this.networkingMode = Codegen.empty();
        this.nodeConfig = Codegen.empty();
        this.nodeLocations = Codegen.empty();
        this.nodePools = Codegen.empty();
        this.nodeVersion = Codegen.empty();
        this.notificationConfig = Codegen.empty();
        this.podSecurityPolicyConfig = Codegen.empty();
        this.privateClusterConfig = Codegen.empty();
        this.privateIpv6GoogleAccess = Codegen.empty();
        this.project = Codegen.empty();
        this.releaseChannel = Codegen.empty();
        this.removeDefaultNodePool = Codegen.empty();
        this.resourceLabels = Codegen.empty();
        this.resourceUsageExportConfig = Codegen.empty();
        this.subnetwork = Codegen.empty();
        this.verticalPodAutoscaling = Codegen.empty();
        this.workloadIdentityConfig = Codegen.empty();
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(ClusterArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private @Nullable Output<ClusterAddonsConfigArgs> addonsConfig;
        private @Nullable Output<ClusterAuthenticatorGroupsConfigArgs> authenticatorGroupsConfig;
        private @Nullable Output<ClusterClusterAutoscalingArgs> clusterAutoscaling;
        private @Nullable Output<String> clusterIpv4Cidr;
        private @Nullable Output<ClusterClusterTelemetryArgs> clusterTelemetry;
        private @Nullable Output<ClusterConfidentialNodesArgs> confidentialNodes;
        private @Nullable Output<ClusterDatabaseEncryptionArgs> databaseEncryption;
        private @Nullable Output<String> datapathProvider;
        private @Nullable Output<Integer> defaultMaxPodsPerNode;
        private @Nullable Output<ClusterDefaultSnatStatusArgs> defaultSnatStatus;
        private @Nullable Output<String> description;
        private @Nullable Output<ClusterDnsConfigArgs> dnsConfig;
        private @Nullable Output<Boolean> enableAutopilot;
        private @Nullable Output<Boolean> enableBinaryAuthorization;
        private @Nullable Output<Boolean> enableIntranodeVisibility;
        private @Nullable Output<Boolean> enableKubernetesAlpha;
        private @Nullable Output<Boolean> enableL4IlbSubsetting;
        private @Nullable Output<Boolean> enableLegacyAbac;
        private @Nullable Output<Boolean> enableShieldedNodes;
        private @Nullable Output<Boolean> enableTpu;
        private @Nullable Output<ClusterIdentityServiceConfigArgs> identityServiceConfig;
        private @Nullable Output<Integer> initialNodeCount;
        private @Nullable Output<ClusterIpAllocationPolicyArgs> ipAllocationPolicy;
        private @Nullable Output<String> location;
        private @Nullable Output<ClusterLoggingConfigArgs> loggingConfig;
        private @Nullable Output<String> loggingService;
        private @Nullable Output<ClusterMaintenancePolicyArgs> maintenancePolicy;
        private @Nullable Output<ClusterMasterAuthArgs> masterAuth;
        private @Nullable Output<ClusterMasterAuthorizedNetworksConfigArgs> masterAuthorizedNetworksConfig;
        private @Nullable Output<String> minMasterVersion;
        private @Nullable Output<ClusterMonitoringConfigArgs> monitoringConfig;
        private @Nullable Output<String> monitoringService;
        private @Nullable Output<String> name;
        private @Nullable Output<String> network;
        private @Nullable Output<ClusterNetworkPolicyArgs> networkPolicy;
        private @Nullable Output<String> networkingMode;
        private @Nullable Output<ClusterNodeConfigArgs> nodeConfig;
        private @Nullable Output<List<String>> nodeLocations;
        private @Nullable Output<List<ClusterNodePoolArgs>> nodePools;
        private @Nullable Output<String> nodeVersion;
        private @Nullable Output<ClusterNotificationConfigArgs> notificationConfig;
        private @Nullable Output<ClusterPodSecurityPolicyConfigArgs> podSecurityPolicyConfig;
        private @Nullable Output<ClusterPrivateClusterConfigArgs> privateClusterConfig;
        private @Nullable Output<String> privateIpv6GoogleAccess;
        private @Nullable Output<String> project;
        private @Nullable Output<ClusterReleaseChannelArgs> releaseChannel;
        private @Nullable Output<Boolean> removeDefaultNodePool;
        private @Nullable Output<Map<String,String>> resourceLabels;
        private @Nullable Output<ClusterResourceUsageExportConfigArgs> resourceUsageExportConfig;
        private @Nullable Output<String> subnetwork;
        private @Nullable Output<ClusterVerticalPodAutoscalingArgs> verticalPodAutoscaling;
        private @Nullable Output<ClusterWorkloadIdentityConfigArgs> workloadIdentityConfig;

        public Builder() {
    	      // Empty
        }

        public Builder(ClusterArgs defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.addonsConfig = defaults.addonsConfig;
    	      this.authenticatorGroupsConfig = defaults.authenticatorGroupsConfig;
    	      this.clusterAutoscaling = defaults.clusterAutoscaling;
    	      this.clusterIpv4Cidr = defaults.clusterIpv4Cidr;
    	      this.clusterTelemetry = defaults.clusterTelemetry;
    	      this.confidentialNodes = defaults.confidentialNodes;
    	      this.databaseEncryption = defaults.databaseEncryption;
    	      this.datapathProvider = defaults.datapathProvider;
    	      this.defaultMaxPodsPerNode = defaults.defaultMaxPodsPerNode;
    	      this.defaultSnatStatus = defaults.defaultSnatStatus;
    	      this.description = defaults.description;
    	      this.dnsConfig = defaults.dnsConfig;
    	      this.enableAutopilot = defaults.enableAutopilot;
    	      this.enableBinaryAuthorization = defaults.enableBinaryAuthorization;
    	      this.enableIntranodeVisibility = defaults.enableIntranodeVisibility;
    	      this.enableKubernetesAlpha = defaults.enableKubernetesAlpha;
    	      this.enableL4IlbSubsetting = defaults.enableL4IlbSubsetting;
    	      this.enableLegacyAbac = defaults.enableLegacyAbac;
    	      this.enableShieldedNodes = defaults.enableShieldedNodes;
    	      this.enableTpu = defaults.enableTpu;
    	      this.identityServiceConfig = defaults.identityServiceConfig;
    	      this.initialNodeCount = defaults.initialNodeCount;
    	      this.ipAllocationPolicy = defaults.ipAllocationPolicy;
    	      this.location = defaults.location;
    	      this.loggingConfig = defaults.loggingConfig;
    	      this.loggingService = defaults.loggingService;
    	      this.maintenancePolicy = defaults.maintenancePolicy;
    	      this.masterAuth = defaults.masterAuth;
    	      this.masterAuthorizedNetworksConfig = defaults.masterAuthorizedNetworksConfig;
    	      this.minMasterVersion = defaults.minMasterVersion;
    	      this.monitoringConfig = defaults.monitoringConfig;
    	      this.monitoringService = defaults.monitoringService;
    	      this.name = defaults.name;
    	      this.network = defaults.network;
    	      this.networkPolicy = defaults.networkPolicy;
    	      this.networkingMode = defaults.networkingMode;
    	      this.nodeConfig = defaults.nodeConfig;
    	      this.nodeLocations = defaults.nodeLocations;
    	      this.nodePools = defaults.nodePools;
    	      this.nodeVersion = defaults.nodeVersion;
    	      this.notificationConfig = defaults.notificationConfig;
    	      this.podSecurityPolicyConfig = defaults.podSecurityPolicyConfig;
    	      this.privateClusterConfig = defaults.privateClusterConfig;
    	      this.privateIpv6GoogleAccess = defaults.privateIpv6GoogleAccess;
    	      this.project = defaults.project;
    	      this.releaseChannel = defaults.releaseChannel;
    	      this.removeDefaultNodePool = defaults.removeDefaultNodePool;
    	      this.resourceLabels = defaults.resourceLabels;
    	      this.resourceUsageExportConfig = defaults.resourceUsageExportConfig;
    	      this.subnetwork = defaults.subnetwork;
    	      this.verticalPodAutoscaling = defaults.verticalPodAutoscaling;
    	      this.workloadIdentityConfig = defaults.workloadIdentityConfig;
        }

        public Builder addonsConfig(@Nullable Output<ClusterAddonsConfigArgs> addonsConfig) {
            this.addonsConfig = addonsConfig;
            return this;
        }
        public Builder addonsConfig(@Nullable ClusterAddonsConfigArgs addonsConfig) {
            this.addonsConfig = Codegen.ofNullable(addonsConfig);
            return this;
        }
        public Builder authenticatorGroupsConfig(@Nullable Output<ClusterAuthenticatorGroupsConfigArgs> authenticatorGroupsConfig) {
            this.authenticatorGroupsConfig = authenticatorGroupsConfig;
            return this;
        }
        public Builder authenticatorGroupsConfig(@Nullable ClusterAuthenticatorGroupsConfigArgs authenticatorGroupsConfig) {
            this.authenticatorGroupsConfig = Codegen.ofNullable(authenticatorGroupsConfig);
            return this;
        }
        public Builder clusterAutoscaling(@Nullable Output<ClusterClusterAutoscalingArgs> clusterAutoscaling) {
            this.clusterAutoscaling = clusterAutoscaling;
            return this;
        }
        public Builder clusterAutoscaling(@Nullable ClusterClusterAutoscalingArgs clusterAutoscaling) {
            this.clusterAutoscaling = Codegen.ofNullable(clusterAutoscaling);
            return this;
        }
        public Builder clusterIpv4Cidr(@Nullable Output<String> clusterIpv4Cidr) {
            this.clusterIpv4Cidr = clusterIpv4Cidr;
            return this;
        }
        public Builder clusterIpv4Cidr(@Nullable String clusterIpv4Cidr) {
            this.clusterIpv4Cidr = Codegen.ofNullable(clusterIpv4Cidr);
            return this;
        }
        public Builder clusterTelemetry(@Nullable Output<ClusterClusterTelemetryArgs> clusterTelemetry) {
            this.clusterTelemetry = clusterTelemetry;
            return this;
        }
        public Builder clusterTelemetry(@Nullable ClusterClusterTelemetryArgs clusterTelemetry) {
            this.clusterTelemetry = Codegen.ofNullable(clusterTelemetry);
            return this;
        }
        public Builder confidentialNodes(@Nullable Output<ClusterConfidentialNodesArgs> confidentialNodes) {
            this.confidentialNodes = confidentialNodes;
            return this;
        }
        public Builder confidentialNodes(@Nullable ClusterConfidentialNodesArgs confidentialNodes) {
            this.confidentialNodes = Codegen.ofNullable(confidentialNodes);
            return this;
        }
        public Builder databaseEncryption(@Nullable Output<ClusterDatabaseEncryptionArgs> databaseEncryption) {
            this.databaseEncryption = databaseEncryption;
            return this;
        }
        public Builder databaseEncryption(@Nullable ClusterDatabaseEncryptionArgs databaseEncryption) {
            this.databaseEncryption = Codegen.ofNullable(databaseEncryption);
            return this;
        }
        public Builder datapathProvider(@Nullable Output<String> datapathProvider) {
            this.datapathProvider = datapathProvider;
            return this;
        }
        public Builder datapathProvider(@Nullable String datapathProvider) {
            this.datapathProvider = Codegen.ofNullable(datapathProvider);
            return this;
        }
        public Builder defaultMaxPodsPerNode(@Nullable Output<Integer> defaultMaxPodsPerNode) {
            this.defaultMaxPodsPerNode = defaultMaxPodsPerNode;
            return this;
        }
        public Builder defaultMaxPodsPerNode(@Nullable Integer defaultMaxPodsPerNode) {
            this.defaultMaxPodsPerNode = Codegen.ofNullable(defaultMaxPodsPerNode);
            return this;
        }
        public Builder defaultSnatStatus(@Nullable Output<ClusterDefaultSnatStatusArgs> defaultSnatStatus) {
            this.defaultSnatStatus = defaultSnatStatus;
            return this;
        }
        public Builder defaultSnatStatus(@Nullable ClusterDefaultSnatStatusArgs defaultSnatStatus) {
            this.defaultSnatStatus = Codegen.ofNullable(defaultSnatStatus);
            return this;
        }
        public Builder description(@Nullable Output<String> description) {
            this.description = description;
            return this;
        }
        public Builder description(@Nullable String description) {
            this.description = Codegen.ofNullable(description);
            return this;
        }
        public Builder dnsConfig(@Nullable Output<ClusterDnsConfigArgs> dnsConfig) {
            this.dnsConfig = dnsConfig;
            return this;
        }
        public Builder dnsConfig(@Nullable ClusterDnsConfigArgs dnsConfig) {
            this.dnsConfig = Codegen.ofNullable(dnsConfig);
            return this;
        }
        public Builder enableAutopilot(@Nullable Output<Boolean> enableAutopilot) {
            this.enableAutopilot = enableAutopilot;
            return this;
        }
        public Builder enableAutopilot(@Nullable Boolean enableAutopilot) {
            this.enableAutopilot = Codegen.ofNullable(enableAutopilot);
            return this;
        }
        public Builder enableBinaryAuthorization(@Nullable Output<Boolean> enableBinaryAuthorization) {
            this.enableBinaryAuthorization = enableBinaryAuthorization;
            return this;
        }
        public Builder enableBinaryAuthorization(@Nullable Boolean enableBinaryAuthorization) {
            this.enableBinaryAuthorization = Codegen.ofNullable(enableBinaryAuthorization);
            return this;
        }
        public Builder enableIntranodeVisibility(@Nullable Output<Boolean> enableIntranodeVisibility) {
            this.enableIntranodeVisibility = enableIntranodeVisibility;
            return this;
        }
        public Builder enableIntranodeVisibility(@Nullable Boolean enableIntranodeVisibility) {
            this.enableIntranodeVisibility = Codegen.ofNullable(enableIntranodeVisibility);
            return this;
        }
        public Builder enableKubernetesAlpha(@Nullable Output<Boolean> enableKubernetesAlpha) {
            this.enableKubernetesAlpha = enableKubernetesAlpha;
            return this;
        }
        public Builder enableKubernetesAlpha(@Nullable Boolean enableKubernetesAlpha) {
            this.enableKubernetesAlpha = Codegen.ofNullable(enableKubernetesAlpha);
            return this;
        }
        public Builder enableL4IlbSubsetting(@Nullable Output<Boolean> enableL4IlbSubsetting) {
            this.enableL4IlbSubsetting = enableL4IlbSubsetting;
            return this;
        }
        public Builder enableL4IlbSubsetting(@Nullable Boolean enableL4IlbSubsetting) {
            this.enableL4IlbSubsetting = Codegen.ofNullable(enableL4IlbSubsetting);
            return this;
        }
        public Builder enableLegacyAbac(@Nullable Output<Boolean> enableLegacyAbac) {
            this.enableLegacyAbac = enableLegacyAbac;
            return this;
        }
        public Builder enableLegacyAbac(@Nullable Boolean enableLegacyAbac) {
            this.enableLegacyAbac = Codegen.ofNullable(enableLegacyAbac);
            return this;
        }
        public Builder enableShieldedNodes(@Nullable Output<Boolean> enableShieldedNodes) {
            this.enableShieldedNodes = enableShieldedNodes;
            return this;
        }
        public Builder enableShieldedNodes(@Nullable Boolean enableShieldedNodes) {
            this.enableShieldedNodes = Codegen.ofNullable(enableShieldedNodes);
            return this;
        }
        public Builder enableTpu(@Nullable Output<Boolean> enableTpu) {
            this.enableTpu = enableTpu;
            return this;
        }
        public Builder enableTpu(@Nullable Boolean enableTpu) {
            this.enableTpu = Codegen.ofNullable(enableTpu);
            return this;
        }
        public Builder identityServiceConfig(@Nullable Output<ClusterIdentityServiceConfigArgs> identityServiceConfig) {
            this.identityServiceConfig = identityServiceConfig;
            return this;
        }
        public Builder identityServiceConfig(@Nullable ClusterIdentityServiceConfigArgs identityServiceConfig) {
            this.identityServiceConfig = Codegen.ofNullable(identityServiceConfig);
            return this;
        }
        public Builder initialNodeCount(@Nullable Output<Integer> initialNodeCount) {
            this.initialNodeCount = initialNodeCount;
            return this;
        }
        public Builder initialNodeCount(@Nullable Integer initialNodeCount) {
            this.initialNodeCount = Codegen.ofNullable(initialNodeCount);
            return this;
        }
        public Builder ipAllocationPolicy(@Nullable Output<ClusterIpAllocationPolicyArgs> ipAllocationPolicy) {
            this.ipAllocationPolicy = ipAllocationPolicy;
            return this;
        }
        public Builder ipAllocationPolicy(@Nullable ClusterIpAllocationPolicyArgs ipAllocationPolicy) {
            this.ipAllocationPolicy = Codegen.ofNullable(ipAllocationPolicy);
            return this;
        }
        public Builder location(@Nullable Output<String> location) {
            this.location = location;
            return this;
        }
        public Builder location(@Nullable String location) {
            this.location = Codegen.ofNullable(location);
            return this;
        }
        public Builder loggingConfig(@Nullable Output<ClusterLoggingConfigArgs> loggingConfig) {
            this.loggingConfig = loggingConfig;
            return this;
        }
        public Builder loggingConfig(@Nullable ClusterLoggingConfigArgs loggingConfig) {
            this.loggingConfig = Codegen.ofNullable(loggingConfig);
            return this;
        }
        public Builder loggingService(@Nullable Output<String> loggingService) {
            this.loggingService = loggingService;
            return this;
        }
        public Builder loggingService(@Nullable String loggingService) {
            this.loggingService = Codegen.ofNullable(loggingService);
            return this;
        }
        public Builder maintenancePolicy(@Nullable Output<ClusterMaintenancePolicyArgs> maintenancePolicy) {
            this.maintenancePolicy = maintenancePolicy;
            return this;
        }
        public Builder maintenancePolicy(@Nullable ClusterMaintenancePolicyArgs maintenancePolicy) {
            this.maintenancePolicy = Codegen.ofNullable(maintenancePolicy);
            return this;
        }
        public Builder masterAuth(@Nullable Output<ClusterMasterAuthArgs> masterAuth) {
            this.masterAuth = masterAuth;
            return this;
        }
        public Builder masterAuth(@Nullable ClusterMasterAuthArgs masterAuth) {
            this.masterAuth = Codegen.ofNullable(masterAuth);
            return this;
        }
        public Builder masterAuthorizedNetworksConfig(@Nullable Output<ClusterMasterAuthorizedNetworksConfigArgs> masterAuthorizedNetworksConfig) {
            this.masterAuthorizedNetworksConfig = masterAuthorizedNetworksConfig;
            return this;
        }
        public Builder masterAuthorizedNetworksConfig(@Nullable ClusterMasterAuthorizedNetworksConfigArgs masterAuthorizedNetworksConfig) {
            this.masterAuthorizedNetworksConfig = Codegen.ofNullable(masterAuthorizedNetworksConfig);
            return this;
        }
        public Builder minMasterVersion(@Nullable Output<String> minMasterVersion) {
            this.minMasterVersion = minMasterVersion;
            return this;
        }
        public Builder minMasterVersion(@Nullable String minMasterVersion) {
            this.minMasterVersion = Codegen.ofNullable(minMasterVersion);
            return this;
        }
        public Builder monitoringConfig(@Nullable Output<ClusterMonitoringConfigArgs> monitoringConfig) {
            this.monitoringConfig = monitoringConfig;
            return this;
        }
        public Builder monitoringConfig(@Nullable ClusterMonitoringConfigArgs monitoringConfig) {
            this.monitoringConfig = Codegen.ofNullable(monitoringConfig);
            return this;
        }
        public Builder monitoringService(@Nullable Output<String> monitoringService) {
            this.monitoringService = monitoringService;
            return this;
        }
        public Builder monitoringService(@Nullable String monitoringService) {
            this.monitoringService = Codegen.ofNullable(monitoringService);
            return this;
        }
        public Builder name(@Nullable Output<String> name) {
            this.name = name;
            return this;
        }
        public Builder name(@Nullable String name) {
            this.name = Codegen.ofNullable(name);
            return this;
        }
        public Builder network(@Nullable Output<String> network) {
            this.network = network;
            return this;
        }
        public Builder network(@Nullable String network) {
            this.network = Codegen.ofNullable(network);
            return this;
        }
        public Builder networkPolicy(@Nullable Output<ClusterNetworkPolicyArgs> networkPolicy) {
            this.networkPolicy = networkPolicy;
            return this;
        }
        public Builder networkPolicy(@Nullable ClusterNetworkPolicyArgs networkPolicy) {
            this.networkPolicy = Codegen.ofNullable(networkPolicy);
            return this;
        }
        public Builder networkingMode(@Nullable Output<String> networkingMode) {
            this.networkingMode = networkingMode;
            return this;
        }
        public Builder networkingMode(@Nullable String networkingMode) {
            this.networkingMode = Codegen.ofNullable(networkingMode);
            return this;
        }
        public Builder nodeConfig(@Nullable Output<ClusterNodeConfigArgs> nodeConfig) {
            this.nodeConfig = nodeConfig;
            return this;
        }
        public Builder nodeConfig(@Nullable ClusterNodeConfigArgs nodeConfig) {
            this.nodeConfig = Codegen.ofNullable(nodeConfig);
            return this;
        }
        public Builder nodeLocations(@Nullable Output<List<String>> nodeLocations) {
            this.nodeLocations = nodeLocations;
            return this;
        }
        public Builder nodeLocations(@Nullable List<String> nodeLocations) {
            this.nodeLocations = Codegen.ofNullable(nodeLocations);
            return this;
        }
        public Builder nodeLocations(String... nodeLocations) {
            return nodeLocations(List.of(nodeLocations));
        }
        public Builder nodePools(@Nullable Output<List<ClusterNodePoolArgs>> nodePools) {
            this.nodePools = nodePools;
            return this;
        }
        public Builder nodePools(@Nullable List<ClusterNodePoolArgs> nodePools) {
            this.nodePools = Codegen.ofNullable(nodePools);
            return this;
        }
        public Builder nodePools(ClusterNodePoolArgs... nodePools) {
            return nodePools(List.of(nodePools));
        }
        public Builder nodeVersion(@Nullable Output<String> nodeVersion) {
            this.nodeVersion = nodeVersion;
            return this;
        }
        public Builder nodeVersion(@Nullable String nodeVersion) {
            this.nodeVersion = Codegen.ofNullable(nodeVersion);
            return this;
        }
        public Builder notificationConfig(@Nullable Output<ClusterNotificationConfigArgs> notificationConfig) {
            this.notificationConfig = notificationConfig;
            return this;
        }
        public Builder notificationConfig(@Nullable ClusterNotificationConfigArgs notificationConfig) {
            this.notificationConfig = Codegen.ofNullable(notificationConfig);
            return this;
        }
        public Builder podSecurityPolicyConfig(@Nullable Output<ClusterPodSecurityPolicyConfigArgs> podSecurityPolicyConfig) {
            this.podSecurityPolicyConfig = podSecurityPolicyConfig;
            return this;
        }
        public Builder podSecurityPolicyConfig(@Nullable ClusterPodSecurityPolicyConfigArgs podSecurityPolicyConfig) {
            this.podSecurityPolicyConfig = Codegen.ofNullable(podSecurityPolicyConfig);
            return this;
        }
        public Builder privateClusterConfig(@Nullable Output<ClusterPrivateClusterConfigArgs> privateClusterConfig) {
            this.privateClusterConfig = privateClusterConfig;
            return this;
        }
        public Builder privateClusterConfig(@Nullable ClusterPrivateClusterConfigArgs privateClusterConfig) {
            this.privateClusterConfig = Codegen.ofNullable(privateClusterConfig);
            return this;
        }
        public Builder privateIpv6GoogleAccess(@Nullable Output<String> privateIpv6GoogleAccess) {
            this.privateIpv6GoogleAccess = privateIpv6GoogleAccess;
            return this;
        }
        public Builder privateIpv6GoogleAccess(@Nullable String privateIpv6GoogleAccess) {
            this.privateIpv6GoogleAccess = Codegen.ofNullable(privateIpv6GoogleAccess);
            return this;
        }
        public Builder project(@Nullable Output<String> project) {
            this.project = project;
            return this;
        }
        public Builder project(@Nullable String project) {
            this.project = Codegen.ofNullable(project);
            return this;
        }
        public Builder releaseChannel(@Nullable Output<ClusterReleaseChannelArgs> releaseChannel) {
            this.releaseChannel = releaseChannel;
            return this;
        }
        public Builder releaseChannel(@Nullable ClusterReleaseChannelArgs releaseChannel) {
            this.releaseChannel = Codegen.ofNullable(releaseChannel);
            return this;
        }
        public Builder removeDefaultNodePool(@Nullable Output<Boolean> removeDefaultNodePool) {
            this.removeDefaultNodePool = removeDefaultNodePool;
            return this;
        }
        public Builder removeDefaultNodePool(@Nullable Boolean removeDefaultNodePool) {
            this.removeDefaultNodePool = Codegen.ofNullable(removeDefaultNodePool);
            return this;
        }
        public Builder resourceLabels(@Nullable Output<Map<String,String>> resourceLabels) {
            this.resourceLabels = resourceLabels;
            return this;
        }
        public Builder resourceLabels(@Nullable Map<String,String> resourceLabels) {
            this.resourceLabels = Codegen.ofNullable(resourceLabels);
            return this;
        }
        public Builder resourceUsageExportConfig(@Nullable Output<ClusterResourceUsageExportConfigArgs> resourceUsageExportConfig) {
            this.resourceUsageExportConfig = resourceUsageExportConfig;
            return this;
        }
        public Builder resourceUsageExportConfig(@Nullable ClusterResourceUsageExportConfigArgs resourceUsageExportConfig) {
            this.resourceUsageExportConfig = Codegen.ofNullable(resourceUsageExportConfig);
            return this;
        }
        public Builder subnetwork(@Nullable Output<String> subnetwork) {
            this.subnetwork = subnetwork;
            return this;
        }
        public Builder subnetwork(@Nullable String subnetwork) {
            this.subnetwork = Codegen.ofNullable(subnetwork);
            return this;
        }
        public Builder verticalPodAutoscaling(@Nullable Output<ClusterVerticalPodAutoscalingArgs> verticalPodAutoscaling) {
            this.verticalPodAutoscaling = verticalPodAutoscaling;
            return this;
        }
        public Builder verticalPodAutoscaling(@Nullable ClusterVerticalPodAutoscalingArgs verticalPodAutoscaling) {
            this.verticalPodAutoscaling = Codegen.ofNullable(verticalPodAutoscaling);
            return this;
        }
        public Builder workloadIdentityConfig(@Nullable Output<ClusterWorkloadIdentityConfigArgs> workloadIdentityConfig) {
            this.workloadIdentityConfig = workloadIdentityConfig;
            return this;
        }
        public Builder workloadIdentityConfig(@Nullable ClusterWorkloadIdentityConfigArgs workloadIdentityConfig) {
            this.workloadIdentityConfig = Codegen.ofNullable(workloadIdentityConfig);
            return this;
        }        public ClusterArgs build() {
            return new ClusterArgs(addonsConfig, authenticatorGroupsConfig, clusterAutoscaling, clusterIpv4Cidr, clusterTelemetry, confidentialNodes, databaseEncryption, datapathProvider, defaultMaxPodsPerNode, defaultSnatStatus, description, dnsConfig, enableAutopilot, enableBinaryAuthorization, enableIntranodeVisibility, enableKubernetesAlpha, enableL4IlbSubsetting, enableLegacyAbac, enableShieldedNodes, enableTpu, identityServiceConfig, initialNodeCount, ipAllocationPolicy, location, loggingConfig, loggingService, maintenancePolicy, masterAuth, masterAuthorizedNetworksConfig, minMasterVersion, monitoringConfig, monitoringService, name, network, networkPolicy, networkingMode, nodeConfig, nodeLocations, nodePools, nodeVersion, notificationConfig, podSecurityPolicyConfig, privateClusterConfig, privateIpv6GoogleAccess, project, releaseChannel, removeDefaultNodePool, resourceLabels, resourceUsageExportConfig, subnetwork, verticalPodAutoscaling, workloadIdentityConfig);
        }
    }
}
