// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package io.pulumi.azurenative.datafactory.inputs;

import io.pulumi.core.Input;
import io.pulumi.core.internal.annotations.InputImport;
import java.lang.Object;
import java.lang.String;
import java.util.Objects;
import javax.annotation.Nullable;


/**
 * The data stored in JSON format.
 */
public final class JsonFormatArgs extends io.pulumi.resources.ResourceArgs {

    public static final JsonFormatArgs Empty = new JsonFormatArgs();

    /**
     * Deserializer. Type: string (or Expression with resultType string).
     */
    @InputImport(name="deserializer")
    private final @Nullable Input<Object> deserializer;

    public Input<Object> getDeserializer() {
        return this.deserializer == null ? Input.empty() : this.deserializer;
    }

    /**
     * The code page name of the preferred encoding. If not provided, the default value is 'utf-8', unless the byte order mark (BOM) denotes another Unicode encoding. The full list of supported values can be found in the 'Name' column of the table of encodings in the following reference: https://go.microsoft.com/fwlink/?linkid=861078. Type: string (or Expression with resultType string).
     */
    @InputImport(name="encodingName")
    private final @Nullable Input<Object> encodingName;

    public Input<Object> getEncodingName() {
        return this.encodingName == null ? Input.empty() : this.encodingName;
    }

    /**
     * File pattern of JSON. To be more specific, the way of separating a collection of JSON objects. The default value is 'setOfObjects'. It is case-sensitive.
     */
    @InputImport(name="filePattern")
    private final @Nullable Input<Object> filePattern;

    public Input<Object> getFilePattern() {
        return this.filePattern == null ? Input.empty() : this.filePattern;
    }

    /**
     * The JSONPath of the JSON array element to be flattened. Example: "$.ArrayPath". Type: string (or Expression with resultType string).
     */
    @InputImport(name="jsonNodeReference")
    private final @Nullable Input<Object> jsonNodeReference;

    public Input<Object> getJsonNodeReference() {
        return this.jsonNodeReference == null ? Input.empty() : this.jsonNodeReference;
    }

    /**
     * The JSONPath definition for each column mapping with a customized column name to extract data from JSON file. For fields under root object, start with "$"; for fields inside the array chosen by jsonNodeReference property, start from the array element. Example: {"Column1": "$.Column1Path", "Column2": "Column2PathInArray"}. Type: object (or Expression with resultType object).
     */
    @InputImport(name="jsonPathDefinition")
    private final @Nullable Input<Object> jsonPathDefinition;

    public Input<Object> getJsonPathDefinition() {
        return this.jsonPathDefinition == null ? Input.empty() : this.jsonPathDefinition;
    }

    /**
     * The character used to separate nesting levels. Default value is '.' (dot). Type: string (or Expression with resultType string).
     */
    @InputImport(name="nestingSeparator")
    private final @Nullable Input<Object> nestingSeparator;

    public Input<Object> getNestingSeparator() {
        return this.nestingSeparator == null ? Input.empty() : this.nestingSeparator;
    }

    /**
     * Serializer. Type: string (or Expression with resultType string).
     */
    @InputImport(name="serializer")
    private final @Nullable Input<Object> serializer;

    public Input<Object> getSerializer() {
        return this.serializer == null ? Input.empty() : this.serializer;
    }

    /**
     * Type of dataset storage format.
Expected value is 'JsonFormat'.
     */
    @InputImport(name="type", required=true)
    private final Input<String> type;

    public Input<String> getType() {
        return this.type;
    }

    public JsonFormatArgs(
        @Nullable Input<Object> deserializer,
        @Nullable Input<Object> encodingName,
        @Nullable Input<Object> filePattern,
        @Nullable Input<Object> jsonNodeReference,
        @Nullable Input<Object> jsonPathDefinition,
        @Nullable Input<Object> nestingSeparator,
        @Nullable Input<Object> serializer,
        Input<String> type) {
        this.deserializer = deserializer;
        this.encodingName = encodingName;
        this.filePattern = filePattern;
        this.jsonNodeReference = jsonNodeReference;
        this.jsonPathDefinition = jsonPathDefinition;
        this.nestingSeparator = nestingSeparator;
        this.serializer = serializer;
        this.type = Objects.requireNonNull(type, "expected parameter 'type' to be non-null");
    }

    private JsonFormatArgs() {
        this.deserializer = Input.empty();
        this.encodingName = Input.empty();
        this.filePattern = Input.empty();
        this.jsonNodeReference = Input.empty();
        this.jsonPathDefinition = Input.empty();
        this.nestingSeparator = Input.empty();
        this.serializer = Input.empty();
        this.type = Input.empty();
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(JsonFormatArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private @Nullable Input<Object> deserializer;
        private @Nullable Input<Object> encodingName;
        private @Nullable Input<Object> filePattern;
        private @Nullable Input<Object> jsonNodeReference;
        private @Nullable Input<Object> jsonPathDefinition;
        private @Nullable Input<Object> nestingSeparator;
        private @Nullable Input<Object> serializer;
        private Input<String> type;

        public Builder() {
    	      // Empty
        }

        public Builder(JsonFormatArgs defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.deserializer = defaults.deserializer;
    	      this.encodingName = defaults.encodingName;
    	      this.filePattern = defaults.filePattern;
    	      this.jsonNodeReference = defaults.jsonNodeReference;
    	      this.jsonPathDefinition = defaults.jsonPathDefinition;
    	      this.nestingSeparator = defaults.nestingSeparator;
    	      this.serializer = defaults.serializer;
    	      this.type = defaults.type;
        }

        public Builder setDeserializer(@Nullable Input<Object> deserializer) {
            this.deserializer = deserializer;
            return this;
        }

        public Builder setDeserializer(@Nullable Object deserializer) {
            this.deserializer = Input.ofNullable(deserializer);
            return this;
        }

        public Builder setEncodingName(@Nullable Input<Object> encodingName) {
            this.encodingName = encodingName;
            return this;
        }

        public Builder setEncodingName(@Nullable Object encodingName) {
            this.encodingName = Input.ofNullable(encodingName);
            return this;
        }

        public Builder setFilePattern(@Nullable Input<Object> filePattern) {
            this.filePattern = filePattern;
            return this;
        }

        public Builder setFilePattern(@Nullable Object filePattern) {
            this.filePattern = Input.ofNullable(filePattern);
            return this;
        }

        public Builder setJsonNodeReference(@Nullable Input<Object> jsonNodeReference) {
            this.jsonNodeReference = jsonNodeReference;
            return this;
        }

        public Builder setJsonNodeReference(@Nullable Object jsonNodeReference) {
            this.jsonNodeReference = Input.ofNullable(jsonNodeReference);
            return this;
        }

        public Builder setJsonPathDefinition(@Nullable Input<Object> jsonPathDefinition) {
            this.jsonPathDefinition = jsonPathDefinition;
            return this;
        }

        public Builder setJsonPathDefinition(@Nullable Object jsonPathDefinition) {
            this.jsonPathDefinition = Input.ofNullable(jsonPathDefinition);
            return this;
        }

        public Builder setNestingSeparator(@Nullable Input<Object> nestingSeparator) {
            this.nestingSeparator = nestingSeparator;
            return this;
        }

        public Builder setNestingSeparator(@Nullable Object nestingSeparator) {
            this.nestingSeparator = Input.ofNullable(nestingSeparator);
            return this;
        }

        public Builder setSerializer(@Nullable Input<Object> serializer) {
            this.serializer = serializer;
            return this;
        }

        public Builder setSerializer(@Nullable Object serializer) {
            this.serializer = Input.ofNullable(serializer);
            return this;
        }

        public Builder setType(Input<String> type) {
            this.type = Objects.requireNonNull(type);
            return this;
        }

        public Builder setType(String type) {
            this.type = Input.of(Objects.requireNonNull(type));
            return this;
        }

        public JsonFormatArgs build() {
            return new JsonFormatArgs(deserializer, encodingName, filePattern, jsonNodeReference, jsonPathDefinition, nestingSeparator, serializer, type);
        }
    }
}
