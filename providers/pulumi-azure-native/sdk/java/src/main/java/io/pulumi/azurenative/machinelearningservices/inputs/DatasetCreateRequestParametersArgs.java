// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package io.pulumi.azurenative.machinelearningservices.inputs;

import io.pulumi.azurenative.machinelearningservices.enums.Header;
import io.pulumi.azurenative.machinelearningservices.enums.SourceType;
import io.pulumi.azurenative.machinelearningservices.inputs.DatasetCreateRequestPathArgs;
import io.pulumi.azurenative.machinelearningservices.inputs.DatasetCreateRequestQueryArgs;
import io.pulumi.core.Either;
import io.pulumi.core.Output;
import io.pulumi.core.annotations.Import;
import io.pulumi.core.internal.Codegen;
import java.lang.Boolean;
import java.lang.String;
import java.util.Objects;
import javax.annotation.Nullable;


public final class DatasetCreateRequestParametersArgs extends io.pulumi.resources.ResourceArgs {

    public static final DatasetCreateRequestParametersArgs Empty = new DatasetCreateRequestParametersArgs();

    /**
     * Header type.
     * 
     */
    @Import(name="header")
      private final @Nullable Output<Either<String,Header>> header;

    public Output<Either<String,Header>> header() {
        return this.header == null ? Codegen.empty() : this.header;
    }

    /**
     * Boolean to keep path information as column in the dataset. Defaults to False. This is useful when reading multiple files, and want to know which file a particular record originated from, or to keep useful information in file path.
     * 
     */
    @Import(name="includePath")
      private final @Nullable Output<Boolean> includePath;

    public Output<Boolean> includePath() {
        return this.includePath == null ? Codegen.empty() : this.includePath;
    }

    /**
     * The partition information of each path will be extracted into columns based on the specified format. Format part '{column_name}' creates string column, and '{column_name:yyyy/MM/dd/HH/mm/ss}' creates datetime column, where 'yyyy', 'MM', 'dd', 'HH', 'mm' and 'ss' are used to extract year, month, day, hour, minute and second for the datetime type. The format should start from the position of first partition key until the end of file path. For example, given the path '../USA/2019/01/01/data.parquet' where the partition is by country/region and time, partition_format='/{CountryOrRegion}/{PartitionDate:yyyy/MM/dd}/data.csv' creates a string column 'CountryOrRegion' with the value 'USA' and a datetime column 'PartitionDate' with the value '2019-01-01
     * 
     */
    @Import(name="partitionFormat")
      private final @Nullable Output<String> partitionFormat;

    public Output<String> partitionFormat() {
        return this.partitionFormat == null ? Codegen.empty() : this.partitionFormat;
    }

    @Import(name="path")
      private final @Nullable Output<DatasetCreateRequestPathArgs> path;

    public Output<DatasetCreateRequestPathArgs> path() {
        return this.path == null ? Codegen.empty() : this.path;
    }

    @Import(name="query")
      private final @Nullable Output<DatasetCreateRequestQueryArgs> query;

    public Output<DatasetCreateRequestQueryArgs> query() {
        return this.query == null ? Codegen.empty() : this.query;
    }

    /**
     * The separator used to split columns for 'delimited_files' sourceType.
     * 
     */
    @Import(name="separator")
      private final @Nullable Output<String> separator;

    public Output<String> separator() {
        return this.separator == null ? Codegen.empty() : this.separator;
    }

    /**
     * Data source type.
     * 
     */
    @Import(name="sourceType")
      private final @Nullable Output<Either<String,SourceType>> sourceType;

    public Output<Either<String,SourceType>> sourceType() {
        return this.sourceType == null ? Codegen.empty() : this.sourceType;
    }

    public DatasetCreateRequestParametersArgs(
        @Nullable Output<Either<String,Header>> header,
        @Nullable Output<Boolean> includePath,
        @Nullable Output<String> partitionFormat,
        @Nullable Output<DatasetCreateRequestPathArgs> path,
        @Nullable Output<DatasetCreateRequestQueryArgs> query,
        @Nullable Output<String> separator,
        @Nullable Output<Either<String,SourceType>> sourceType) {
        this.header = header;
        this.includePath = includePath == null ? Codegen.ofNullable(false) : includePath;
        this.partitionFormat = partitionFormat;
        this.path = path;
        this.query = query;
        this.separator = separator;
        this.sourceType = sourceType;
    }

    private DatasetCreateRequestParametersArgs() {
        this.header = Codegen.empty();
        this.includePath = Codegen.empty();
        this.partitionFormat = Codegen.empty();
        this.path = Codegen.empty();
        this.query = Codegen.empty();
        this.separator = Codegen.empty();
        this.sourceType = Codegen.empty();
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(DatasetCreateRequestParametersArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private @Nullable Output<Either<String,Header>> header;
        private @Nullable Output<Boolean> includePath;
        private @Nullable Output<String> partitionFormat;
        private @Nullable Output<DatasetCreateRequestPathArgs> path;
        private @Nullable Output<DatasetCreateRequestQueryArgs> query;
        private @Nullable Output<String> separator;
        private @Nullable Output<Either<String,SourceType>> sourceType;

        public Builder() {
    	      // Empty
        }

        public Builder(DatasetCreateRequestParametersArgs defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.header = defaults.header;
    	      this.includePath = defaults.includePath;
    	      this.partitionFormat = defaults.partitionFormat;
    	      this.path = defaults.path;
    	      this.query = defaults.query;
    	      this.separator = defaults.separator;
    	      this.sourceType = defaults.sourceType;
        }

        public Builder header(@Nullable Output<Either<String,Header>> header) {
            this.header = header;
            return this;
        }
        public Builder header(@Nullable Either<String,Header> header) {
            this.header = Codegen.ofNullable(header);
            return this;
        }
        public Builder includePath(@Nullable Output<Boolean> includePath) {
            this.includePath = includePath;
            return this;
        }
        public Builder includePath(@Nullable Boolean includePath) {
            this.includePath = Codegen.ofNullable(includePath);
            return this;
        }
        public Builder partitionFormat(@Nullable Output<String> partitionFormat) {
            this.partitionFormat = partitionFormat;
            return this;
        }
        public Builder partitionFormat(@Nullable String partitionFormat) {
            this.partitionFormat = Codegen.ofNullable(partitionFormat);
            return this;
        }
        public Builder path(@Nullable Output<DatasetCreateRequestPathArgs> path) {
            this.path = path;
            return this;
        }
        public Builder path(@Nullable DatasetCreateRequestPathArgs path) {
            this.path = Codegen.ofNullable(path);
            return this;
        }
        public Builder query(@Nullable Output<DatasetCreateRequestQueryArgs> query) {
            this.query = query;
            return this;
        }
        public Builder query(@Nullable DatasetCreateRequestQueryArgs query) {
            this.query = Codegen.ofNullable(query);
            return this;
        }
        public Builder separator(@Nullable Output<String> separator) {
            this.separator = separator;
            return this;
        }
        public Builder separator(@Nullable String separator) {
            this.separator = Codegen.ofNullable(separator);
            return this;
        }
        public Builder sourceType(@Nullable Output<Either<String,SourceType>> sourceType) {
            this.sourceType = sourceType;
            return this;
        }
        public Builder sourceType(@Nullable Either<String,SourceType> sourceType) {
            this.sourceType = Codegen.ofNullable(sourceType);
            return this;
        }        public DatasetCreateRequestParametersArgs build() {
            return new DatasetCreateRequestParametersArgs(header, includePath, partitionFormat, path, query, separator, sourceType);
        }
    }
}
