// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.azurenative.datafactory.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.core.internal.Codegen;
import java.lang.Object;
import java.lang.String;
import java.util.Objects;
import javax.annotation.Nullable;


/**
 * The data stored in JSON format.
 * 
 */
public final class JsonFormatArgs extends com.pulumi.resources.ResourceArgs {

    public static final JsonFormatArgs Empty = new JsonFormatArgs();

    /**
     * Deserializer. Type: string (or Expression with resultType string).
     * 
     */
    @Import(name="deserializer")
      private final @Nullable Output<Object> deserializer;

    public Output<Object> deserializer() {
        return this.deserializer == null ? Codegen.empty() : this.deserializer;
    }

    /**
     * The code page name of the preferred encoding. If not provided, the default value is 'utf-8', unless the byte order mark (BOM) denotes another Unicode encoding. The full list of supported values can be found in the 'Name' column of the table of encodings in the following reference: https://go.microsoft.com/fwlink/?linkid=861078. Type: string (or Expression with resultType string).
     * 
     */
    @Import(name="encodingName")
      private final @Nullable Output<Object> encodingName;

    public Output<Object> encodingName() {
        return this.encodingName == null ? Codegen.empty() : this.encodingName;
    }

    /**
     * File pattern of JSON. To be more specific, the way of separating a collection of JSON objects. The default value is 'setOfObjects'. It is case-sensitive.
     * 
     */
    @Import(name="filePattern")
      private final @Nullable Output<Object> filePattern;

    public Output<Object> filePattern() {
        return this.filePattern == null ? Codegen.empty() : this.filePattern;
    }

    /**
     * The JSONPath of the JSON array element to be flattened. Example: "$.ArrayPath". Type: string (or Expression with resultType string).
     * 
     */
    @Import(name="jsonNodeReference")
      private final @Nullable Output<Object> jsonNodeReference;

    public Output<Object> jsonNodeReference() {
        return this.jsonNodeReference == null ? Codegen.empty() : this.jsonNodeReference;
    }

    /**
     * The JSONPath definition for each column mapping with a customized column name to extract data from JSON file. For fields under root object, start with "$"; for fields inside the array chosen by jsonNodeReference property, start from the array element. Example: {"Column1": "$.Column1Path", "Column2": "Column2PathInArray"}. Type: object (or Expression with resultType object).
     * 
     */
    @Import(name="jsonPathDefinition")
      private final @Nullable Output<Object> jsonPathDefinition;

    public Output<Object> jsonPathDefinition() {
        return this.jsonPathDefinition == null ? Codegen.empty() : this.jsonPathDefinition;
    }

    /**
     * The character used to separate nesting levels. Default value is '.' (dot). Type: string (or Expression with resultType string).
     * 
     */
    @Import(name="nestingSeparator")
      private final @Nullable Output<Object> nestingSeparator;

    public Output<Object> nestingSeparator() {
        return this.nestingSeparator == null ? Codegen.empty() : this.nestingSeparator;
    }

    /**
     * Serializer. Type: string (or Expression with resultType string).
     * 
     */
    @Import(name="serializer")
      private final @Nullable Output<Object> serializer;

    public Output<Object> serializer() {
        return this.serializer == null ? Codegen.empty() : this.serializer;
    }

    /**
     * Type of dataset storage format.
     * Expected value is 'JsonFormat'.
     * 
     */
    @Import(name="type", required=true)
      private final Output<String> type;

    public Output<String> type() {
        return this.type;
    }

    public JsonFormatArgs(
        @Nullable Output<Object> deserializer,
        @Nullable Output<Object> encodingName,
        @Nullable Output<Object> filePattern,
        @Nullable Output<Object> jsonNodeReference,
        @Nullable Output<Object> jsonPathDefinition,
        @Nullable Output<Object> nestingSeparator,
        @Nullable Output<Object> serializer,
        Output<String> type) {
        this.deserializer = deserializer;
        this.encodingName = encodingName;
        this.filePattern = filePattern;
        this.jsonNodeReference = jsonNodeReference;
        this.jsonPathDefinition = jsonPathDefinition;
        this.nestingSeparator = nestingSeparator;
        this.serializer = serializer;
        this.type = Codegen.stringProp("type").output().arg(type).require();
    }

    private JsonFormatArgs() {
        this.deserializer = Codegen.empty();
        this.encodingName = Codegen.empty();
        this.filePattern = Codegen.empty();
        this.jsonNodeReference = Codegen.empty();
        this.jsonPathDefinition = Codegen.empty();
        this.nestingSeparator = Codegen.empty();
        this.serializer = Codegen.empty();
        this.type = Codegen.empty();
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(JsonFormatArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private @Nullable Output<Object> deserializer;
        private @Nullable Output<Object> encodingName;
        private @Nullable Output<Object> filePattern;
        private @Nullable Output<Object> jsonNodeReference;
        private @Nullable Output<Object> jsonPathDefinition;
        private @Nullable Output<Object> nestingSeparator;
        private @Nullable Output<Object> serializer;
        private Output<String> type;

        public Builder() {
    	      // Empty
        }

        public Builder(JsonFormatArgs defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.deserializer = defaults.deserializer;
    	      this.encodingName = defaults.encodingName;
    	      this.filePattern = defaults.filePattern;
    	      this.jsonNodeReference = defaults.jsonNodeReference;
    	      this.jsonPathDefinition = defaults.jsonPathDefinition;
    	      this.nestingSeparator = defaults.nestingSeparator;
    	      this.serializer = defaults.serializer;
    	      this.type = defaults.type;
        }

        public Builder deserializer(@Nullable Output<Object> deserializer) {
            this.deserializer = deserializer;
            return this;
        }
        public Builder deserializer(@Nullable Object deserializer) {
            this.deserializer = Codegen.ofNullable(deserializer);
            return this;
        }
        public Builder encodingName(@Nullable Output<Object> encodingName) {
            this.encodingName = encodingName;
            return this;
        }
        public Builder encodingName(@Nullable Object encodingName) {
            this.encodingName = Codegen.ofNullable(encodingName);
            return this;
        }
        public Builder filePattern(@Nullable Output<Object> filePattern) {
            this.filePattern = filePattern;
            return this;
        }
        public Builder filePattern(@Nullable Object filePattern) {
            this.filePattern = Codegen.ofNullable(filePattern);
            return this;
        }
        public Builder jsonNodeReference(@Nullable Output<Object> jsonNodeReference) {
            this.jsonNodeReference = jsonNodeReference;
            return this;
        }
        public Builder jsonNodeReference(@Nullable Object jsonNodeReference) {
            this.jsonNodeReference = Codegen.ofNullable(jsonNodeReference);
            return this;
        }
        public Builder jsonPathDefinition(@Nullable Output<Object> jsonPathDefinition) {
            this.jsonPathDefinition = jsonPathDefinition;
            return this;
        }
        public Builder jsonPathDefinition(@Nullable Object jsonPathDefinition) {
            this.jsonPathDefinition = Codegen.ofNullable(jsonPathDefinition);
            return this;
        }
        public Builder nestingSeparator(@Nullable Output<Object> nestingSeparator) {
            this.nestingSeparator = nestingSeparator;
            return this;
        }
        public Builder nestingSeparator(@Nullable Object nestingSeparator) {
            this.nestingSeparator = Codegen.ofNullable(nestingSeparator);
            return this;
        }
        public Builder serializer(@Nullable Output<Object> serializer) {
            this.serializer = serializer;
            return this;
        }
        public Builder serializer(@Nullable Object serializer) {
            this.serializer = Codegen.ofNullable(serializer);
            return this;
        }
        public Builder type(Output<String> type) {
            this.type = Objects.requireNonNull(type);
            return this;
        }
        public Builder type(String type) {
            this.type = Output.of(Objects.requireNonNull(type));
            return this;
        }        public JsonFormatArgs build() {
            return new JsonFormatArgs(deserializer, encodingName, filePattern, jsonNodeReference, jsonPathDefinition, nestingSeparator, serializer, type);
        }
    }
}
