// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.azurenative.videoanalyzer.inputs;

import com.pulumi.azurenative.videoanalyzer.inputs.TlsEndpointResponse;
import com.pulumi.azurenative.videoanalyzer.inputs.UnsecuredEndpointResponse;
import com.pulumi.core.Either;
import com.pulumi.core.annotations.Import;
import com.pulumi.core.internal.Codegen;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


/**
 * RTSP source allows for media from an RTSP camera or generic RTSP server to be ingested into a pipeline.
 * 
 */
public final class RtspSourceResponse extends com.pulumi.resources.InvokeArgs {

    public static final RtspSourceResponse Empty = new RtspSourceResponse();

    /**
     * RTSP endpoint information for Video Analyzer to connect to. This contains the required information for Video Analyzer to connect to RTSP cameras and/or generic RTSP servers.
     * 
     */
    @Import(name="endpoint", required=true)
    private Either<TlsEndpointResponse,UnsecuredEndpointResponse> endpoint;

    public Either<TlsEndpointResponse,UnsecuredEndpointResponse> endpoint() {
        return this.endpoint;
    }

    /**
     * Node name. Must be unique within the topology.
     * 
     */
    @Import(name="name", required=true)
    private String name;

    public String name() {
        return this.name;
    }

    /**
     * Network transport utilized by the RTSP and RTP exchange: TCP or HTTP. When using TCP, the RTP packets are interleaved on the TCP RTSP connection. When using HTTP, the RTSP messages are exchanged through long lived HTTP connections, and the RTP packages are interleaved in the HTTP connections alongside the RTSP messages.
     * 
     */
    @Import(name="transport")
    private @Nullable String transport;

    public Optional<String> transport() {
        return Optional.ofNullable(this.transport);
    }

    /**
     * The discriminator for derived types.
     * Expected value is &#39;#Microsoft.VideoAnalyzer.RtspSource&#39;.
     * 
     */
    @Import(name="type", required=true)
    private String type;

    public String type() {
        return this.type;
    }

    private RtspSourceResponse() {}

    private RtspSourceResponse(RtspSourceResponse $) {
        this.endpoint = $.endpoint;
        this.name = $.name;
        this.transport = $.transport;
        this.type = $.type;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(RtspSourceResponse defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private RtspSourceResponse $;

        public Builder() {
            $ = new RtspSourceResponse();
        }

        public Builder(RtspSourceResponse defaults) {
            $ = new RtspSourceResponse(Objects.requireNonNull(defaults));
        }

        public Builder endpoint(Either<TlsEndpointResponse,UnsecuredEndpointResponse> endpoint) {
            $.endpoint = endpoint;
            return this;
        }

        public Builder name(String name) {
            $.name = name;
            return this;
        }

        public Builder transport(@Nullable String transport) {
            $.transport = transport;
            return this;
        }

        public Builder type(String type) {
            $.type = type;
            return this;
        }

        public RtspSourceResponse build() {
            $.endpoint = Objects.requireNonNull($.endpoint, "expected parameter 'endpoint' to be non-null");
            $.name = Objects.requireNonNull($.name, "expected parameter 'name' to be non-null");
            $.type = Codegen.stringProp("type").arg($.type).require();
            return $;
        }
    }

}
