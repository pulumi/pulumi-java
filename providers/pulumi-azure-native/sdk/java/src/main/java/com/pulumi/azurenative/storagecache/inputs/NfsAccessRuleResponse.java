// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.azurenative.storagecache.inputs;

import com.pulumi.core.annotations.Import;
import java.lang.Boolean;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


/**
 * Rule to place restrictions on portions of the cache namespace being presented to clients.
 * 
 */
public final class NfsAccessRuleResponse extends com.pulumi.resources.InvokeArgs {

    public static final NfsAccessRuleResponse Empty = new NfsAccessRuleResponse();

    /**
     * Access allowed by this rule.
     * 
     */
    @Import(name="access", required=true)
    private String access;

    public String access() {
        return this.access;
    }

    /**
     * GID value that replaces 0 when rootSquash is true. This will use the value of anonymousUID if not provided.
     * 
     */
    @Import(name="anonymousGID")
    private @Nullable String anonymousGID;

    public Optional<String> anonymousGID() {
        return Optional.ofNullable(this.anonymousGID);
    }

    /**
     * UID value that replaces 0 when rootSquash is true. 65534 will be used if not provided.
     * 
     */
    @Import(name="anonymousUID")
    private @Nullable String anonymousUID;

    public Optional<String> anonymousUID() {
        return Optional.ofNullable(this.anonymousUID);
    }

    /**
     * Filter applied to the scope for this rule. The filter&#39;s format depends on its scope. &#39;default&#39; scope matches all clients and has no filter value. &#39;network&#39; scope takes a filter in CIDR format (for example, 10.99.1.0/24). &#39;host&#39; takes an IP address or fully qualified domain name as filter. If a client does not match any filter rule and there is no default rule, access is denied.
     * 
     */
    @Import(name="filter")
    private @Nullable String filter;

    public Optional<String> filter() {
        return Optional.ofNullable(this.filter);
    }

    /**
     * Map root accesses to anonymousUID and anonymousGID.
     * 
     */
    @Import(name="rootSquash")
    private @Nullable Boolean rootSquash;

    public Optional<Boolean> rootSquash() {
        return Optional.ofNullable(this.rootSquash);
    }

    /**
     * Scope for this rule. The scope and filter determine which clients match the rule.
     * 
     */
    @Import(name="scope", required=true)
    private String scope;

    public String scope() {
        return this.scope;
    }

    /**
     * For the default policy, allow access to subdirectories under the root export. If this is set to no, clients can only mount the path &#39;/&#39;. If set to yes, clients can mount a deeper path, like &#39;/a/b&#39;.
     * 
     */
    @Import(name="submountAccess")
    private @Nullable Boolean submountAccess;

    public Optional<Boolean> submountAccess() {
        return Optional.ofNullable(this.submountAccess);
    }

    /**
     * Allow SUID semantics.
     * 
     */
    @Import(name="suid")
    private @Nullable Boolean suid;

    public Optional<Boolean> suid() {
        return Optional.ofNullable(this.suid);
    }

    private NfsAccessRuleResponse() {}

    private NfsAccessRuleResponse(NfsAccessRuleResponse $) {
        this.access = $.access;
        this.anonymousGID = $.anonymousGID;
        this.anonymousUID = $.anonymousUID;
        this.filter = $.filter;
        this.rootSquash = $.rootSquash;
        this.scope = $.scope;
        this.submountAccess = $.submountAccess;
        this.suid = $.suid;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(NfsAccessRuleResponse defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private NfsAccessRuleResponse $;

        public Builder() {
            $ = new NfsAccessRuleResponse();
        }

        public Builder(NfsAccessRuleResponse defaults) {
            $ = new NfsAccessRuleResponse(Objects.requireNonNull(defaults));
        }

        public Builder access(String access) {
            $.access = access;
            return this;
        }

        public Builder anonymousGID(@Nullable String anonymousGID) {
            $.anonymousGID = anonymousGID;
            return this;
        }

        public Builder anonymousUID(@Nullable String anonymousUID) {
            $.anonymousUID = anonymousUID;
            return this;
        }

        public Builder filter(@Nullable String filter) {
            $.filter = filter;
            return this;
        }

        public Builder rootSquash(@Nullable Boolean rootSquash) {
            $.rootSquash = rootSquash;
            return this;
        }

        public Builder scope(String scope) {
            $.scope = scope;
            return this;
        }

        public Builder submountAccess(@Nullable Boolean submountAccess) {
            $.submountAccess = submountAccess;
            return this;
        }

        public Builder suid(@Nullable Boolean suid) {
            $.suid = suid;
            return this;
        }

        public NfsAccessRuleResponse build() {
            $.access = Objects.requireNonNull($.access, "expected parameter 'access' to be non-null");
            $.scope = Objects.requireNonNull($.scope, "expected parameter 'scope' to be non-null");
            return $;
        }
    }

}
