// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.azurenative.documentdb.inputs;

import com.pulumi.azurenative.documentdb.enums.AuthenticationMethod;
import com.pulumi.azurenative.documentdb.enums.ManagedCassandraProvisioningState;
import com.pulumi.azurenative.documentdb.inputs.CertificateArgs;
import com.pulumi.azurenative.documentdb.inputs.SeedNodeArgs;
import com.pulumi.core.Either;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


/**
 * Properties of a managed Cassandra cluster.
 * 
 */
public final class ClusterResourcePropertiesArgs extends com.pulumi.resources.ResourceArgs {

    public static final ClusterResourcePropertiesArgs Empty = new ClusterResourcePropertiesArgs();

    /**
     * Which authentication method Cassandra should use to authenticate clients. &#39;None&#39; turns off authentication, so should not be used except in emergencies. &#39;Cassandra&#39; is the default password based authentication. The default is &#39;Cassandra&#39;.
     * 
     */
    @Import(name="authenticationMethod")
    private @Nullable Output<Either<String,AuthenticationMethod>> authenticationMethod;

    /**
     * @return Which authentication method Cassandra should use to authenticate clients. &#39;None&#39; turns off authentication, so should not be used except in emergencies. &#39;Cassandra&#39; is the default password based authentication. The default is &#39;Cassandra&#39;.
     * 
     */
    public Optional<Output<Either<String,AuthenticationMethod>>> authenticationMethod() {
        return Optional.ofNullable(this.authenticationMethod);
    }

    /**
     * Which version of Cassandra should this cluster converge to running (e.g., 3.11). When updated, the cluster may take some time to migrate to the new version.
     * 
     */
    @Import(name="cassandraVersion")
    private @Nullable Output<String> cassandraVersion;

    /**
     * @return Which version of Cassandra should this cluster converge to running (e.g., 3.11). When updated, the cluster may take some time to migrate to the new version.
     * 
     */
    public Optional<Output<String>> cassandraVersion() {
        return Optional.ofNullable(this.cassandraVersion);
    }

    /**
     * List of TLS certificates used to authorize clients connecting to the cluster. All connections are TLS encrypted whether clientCertificates is set or not, but if clientCertificates is set, the managed Cassandra cluster will reject all connections not bearing a TLS client certificate that can be validated from one or more of the public certificates in this property.
     * 
     */
    @Import(name="clientCertificates")
    private @Nullable Output<List<CertificateArgs>> clientCertificates;

    /**
     * @return List of TLS certificates used to authorize clients connecting to the cluster. All connections are TLS encrypted whether clientCertificates is set or not, but if clientCertificates is set, the managed Cassandra cluster will reject all connections not bearing a TLS client certificate that can be validated from one or more of the public certificates in this property.
     * 
     */
    public Optional<Output<List<CertificateArgs>>> clientCertificates() {
        return Optional.ofNullable(this.clientCertificates);
    }

    /**
     * If you need to set the clusterName property in cassandra.yaml to something besides the resource name of the cluster, set the value to use on this property.
     * 
     */
    @Import(name="clusterNameOverride")
    private @Nullable Output<String> clusterNameOverride;

    /**
     * @return If you need to set the clusterName property in cassandra.yaml to something besides the resource name of the cluster, set the value to use on this property.
     * 
     */
    public Optional<Output<String>> clusterNameOverride() {
        return Optional.ofNullable(this.clusterNameOverride);
    }

    /**
     * Resource id of a subnet that this cluster&#39;s management service should have its network interface attached to. The subnet must be routable to all subnets that will be delegated to data centers. The resource id must be of the form &#39;/subscriptions/&lt;subscription id&gt;/resourceGroups/&lt;resource group&gt;/providers/Microsoft.Network/virtualNetworks/&lt;virtual network&gt;/subnets/&lt;subnet&gt;&#39;
     * 
     */
    @Import(name="delegatedManagementSubnetId")
    private @Nullable Output<String> delegatedManagementSubnetId;

    /**
     * @return Resource id of a subnet that this cluster&#39;s management service should have its network interface attached to. The subnet must be routable to all subnets that will be delegated to data centers. The resource id must be of the form &#39;/subscriptions/&lt;subscription id&gt;/resourceGroups/&lt;resource group&gt;/providers/Microsoft.Network/virtualNetworks/&lt;virtual network&gt;/subnets/&lt;subnet&gt;&#39;
     * 
     */
    public Optional<Output<String>> delegatedManagementSubnetId() {
        return Optional.ofNullable(this.delegatedManagementSubnetId);
    }

    /**
     * List of TLS certificates used to authorize gossip from unmanaged data centers. The TLS certificates of all nodes in unmanaged data centers must be verifiable using one of the certificates provided in this property.
     * 
     */
    @Import(name="externalGossipCertificates")
    private @Nullable Output<List<CertificateArgs>> externalGossipCertificates;

    /**
     * @return List of TLS certificates used to authorize gossip from unmanaged data centers. The TLS certificates of all nodes in unmanaged data centers must be verifiable using one of the certificates provided in this property.
     * 
     */
    public Optional<Output<List<CertificateArgs>>> externalGossipCertificates() {
        return Optional.ofNullable(this.externalGossipCertificates);
    }

    /**
     * List of IP addresses of seed nodes in unmanaged data centers. These will be added to the seed node lists of all managed nodes.
     * 
     */
    @Import(name="externalSeedNodes")
    private @Nullable Output<List<SeedNodeArgs>> externalSeedNodes;

    /**
     * @return List of IP addresses of seed nodes in unmanaged data centers. These will be added to the seed node lists of all managed nodes.
     * 
     */
    public Optional<Output<List<SeedNodeArgs>>> externalSeedNodes() {
        return Optional.ofNullable(this.externalSeedNodes);
    }

    /**
     * Number of hours to wait between taking a backup of the cluster. To disable backups, set this property to 0.
     * 
     */
    @Import(name="hoursBetweenBackups")
    private @Nullable Output<Integer> hoursBetweenBackups;

    /**
     * @return Number of hours to wait between taking a backup of the cluster. To disable backups, set this property to 0.
     * 
     */
    public Optional<Output<Integer>> hoursBetweenBackups() {
        return Optional.ofNullable(this.hoursBetweenBackups);
    }

    /**
     * Initial password for clients connecting as admin to the cluster. Should be changed after cluster creation. Returns null on GET. This field only applies when the authenticationMethod field is &#39;Cassandra&#39;.
     * 
     */
    @Import(name="initialCassandraAdminPassword")
    private @Nullable Output<String> initialCassandraAdminPassword;

    /**
     * @return Initial password for clients connecting as admin to the cluster. Should be changed after cluster creation. Returns null on GET. This field only applies when the authenticationMethod field is &#39;Cassandra&#39;.
     * 
     */
    public Optional<Output<String>> initialCassandraAdminPassword() {
        return Optional.ofNullable(this.initialCassandraAdminPassword);
    }

    /**
     * Hostname or IP address where the Prometheus endpoint containing data about the managed Cassandra nodes can be reached.
     * 
     */
    @Import(name="prometheusEndpoint")
    private @Nullable Output<SeedNodeArgs> prometheusEndpoint;

    /**
     * @return Hostname or IP address where the Prometheus endpoint containing data about the managed Cassandra nodes can be reached.
     * 
     */
    public Optional<Output<SeedNodeArgs>> prometheusEndpoint() {
        return Optional.ofNullable(this.prometheusEndpoint);
    }

    /**
     * The status of the resource at the time the operation was called.
     * 
     */
    @Import(name="provisioningState")
    private @Nullable Output<Either<String,ManagedCassandraProvisioningState>> provisioningState;

    /**
     * @return The status of the resource at the time the operation was called.
     * 
     */
    public Optional<Output<Either<String,ManagedCassandraProvisioningState>>> provisioningState() {
        return Optional.ofNullable(this.provisioningState);
    }

    /**
     * Should automatic repairs run on this cluster? If omitted, this is true, and should stay true unless you are running a hybrid cluster where you are already doing your own repairs.
     * 
     */
    @Import(name="repairEnabled")
    private @Nullable Output<Boolean> repairEnabled;

    /**
     * @return Should automatic repairs run on this cluster? If omitted, this is true, and should stay true unless you are running a hybrid cluster where you are already doing your own repairs.
     * 
     */
    public Optional<Output<Boolean>> repairEnabled() {
        return Optional.ofNullable(this.repairEnabled);
    }

    /**
     * To create an empty cluster, omit this field or set it to null. To restore a backup into a new cluster, set this field to the resource id of the backup.
     * 
     */
    @Import(name="restoreFromBackupId")
    private @Nullable Output<String> restoreFromBackupId;

    /**
     * @return To create an empty cluster, omit this field or set it to null. To restore a backup into a new cluster, set this field to the resource id of the backup.
     * 
     */
    public Optional<Output<String>> restoreFromBackupId() {
        return Optional.ofNullable(this.restoreFromBackupId);
    }

    private ClusterResourcePropertiesArgs() {}

    private ClusterResourcePropertiesArgs(ClusterResourcePropertiesArgs $) {
        this.authenticationMethod = $.authenticationMethod;
        this.cassandraVersion = $.cassandraVersion;
        this.clientCertificates = $.clientCertificates;
        this.clusterNameOverride = $.clusterNameOverride;
        this.delegatedManagementSubnetId = $.delegatedManagementSubnetId;
        this.externalGossipCertificates = $.externalGossipCertificates;
        this.externalSeedNodes = $.externalSeedNodes;
        this.hoursBetweenBackups = $.hoursBetweenBackups;
        this.initialCassandraAdminPassword = $.initialCassandraAdminPassword;
        this.prometheusEndpoint = $.prometheusEndpoint;
        this.provisioningState = $.provisioningState;
        this.repairEnabled = $.repairEnabled;
        this.restoreFromBackupId = $.restoreFromBackupId;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(ClusterResourcePropertiesArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private ClusterResourcePropertiesArgs $;

        public Builder() {
            $ = new ClusterResourcePropertiesArgs();
        }

        public Builder(ClusterResourcePropertiesArgs defaults) {
            $ = new ClusterResourcePropertiesArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param authenticationMethod Which authentication method Cassandra should use to authenticate clients. &#39;None&#39; turns off authentication, so should not be used except in emergencies. &#39;Cassandra&#39; is the default password based authentication. The default is &#39;Cassandra&#39;.
         * 
         * @return builder
         * 
         */
        public Builder authenticationMethod(@Nullable Output<Either<String,AuthenticationMethod>> authenticationMethod) {
            $.authenticationMethod = authenticationMethod;
            return this;
        }

        /**
         * @param authenticationMethod Which authentication method Cassandra should use to authenticate clients. &#39;None&#39; turns off authentication, so should not be used except in emergencies. &#39;Cassandra&#39; is the default password based authentication. The default is &#39;Cassandra&#39;.
         * 
         * @return builder
         * 
         */
        public Builder authenticationMethod(Either<String,AuthenticationMethod> authenticationMethod) {
            return authenticationMethod(Output.of(authenticationMethod));
        }

        /**
         * @param authenticationMethod Which authentication method Cassandra should use to authenticate clients. &#39;None&#39; turns off authentication, so should not be used except in emergencies. &#39;Cassandra&#39; is the default password based authentication. The default is &#39;Cassandra&#39;.
         * 
         * @return builder
         * 
         */
        public Builder authenticationMethod(String authenticationMethod) {
            return authenticationMethod(Either.ofLeft(authenticationMethod));
        }

        /**
         * @param authenticationMethod Which authentication method Cassandra should use to authenticate clients. &#39;None&#39; turns off authentication, so should not be used except in emergencies. &#39;Cassandra&#39; is the default password based authentication. The default is &#39;Cassandra&#39;.
         * 
         * @return builder
         * 
         */
        public Builder authenticationMethod(AuthenticationMethod authenticationMethod) {
            return authenticationMethod(Either.ofRight(authenticationMethod));
        }

        /**
         * @param cassandraVersion Which version of Cassandra should this cluster converge to running (e.g., 3.11). When updated, the cluster may take some time to migrate to the new version.
         * 
         * @return builder
         * 
         */
        public Builder cassandraVersion(@Nullable Output<String> cassandraVersion) {
            $.cassandraVersion = cassandraVersion;
            return this;
        }

        /**
         * @param cassandraVersion Which version of Cassandra should this cluster converge to running (e.g., 3.11). When updated, the cluster may take some time to migrate to the new version.
         * 
         * @return builder
         * 
         */
        public Builder cassandraVersion(String cassandraVersion) {
            return cassandraVersion(Output.of(cassandraVersion));
        }

        /**
         * @param clientCertificates List of TLS certificates used to authorize clients connecting to the cluster. All connections are TLS encrypted whether clientCertificates is set or not, but if clientCertificates is set, the managed Cassandra cluster will reject all connections not bearing a TLS client certificate that can be validated from one or more of the public certificates in this property.
         * 
         * @return builder
         * 
         */
        public Builder clientCertificates(@Nullable Output<List<CertificateArgs>> clientCertificates) {
            $.clientCertificates = clientCertificates;
            return this;
        }

        /**
         * @param clientCertificates List of TLS certificates used to authorize clients connecting to the cluster. All connections are TLS encrypted whether clientCertificates is set or not, but if clientCertificates is set, the managed Cassandra cluster will reject all connections not bearing a TLS client certificate that can be validated from one or more of the public certificates in this property.
         * 
         * @return builder
         * 
         */
        public Builder clientCertificates(List<CertificateArgs> clientCertificates) {
            return clientCertificates(Output.of(clientCertificates));
        }

        /**
         * @param clientCertificates List of TLS certificates used to authorize clients connecting to the cluster. All connections are TLS encrypted whether clientCertificates is set or not, but if clientCertificates is set, the managed Cassandra cluster will reject all connections not bearing a TLS client certificate that can be validated from one or more of the public certificates in this property.
         * 
         * @return builder
         * 
         */
        public Builder clientCertificates(CertificateArgs... clientCertificates) {
            return clientCertificates(List.of(clientCertificates));
        }

        /**
         * @param clusterNameOverride If you need to set the clusterName property in cassandra.yaml to something besides the resource name of the cluster, set the value to use on this property.
         * 
         * @return builder
         * 
         */
        public Builder clusterNameOverride(@Nullable Output<String> clusterNameOverride) {
            $.clusterNameOverride = clusterNameOverride;
            return this;
        }

        /**
         * @param clusterNameOverride If you need to set the clusterName property in cassandra.yaml to something besides the resource name of the cluster, set the value to use on this property.
         * 
         * @return builder
         * 
         */
        public Builder clusterNameOverride(String clusterNameOverride) {
            return clusterNameOverride(Output.of(clusterNameOverride));
        }

        /**
         * @param delegatedManagementSubnetId Resource id of a subnet that this cluster&#39;s management service should have its network interface attached to. The subnet must be routable to all subnets that will be delegated to data centers. The resource id must be of the form &#39;/subscriptions/&lt;subscription id&gt;/resourceGroups/&lt;resource group&gt;/providers/Microsoft.Network/virtualNetworks/&lt;virtual network&gt;/subnets/&lt;subnet&gt;&#39;
         * 
         * @return builder
         * 
         */
        public Builder delegatedManagementSubnetId(@Nullable Output<String> delegatedManagementSubnetId) {
            $.delegatedManagementSubnetId = delegatedManagementSubnetId;
            return this;
        }

        /**
         * @param delegatedManagementSubnetId Resource id of a subnet that this cluster&#39;s management service should have its network interface attached to. The subnet must be routable to all subnets that will be delegated to data centers. The resource id must be of the form &#39;/subscriptions/&lt;subscription id&gt;/resourceGroups/&lt;resource group&gt;/providers/Microsoft.Network/virtualNetworks/&lt;virtual network&gt;/subnets/&lt;subnet&gt;&#39;
         * 
         * @return builder
         * 
         */
        public Builder delegatedManagementSubnetId(String delegatedManagementSubnetId) {
            return delegatedManagementSubnetId(Output.of(delegatedManagementSubnetId));
        }

        /**
         * @param externalGossipCertificates List of TLS certificates used to authorize gossip from unmanaged data centers. The TLS certificates of all nodes in unmanaged data centers must be verifiable using one of the certificates provided in this property.
         * 
         * @return builder
         * 
         */
        public Builder externalGossipCertificates(@Nullable Output<List<CertificateArgs>> externalGossipCertificates) {
            $.externalGossipCertificates = externalGossipCertificates;
            return this;
        }

        /**
         * @param externalGossipCertificates List of TLS certificates used to authorize gossip from unmanaged data centers. The TLS certificates of all nodes in unmanaged data centers must be verifiable using one of the certificates provided in this property.
         * 
         * @return builder
         * 
         */
        public Builder externalGossipCertificates(List<CertificateArgs> externalGossipCertificates) {
            return externalGossipCertificates(Output.of(externalGossipCertificates));
        }

        /**
         * @param externalGossipCertificates List of TLS certificates used to authorize gossip from unmanaged data centers. The TLS certificates of all nodes in unmanaged data centers must be verifiable using one of the certificates provided in this property.
         * 
         * @return builder
         * 
         */
        public Builder externalGossipCertificates(CertificateArgs... externalGossipCertificates) {
            return externalGossipCertificates(List.of(externalGossipCertificates));
        }

        /**
         * @param externalSeedNodes List of IP addresses of seed nodes in unmanaged data centers. These will be added to the seed node lists of all managed nodes.
         * 
         * @return builder
         * 
         */
        public Builder externalSeedNodes(@Nullable Output<List<SeedNodeArgs>> externalSeedNodes) {
            $.externalSeedNodes = externalSeedNodes;
            return this;
        }

        /**
         * @param externalSeedNodes List of IP addresses of seed nodes in unmanaged data centers. These will be added to the seed node lists of all managed nodes.
         * 
         * @return builder
         * 
         */
        public Builder externalSeedNodes(List<SeedNodeArgs> externalSeedNodes) {
            return externalSeedNodes(Output.of(externalSeedNodes));
        }

        /**
         * @param externalSeedNodes List of IP addresses of seed nodes in unmanaged data centers. These will be added to the seed node lists of all managed nodes.
         * 
         * @return builder
         * 
         */
        public Builder externalSeedNodes(SeedNodeArgs... externalSeedNodes) {
            return externalSeedNodes(List.of(externalSeedNodes));
        }

        /**
         * @param hoursBetweenBackups Number of hours to wait between taking a backup of the cluster. To disable backups, set this property to 0.
         * 
         * @return builder
         * 
         */
        public Builder hoursBetweenBackups(@Nullable Output<Integer> hoursBetweenBackups) {
            $.hoursBetweenBackups = hoursBetweenBackups;
            return this;
        }

        /**
         * @param hoursBetweenBackups Number of hours to wait between taking a backup of the cluster. To disable backups, set this property to 0.
         * 
         * @return builder
         * 
         */
        public Builder hoursBetweenBackups(Integer hoursBetweenBackups) {
            return hoursBetweenBackups(Output.of(hoursBetweenBackups));
        }

        /**
         * @param initialCassandraAdminPassword Initial password for clients connecting as admin to the cluster. Should be changed after cluster creation. Returns null on GET. This field only applies when the authenticationMethod field is &#39;Cassandra&#39;.
         * 
         * @return builder
         * 
         */
        public Builder initialCassandraAdminPassword(@Nullable Output<String> initialCassandraAdminPassword) {
            $.initialCassandraAdminPassword = initialCassandraAdminPassword;
            return this;
        }

        /**
         * @param initialCassandraAdminPassword Initial password for clients connecting as admin to the cluster. Should be changed after cluster creation. Returns null on GET. This field only applies when the authenticationMethod field is &#39;Cassandra&#39;.
         * 
         * @return builder
         * 
         */
        public Builder initialCassandraAdminPassword(String initialCassandraAdminPassword) {
            return initialCassandraAdminPassword(Output.of(initialCassandraAdminPassword));
        }

        /**
         * @param prometheusEndpoint Hostname or IP address where the Prometheus endpoint containing data about the managed Cassandra nodes can be reached.
         * 
         * @return builder
         * 
         */
        public Builder prometheusEndpoint(@Nullable Output<SeedNodeArgs> prometheusEndpoint) {
            $.prometheusEndpoint = prometheusEndpoint;
            return this;
        }

        /**
         * @param prometheusEndpoint Hostname or IP address where the Prometheus endpoint containing data about the managed Cassandra nodes can be reached.
         * 
         * @return builder
         * 
         */
        public Builder prometheusEndpoint(SeedNodeArgs prometheusEndpoint) {
            return prometheusEndpoint(Output.of(prometheusEndpoint));
        }

        /**
         * @param provisioningState The status of the resource at the time the operation was called.
         * 
         * @return builder
         * 
         */
        public Builder provisioningState(@Nullable Output<Either<String,ManagedCassandraProvisioningState>> provisioningState) {
            $.provisioningState = provisioningState;
            return this;
        }

        /**
         * @param provisioningState The status of the resource at the time the operation was called.
         * 
         * @return builder
         * 
         */
        public Builder provisioningState(Either<String,ManagedCassandraProvisioningState> provisioningState) {
            return provisioningState(Output.of(provisioningState));
        }

        /**
         * @param provisioningState The status of the resource at the time the operation was called.
         * 
         * @return builder
         * 
         */
        public Builder provisioningState(String provisioningState) {
            return provisioningState(Either.ofLeft(provisioningState));
        }

        /**
         * @param provisioningState The status of the resource at the time the operation was called.
         * 
         * @return builder
         * 
         */
        public Builder provisioningState(ManagedCassandraProvisioningState provisioningState) {
            return provisioningState(Either.ofRight(provisioningState));
        }

        /**
         * @param repairEnabled Should automatic repairs run on this cluster? If omitted, this is true, and should stay true unless you are running a hybrid cluster where you are already doing your own repairs.
         * 
         * @return builder
         * 
         */
        public Builder repairEnabled(@Nullable Output<Boolean> repairEnabled) {
            $.repairEnabled = repairEnabled;
            return this;
        }

        /**
         * @param repairEnabled Should automatic repairs run on this cluster? If omitted, this is true, and should stay true unless you are running a hybrid cluster where you are already doing your own repairs.
         * 
         * @return builder
         * 
         */
        public Builder repairEnabled(Boolean repairEnabled) {
            return repairEnabled(Output.of(repairEnabled));
        }

        /**
         * @param restoreFromBackupId To create an empty cluster, omit this field or set it to null. To restore a backup into a new cluster, set this field to the resource id of the backup.
         * 
         * @return builder
         * 
         */
        public Builder restoreFromBackupId(@Nullable Output<String> restoreFromBackupId) {
            $.restoreFromBackupId = restoreFromBackupId;
            return this;
        }

        /**
         * @param restoreFromBackupId To create an empty cluster, omit this field or set it to null. To restore a backup into a new cluster, set this field to the resource id of the backup.
         * 
         * @return builder
         * 
         */
        public Builder restoreFromBackupId(String restoreFromBackupId) {
            return restoreFromBackupId(Output.of(restoreFromBackupId));
        }

        public ClusterResourcePropertiesArgs build() {
            return $;
        }
    }

}
