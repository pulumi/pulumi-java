// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.azurenative.sql;

import com.pulumi.azurenative.sql.inputs.VulnerabilityAssessmentRecurringScansPropertiesArgs;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.core.internal.Codegen;
import java.lang.String;
import java.util.Objects;
import javax.annotation.Nullable;


public final class ManagedInstanceVulnerabilityAssessmentArgs extends com.pulumi.resources.ResourceArgs {

    public static final ManagedInstanceVulnerabilityAssessmentArgs Empty = new ManagedInstanceVulnerabilityAssessmentArgs();

    /**
     * The name of the managed instance for which the vulnerability assessment is defined.
     * 
     */
    @Import(name="managedInstanceName", required=true)
      private final Output<String> managedInstanceName;

    public Output<String> managedInstanceName() {
        return this.managedInstanceName;
    }

    /**
     * The recurring scans settings
     * 
     */
    @Import(name="recurringScans")
      private final @Nullable Output<VulnerabilityAssessmentRecurringScansPropertiesArgs> recurringScans;

    public Output<VulnerabilityAssessmentRecurringScansPropertiesArgs> recurringScans() {
        return this.recurringScans == null ? Codegen.empty() : this.recurringScans;
    }

    /**
     * The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.
     * 
     */
    @Import(name="resourceGroupName", required=true)
      private final Output<String> resourceGroupName;

    public Output<String> resourceGroupName() {
        return this.resourceGroupName;
    }

    /**
     * Specifies the identifier key of the storage account for vulnerability assessment scan results. If 'StorageContainerSasKey' isn't specified, storageAccountAccessKey is required. Applies only if the storage account is not behind a Vnet or a firewall
     * 
     */
    @Import(name="storageAccountAccessKey")
      private final @Nullable Output<String> storageAccountAccessKey;

    public Output<String> storageAccountAccessKey() {
        return this.storageAccountAccessKey == null ? Codegen.empty() : this.storageAccountAccessKey;
    }

    /**
     * A blob storage container path to hold the scan results (e.g. https://myStorage.blob.core.windows.net/VaScans/).
     * 
     */
    @Import(name="storageContainerPath", required=true)
      private final Output<String> storageContainerPath;

    public Output<String> storageContainerPath() {
        return this.storageContainerPath;
    }

    /**
     * A shared access signature (SAS Key) that has write access to the blob container specified in 'storageContainerPath' parameter. If 'storageAccountAccessKey' isn't specified, StorageContainerSasKey is required. Applies only if the storage account is not behind a Vnet or a firewall
     * 
     */
    @Import(name="storageContainerSasKey")
      private final @Nullable Output<String> storageContainerSasKey;

    public Output<String> storageContainerSasKey() {
        return this.storageContainerSasKey == null ? Codegen.empty() : this.storageContainerSasKey;
    }

    /**
     * The name of the vulnerability assessment.
     * 
     */
    @Import(name="vulnerabilityAssessmentName")
      private final @Nullable Output<String> vulnerabilityAssessmentName;

    public Output<String> vulnerabilityAssessmentName() {
        return this.vulnerabilityAssessmentName == null ? Codegen.empty() : this.vulnerabilityAssessmentName;
    }

    public ManagedInstanceVulnerabilityAssessmentArgs(
        Output<String> managedInstanceName,
        @Nullable Output<VulnerabilityAssessmentRecurringScansPropertiesArgs> recurringScans,
        Output<String> resourceGroupName,
        @Nullable Output<String> storageAccountAccessKey,
        Output<String> storageContainerPath,
        @Nullable Output<String> storageContainerSasKey,
        @Nullable Output<String> vulnerabilityAssessmentName) {
        this.managedInstanceName = Objects.requireNonNull(managedInstanceName, "expected parameter 'managedInstanceName' to be non-null");
        this.recurringScans = recurringScans;
        this.resourceGroupName = Objects.requireNonNull(resourceGroupName, "expected parameter 'resourceGroupName' to be non-null");
        this.storageAccountAccessKey = storageAccountAccessKey;
        this.storageContainerPath = Objects.requireNonNull(storageContainerPath, "expected parameter 'storageContainerPath' to be non-null");
        this.storageContainerSasKey = storageContainerSasKey;
        this.vulnerabilityAssessmentName = vulnerabilityAssessmentName;
    }

    private ManagedInstanceVulnerabilityAssessmentArgs() {
        this.managedInstanceName = Codegen.empty();
        this.recurringScans = Codegen.empty();
        this.resourceGroupName = Codegen.empty();
        this.storageAccountAccessKey = Codegen.empty();
        this.storageContainerPath = Codegen.empty();
        this.storageContainerSasKey = Codegen.empty();
        this.vulnerabilityAssessmentName = Codegen.empty();
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(ManagedInstanceVulnerabilityAssessmentArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private Output<String> managedInstanceName;
        private @Nullable Output<VulnerabilityAssessmentRecurringScansPropertiesArgs> recurringScans;
        private Output<String> resourceGroupName;
        private @Nullable Output<String> storageAccountAccessKey;
        private Output<String> storageContainerPath;
        private @Nullable Output<String> storageContainerSasKey;
        private @Nullable Output<String> vulnerabilityAssessmentName;

        public Builder() {
    	      // Empty
        }

        public Builder(ManagedInstanceVulnerabilityAssessmentArgs defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.managedInstanceName = defaults.managedInstanceName;
    	      this.recurringScans = defaults.recurringScans;
    	      this.resourceGroupName = defaults.resourceGroupName;
    	      this.storageAccountAccessKey = defaults.storageAccountAccessKey;
    	      this.storageContainerPath = defaults.storageContainerPath;
    	      this.storageContainerSasKey = defaults.storageContainerSasKey;
    	      this.vulnerabilityAssessmentName = defaults.vulnerabilityAssessmentName;
        }

        public Builder managedInstanceName(Output<String> managedInstanceName) {
            this.managedInstanceName = Objects.requireNonNull(managedInstanceName);
            return this;
        }
        public Builder managedInstanceName(String managedInstanceName) {
            this.managedInstanceName = Output.of(Objects.requireNonNull(managedInstanceName));
            return this;
        }
        public Builder recurringScans(@Nullable Output<VulnerabilityAssessmentRecurringScansPropertiesArgs> recurringScans) {
            this.recurringScans = recurringScans;
            return this;
        }
        public Builder recurringScans(@Nullable VulnerabilityAssessmentRecurringScansPropertiesArgs recurringScans) {
            this.recurringScans = Codegen.ofNullable(recurringScans);
            return this;
        }
        public Builder resourceGroupName(Output<String> resourceGroupName) {
            this.resourceGroupName = Objects.requireNonNull(resourceGroupName);
            return this;
        }
        public Builder resourceGroupName(String resourceGroupName) {
            this.resourceGroupName = Output.of(Objects.requireNonNull(resourceGroupName));
            return this;
        }
        public Builder storageAccountAccessKey(@Nullable Output<String> storageAccountAccessKey) {
            this.storageAccountAccessKey = storageAccountAccessKey;
            return this;
        }
        public Builder storageAccountAccessKey(@Nullable String storageAccountAccessKey) {
            this.storageAccountAccessKey = Codegen.ofNullable(storageAccountAccessKey);
            return this;
        }
        public Builder storageContainerPath(Output<String> storageContainerPath) {
            this.storageContainerPath = Objects.requireNonNull(storageContainerPath);
            return this;
        }
        public Builder storageContainerPath(String storageContainerPath) {
            this.storageContainerPath = Output.of(Objects.requireNonNull(storageContainerPath));
            return this;
        }
        public Builder storageContainerSasKey(@Nullable Output<String> storageContainerSasKey) {
            this.storageContainerSasKey = storageContainerSasKey;
            return this;
        }
        public Builder storageContainerSasKey(@Nullable String storageContainerSasKey) {
            this.storageContainerSasKey = Codegen.ofNullable(storageContainerSasKey);
            return this;
        }
        public Builder vulnerabilityAssessmentName(@Nullable Output<String> vulnerabilityAssessmentName) {
            this.vulnerabilityAssessmentName = vulnerabilityAssessmentName;
            return this;
        }
        public Builder vulnerabilityAssessmentName(@Nullable String vulnerabilityAssessmentName) {
            this.vulnerabilityAssessmentName = Codegen.ofNullable(vulnerabilityAssessmentName);
            return this;
        }        public ManagedInstanceVulnerabilityAssessmentArgs build() {
            return new ManagedInstanceVulnerabilityAssessmentArgs(managedInstanceName, recurringScans, resourceGroupName, storageAccountAccessKey, storageContainerPath, storageContainerSasKey, vulnerabilityAssessmentName);
        }
    }
}
