// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.azurenative.mobilenetwork.inputs;

import com.pulumi.azurenative.mobilenetwork.enums.NaptEnabled;
import com.pulumi.azurenative.mobilenetwork.inputs.PinholeTimeoutsArgs;
import com.pulumi.azurenative.mobilenetwork.inputs.PortRangeArgs;
import com.pulumi.azurenative.mobilenetwork.inputs.PortReuseHoldTimesArgs;
import com.pulumi.core.Either;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.core.internal.Codegen;
import java.lang.Integer;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


/**
 * The Network Address and Port Translation settings to use for the attached data network.
 * 
 */
public final class NaptConfigurationArgs extends com.pulumi.resources.ResourceArgs {

    public static final NaptConfigurationArgs Empty = new NaptConfigurationArgs();

    /**
     * Whether NAPT is enabled for connections to this attachedDataNetwork.
     * 
     */
    @Import(name="enabled")
    private @Nullable Output<Either<String,NaptEnabled>> enabled;

    /**
     * @return Whether NAPT is enabled for connections to this attachedDataNetwork.
     * 
     */
    public Optional<Output<Either<String,NaptEnabled>>> enabled() {
        return Optional.ofNullable(this.enabled);
    }

    /**
     * Maximum number of UDP and TCP pinholes that can be open simultaneously on the core interface.
     * 
     */
    @Import(name="pinholeLimits")
    private @Nullable Output<Integer> pinholeLimits;

    /**
     * @return Maximum number of UDP and TCP pinholes that can be open simultaneously on the core interface.
     * 
     */
    public Optional<Output<Integer>> pinholeLimits() {
        return Optional.ofNullable(this.pinholeLimits);
    }

    /**
     * Expiry times of inactive NAPT pinholes, in seconds. All timers must be at least 1 second.
     * 
     */
    @Import(name="pinholeTimeouts")
    private @Nullable Output<PinholeTimeoutsArgs> pinholeTimeouts;

    /**
     * @return Expiry times of inactive NAPT pinholes, in seconds. All timers must be at least 1 second.
     * 
     */
    public Optional<Output<PinholeTimeoutsArgs>> pinholeTimeouts() {
        return Optional.ofNullable(this.pinholeTimeouts);
    }

    /**
     * Range of port numbers to use as translated ports on each translated address.
     * If not specified and NAPT is enabled, this range defaults to 1,024 - 65,535. (Ports under 1,024 should not be used because these are special purpose ports reserved by IANA.)
     * 
     */
    @Import(name="portRange")
    private @Nullable Output<PortRangeArgs> portRange;

    /**
     * @return Range of port numbers to use as translated ports on each translated address.
     * If not specified and NAPT is enabled, this range defaults to 1,024 - 65,535. (Ports under 1,024 should not be used because these are special purpose ports reserved by IANA.)
     * 
     */
    public Optional<Output<PortRangeArgs>> portRange() {
        return Optional.ofNullable(this.portRange);
    }

    /**
     * The minimum time (in seconds) that will pass before a port that was used by a closed pinhole can be recycled for use by another pinhole. All hold times must be minimum 1 second.
     * 
     */
    @Import(name="portReuseHoldTime")
    private @Nullable Output<PortReuseHoldTimesArgs> portReuseHoldTime;

    /**
     * @return The minimum time (in seconds) that will pass before a port that was used by a closed pinhole can be recycled for use by another pinhole. All hold times must be minimum 1 second.
     * 
     */
    public Optional<Output<PortReuseHoldTimesArgs>> portReuseHoldTime() {
        return Optional.ofNullable(this.portReuseHoldTime);
    }

    private NaptConfigurationArgs() {}

    private NaptConfigurationArgs(NaptConfigurationArgs $) {
        this.enabled = $.enabled;
        this.pinholeLimits = $.pinholeLimits;
        this.pinholeTimeouts = $.pinholeTimeouts;
        this.portRange = $.portRange;
        this.portReuseHoldTime = $.portReuseHoldTime;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(NaptConfigurationArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private NaptConfigurationArgs $;

        public Builder() {
            $ = new NaptConfigurationArgs();
        }

        public Builder(NaptConfigurationArgs defaults) {
            $ = new NaptConfigurationArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param enabled Whether NAPT is enabled for connections to this attachedDataNetwork.
         * 
         * @return builder
         * 
         */
        public Builder enabled(@Nullable Output<Either<String,NaptEnabled>> enabled) {
            $.enabled = enabled;
            return this;
        }

        /**
         * @param enabled Whether NAPT is enabled for connections to this attachedDataNetwork.
         * 
         * @return builder
         * 
         */
        public Builder enabled(Either<String,NaptEnabled> enabled) {
            return enabled(Output.of(enabled));
        }

        /**
         * @param enabled Whether NAPT is enabled for connections to this attachedDataNetwork.
         * 
         * @return builder
         * 
         */
        public Builder enabled(String enabled) {
            return enabled(Either.ofLeft(enabled));
        }

        /**
         * @param enabled Whether NAPT is enabled for connections to this attachedDataNetwork.
         * 
         * @return builder
         * 
         */
        public Builder enabled(NaptEnabled enabled) {
            return enabled(Either.ofRight(enabled));
        }

        /**
         * @param pinholeLimits Maximum number of UDP and TCP pinholes that can be open simultaneously on the core interface.
         * 
         * @return builder
         * 
         */
        public Builder pinholeLimits(@Nullable Output<Integer> pinholeLimits) {
            $.pinholeLimits = pinholeLimits;
            return this;
        }

        /**
         * @param pinholeLimits Maximum number of UDP and TCP pinholes that can be open simultaneously on the core interface.
         * 
         * @return builder
         * 
         */
        public Builder pinholeLimits(Integer pinholeLimits) {
            return pinholeLimits(Output.of(pinholeLimits));
        }

        /**
         * @param pinholeTimeouts Expiry times of inactive NAPT pinholes, in seconds. All timers must be at least 1 second.
         * 
         * @return builder
         * 
         */
        public Builder pinholeTimeouts(@Nullable Output<PinholeTimeoutsArgs> pinholeTimeouts) {
            $.pinholeTimeouts = pinholeTimeouts;
            return this;
        }

        /**
         * @param pinholeTimeouts Expiry times of inactive NAPT pinholes, in seconds. All timers must be at least 1 second.
         * 
         * @return builder
         * 
         */
        public Builder pinholeTimeouts(PinholeTimeoutsArgs pinholeTimeouts) {
            return pinholeTimeouts(Output.of(pinholeTimeouts));
        }

        /**
         * @param portRange Range of port numbers to use as translated ports on each translated address.
         * If not specified and NAPT is enabled, this range defaults to 1,024 - 65,535. (Ports under 1,024 should not be used because these are special purpose ports reserved by IANA.)
         * 
         * @return builder
         * 
         */
        public Builder portRange(@Nullable Output<PortRangeArgs> portRange) {
            $.portRange = portRange;
            return this;
        }

        /**
         * @param portRange Range of port numbers to use as translated ports on each translated address.
         * If not specified and NAPT is enabled, this range defaults to 1,024 - 65,535. (Ports under 1,024 should not be used because these are special purpose ports reserved by IANA.)
         * 
         * @return builder
         * 
         */
        public Builder portRange(PortRangeArgs portRange) {
            return portRange(Output.of(portRange));
        }

        /**
         * @param portReuseHoldTime The minimum time (in seconds) that will pass before a port that was used by a closed pinhole can be recycled for use by another pinhole. All hold times must be minimum 1 second.
         * 
         * @return builder
         * 
         */
        public Builder portReuseHoldTime(@Nullable Output<PortReuseHoldTimesArgs> portReuseHoldTime) {
            $.portReuseHoldTime = portReuseHoldTime;
            return this;
        }

        /**
         * @param portReuseHoldTime The minimum time (in seconds) that will pass before a port that was used by a closed pinhole can be recycled for use by another pinhole. All hold times must be minimum 1 second.
         * 
         * @return builder
         * 
         */
        public Builder portReuseHoldTime(PortReuseHoldTimesArgs portReuseHoldTime) {
            return portReuseHoldTime(Output.of(portReuseHoldTime));
        }

        public NaptConfigurationArgs build() {
            $.pinholeLimits = Codegen.integerProp("pinholeLimits").output().arg($.pinholeLimits).def(65536).getNullable();
            return $;
        }
    }

}
