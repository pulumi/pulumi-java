// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.azurenative.videoanalyzer.inputs;

import com.pulumi.azurenative.videoanalyzer.enums.RtspTransport;
import com.pulumi.azurenative.videoanalyzer.inputs.TlsEndpointArgs;
import com.pulumi.azurenative.videoanalyzer.inputs.UnsecuredEndpointArgs;
import com.pulumi.core.Either;
import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.core.internal.Codegen;
import java.lang.String;
import java.util.Objects;
import javax.annotation.Nullable;


/**
 * RTSP source allows for media from an RTSP camera or generic RTSP server to be ingested into a pipeline.
 * 
 */
public final class RtspSourceArgs extends com.pulumi.resources.ResourceArgs {

    public static final RtspSourceArgs Empty = new RtspSourceArgs();

    /**
     * RTSP endpoint information for Video Analyzer to connect to. This contains the required information for Video Analyzer to connect to RTSP cameras and/or generic RTSP servers.
     * 
     */
    @Import(name="endpoint", required=true)
      private final Output<Either<TlsEndpointArgs,UnsecuredEndpointArgs>> endpoint;

    public Output<Either<TlsEndpointArgs,UnsecuredEndpointArgs>> endpoint() {
        return this.endpoint;
    }

    /**
     * Node name. Must be unique within the topology.
     * 
     */
    @Import(name="name", required=true)
      private final Output<String> name;

    public Output<String> name() {
        return this.name;
    }

    /**
     * Network transport utilized by the RTSP and RTP exchange: TCP or HTTP. When using TCP, the RTP packets are interleaved on the TCP RTSP connection. When using HTTP, the RTSP messages are exchanged through long lived HTTP connections, and the RTP packages are interleaved in the HTTP connections alongside the RTSP messages.
     * 
     */
    @Import(name="transport")
      private final @Nullable Output<Either<String,RtspTransport>> transport;

    public Output<Either<String,RtspTransport>> transport() {
        return this.transport == null ? Codegen.empty() : this.transport;
    }

    /**
     * The discriminator for derived types.
     * Expected value is &#39;#Microsoft.VideoAnalyzer.RtspSource&#39;.
     * 
     */
    @Import(name="type", required=true)
      private final Output<String> type;

    public Output<String> type() {
        return this.type;
    }

    public RtspSourceArgs(
        Output<Either<TlsEndpointArgs,UnsecuredEndpointArgs>> endpoint,
        Output<String> name,
        @Nullable Output<Either<String,RtspTransport>> transport,
        Output<String> type) {
        this.endpoint = Objects.requireNonNull(endpoint, "expected parameter 'endpoint' to be non-null");
        this.name = Objects.requireNonNull(name, "expected parameter 'name' to be non-null");
        this.transport = transport;
        this.type = Codegen.stringProp("type").output().arg(type).require();
    }

    private RtspSourceArgs() {
        this.endpoint = Codegen.empty();
        this.name = Codegen.empty();
        this.transport = Codegen.empty();
        this.type = Codegen.empty();
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(RtspSourceArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private Output<Either<TlsEndpointArgs,UnsecuredEndpointArgs>> endpoint;
        private Output<String> name;
        private @Nullable Output<Either<String,RtspTransport>> transport;
        private Output<String> type;

        public Builder() {
    	      // Empty
        }

        public Builder(RtspSourceArgs defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.endpoint = defaults.endpoint;
    	      this.name = defaults.name;
    	      this.transport = defaults.transport;
    	      this.type = defaults.type;
        }

        public Builder endpoint(Output<Either<TlsEndpointArgs,UnsecuredEndpointArgs>> endpoint) {
            this.endpoint = Objects.requireNonNull(endpoint);
            return this;
        }
        public Builder endpoint(Either<TlsEndpointArgs,UnsecuredEndpointArgs> endpoint) {
            this.endpoint = Output.of(Objects.requireNonNull(endpoint));
            return this;
        }
        public Builder name(Output<String> name) {
            this.name = Objects.requireNonNull(name);
            return this;
        }
        public Builder name(String name) {
            this.name = Output.of(Objects.requireNonNull(name));
            return this;
        }
        public Builder transport(@Nullable Output<Either<String,RtspTransport>> transport) {
            this.transport = transport;
            return this;
        }
        public Builder transport(@Nullable Either<String,RtspTransport> transport) {
            this.transport = Codegen.ofNullable(transport);
            return this;
        }
        public Builder type(Output<String> type) {
            this.type = Objects.requireNonNull(type);
            return this;
        }
        public Builder type(String type) {
            this.type = Output.of(Objects.requireNonNull(type));
            return this;
        }        public RtspSourceArgs build() {
            return new RtspSourceArgs(endpoint, name, transport, type);
        }
    }
}
