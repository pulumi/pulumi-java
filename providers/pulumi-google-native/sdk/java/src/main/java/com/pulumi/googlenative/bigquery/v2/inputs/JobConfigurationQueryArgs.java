// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.googlenative.bigquery.v2.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.googlenative.bigquery.v2.inputs.ClusteringArgs;
import com.pulumi.googlenative.bigquery.v2.inputs.ConnectionPropertyArgs;
import com.pulumi.googlenative.bigquery.v2.inputs.DatasetReferenceArgs;
import com.pulumi.googlenative.bigquery.v2.inputs.EncryptionConfigurationArgs;
import com.pulumi.googlenative.bigquery.v2.inputs.QueryParameterArgs;
import com.pulumi.googlenative.bigquery.v2.inputs.RangePartitioningArgs;
import com.pulumi.googlenative.bigquery.v2.inputs.TableReferenceArgs;
import com.pulumi.googlenative.bigquery.v2.inputs.TimePartitioningArgs;
import com.pulumi.googlenative.bigquery.v2.inputs.UserDefinedFunctionResourceArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class JobConfigurationQueryArgs extends com.pulumi.resources.ResourceArgs {

    public static final JobConfigurationQueryArgs Empty = new JobConfigurationQueryArgs();

    /**
     * [Optional] If true and query uses legacy SQL dialect, allows the query to produce arbitrarily large result tables at a slight cost in performance. Requires destinationTable to be set. For standard SQL queries, this flag is ignored and large results are always allowed. However, you must still set destinationTable when result size exceeds the allowed maximum response size.
     * 
     */
    @Import(name="allowLargeResults")
    private @Nullable Output<Boolean> allowLargeResults;

    /**
     * @return [Optional] If true and query uses legacy SQL dialect, allows the query to produce arbitrarily large result tables at a slight cost in performance. Requires destinationTable to be set. For standard SQL queries, this flag is ignored and large results are always allowed. However, you must still set destinationTable when result size exceeds the allowed maximum response size.
     * 
     */
    public Optional<Output<Boolean>> allowLargeResults() {
        return Optional.ofNullable(this.allowLargeResults);
    }

    /**
     * [Beta] Clustering specification for the destination table. Must be specified with time-based partitioning, data in the table will be first partitioned and subsequently clustered.
     * 
     */
    @Import(name="clustering")
    private @Nullable Output<ClusteringArgs> clustering;

    /**
     * @return [Beta] Clustering specification for the destination table. Must be specified with time-based partitioning, data in the table will be first partitioned and subsequently clustered.
     * 
     */
    public Optional<Output<ClusteringArgs>> clustering() {
        return Optional.ofNullable(this.clustering);
    }

    /**
     * Connection properties.
     * 
     */
    @Import(name="connectionProperties")
    private @Nullable Output<List<ConnectionPropertyArgs>> connectionProperties;

    /**
     * @return Connection properties.
     * 
     */
    public Optional<Output<List<ConnectionPropertyArgs>>> connectionProperties() {
        return Optional.ofNullable(this.connectionProperties);
    }

    /**
     * [Optional] Specifies whether the job is allowed to create new tables. The following values are supported: CREATE_IF_NEEDED: If the table does not exist, BigQuery creates the table. CREATE_NEVER: The table must already exist. If it does not, a &#39;notFound&#39; error is returned in the job result. The default value is CREATE_IF_NEEDED. Creation, truncation and append actions occur as one atomic update upon job completion.
     * 
     */
    @Import(name="createDisposition")
    private @Nullable Output<String> createDisposition;

    /**
     * @return [Optional] Specifies whether the job is allowed to create new tables. The following values are supported: CREATE_IF_NEEDED: If the table does not exist, BigQuery creates the table. CREATE_NEVER: The table must already exist. If it does not, a &#39;notFound&#39; error is returned in the job result. The default value is CREATE_IF_NEEDED. Creation, truncation and append actions occur as one atomic update upon job completion.
     * 
     */
    public Optional<Output<String>> createDisposition() {
        return Optional.ofNullable(this.createDisposition);
    }

    /**
     * If true, creates a new session, where session id will be a server generated random id. If false, runs query with an existing session_id passed in ConnectionProperty, otherwise runs query in non-session mode.
     * 
     */
    @Import(name="createSession")
    private @Nullable Output<Boolean> createSession;

    /**
     * @return If true, creates a new session, where session id will be a server generated random id. If false, runs query with an existing session_id passed in ConnectionProperty, otherwise runs query in non-session mode.
     * 
     */
    public Optional<Output<Boolean>> createSession() {
        return Optional.ofNullable(this.createSession);
    }

    /**
     * [Optional] Specifies the default dataset to use for unqualified table names in the query. Note that this does not alter behavior of unqualified dataset names.
     * 
     */
    @Import(name="defaultDataset")
    private @Nullable Output<DatasetReferenceArgs> defaultDataset;

    /**
     * @return [Optional] Specifies the default dataset to use for unqualified table names in the query. Note that this does not alter behavior of unqualified dataset names.
     * 
     */
    public Optional<Output<DatasetReferenceArgs>> defaultDataset() {
        return Optional.ofNullable(this.defaultDataset);
    }

    /**
     * Custom encryption configuration (e.g., Cloud KMS keys).
     * 
     */
    @Import(name="destinationEncryptionConfiguration")
    private @Nullable Output<EncryptionConfigurationArgs> destinationEncryptionConfiguration;

    /**
     * @return Custom encryption configuration (e.g., Cloud KMS keys).
     * 
     */
    public Optional<Output<EncryptionConfigurationArgs>> destinationEncryptionConfiguration() {
        return Optional.ofNullable(this.destinationEncryptionConfiguration);
    }

    /**
     * [Optional] Describes the table where the query results should be stored. If not present, a new table will be created to store the results. This property must be set for large results that exceed the maximum response size.
     * 
     */
    @Import(name="destinationTable")
    private @Nullable Output<TableReferenceArgs> destinationTable;

    /**
     * @return [Optional] Describes the table where the query results should be stored. If not present, a new table will be created to store the results. This property must be set for large results that exceed the maximum response size.
     * 
     */
    public Optional<Output<TableReferenceArgs>> destinationTable() {
        return Optional.ofNullable(this.destinationTable);
    }

    /**
     * [Optional] If true and query uses legacy SQL dialect, flattens all nested and repeated fields in the query results. allowLargeResults must be true if this is set to false. For standard SQL queries, this flag is ignored and results are never flattened.
     * 
     */
    @Import(name="flattenResults")
    private @Nullable Output<Boolean> flattenResults;

    /**
     * @return [Optional] If true and query uses legacy SQL dialect, flattens all nested and repeated fields in the query results. allowLargeResults must be true if this is set to false. For standard SQL queries, this flag is ignored and results are never flattened.
     * 
     */
    public Optional<Output<Boolean>> flattenResults() {
        return Optional.ofNullable(this.flattenResults);
    }

    /**
     * [Optional] Limits the billing tier for this job. Queries that have resource usage beyond this tier will fail (without incurring a charge). If unspecified, this will be set to your project default.
     * 
     */
    @Import(name="maximumBillingTier")
    private @Nullable Output<Integer> maximumBillingTier;

    /**
     * @return [Optional] Limits the billing tier for this job. Queries that have resource usage beyond this tier will fail (without incurring a charge). If unspecified, this will be set to your project default.
     * 
     */
    public Optional<Output<Integer>> maximumBillingTier() {
        return Optional.ofNullable(this.maximumBillingTier);
    }

    /**
     * [Optional] Limits the bytes billed for this job. Queries that will have bytes billed beyond this limit will fail (without incurring a charge). If unspecified, this will be set to your project default.
     * 
     */
    @Import(name="maximumBytesBilled")
    private @Nullable Output<String> maximumBytesBilled;

    /**
     * @return [Optional] Limits the bytes billed for this job. Queries that will have bytes billed beyond this limit will fail (without incurring a charge). If unspecified, this will be set to your project default.
     * 
     */
    public Optional<Output<String>> maximumBytesBilled() {
        return Optional.ofNullable(this.maximumBytesBilled);
    }

    /**
     * Standard SQL only. Set to POSITIONAL to use positional (?) query parameters or to NAMED to use named (@myparam) query parameters in this query.
     * 
     */
    @Import(name="parameterMode")
    private @Nullable Output<String> parameterMode;

    /**
     * @return Standard SQL only. Set to POSITIONAL to use positional (?) query parameters or to NAMED to use named (@myparam) query parameters in this query.
     * 
     */
    public Optional<Output<String>> parameterMode() {
        return Optional.ofNullable(this.parameterMode);
    }

    /**
     * [Deprecated] This property is deprecated.
     * 
     * @deprecated
     * [Deprecated] This property is deprecated.
     * 
     */
    @Deprecated /* [Deprecated] This property is deprecated. */
    @Import(name="preserveNulls")
    private @Nullable Output<Boolean> preserveNulls;

    /**
     * @return [Deprecated] This property is deprecated.
     * 
     * @deprecated
     * [Deprecated] This property is deprecated.
     * 
     */
    @Deprecated /* [Deprecated] This property is deprecated. */
    public Optional<Output<Boolean>> preserveNulls() {
        return Optional.ofNullable(this.preserveNulls);
    }

    /**
     * [Optional] Specifies a priority for the query. Possible values include INTERACTIVE and BATCH. The default value is INTERACTIVE.
     * 
     */
    @Import(name="priority")
    private @Nullable Output<String> priority;

    /**
     * @return [Optional] Specifies a priority for the query. Possible values include INTERACTIVE and BATCH. The default value is INTERACTIVE.
     * 
     */
    public Optional<Output<String>> priority() {
        return Optional.ofNullable(this.priority);
    }

    /**
     * [Required] SQL query text to execute. The useLegacySql field can be used to indicate whether the query uses legacy SQL or standard SQL.
     * 
     */
    @Import(name="query")
    private @Nullable Output<String> query;

    /**
     * @return [Required] SQL query text to execute. The useLegacySql field can be used to indicate whether the query uses legacy SQL or standard SQL.
     * 
     */
    public Optional<Output<String>> query() {
        return Optional.ofNullable(this.query);
    }

    /**
     * Query parameters for standard SQL queries.
     * 
     */
    @Import(name="queryParameters")
    private @Nullable Output<List<QueryParameterArgs>> queryParameters;

    /**
     * @return Query parameters for standard SQL queries.
     * 
     */
    public Optional<Output<List<QueryParameterArgs>>> queryParameters() {
        return Optional.ofNullable(this.queryParameters);
    }

    /**
     * [TrustedTester] Range partitioning specification for this table. Only one of timePartitioning and rangePartitioning should be specified.
     * 
     */
    @Import(name="rangePartitioning")
    private @Nullable Output<RangePartitioningArgs> rangePartitioning;

    /**
     * @return [TrustedTester] Range partitioning specification for this table. Only one of timePartitioning and rangePartitioning should be specified.
     * 
     */
    public Optional<Output<RangePartitioningArgs>> rangePartitioning() {
        return Optional.ofNullable(this.rangePartitioning);
    }

    /**
     * Allows the schema of the destination table to be updated as a side effect of the query job. Schema update options are supported in two cases: when writeDisposition is WRITE_APPEND; when writeDisposition is WRITE_TRUNCATE and the destination table is a partition of a table, specified by partition decorators. For normal tables, WRITE_TRUNCATE will always overwrite the schema. One or more of the following values are specified: ALLOW_FIELD_ADDITION: allow adding a nullable field to the schema. ALLOW_FIELD_RELAXATION: allow relaxing a required field in the original schema to nullable.
     * 
     */
    @Import(name="schemaUpdateOptions")
    private @Nullable Output<List<String>> schemaUpdateOptions;

    /**
     * @return Allows the schema of the destination table to be updated as a side effect of the query job. Schema update options are supported in two cases: when writeDisposition is WRITE_APPEND; when writeDisposition is WRITE_TRUNCATE and the destination table is a partition of a table, specified by partition decorators. For normal tables, WRITE_TRUNCATE will always overwrite the schema. One or more of the following values are specified: ALLOW_FIELD_ADDITION: allow adding a nullable field to the schema. ALLOW_FIELD_RELAXATION: allow relaxing a required field in the original schema to nullable.
     * 
     */
    public Optional<Output<List<String>>> schemaUpdateOptions() {
        return Optional.ofNullable(this.schemaUpdateOptions);
    }

    /**
     * [Optional] If querying an external data source outside of BigQuery, describes the data format, location and other properties of the data source. By defining these properties, the data source can then be queried as if it were a standard BigQuery table.
     * 
     */
    @Import(name="tableDefinitions")
    private @Nullable Output<Map<String,String>> tableDefinitions;

    /**
     * @return [Optional] If querying an external data source outside of BigQuery, describes the data format, location and other properties of the data source. By defining these properties, the data source can then be queried as if it were a standard BigQuery table.
     * 
     */
    public Optional<Output<Map<String,String>>> tableDefinitions() {
        return Optional.ofNullable(this.tableDefinitions);
    }

    /**
     * Time-based partitioning specification for the destination table. Only one of timePartitioning and rangePartitioning should be specified.
     * 
     */
    @Import(name="timePartitioning")
    private @Nullable Output<TimePartitioningArgs> timePartitioning;

    /**
     * @return Time-based partitioning specification for the destination table. Only one of timePartitioning and rangePartitioning should be specified.
     * 
     */
    public Optional<Output<TimePartitioningArgs>> timePartitioning() {
        return Optional.ofNullable(this.timePartitioning);
    }

    /**
     * Specifies whether to use BigQuery&#39;s legacy SQL dialect for this query. The default value is true. If set to false, the query will use BigQuery&#39;s standard SQL: https://cloud.google.com/bigquery/sql-reference/ When useLegacySql is set to false, the value of flattenResults is ignored; query will be run as if flattenResults is false.
     * 
     */
    @Import(name="useLegacySql")
    private @Nullable Output<Boolean> useLegacySql;

    /**
     * @return Specifies whether to use BigQuery&#39;s legacy SQL dialect for this query. The default value is true. If set to false, the query will use BigQuery&#39;s standard SQL: https://cloud.google.com/bigquery/sql-reference/ When useLegacySql is set to false, the value of flattenResults is ignored; query will be run as if flattenResults is false.
     * 
     */
    public Optional<Output<Boolean>> useLegacySql() {
        return Optional.ofNullable(this.useLegacySql);
    }

    /**
     * [Optional] Whether to look for the result in the query cache. The query cache is a best-effort cache that will be flushed whenever tables in the query are modified. Moreover, the query cache is only available when a query does not have a destination table specified. The default value is true.
     * 
     */
    @Import(name="useQueryCache")
    private @Nullable Output<Boolean> useQueryCache;

    /**
     * @return [Optional] Whether to look for the result in the query cache. The query cache is a best-effort cache that will be flushed whenever tables in the query are modified. Moreover, the query cache is only available when a query does not have a destination table specified. The default value is true.
     * 
     */
    public Optional<Output<Boolean>> useQueryCache() {
        return Optional.ofNullable(this.useQueryCache);
    }

    /**
     * Describes user-defined function resources used in the query.
     * 
     */
    @Import(name="userDefinedFunctionResources")
    private @Nullable Output<List<UserDefinedFunctionResourceArgs>> userDefinedFunctionResources;

    /**
     * @return Describes user-defined function resources used in the query.
     * 
     */
    public Optional<Output<List<UserDefinedFunctionResourceArgs>>> userDefinedFunctionResources() {
        return Optional.ofNullable(this.userDefinedFunctionResources);
    }

    /**
     * [Optional] Specifies the action that occurs if the destination table already exists. The following values are supported: WRITE_TRUNCATE: If the table already exists, BigQuery overwrites the table data and uses the schema from the query result. WRITE_APPEND: If the table already exists, BigQuery appends the data to the table. WRITE_EMPTY: If the table already exists and contains data, a &#39;duplicate&#39; error is returned in the job result. The default value is WRITE_EMPTY. Each action is atomic and only occurs if BigQuery is able to complete the job successfully. Creation, truncation and append actions occur as one atomic update upon job completion.
     * 
     */
    @Import(name="writeDisposition")
    private @Nullable Output<String> writeDisposition;

    /**
     * @return [Optional] Specifies the action that occurs if the destination table already exists. The following values are supported: WRITE_TRUNCATE: If the table already exists, BigQuery overwrites the table data and uses the schema from the query result. WRITE_APPEND: If the table already exists, BigQuery appends the data to the table. WRITE_EMPTY: If the table already exists and contains data, a &#39;duplicate&#39; error is returned in the job result. The default value is WRITE_EMPTY. Each action is atomic and only occurs if BigQuery is able to complete the job successfully. Creation, truncation and append actions occur as one atomic update upon job completion.
     * 
     */
    public Optional<Output<String>> writeDisposition() {
        return Optional.ofNullable(this.writeDisposition);
    }

    private JobConfigurationQueryArgs() {}

    private JobConfigurationQueryArgs(JobConfigurationQueryArgs $) {
        this.allowLargeResults = $.allowLargeResults;
        this.clustering = $.clustering;
        this.connectionProperties = $.connectionProperties;
        this.createDisposition = $.createDisposition;
        this.createSession = $.createSession;
        this.defaultDataset = $.defaultDataset;
        this.destinationEncryptionConfiguration = $.destinationEncryptionConfiguration;
        this.destinationTable = $.destinationTable;
        this.flattenResults = $.flattenResults;
        this.maximumBillingTier = $.maximumBillingTier;
        this.maximumBytesBilled = $.maximumBytesBilled;
        this.parameterMode = $.parameterMode;
        this.preserveNulls = $.preserveNulls;
        this.priority = $.priority;
        this.query = $.query;
        this.queryParameters = $.queryParameters;
        this.rangePartitioning = $.rangePartitioning;
        this.schemaUpdateOptions = $.schemaUpdateOptions;
        this.tableDefinitions = $.tableDefinitions;
        this.timePartitioning = $.timePartitioning;
        this.useLegacySql = $.useLegacySql;
        this.useQueryCache = $.useQueryCache;
        this.userDefinedFunctionResources = $.userDefinedFunctionResources;
        this.writeDisposition = $.writeDisposition;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(JobConfigurationQueryArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private JobConfigurationQueryArgs $;

        public Builder() {
            $ = new JobConfigurationQueryArgs();
        }

        public Builder(JobConfigurationQueryArgs defaults) {
            $ = new JobConfigurationQueryArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param allowLargeResults [Optional] If true and query uses legacy SQL dialect, allows the query to produce arbitrarily large result tables at a slight cost in performance. Requires destinationTable to be set. For standard SQL queries, this flag is ignored and large results are always allowed. However, you must still set destinationTable when result size exceeds the allowed maximum response size.
         * 
         * @return builder
         * 
         */
        public Builder allowLargeResults(@Nullable Output<Boolean> allowLargeResults) {
            $.allowLargeResults = allowLargeResults;
            return this;
        }

        /**
         * @param allowLargeResults [Optional] If true and query uses legacy SQL dialect, allows the query to produce arbitrarily large result tables at a slight cost in performance. Requires destinationTable to be set. For standard SQL queries, this flag is ignored and large results are always allowed. However, you must still set destinationTable when result size exceeds the allowed maximum response size.
         * 
         * @return builder
         * 
         */
        public Builder allowLargeResults(Boolean allowLargeResults) {
            return allowLargeResults(Output.of(allowLargeResults));
        }

        /**
         * @param clustering [Beta] Clustering specification for the destination table. Must be specified with time-based partitioning, data in the table will be first partitioned and subsequently clustered.
         * 
         * @return builder
         * 
         */
        public Builder clustering(@Nullable Output<ClusteringArgs> clustering) {
            $.clustering = clustering;
            return this;
        }

        /**
         * @param clustering [Beta] Clustering specification for the destination table. Must be specified with time-based partitioning, data in the table will be first partitioned and subsequently clustered.
         * 
         * @return builder
         * 
         */
        public Builder clustering(ClusteringArgs clustering) {
            return clustering(Output.of(clustering));
        }

        /**
         * @param connectionProperties Connection properties.
         * 
         * @return builder
         * 
         */
        public Builder connectionProperties(@Nullable Output<List<ConnectionPropertyArgs>> connectionProperties) {
            $.connectionProperties = connectionProperties;
            return this;
        }

        /**
         * @param connectionProperties Connection properties.
         * 
         * @return builder
         * 
         */
        public Builder connectionProperties(List<ConnectionPropertyArgs> connectionProperties) {
            return connectionProperties(Output.of(connectionProperties));
        }

        /**
         * @param connectionProperties Connection properties.
         * 
         * @return builder
         * 
         */
        public Builder connectionProperties(ConnectionPropertyArgs... connectionProperties) {
            return connectionProperties(List.of(connectionProperties));
        }

        /**
         * @param createDisposition [Optional] Specifies whether the job is allowed to create new tables. The following values are supported: CREATE_IF_NEEDED: If the table does not exist, BigQuery creates the table. CREATE_NEVER: The table must already exist. If it does not, a &#39;notFound&#39; error is returned in the job result. The default value is CREATE_IF_NEEDED. Creation, truncation and append actions occur as one atomic update upon job completion.
         * 
         * @return builder
         * 
         */
        public Builder createDisposition(@Nullable Output<String> createDisposition) {
            $.createDisposition = createDisposition;
            return this;
        }

        /**
         * @param createDisposition [Optional] Specifies whether the job is allowed to create new tables. The following values are supported: CREATE_IF_NEEDED: If the table does not exist, BigQuery creates the table. CREATE_NEVER: The table must already exist. If it does not, a &#39;notFound&#39; error is returned in the job result. The default value is CREATE_IF_NEEDED. Creation, truncation and append actions occur as one atomic update upon job completion.
         * 
         * @return builder
         * 
         */
        public Builder createDisposition(String createDisposition) {
            return createDisposition(Output.of(createDisposition));
        }

        /**
         * @param createSession If true, creates a new session, where session id will be a server generated random id. If false, runs query with an existing session_id passed in ConnectionProperty, otherwise runs query in non-session mode.
         * 
         * @return builder
         * 
         */
        public Builder createSession(@Nullable Output<Boolean> createSession) {
            $.createSession = createSession;
            return this;
        }

        /**
         * @param createSession If true, creates a new session, where session id will be a server generated random id. If false, runs query with an existing session_id passed in ConnectionProperty, otherwise runs query in non-session mode.
         * 
         * @return builder
         * 
         */
        public Builder createSession(Boolean createSession) {
            return createSession(Output.of(createSession));
        }

        /**
         * @param defaultDataset [Optional] Specifies the default dataset to use for unqualified table names in the query. Note that this does not alter behavior of unqualified dataset names.
         * 
         * @return builder
         * 
         */
        public Builder defaultDataset(@Nullable Output<DatasetReferenceArgs> defaultDataset) {
            $.defaultDataset = defaultDataset;
            return this;
        }

        /**
         * @param defaultDataset [Optional] Specifies the default dataset to use for unqualified table names in the query. Note that this does not alter behavior of unqualified dataset names.
         * 
         * @return builder
         * 
         */
        public Builder defaultDataset(DatasetReferenceArgs defaultDataset) {
            return defaultDataset(Output.of(defaultDataset));
        }

        /**
         * @param destinationEncryptionConfiguration Custom encryption configuration (e.g., Cloud KMS keys).
         * 
         * @return builder
         * 
         */
        public Builder destinationEncryptionConfiguration(@Nullable Output<EncryptionConfigurationArgs> destinationEncryptionConfiguration) {
            $.destinationEncryptionConfiguration = destinationEncryptionConfiguration;
            return this;
        }

        /**
         * @param destinationEncryptionConfiguration Custom encryption configuration (e.g., Cloud KMS keys).
         * 
         * @return builder
         * 
         */
        public Builder destinationEncryptionConfiguration(EncryptionConfigurationArgs destinationEncryptionConfiguration) {
            return destinationEncryptionConfiguration(Output.of(destinationEncryptionConfiguration));
        }

        /**
         * @param destinationTable [Optional] Describes the table where the query results should be stored. If not present, a new table will be created to store the results. This property must be set for large results that exceed the maximum response size.
         * 
         * @return builder
         * 
         */
        public Builder destinationTable(@Nullable Output<TableReferenceArgs> destinationTable) {
            $.destinationTable = destinationTable;
            return this;
        }

        /**
         * @param destinationTable [Optional] Describes the table where the query results should be stored. If not present, a new table will be created to store the results. This property must be set for large results that exceed the maximum response size.
         * 
         * @return builder
         * 
         */
        public Builder destinationTable(TableReferenceArgs destinationTable) {
            return destinationTable(Output.of(destinationTable));
        }

        /**
         * @param flattenResults [Optional] If true and query uses legacy SQL dialect, flattens all nested and repeated fields in the query results. allowLargeResults must be true if this is set to false. For standard SQL queries, this flag is ignored and results are never flattened.
         * 
         * @return builder
         * 
         */
        public Builder flattenResults(@Nullable Output<Boolean> flattenResults) {
            $.flattenResults = flattenResults;
            return this;
        }

        /**
         * @param flattenResults [Optional] If true and query uses legacy SQL dialect, flattens all nested and repeated fields in the query results. allowLargeResults must be true if this is set to false. For standard SQL queries, this flag is ignored and results are never flattened.
         * 
         * @return builder
         * 
         */
        public Builder flattenResults(Boolean flattenResults) {
            return flattenResults(Output.of(flattenResults));
        }

        /**
         * @param maximumBillingTier [Optional] Limits the billing tier for this job. Queries that have resource usage beyond this tier will fail (without incurring a charge). If unspecified, this will be set to your project default.
         * 
         * @return builder
         * 
         */
        public Builder maximumBillingTier(@Nullable Output<Integer> maximumBillingTier) {
            $.maximumBillingTier = maximumBillingTier;
            return this;
        }

        /**
         * @param maximumBillingTier [Optional] Limits the billing tier for this job. Queries that have resource usage beyond this tier will fail (without incurring a charge). If unspecified, this will be set to your project default.
         * 
         * @return builder
         * 
         */
        public Builder maximumBillingTier(Integer maximumBillingTier) {
            return maximumBillingTier(Output.of(maximumBillingTier));
        }

        /**
         * @param maximumBytesBilled [Optional] Limits the bytes billed for this job. Queries that will have bytes billed beyond this limit will fail (without incurring a charge). If unspecified, this will be set to your project default.
         * 
         * @return builder
         * 
         */
        public Builder maximumBytesBilled(@Nullable Output<String> maximumBytesBilled) {
            $.maximumBytesBilled = maximumBytesBilled;
            return this;
        }

        /**
         * @param maximumBytesBilled [Optional] Limits the bytes billed for this job. Queries that will have bytes billed beyond this limit will fail (without incurring a charge). If unspecified, this will be set to your project default.
         * 
         * @return builder
         * 
         */
        public Builder maximumBytesBilled(String maximumBytesBilled) {
            return maximumBytesBilled(Output.of(maximumBytesBilled));
        }

        /**
         * @param parameterMode Standard SQL only. Set to POSITIONAL to use positional (?) query parameters or to NAMED to use named (@myparam) query parameters in this query.
         * 
         * @return builder
         * 
         */
        public Builder parameterMode(@Nullable Output<String> parameterMode) {
            $.parameterMode = parameterMode;
            return this;
        }

        /**
         * @param parameterMode Standard SQL only. Set to POSITIONAL to use positional (?) query parameters or to NAMED to use named (@myparam) query parameters in this query.
         * 
         * @return builder
         * 
         */
        public Builder parameterMode(String parameterMode) {
            return parameterMode(Output.of(parameterMode));
        }

        /**
         * @param preserveNulls [Deprecated] This property is deprecated.
         * 
         * @return builder
         * 
         * @deprecated
         * [Deprecated] This property is deprecated.
         * 
         */
        @Deprecated /* [Deprecated] This property is deprecated. */
        public Builder preserveNulls(@Nullable Output<Boolean> preserveNulls) {
            $.preserveNulls = preserveNulls;
            return this;
        }

        /**
         * @param preserveNulls [Deprecated] This property is deprecated.
         * 
         * @return builder
         * 
         * @deprecated
         * [Deprecated] This property is deprecated.
         * 
         */
        @Deprecated /* [Deprecated] This property is deprecated. */
        public Builder preserveNulls(Boolean preserveNulls) {
            return preserveNulls(Output.of(preserveNulls));
        }

        /**
         * @param priority [Optional] Specifies a priority for the query. Possible values include INTERACTIVE and BATCH. The default value is INTERACTIVE.
         * 
         * @return builder
         * 
         */
        public Builder priority(@Nullable Output<String> priority) {
            $.priority = priority;
            return this;
        }

        /**
         * @param priority [Optional] Specifies a priority for the query. Possible values include INTERACTIVE and BATCH. The default value is INTERACTIVE.
         * 
         * @return builder
         * 
         */
        public Builder priority(String priority) {
            return priority(Output.of(priority));
        }

        /**
         * @param query [Required] SQL query text to execute. The useLegacySql field can be used to indicate whether the query uses legacy SQL or standard SQL.
         * 
         * @return builder
         * 
         */
        public Builder query(@Nullable Output<String> query) {
            $.query = query;
            return this;
        }

        /**
         * @param query [Required] SQL query text to execute. The useLegacySql field can be used to indicate whether the query uses legacy SQL or standard SQL.
         * 
         * @return builder
         * 
         */
        public Builder query(String query) {
            return query(Output.of(query));
        }

        /**
         * @param queryParameters Query parameters for standard SQL queries.
         * 
         * @return builder
         * 
         */
        public Builder queryParameters(@Nullable Output<List<QueryParameterArgs>> queryParameters) {
            $.queryParameters = queryParameters;
            return this;
        }

        /**
         * @param queryParameters Query parameters for standard SQL queries.
         * 
         * @return builder
         * 
         */
        public Builder queryParameters(List<QueryParameterArgs> queryParameters) {
            return queryParameters(Output.of(queryParameters));
        }

        /**
         * @param queryParameters Query parameters for standard SQL queries.
         * 
         * @return builder
         * 
         */
        public Builder queryParameters(QueryParameterArgs... queryParameters) {
            return queryParameters(List.of(queryParameters));
        }

        /**
         * @param rangePartitioning [TrustedTester] Range partitioning specification for this table. Only one of timePartitioning and rangePartitioning should be specified.
         * 
         * @return builder
         * 
         */
        public Builder rangePartitioning(@Nullable Output<RangePartitioningArgs> rangePartitioning) {
            $.rangePartitioning = rangePartitioning;
            return this;
        }

        /**
         * @param rangePartitioning [TrustedTester] Range partitioning specification for this table. Only one of timePartitioning and rangePartitioning should be specified.
         * 
         * @return builder
         * 
         */
        public Builder rangePartitioning(RangePartitioningArgs rangePartitioning) {
            return rangePartitioning(Output.of(rangePartitioning));
        }

        /**
         * @param schemaUpdateOptions Allows the schema of the destination table to be updated as a side effect of the query job. Schema update options are supported in two cases: when writeDisposition is WRITE_APPEND; when writeDisposition is WRITE_TRUNCATE and the destination table is a partition of a table, specified by partition decorators. For normal tables, WRITE_TRUNCATE will always overwrite the schema. One or more of the following values are specified: ALLOW_FIELD_ADDITION: allow adding a nullable field to the schema. ALLOW_FIELD_RELAXATION: allow relaxing a required field in the original schema to nullable.
         * 
         * @return builder
         * 
         */
        public Builder schemaUpdateOptions(@Nullable Output<List<String>> schemaUpdateOptions) {
            $.schemaUpdateOptions = schemaUpdateOptions;
            return this;
        }

        /**
         * @param schemaUpdateOptions Allows the schema of the destination table to be updated as a side effect of the query job. Schema update options are supported in two cases: when writeDisposition is WRITE_APPEND; when writeDisposition is WRITE_TRUNCATE and the destination table is a partition of a table, specified by partition decorators. For normal tables, WRITE_TRUNCATE will always overwrite the schema. One or more of the following values are specified: ALLOW_FIELD_ADDITION: allow adding a nullable field to the schema. ALLOW_FIELD_RELAXATION: allow relaxing a required field in the original schema to nullable.
         * 
         * @return builder
         * 
         */
        public Builder schemaUpdateOptions(List<String> schemaUpdateOptions) {
            return schemaUpdateOptions(Output.of(schemaUpdateOptions));
        }

        /**
         * @param schemaUpdateOptions Allows the schema of the destination table to be updated as a side effect of the query job. Schema update options are supported in two cases: when writeDisposition is WRITE_APPEND; when writeDisposition is WRITE_TRUNCATE and the destination table is a partition of a table, specified by partition decorators. For normal tables, WRITE_TRUNCATE will always overwrite the schema. One or more of the following values are specified: ALLOW_FIELD_ADDITION: allow adding a nullable field to the schema. ALLOW_FIELD_RELAXATION: allow relaxing a required field in the original schema to nullable.
         * 
         * @return builder
         * 
         */
        public Builder schemaUpdateOptions(String... schemaUpdateOptions) {
            return schemaUpdateOptions(List.of(schemaUpdateOptions));
        }

        /**
         * @param tableDefinitions [Optional] If querying an external data source outside of BigQuery, describes the data format, location and other properties of the data source. By defining these properties, the data source can then be queried as if it were a standard BigQuery table.
         * 
         * @return builder
         * 
         */
        public Builder tableDefinitions(@Nullable Output<Map<String,String>> tableDefinitions) {
            $.tableDefinitions = tableDefinitions;
            return this;
        }

        /**
         * @param tableDefinitions [Optional] If querying an external data source outside of BigQuery, describes the data format, location and other properties of the data source. By defining these properties, the data source can then be queried as if it were a standard BigQuery table.
         * 
         * @return builder
         * 
         */
        public Builder tableDefinitions(Map<String,String> tableDefinitions) {
            return tableDefinitions(Output.of(tableDefinitions));
        }

        /**
         * @param timePartitioning Time-based partitioning specification for the destination table. Only one of timePartitioning and rangePartitioning should be specified.
         * 
         * @return builder
         * 
         */
        public Builder timePartitioning(@Nullable Output<TimePartitioningArgs> timePartitioning) {
            $.timePartitioning = timePartitioning;
            return this;
        }

        /**
         * @param timePartitioning Time-based partitioning specification for the destination table. Only one of timePartitioning and rangePartitioning should be specified.
         * 
         * @return builder
         * 
         */
        public Builder timePartitioning(TimePartitioningArgs timePartitioning) {
            return timePartitioning(Output.of(timePartitioning));
        }

        /**
         * @param useLegacySql Specifies whether to use BigQuery&#39;s legacy SQL dialect for this query. The default value is true. If set to false, the query will use BigQuery&#39;s standard SQL: https://cloud.google.com/bigquery/sql-reference/ When useLegacySql is set to false, the value of flattenResults is ignored; query will be run as if flattenResults is false.
         * 
         * @return builder
         * 
         */
        public Builder useLegacySql(@Nullable Output<Boolean> useLegacySql) {
            $.useLegacySql = useLegacySql;
            return this;
        }

        /**
         * @param useLegacySql Specifies whether to use BigQuery&#39;s legacy SQL dialect for this query. The default value is true. If set to false, the query will use BigQuery&#39;s standard SQL: https://cloud.google.com/bigquery/sql-reference/ When useLegacySql is set to false, the value of flattenResults is ignored; query will be run as if flattenResults is false.
         * 
         * @return builder
         * 
         */
        public Builder useLegacySql(Boolean useLegacySql) {
            return useLegacySql(Output.of(useLegacySql));
        }

        /**
         * @param useQueryCache [Optional] Whether to look for the result in the query cache. The query cache is a best-effort cache that will be flushed whenever tables in the query are modified. Moreover, the query cache is only available when a query does not have a destination table specified. The default value is true.
         * 
         * @return builder
         * 
         */
        public Builder useQueryCache(@Nullable Output<Boolean> useQueryCache) {
            $.useQueryCache = useQueryCache;
            return this;
        }

        /**
         * @param useQueryCache [Optional] Whether to look for the result in the query cache. The query cache is a best-effort cache that will be flushed whenever tables in the query are modified. Moreover, the query cache is only available when a query does not have a destination table specified. The default value is true.
         * 
         * @return builder
         * 
         */
        public Builder useQueryCache(Boolean useQueryCache) {
            return useQueryCache(Output.of(useQueryCache));
        }

        /**
         * @param userDefinedFunctionResources Describes user-defined function resources used in the query.
         * 
         * @return builder
         * 
         */
        public Builder userDefinedFunctionResources(@Nullable Output<List<UserDefinedFunctionResourceArgs>> userDefinedFunctionResources) {
            $.userDefinedFunctionResources = userDefinedFunctionResources;
            return this;
        }

        /**
         * @param userDefinedFunctionResources Describes user-defined function resources used in the query.
         * 
         * @return builder
         * 
         */
        public Builder userDefinedFunctionResources(List<UserDefinedFunctionResourceArgs> userDefinedFunctionResources) {
            return userDefinedFunctionResources(Output.of(userDefinedFunctionResources));
        }

        /**
         * @param userDefinedFunctionResources Describes user-defined function resources used in the query.
         * 
         * @return builder
         * 
         */
        public Builder userDefinedFunctionResources(UserDefinedFunctionResourceArgs... userDefinedFunctionResources) {
            return userDefinedFunctionResources(List.of(userDefinedFunctionResources));
        }

        /**
         * @param writeDisposition [Optional] Specifies the action that occurs if the destination table already exists. The following values are supported: WRITE_TRUNCATE: If the table already exists, BigQuery overwrites the table data and uses the schema from the query result. WRITE_APPEND: If the table already exists, BigQuery appends the data to the table. WRITE_EMPTY: If the table already exists and contains data, a &#39;duplicate&#39; error is returned in the job result. The default value is WRITE_EMPTY. Each action is atomic and only occurs if BigQuery is able to complete the job successfully. Creation, truncation and append actions occur as one atomic update upon job completion.
         * 
         * @return builder
         * 
         */
        public Builder writeDisposition(@Nullable Output<String> writeDisposition) {
            $.writeDisposition = writeDisposition;
            return this;
        }

        /**
         * @param writeDisposition [Optional] Specifies the action that occurs if the destination table already exists. The following values are supported: WRITE_TRUNCATE: If the table already exists, BigQuery overwrites the table data and uses the schema from the query result. WRITE_APPEND: If the table already exists, BigQuery appends the data to the table. WRITE_EMPTY: If the table already exists and contains data, a &#39;duplicate&#39; error is returned in the job result. The default value is WRITE_EMPTY. Each action is atomic and only occurs if BigQuery is able to complete the job successfully. Creation, truncation and append actions occur as one atomic update upon job completion.
         * 
         * @return builder
         * 
         */
        public Builder writeDisposition(String writeDisposition) {
            return writeDisposition(Output.of(writeDisposition));
        }

        public JobConfigurationQueryArgs build() {
            return $;
        }
    }

}
