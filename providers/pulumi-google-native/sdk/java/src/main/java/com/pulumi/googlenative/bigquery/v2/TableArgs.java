// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.googlenative.bigquery.v2;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.googlenative.bigquery.v2.inputs.ClusteringArgs;
import com.pulumi.googlenative.bigquery.v2.inputs.EncryptionConfigurationArgs;
import com.pulumi.googlenative.bigquery.v2.inputs.ExternalDataConfigurationArgs;
import com.pulumi.googlenative.bigquery.v2.inputs.MaterializedViewDefinitionArgs;
import com.pulumi.googlenative.bigquery.v2.inputs.ModelDefinitionArgs;
import com.pulumi.googlenative.bigquery.v2.inputs.RangePartitioningArgs;
import com.pulumi.googlenative.bigquery.v2.inputs.TableReferenceArgs;
import com.pulumi.googlenative.bigquery.v2.inputs.TableSchemaArgs;
import com.pulumi.googlenative.bigquery.v2.inputs.TimePartitioningArgs;
import com.pulumi.googlenative.bigquery.v2.inputs.ViewDefinitionArgs;
import java.lang.Boolean;
import java.lang.String;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class TableArgs extends com.pulumi.resources.ResourceArgs {

    public static final TableArgs Empty = new TableArgs();

    /**
     * [Beta] Clustering specification for the table. Must be specified with partitioning, data in the table will be first partitioned and subsequently clustered.
     * 
     */
    @Import(name="clustering")
    private @Nullable Output<ClusteringArgs> clustering;

    /**
     * @return [Beta] Clustering specification for the table. Must be specified with partitioning, data in the table will be first partitioned and subsequently clustered.
     * 
     */
    public Optional<Output<ClusteringArgs>> clustering() {
        return Optional.ofNullable(this.clustering);
    }

    @Import(name="datasetId", required=true)
    private Output<String> datasetId;

    public Output<String> datasetId() {
        return this.datasetId;
    }

    /**
     * [Optional] A user-friendly description of this table.
     * 
     */
    @Import(name="description")
    private @Nullable Output<String> description;

    /**
     * @return [Optional] A user-friendly description of this table.
     * 
     */
    public Optional<Output<String>> description() {
        return Optional.ofNullable(this.description);
    }

    /**
     * Custom encryption configuration (e.g., Cloud KMS keys).
     * 
     */
    @Import(name="encryptionConfiguration")
    private @Nullable Output<EncryptionConfigurationArgs> encryptionConfiguration;

    /**
     * @return Custom encryption configuration (e.g., Cloud KMS keys).
     * 
     */
    public Optional<Output<EncryptionConfigurationArgs>> encryptionConfiguration() {
        return Optional.ofNullable(this.encryptionConfiguration);
    }

    /**
     * [Optional] The time when this table expires, in milliseconds since the epoch. If not present, the table will persist indefinitely. Expired tables will be deleted and their storage reclaimed. The defaultTableExpirationMs property of the encapsulating dataset can be used to set a default expirationTime on newly created tables.
     * 
     */
    @Import(name="expirationTime")
    private @Nullable Output<String> expirationTime;

    /**
     * @return [Optional] The time when this table expires, in milliseconds since the epoch. If not present, the table will persist indefinitely. Expired tables will be deleted and their storage reclaimed. The defaultTableExpirationMs property of the encapsulating dataset can be used to set a default expirationTime on newly created tables.
     * 
     */
    public Optional<Output<String>> expirationTime() {
        return Optional.ofNullable(this.expirationTime);
    }

    /**
     * [Optional] Describes the data format, location, and other properties of a table stored outside of BigQuery. By defining these properties, the data source can then be queried as if it were a standard BigQuery table.
     * 
     */
    @Import(name="externalDataConfiguration")
    private @Nullable Output<ExternalDataConfigurationArgs> externalDataConfiguration;

    /**
     * @return [Optional] Describes the data format, location, and other properties of a table stored outside of BigQuery. By defining these properties, the data source can then be queried as if it were a standard BigQuery table.
     * 
     */
    public Optional<Output<ExternalDataConfigurationArgs>> externalDataConfiguration() {
        return Optional.ofNullable(this.externalDataConfiguration);
    }

    /**
     * [Optional] A descriptive name for this table.
     * 
     */
    @Import(name="friendlyName")
    private @Nullable Output<String> friendlyName;

    /**
     * @return [Optional] A descriptive name for this table.
     * 
     */
    public Optional<Output<String>> friendlyName() {
        return Optional.ofNullable(this.friendlyName);
    }

    /**
     * The labels associated with this table. You can use these to organize and group your tables. Label keys and values can be no longer than 63 characters, can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. Label values are optional. Label keys must start with a letter and each label in the list must have a different key.
     * 
     */
    @Import(name="labels")
    private @Nullable Output<Map<String,String>> labels;

    /**
     * @return The labels associated with this table. You can use these to organize and group your tables. Label keys and values can be no longer than 63 characters, can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. Label values are optional. Label keys must start with a letter and each label in the list must have a different key.
     * 
     */
    public Optional<Output<Map<String,String>>> labels() {
        return Optional.ofNullable(this.labels);
    }

    /**
     * [Optional] Materialized view definition.
     * 
     */
    @Import(name="materializedView")
    private @Nullable Output<MaterializedViewDefinitionArgs> materializedView;

    /**
     * @return [Optional] Materialized view definition.
     * 
     */
    public Optional<Output<MaterializedViewDefinitionArgs>> materializedView() {
        return Optional.ofNullable(this.materializedView);
    }

    /**
     * [Optional] Max staleness of data that could be returned when table or materialized view is queried (formatted as Google SQL Interval type).
     * 
     */
    @Import(name="maxStaleness")
    private @Nullable Output<String> maxStaleness;

    /**
     * @return [Optional] Max staleness of data that could be returned when table or materialized view is queried (formatted as Google SQL Interval type).
     * 
     */
    public Optional<Output<String>> maxStaleness() {
        return Optional.ofNullable(this.maxStaleness);
    }

    /**
     * [Output-only, Beta] Present iff this table represents a ML model. Describes the training information for the model, and it is required to run &#39;PREDICT&#39; queries.
     * 
     */
    @Import(name="model")
    private @Nullable Output<ModelDefinitionArgs> model;

    /**
     * @return [Output-only, Beta] Present iff this table represents a ML model. Describes the training information for the model, and it is required to run &#39;PREDICT&#39; queries.
     * 
     */
    public Optional<Output<ModelDefinitionArgs>> model() {
        return Optional.ofNullable(this.model);
    }

    @Import(name="project")
    private @Nullable Output<String> project;

    public Optional<Output<String>> project() {
        return Optional.ofNullable(this.project);
    }

    /**
     * [TrustedTester] Range partitioning specification for this table. Only one of timePartitioning and rangePartitioning should be specified.
     * 
     */
    @Import(name="rangePartitioning")
    private @Nullable Output<RangePartitioningArgs> rangePartitioning;

    /**
     * @return [TrustedTester] Range partitioning specification for this table. Only one of timePartitioning and rangePartitioning should be specified.
     * 
     */
    public Optional<Output<RangePartitioningArgs>> rangePartitioning() {
        return Optional.ofNullable(this.rangePartitioning);
    }

    /**
     * [Optional] If set to true, queries over this table require a partition filter that can be used for partition elimination to be specified.
     * 
     */
    @Import(name="requirePartitionFilter")
    private @Nullable Output<Boolean> requirePartitionFilter;

    /**
     * @return [Optional] If set to true, queries over this table require a partition filter that can be used for partition elimination to be specified.
     * 
     */
    public Optional<Output<Boolean>> requirePartitionFilter() {
        return Optional.ofNullable(this.requirePartitionFilter);
    }

    /**
     * [Optional] Describes the schema of this table.
     * 
     */
    @Import(name="schema")
    private @Nullable Output<TableSchemaArgs> schema;

    /**
     * @return [Optional] Describes the schema of this table.
     * 
     */
    public Optional<Output<TableSchemaArgs>> schema() {
        return Optional.ofNullable(this.schema);
    }

    /**
     * [Required] Reference describing the ID of this table.
     * 
     */
    @Import(name="tableReference")
    private @Nullable Output<TableReferenceArgs> tableReference;

    /**
     * @return [Required] Reference describing the ID of this table.
     * 
     */
    public Optional<Output<TableReferenceArgs>> tableReference() {
        return Optional.ofNullable(this.tableReference);
    }

    /**
     * Time-based partitioning specification for this table. Only one of timePartitioning and rangePartitioning should be specified.
     * 
     */
    @Import(name="timePartitioning")
    private @Nullable Output<TimePartitioningArgs> timePartitioning;

    /**
     * @return Time-based partitioning specification for this table. Only one of timePartitioning and rangePartitioning should be specified.
     * 
     */
    public Optional<Output<TimePartitioningArgs>> timePartitioning() {
        return Optional.ofNullable(this.timePartitioning);
    }

    /**
     * [Optional] The view definition.
     * 
     */
    @Import(name="view")
    private @Nullable Output<ViewDefinitionArgs> view;

    /**
     * @return [Optional] The view definition.
     * 
     */
    public Optional<Output<ViewDefinitionArgs>> view() {
        return Optional.ofNullable(this.view);
    }

    private TableArgs() {}

    private TableArgs(TableArgs $) {
        this.clustering = $.clustering;
        this.datasetId = $.datasetId;
        this.description = $.description;
        this.encryptionConfiguration = $.encryptionConfiguration;
        this.expirationTime = $.expirationTime;
        this.externalDataConfiguration = $.externalDataConfiguration;
        this.friendlyName = $.friendlyName;
        this.labels = $.labels;
        this.materializedView = $.materializedView;
        this.maxStaleness = $.maxStaleness;
        this.model = $.model;
        this.project = $.project;
        this.rangePartitioning = $.rangePartitioning;
        this.requirePartitionFilter = $.requirePartitionFilter;
        this.schema = $.schema;
        this.tableReference = $.tableReference;
        this.timePartitioning = $.timePartitioning;
        this.view = $.view;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(TableArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private TableArgs $;

        public Builder() {
            $ = new TableArgs();
        }

        public Builder(TableArgs defaults) {
            $ = new TableArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param clustering [Beta] Clustering specification for the table. Must be specified with partitioning, data in the table will be first partitioned and subsequently clustered.
         * 
         * @return builder
         * 
         */
        public Builder clustering(@Nullable Output<ClusteringArgs> clustering) {
            $.clustering = clustering;
            return this;
        }

        /**
         * @param clustering [Beta] Clustering specification for the table. Must be specified with partitioning, data in the table will be first partitioned and subsequently clustered.
         * 
         * @return builder
         * 
         */
        public Builder clustering(ClusteringArgs clustering) {
            return clustering(Output.of(clustering));
        }

        public Builder datasetId(Output<String> datasetId) {
            $.datasetId = datasetId;
            return this;
        }

        public Builder datasetId(String datasetId) {
            return datasetId(Output.of(datasetId));
        }

        /**
         * @param description [Optional] A user-friendly description of this table.
         * 
         * @return builder
         * 
         */
        public Builder description(@Nullable Output<String> description) {
            $.description = description;
            return this;
        }

        /**
         * @param description [Optional] A user-friendly description of this table.
         * 
         * @return builder
         * 
         */
        public Builder description(String description) {
            return description(Output.of(description));
        }

        /**
         * @param encryptionConfiguration Custom encryption configuration (e.g., Cloud KMS keys).
         * 
         * @return builder
         * 
         */
        public Builder encryptionConfiguration(@Nullable Output<EncryptionConfigurationArgs> encryptionConfiguration) {
            $.encryptionConfiguration = encryptionConfiguration;
            return this;
        }

        /**
         * @param encryptionConfiguration Custom encryption configuration (e.g., Cloud KMS keys).
         * 
         * @return builder
         * 
         */
        public Builder encryptionConfiguration(EncryptionConfigurationArgs encryptionConfiguration) {
            return encryptionConfiguration(Output.of(encryptionConfiguration));
        }

        /**
         * @param expirationTime [Optional] The time when this table expires, in milliseconds since the epoch. If not present, the table will persist indefinitely. Expired tables will be deleted and their storage reclaimed. The defaultTableExpirationMs property of the encapsulating dataset can be used to set a default expirationTime on newly created tables.
         * 
         * @return builder
         * 
         */
        public Builder expirationTime(@Nullable Output<String> expirationTime) {
            $.expirationTime = expirationTime;
            return this;
        }

        /**
         * @param expirationTime [Optional] The time when this table expires, in milliseconds since the epoch. If not present, the table will persist indefinitely. Expired tables will be deleted and their storage reclaimed. The defaultTableExpirationMs property of the encapsulating dataset can be used to set a default expirationTime on newly created tables.
         * 
         * @return builder
         * 
         */
        public Builder expirationTime(String expirationTime) {
            return expirationTime(Output.of(expirationTime));
        }

        /**
         * @param externalDataConfiguration [Optional] Describes the data format, location, and other properties of a table stored outside of BigQuery. By defining these properties, the data source can then be queried as if it were a standard BigQuery table.
         * 
         * @return builder
         * 
         */
        public Builder externalDataConfiguration(@Nullable Output<ExternalDataConfigurationArgs> externalDataConfiguration) {
            $.externalDataConfiguration = externalDataConfiguration;
            return this;
        }

        /**
         * @param externalDataConfiguration [Optional] Describes the data format, location, and other properties of a table stored outside of BigQuery. By defining these properties, the data source can then be queried as if it were a standard BigQuery table.
         * 
         * @return builder
         * 
         */
        public Builder externalDataConfiguration(ExternalDataConfigurationArgs externalDataConfiguration) {
            return externalDataConfiguration(Output.of(externalDataConfiguration));
        }

        /**
         * @param friendlyName [Optional] A descriptive name for this table.
         * 
         * @return builder
         * 
         */
        public Builder friendlyName(@Nullable Output<String> friendlyName) {
            $.friendlyName = friendlyName;
            return this;
        }

        /**
         * @param friendlyName [Optional] A descriptive name for this table.
         * 
         * @return builder
         * 
         */
        public Builder friendlyName(String friendlyName) {
            return friendlyName(Output.of(friendlyName));
        }

        /**
         * @param labels The labels associated with this table. You can use these to organize and group your tables. Label keys and values can be no longer than 63 characters, can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. Label values are optional. Label keys must start with a letter and each label in the list must have a different key.
         * 
         * @return builder
         * 
         */
        public Builder labels(@Nullable Output<Map<String,String>> labels) {
            $.labels = labels;
            return this;
        }

        /**
         * @param labels The labels associated with this table. You can use these to organize and group your tables. Label keys and values can be no longer than 63 characters, can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. Label values are optional. Label keys must start with a letter and each label in the list must have a different key.
         * 
         * @return builder
         * 
         */
        public Builder labels(Map<String,String> labels) {
            return labels(Output.of(labels));
        }

        /**
         * @param materializedView [Optional] Materialized view definition.
         * 
         * @return builder
         * 
         */
        public Builder materializedView(@Nullable Output<MaterializedViewDefinitionArgs> materializedView) {
            $.materializedView = materializedView;
            return this;
        }

        /**
         * @param materializedView [Optional] Materialized view definition.
         * 
         * @return builder
         * 
         */
        public Builder materializedView(MaterializedViewDefinitionArgs materializedView) {
            return materializedView(Output.of(materializedView));
        }

        /**
         * @param maxStaleness [Optional] Max staleness of data that could be returned when table or materialized view is queried (formatted as Google SQL Interval type).
         * 
         * @return builder
         * 
         */
        public Builder maxStaleness(@Nullable Output<String> maxStaleness) {
            $.maxStaleness = maxStaleness;
            return this;
        }

        /**
         * @param maxStaleness [Optional] Max staleness of data that could be returned when table or materialized view is queried (formatted as Google SQL Interval type).
         * 
         * @return builder
         * 
         */
        public Builder maxStaleness(String maxStaleness) {
            return maxStaleness(Output.of(maxStaleness));
        }

        /**
         * @param model [Output-only, Beta] Present iff this table represents a ML model. Describes the training information for the model, and it is required to run &#39;PREDICT&#39; queries.
         * 
         * @return builder
         * 
         */
        public Builder model(@Nullable Output<ModelDefinitionArgs> model) {
            $.model = model;
            return this;
        }

        /**
         * @param model [Output-only, Beta] Present iff this table represents a ML model. Describes the training information for the model, and it is required to run &#39;PREDICT&#39; queries.
         * 
         * @return builder
         * 
         */
        public Builder model(ModelDefinitionArgs model) {
            return model(Output.of(model));
        }

        public Builder project(@Nullable Output<String> project) {
            $.project = project;
            return this;
        }

        public Builder project(String project) {
            return project(Output.of(project));
        }

        /**
         * @param rangePartitioning [TrustedTester] Range partitioning specification for this table. Only one of timePartitioning and rangePartitioning should be specified.
         * 
         * @return builder
         * 
         */
        public Builder rangePartitioning(@Nullable Output<RangePartitioningArgs> rangePartitioning) {
            $.rangePartitioning = rangePartitioning;
            return this;
        }

        /**
         * @param rangePartitioning [TrustedTester] Range partitioning specification for this table. Only one of timePartitioning and rangePartitioning should be specified.
         * 
         * @return builder
         * 
         */
        public Builder rangePartitioning(RangePartitioningArgs rangePartitioning) {
            return rangePartitioning(Output.of(rangePartitioning));
        }

        /**
         * @param requirePartitionFilter [Optional] If set to true, queries over this table require a partition filter that can be used for partition elimination to be specified.
         * 
         * @return builder
         * 
         */
        public Builder requirePartitionFilter(@Nullable Output<Boolean> requirePartitionFilter) {
            $.requirePartitionFilter = requirePartitionFilter;
            return this;
        }

        /**
         * @param requirePartitionFilter [Optional] If set to true, queries over this table require a partition filter that can be used for partition elimination to be specified.
         * 
         * @return builder
         * 
         */
        public Builder requirePartitionFilter(Boolean requirePartitionFilter) {
            return requirePartitionFilter(Output.of(requirePartitionFilter));
        }

        /**
         * @param schema [Optional] Describes the schema of this table.
         * 
         * @return builder
         * 
         */
        public Builder schema(@Nullable Output<TableSchemaArgs> schema) {
            $.schema = schema;
            return this;
        }

        /**
         * @param schema [Optional] Describes the schema of this table.
         * 
         * @return builder
         * 
         */
        public Builder schema(TableSchemaArgs schema) {
            return schema(Output.of(schema));
        }

        /**
         * @param tableReference [Required] Reference describing the ID of this table.
         * 
         * @return builder
         * 
         */
        public Builder tableReference(@Nullable Output<TableReferenceArgs> tableReference) {
            $.tableReference = tableReference;
            return this;
        }

        /**
         * @param tableReference [Required] Reference describing the ID of this table.
         * 
         * @return builder
         * 
         */
        public Builder tableReference(TableReferenceArgs tableReference) {
            return tableReference(Output.of(tableReference));
        }

        /**
         * @param timePartitioning Time-based partitioning specification for this table. Only one of timePartitioning and rangePartitioning should be specified.
         * 
         * @return builder
         * 
         */
        public Builder timePartitioning(@Nullable Output<TimePartitioningArgs> timePartitioning) {
            $.timePartitioning = timePartitioning;
            return this;
        }

        /**
         * @param timePartitioning Time-based partitioning specification for this table. Only one of timePartitioning and rangePartitioning should be specified.
         * 
         * @return builder
         * 
         */
        public Builder timePartitioning(TimePartitioningArgs timePartitioning) {
            return timePartitioning(Output.of(timePartitioning));
        }

        /**
         * @param view [Optional] The view definition.
         * 
         * @return builder
         * 
         */
        public Builder view(@Nullable Output<ViewDefinitionArgs> view) {
            $.view = view;
            return this;
        }

        /**
         * @param view [Optional] The view definition.
         * 
         * @return builder
         * 
         */
        public Builder view(ViewDefinitionArgs view) {
            return view(Output.of(view));
        }

        public TableArgs build() {
            $.datasetId = Objects.requireNonNull($.datasetId, "expected parameter 'datasetId' to be non-null");
            return $;
        }
    }

}
