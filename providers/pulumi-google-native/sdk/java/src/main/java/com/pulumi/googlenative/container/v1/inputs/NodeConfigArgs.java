// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.googlenative.container.v1.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.googlenative.container.v1.inputs.AcceleratorConfigArgs;
import com.pulumi.googlenative.container.v1.inputs.AdvancedMachineFeaturesArgs;
import com.pulumi.googlenative.container.v1.inputs.ConfidentialNodesArgs;
import com.pulumi.googlenative.container.v1.inputs.GcfsConfigArgs;
import com.pulumi.googlenative.container.v1.inputs.LinuxNodeConfigArgs;
import com.pulumi.googlenative.container.v1.inputs.NodeKubeletConfigArgs;
import com.pulumi.googlenative.container.v1.inputs.NodeTaintArgs;
import com.pulumi.googlenative.container.v1.inputs.ReservationAffinityArgs;
import com.pulumi.googlenative.container.v1.inputs.SandboxConfigArgs;
import com.pulumi.googlenative.container.v1.inputs.ShieldedInstanceConfigArgs;
import com.pulumi.googlenative.container.v1.inputs.VirtualNICArgs;
import com.pulumi.googlenative.container.v1.inputs.WorkloadMetadataConfigArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


/**
 * Parameters that describe the nodes in a cluster. GKE Autopilot clusters do not recognize parameters in `NodeConfig`. Use AutoprovisioningNodePoolDefaults instead.
 * 
 */
public final class NodeConfigArgs extends com.pulumi.resources.ResourceArgs {

    public static final NodeConfigArgs Empty = new NodeConfigArgs();

    /**
     * A list of hardware accelerators to be attached to each node. See https://cloud.google.com/compute/docs/gpus for more information about support for GPUs.
     * 
     */
    @Import(name="accelerators")
    private @Nullable Output<List<AcceleratorConfigArgs>> accelerators;

    /**
     * @return A list of hardware accelerators to be attached to each node. See https://cloud.google.com/compute/docs/gpus for more information about support for GPUs.
     * 
     */
    public Optional<Output<List<AcceleratorConfigArgs>>> accelerators() {
        return Optional.ofNullable(this.accelerators);
    }

    /**
     * Advanced features for the Compute Engine VM.
     * 
     */
    @Import(name="advancedMachineFeatures")
    private @Nullable Output<AdvancedMachineFeaturesArgs> advancedMachineFeatures;

    /**
     * @return Advanced features for the Compute Engine VM.
     * 
     */
    public Optional<Output<AdvancedMachineFeaturesArgs>> advancedMachineFeatures() {
        return Optional.ofNullable(this.advancedMachineFeatures);
    }

    /**
     *  The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool. This should be of the form projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME]. For more information about protecting resources with Cloud KMS Keys please see: https://cloud.google.com/compute/docs/disks/customer-managed-encryption
     * 
     */
    @Import(name="bootDiskKmsKey")
    private @Nullable Output<String> bootDiskKmsKey;

    /**
     * @return  The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool. This should be of the form projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME]. For more information about protecting resources with Cloud KMS Keys please see: https://cloud.google.com/compute/docs/disks/customer-managed-encryption
     * 
     */
    public Optional<Output<String>> bootDiskKmsKey() {
        return Optional.ofNullable(this.bootDiskKmsKey);
    }

    /**
     * Confidential nodes config. All the nodes in the node pool will be Confidential VM once enabled.
     * 
     */
    @Import(name="confidentialNodes")
    private @Nullable Output<ConfidentialNodesArgs> confidentialNodes;

    /**
     * @return Confidential nodes config. All the nodes in the node pool will be Confidential VM once enabled.
     * 
     */
    public Optional<Output<ConfidentialNodesArgs>> confidentialNodes() {
        return Optional.ofNullable(this.confidentialNodes);
    }

    /**
     * Size of the disk attached to each node, specified in GB. The smallest allowed disk size is 10GB. If unspecified, the default disk size is 100GB.
     * 
     */
    @Import(name="diskSizeGb")
    private @Nullable Output<Integer> diskSizeGb;

    /**
     * @return Size of the disk attached to each node, specified in GB. The smallest allowed disk size is 10GB. If unspecified, the default disk size is 100GB.
     * 
     */
    public Optional<Output<Integer>> diskSizeGb() {
        return Optional.ofNullable(this.diskSizeGb);
    }

    /**
     * Type of the disk attached to each node (e.g. &#39;pd-standard&#39;, &#39;pd-ssd&#39; or &#39;pd-balanced&#39;) If unspecified, the default disk type is &#39;pd-standard&#39;
     * 
     */
    @Import(name="diskType")
    private @Nullable Output<String> diskType;

    /**
     * @return Type of the disk attached to each node (e.g. &#39;pd-standard&#39;, &#39;pd-ssd&#39; or &#39;pd-balanced&#39;) If unspecified, the default disk type is &#39;pd-standard&#39;
     * 
     */
    public Optional<Output<String>> diskType() {
        return Optional.ofNullable(this.diskType);
    }

    /**
     * Google Container File System (image streaming) configs.
     * 
     */
    @Import(name="gcfsConfig")
    private @Nullable Output<GcfsConfigArgs> gcfsConfig;

    /**
     * @return Google Container File System (image streaming) configs.
     * 
     */
    public Optional<Output<GcfsConfigArgs>> gcfsConfig() {
        return Optional.ofNullable(this.gcfsConfig);
    }

    /**
     * Enable or disable gvnic in the node pool.
     * 
     */
    @Import(name="gvnic")
    private @Nullable Output<VirtualNICArgs> gvnic;

    /**
     * @return Enable or disable gvnic in the node pool.
     * 
     */
    public Optional<Output<VirtualNICArgs>> gvnic() {
        return Optional.ofNullable(this.gvnic);
    }

    /**
     * The image type to use for this node. Note that for a given image type, the latest version of it will be used.
     * 
     */
    @Import(name="imageType")
    private @Nullable Output<String> imageType;

    /**
     * @return The image type to use for this node. Note that for a given image type, the latest version of it will be used.
     * 
     */
    public Optional<Output<String>> imageType() {
        return Optional.ofNullable(this.imageType);
    }

    /**
     * Node kubelet configs.
     * 
     */
    @Import(name="kubeletConfig")
    private @Nullable Output<NodeKubeletConfigArgs> kubeletConfig;

    /**
     * @return Node kubelet configs.
     * 
     */
    public Optional<Output<NodeKubeletConfigArgs>> kubeletConfig() {
        return Optional.ofNullable(this.kubeletConfig);
    }

    /**
     * The map of Kubernetes labels (key/value pairs) to be applied to each node. These will added in addition to any default label(s) that Kubernetes may apply to the node. In case of conflict in label keys, the applied set may differ depending on the Kubernetes version -- it&#39;s best to assume the behavior is undefined and conflicts should be avoided. For more information, including usage and the valid values, see: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
     * 
     */
    @Import(name="labels")
    private @Nullable Output<Map<String,String>> labels;

    /**
     * @return The map of Kubernetes labels (key/value pairs) to be applied to each node. These will added in addition to any default label(s) that Kubernetes may apply to the node. In case of conflict in label keys, the applied set may differ depending on the Kubernetes version -- it&#39;s best to assume the behavior is undefined and conflicts should be avoided. For more information, including usage and the valid values, see: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
     * 
     */
    public Optional<Output<Map<String,String>>> labels() {
        return Optional.ofNullable(this.labels);
    }

    /**
     * Parameters that can be configured on Linux nodes.
     * 
     */
    @Import(name="linuxNodeConfig")
    private @Nullable Output<LinuxNodeConfigArgs> linuxNodeConfig;

    /**
     * @return Parameters that can be configured on Linux nodes.
     * 
     */
    public Optional<Output<LinuxNodeConfigArgs>> linuxNodeConfig() {
        return Optional.ofNullable(this.linuxNodeConfig);
    }

    /**
     * The number of local SSD disks to be attached to the node. The limit for this value is dependent upon the maximum number of disks available on a machine per zone. See: https://cloud.google.com/compute/docs/disks/local-ssd for more information.
     * 
     */
    @Import(name="localSsdCount")
    private @Nullable Output<Integer> localSsdCount;

    /**
     * @return The number of local SSD disks to be attached to the node. The limit for this value is dependent upon the maximum number of disks available on a machine per zone. See: https://cloud.google.com/compute/docs/disks/local-ssd for more information.
     * 
     */
    public Optional<Output<Integer>> localSsdCount() {
        return Optional.ofNullable(this.localSsdCount);
    }

    /**
     * The name of a Google Compute Engine [machine type](https://cloud.google.com/compute/docs/machine-types) If unspecified, the default machine type is `e2-medium`.
     * 
     */
    @Import(name="machineType")
    private @Nullable Output<String> machineType;

    /**
     * @return The name of a Google Compute Engine [machine type](https://cloud.google.com/compute/docs/machine-types) If unspecified, the default machine type is `e2-medium`.
     * 
     */
    public Optional<Output<String>> machineType() {
        return Optional.ofNullable(this.machineType);
    }

    /**
     * The metadata key/value pairs assigned to instances in the cluster. Keys must conform to the regexp `[a-zA-Z0-9-_]+` and be less than 128 bytes in length. These are reflected as part of a URL in the metadata server. Additionally, to avoid ambiguity, keys must not conflict with any other metadata keys for the project or be one of the reserved keys: - &#34;cluster-location&#34; - &#34;cluster-name&#34; - &#34;cluster-uid&#34; - &#34;configure-sh&#34; - &#34;containerd-configure-sh&#34; - &#34;enable-os-login&#34; - &#34;gci-ensure-gke-docker&#34; - &#34;gci-metrics-enabled&#34; - &#34;gci-update-strategy&#34; - &#34;instance-template&#34; - &#34;kube-env&#34; - &#34;startup-script&#34; - &#34;user-data&#34; - &#34;disable-address-manager&#34; - &#34;windows-startup-script-ps1&#34; - &#34;common-psm1&#34; - &#34;k8s-node-setup-psm1&#34; - &#34;install-ssh-psm1&#34; - &#34;user-profile-psm1&#34; Values are free-form strings, and only have meaning as interpreted by the image running in the instance. The only restriction placed on them is that each value&#39;s size must be less than or equal to 32 KB. The total size of all keys and values must be less than 512 KB.
     * 
     */
    @Import(name="metadata")
    private @Nullable Output<Map<String,String>> metadata;

    /**
     * @return The metadata key/value pairs assigned to instances in the cluster. Keys must conform to the regexp `[a-zA-Z0-9-_]+` and be less than 128 bytes in length. These are reflected as part of a URL in the metadata server. Additionally, to avoid ambiguity, keys must not conflict with any other metadata keys for the project or be one of the reserved keys: - &#34;cluster-location&#34; - &#34;cluster-name&#34; - &#34;cluster-uid&#34; - &#34;configure-sh&#34; - &#34;containerd-configure-sh&#34; - &#34;enable-os-login&#34; - &#34;gci-ensure-gke-docker&#34; - &#34;gci-metrics-enabled&#34; - &#34;gci-update-strategy&#34; - &#34;instance-template&#34; - &#34;kube-env&#34; - &#34;startup-script&#34; - &#34;user-data&#34; - &#34;disable-address-manager&#34; - &#34;windows-startup-script-ps1&#34; - &#34;common-psm1&#34; - &#34;k8s-node-setup-psm1&#34; - &#34;install-ssh-psm1&#34; - &#34;user-profile-psm1&#34; Values are free-form strings, and only have meaning as interpreted by the image running in the instance. The only restriction placed on them is that each value&#39;s size must be less than or equal to 32 KB. The total size of all keys and values must be less than 512 KB.
     * 
     */
    public Optional<Output<Map<String,String>>> metadata() {
        return Optional.ofNullable(this.metadata);
    }

    /**
     * Minimum CPU platform to be used by this instance. The instance may be scheduled on the specified or newer CPU platform. Applicable values are the friendly names of CPU platforms, such as `minCpuPlatform: &#34;Intel Haswell&#34;` or `minCpuPlatform: &#34;Intel Sandy Bridge&#34;`. For more information, read [how to specify min CPU platform](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform)
     * 
     */
    @Import(name="minCpuPlatform")
    private @Nullable Output<String> minCpuPlatform;

    /**
     * @return Minimum CPU platform to be used by this instance. The instance may be scheduled on the specified or newer CPU platform. Applicable values are the friendly names of CPU platforms, such as `minCpuPlatform: &#34;Intel Haswell&#34;` or `minCpuPlatform: &#34;Intel Sandy Bridge&#34;`. For more information, read [how to specify min CPU platform](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform)
     * 
     */
    public Optional<Output<String>> minCpuPlatform() {
        return Optional.ofNullable(this.minCpuPlatform);
    }

    /**
     * Setting this field will assign instances of this pool to run on the specified node group. This is useful for running workloads on [sole tenant nodes](https://cloud.google.com/compute/docs/nodes/sole-tenant-nodes).
     * 
     */
    @Import(name="nodeGroup")
    private @Nullable Output<String> nodeGroup;

    /**
     * @return Setting this field will assign instances of this pool to run on the specified node group. This is useful for running workloads on [sole tenant nodes](https://cloud.google.com/compute/docs/nodes/sole-tenant-nodes).
     * 
     */
    public Optional<Output<String>> nodeGroup() {
        return Optional.ofNullable(this.nodeGroup);
    }

    /**
     * The set of Google API scopes to be made available on all of the node VMs under the &#34;default&#34; service account. The following scopes are recommended, but not required, and by default are not included: * `https://www.googleapis.com/auth/compute` is required for mounting persistent storage on your nodes. * `https://www.googleapis.com/auth/devstorage.read_only` is required for communicating with **gcr.io** (the [Google Container Registry](https://cloud.google.com/container-registry/)). If unspecified, no scopes are added, unless Cloud Logging or Cloud Monitoring are enabled, in which case their required scopes will be added.
     * 
     */
    @Import(name="oauthScopes")
    private @Nullable Output<List<String>> oauthScopes;

    /**
     * @return The set of Google API scopes to be made available on all of the node VMs under the &#34;default&#34; service account. The following scopes are recommended, but not required, and by default are not included: * `https://www.googleapis.com/auth/compute` is required for mounting persistent storage on your nodes. * `https://www.googleapis.com/auth/devstorage.read_only` is required for communicating with **gcr.io** (the [Google Container Registry](https://cloud.google.com/container-registry/)). If unspecified, no scopes are added, unless Cloud Logging or Cloud Monitoring are enabled, in which case their required scopes will be added.
     * 
     */
    public Optional<Output<List<String>>> oauthScopes() {
        return Optional.ofNullable(this.oauthScopes);
    }

    /**
     * Whether the nodes are created as preemptible VM instances. See: https://cloud.google.com/compute/docs/instances/preemptible for more information about preemptible VM instances.
     * 
     */
    @Import(name="preemptible")
    private @Nullable Output<Boolean> preemptible;

    /**
     * @return Whether the nodes are created as preemptible VM instances. See: https://cloud.google.com/compute/docs/instances/preemptible for more information about preemptible VM instances.
     * 
     */
    public Optional<Output<Boolean>> preemptible() {
        return Optional.ofNullable(this.preemptible);
    }

    /**
     * The optional reservation affinity. Setting this field will apply the specified [Zonal Compute Reservation](https://cloud.google.com/compute/docs/instances/reserving-zonal-resources) to this node pool.
     * 
     */
    @Import(name="reservationAffinity")
    private @Nullable Output<ReservationAffinityArgs> reservationAffinity;

    /**
     * @return The optional reservation affinity. Setting this field will apply the specified [Zonal Compute Reservation](https://cloud.google.com/compute/docs/instances/reserving-zonal-resources) to this node pool.
     * 
     */
    public Optional<Output<ReservationAffinityArgs>> reservationAffinity() {
        return Optional.ofNullable(this.reservationAffinity);
    }

    /**
     * Sandbox configuration for this node.
     * 
     */
    @Import(name="sandboxConfig")
    private @Nullable Output<SandboxConfigArgs> sandboxConfig;

    /**
     * @return Sandbox configuration for this node.
     * 
     */
    public Optional<Output<SandboxConfigArgs>> sandboxConfig() {
        return Optional.ofNullable(this.sandboxConfig);
    }

    /**
     * The Google Cloud Platform Service Account to be used by the node VMs. Specify the email address of the Service Account; otherwise, if no Service Account is specified, the &#34;default&#34; service account is used.
     * 
     */
    @Import(name="serviceAccount")
    private @Nullable Output<String> serviceAccount;

    /**
     * @return The Google Cloud Platform Service Account to be used by the node VMs. Specify the email address of the Service Account; otherwise, if no Service Account is specified, the &#34;default&#34; service account is used.
     * 
     */
    public Optional<Output<String>> serviceAccount() {
        return Optional.ofNullable(this.serviceAccount);
    }

    /**
     * Shielded Instance options.
     * 
     */
    @Import(name="shieldedInstanceConfig")
    private @Nullable Output<ShieldedInstanceConfigArgs> shieldedInstanceConfig;

    /**
     * @return Shielded Instance options.
     * 
     */
    public Optional<Output<ShieldedInstanceConfigArgs>> shieldedInstanceConfig() {
        return Optional.ofNullable(this.shieldedInstanceConfig);
    }

    /**
     * Spot flag for enabling Spot VM, which is a rebrand of the existing preemptible flag.
     * 
     */
    @Import(name="spot")
    private @Nullable Output<Boolean> spot;

    /**
     * @return Spot flag for enabling Spot VM, which is a rebrand of the existing preemptible flag.
     * 
     */
    public Optional<Output<Boolean>> spot() {
        return Optional.ofNullable(this.spot);
    }

    /**
     * The list of instance tags applied to all nodes. Tags are used to identify valid sources or targets for network firewalls and are specified by the client during cluster or node pool creation. Each tag within the list must comply with RFC1035.
     * 
     */
    @Import(name="tags")
    private @Nullable Output<List<String>> tags;

    /**
     * @return The list of instance tags applied to all nodes. Tags are used to identify valid sources or targets for network firewalls and are specified by the client during cluster or node pool creation. Each tag within the list must comply with RFC1035.
     * 
     */
    public Optional<Output<List<String>>> tags() {
        return Optional.ofNullable(this.tags);
    }

    /**
     * List of kubernetes taints to be applied to each node. For more information, including usage and the valid values, see: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
     * 
     */
    @Import(name="taints")
    private @Nullable Output<List<NodeTaintArgs>> taints;

    /**
     * @return List of kubernetes taints to be applied to each node. For more information, including usage and the valid values, see: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
     * 
     */
    public Optional<Output<List<NodeTaintArgs>>> taints() {
        return Optional.ofNullable(this.taints);
    }

    /**
     * The workload metadata configuration for this node.
     * 
     */
    @Import(name="workloadMetadataConfig")
    private @Nullable Output<WorkloadMetadataConfigArgs> workloadMetadataConfig;

    /**
     * @return The workload metadata configuration for this node.
     * 
     */
    public Optional<Output<WorkloadMetadataConfigArgs>> workloadMetadataConfig() {
        return Optional.ofNullable(this.workloadMetadataConfig);
    }

    private NodeConfigArgs() {}

    private NodeConfigArgs(NodeConfigArgs $) {
        this.accelerators = $.accelerators;
        this.advancedMachineFeatures = $.advancedMachineFeatures;
        this.bootDiskKmsKey = $.bootDiskKmsKey;
        this.confidentialNodes = $.confidentialNodes;
        this.diskSizeGb = $.diskSizeGb;
        this.diskType = $.diskType;
        this.gcfsConfig = $.gcfsConfig;
        this.gvnic = $.gvnic;
        this.imageType = $.imageType;
        this.kubeletConfig = $.kubeletConfig;
        this.labels = $.labels;
        this.linuxNodeConfig = $.linuxNodeConfig;
        this.localSsdCount = $.localSsdCount;
        this.machineType = $.machineType;
        this.metadata = $.metadata;
        this.minCpuPlatform = $.minCpuPlatform;
        this.nodeGroup = $.nodeGroup;
        this.oauthScopes = $.oauthScopes;
        this.preemptible = $.preemptible;
        this.reservationAffinity = $.reservationAffinity;
        this.sandboxConfig = $.sandboxConfig;
        this.serviceAccount = $.serviceAccount;
        this.shieldedInstanceConfig = $.shieldedInstanceConfig;
        this.spot = $.spot;
        this.tags = $.tags;
        this.taints = $.taints;
        this.workloadMetadataConfig = $.workloadMetadataConfig;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(NodeConfigArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private NodeConfigArgs $;

        public Builder() {
            $ = new NodeConfigArgs();
        }

        public Builder(NodeConfigArgs defaults) {
            $ = new NodeConfigArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param accelerators A list of hardware accelerators to be attached to each node. See https://cloud.google.com/compute/docs/gpus for more information about support for GPUs.
         * 
         * @return builder
         * 
         */
        public Builder accelerators(@Nullable Output<List<AcceleratorConfigArgs>> accelerators) {
            $.accelerators = accelerators;
            return this;
        }

        /**
         * @param accelerators A list of hardware accelerators to be attached to each node. See https://cloud.google.com/compute/docs/gpus for more information about support for GPUs.
         * 
         * @return builder
         * 
         */
        public Builder accelerators(List<AcceleratorConfigArgs> accelerators) {
            return accelerators(Output.of(accelerators));
        }

        /**
         * @param accelerators A list of hardware accelerators to be attached to each node. See https://cloud.google.com/compute/docs/gpus for more information about support for GPUs.
         * 
         * @return builder
         * 
         */
        public Builder accelerators(AcceleratorConfigArgs... accelerators) {
            return accelerators(List.of(accelerators));
        }

        /**
         * @param advancedMachineFeatures Advanced features for the Compute Engine VM.
         * 
         * @return builder
         * 
         */
        public Builder advancedMachineFeatures(@Nullable Output<AdvancedMachineFeaturesArgs> advancedMachineFeatures) {
            $.advancedMachineFeatures = advancedMachineFeatures;
            return this;
        }

        /**
         * @param advancedMachineFeatures Advanced features for the Compute Engine VM.
         * 
         * @return builder
         * 
         */
        public Builder advancedMachineFeatures(AdvancedMachineFeaturesArgs advancedMachineFeatures) {
            return advancedMachineFeatures(Output.of(advancedMachineFeatures));
        }

        /**
         * @param bootDiskKmsKey  The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool. This should be of the form projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME]. For more information about protecting resources with Cloud KMS Keys please see: https://cloud.google.com/compute/docs/disks/customer-managed-encryption
         * 
         * @return builder
         * 
         */
        public Builder bootDiskKmsKey(@Nullable Output<String> bootDiskKmsKey) {
            $.bootDiskKmsKey = bootDiskKmsKey;
            return this;
        }

        /**
         * @param bootDiskKmsKey  The Customer Managed Encryption Key used to encrypt the boot disk attached to each node in the node pool. This should be of the form projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME]. For more information about protecting resources with Cloud KMS Keys please see: https://cloud.google.com/compute/docs/disks/customer-managed-encryption
         * 
         * @return builder
         * 
         */
        public Builder bootDiskKmsKey(String bootDiskKmsKey) {
            return bootDiskKmsKey(Output.of(bootDiskKmsKey));
        }

        /**
         * @param confidentialNodes Confidential nodes config. All the nodes in the node pool will be Confidential VM once enabled.
         * 
         * @return builder
         * 
         */
        public Builder confidentialNodes(@Nullable Output<ConfidentialNodesArgs> confidentialNodes) {
            $.confidentialNodes = confidentialNodes;
            return this;
        }

        /**
         * @param confidentialNodes Confidential nodes config. All the nodes in the node pool will be Confidential VM once enabled.
         * 
         * @return builder
         * 
         */
        public Builder confidentialNodes(ConfidentialNodesArgs confidentialNodes) {
            return confidentialNodes(Output.of(confidentialNodes));
        }

        /**
         * @param diskSizeGb Size of the disk attached to each node, specified in GB. The smallest allowed disk size is 10GB. If unspecified, the default disk size is 100GB.
         * 
         * @return builder
         * 
         */
        public Builder diskSizeGb(@Nullable Output<Integer> diskSizeGb) {
            $.diskSizeGb = diskSizeGb;
            return this;
        }

        /**
         * @param diskSizeGb Size of the disk attached to each node, specified in GB. The smallest allowed disk size is 10GB. If unspecified, the default disk size is 100GB.
         * 
         * @return builder
         * 
         */
        public Builder diskSizeGb(Integer diskSizeGb) {
            return diskSizeGb(Output.of(diskSizeGb));
        }

        /**
         * @param diskType Type of the disk attached to each node (e.g. &#39;pd-standard&#39;, &#39;pd-ssd&#39; or &#39;pd-balanced&#39;) If unspecified, the default disk type is &#39;pd-standard&#39;
         * 
         * @return builder
         * 
         */
        public Builder diskType(@Nullable Output<String> diskType) {
            $.diskType = diskType;
            return this;
        }

        /**
         * @param diskType Type of the disk attached to each node (e.g. &#39;pd-standard&#39;, &#39;pd-ssd&#39; or &#39;pd-balanced&#39;) If unspecified, the default disk type is &#39;pd-standard&#39;
         * 
         * @return builder
         * 
         */
        public Builder diskType(String diskType) {
            return diskType(Output.of(diskType));
        }

        /**
         * @param gcfsConfig Google Container File System (image streaming) configs.
         * 
         * @return builder
         * 
         */
        public Builder gcfsConfig(@Nullable Output<GcfsConfigArgs> gcfsConfig) {
            $.gcfsConfig = gcfsConfig;
            return this;
        }

        /**
         * @param gcfsConfig Google Container File System (image streaming) configs.
         * 
         * @return builder
         * 
         */
        public Builder gcfsConfig(GcfsConfigArgs gcfsConfig) {
            return gcfsConfig(Output.of(gcfsConfig));
        }

        /**
         * @param gvnic Enable or disable gvnic in the node pool.
         * 
         * @return builder
         * 
         */
        public Builder gvnic(@Nullable Output<VirtualNICArgs> gvnic) {
            $.gvnic = gvnic;
            return this;
        }

        /**
         * @param gvnic Enable or disable gvnic in the node pool.
         * 
         * @return builder
         * 
         */
        public Builder gvnic(VirtualNICArgs gvnic) {
            return gvnic(Output.of(gvnic));
        }

        /**
         * @param imageType The image type to use for this node. Note that for a given image type, the latest version of it will be used.
         * 
         * @return builder
         * 
         */
        public Builder imageType(@Nullable Output<String> imageType) {
            $.imageType = imageType;
            return this;
        }

        /**
         * @param imageType The image type to use for this node. Note that for a given image type, the latest version of it will be used.
         * 
         * @return builder
         * 
         */
        public Builder imageType(String imageType) {
            return imageType(Output.of(imageType));
        }

        /**
         * @param kubeletConfig Node kubelet configs.
         * 
         * @return builder
         * 
         */
        public Builder kubeletConfig(@Nullable Output<NodeKubeletConfigArgs> kubeletConfig) {
            $.kubeletConfig = kubeletConfig;
            return this;
        }

        /**
         * @param kubeletConfig Node kubelet configs.
         * 
         * @return builder
         * 
         */
        public Builder kubeletConfig(NodeKubeletConfigArgs kubeletConfig) {
            return kubeletConfig(Output.of(kubeletConfig));
        }

        /**
         * @param labels The map of Kubernetes labels (key/value pairs) to be applied to each node. These will added in addition to any default label(s) that Kubernetes may apply to the node. In case of conflict in label keys, the applied set may differ depending on the Kubernetes version -- it&#39;s best to assume the behavior is undefined and conflicts should be avoided. For more information, including usage and the valid values, see: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
         * 
         * @return builder
         * 
         */
        public Builder labels(@Nullable Output<Map<String,String>> labels) {
            $.labels = labels;
            return this;
        }

        /**
         * @param labels The map of Kubernetes labels (key/value pairs) to be applied to each node. These will added in addition to any default label(s) that Kubernetes may apply to the node. In case of conflict in label keys, the applied set may differ depending on the Kubernetes version -- it&#39;s best to assume the behavior is undefined and conflicts should be avoided. For more information, including usage and the valid values, see: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
         * 
         * @return builder
         * 
         */
        public Builder labels(Map<String,String> labels) {
            return labels(Output.of(labels));
        }

        /**
         * @param linuxNodeConfig Parameters that can be configured on Linux nodes.
         * 
         * @return builder
         * 
         */
        public Builder linuxNodeConfig(@Nullable Output<LinuxNodeConfigArgs> linuxNodeConfig) {
            $.linuxNodeConfig = linuxNodeConfig;
            return this;
        }

        /**
         * @param linuxNodeConfig Parameters that can be configured on Linux nodes.
         * 
         * @return builder
         * 
         */
        public Builder linuxNodeConfig(LinuxNodeConfigArgs linuxNodeConfig) {
            return linuxNodeConfig(Output.of(linuxNodeConfig));
        }

        /**
         * @param localSsdCount The number of local SSD disks to be attached to the node. The limit for this value is dependent upon the maximum number of disks available on a machine per zone. See: https://cloud.google.com/compute/docs/disks/local-ssd for more information.
         * 
         * @return builder
         * 
         */
        public Builder localSsdCount(@Nullable Output<Integer> localSsdCount) {
            $.localSsdCount = localSsdCount;
            return this;
        }

        /**
         * @param localSsdCount The number of local SSD disks to be attached to the node. The limit for this value is dependent upon the maximum number of disks available on a machine per zone. See: https://cloud.google.com/compute/docs/disks/local-ssd for more information.
         * 
         * @return builder
         * 
         */
        public Builder localSsdCount(Integer localSsdCount) {
            return localSsdCount(Output.of(localSsdCount));
        }

        /**
         * @param machineType The name of a Google Compute Engine [machine type](https://cloud.google.com/compute/docs/machine-types) If unspecified, the default machine type is `e2-medium`.
         * 
         * @return builder
         * 
         */
        public Builder machineType(@Nullable Output<String> machineType) {
            $.machineType = machineType;
            return this;
        }

        /**
         * @param machineType The name of a Google Compute Engine [machine type](https://cloud.google.com/compute/docs/machine-types) If unspecified, the default machine type is `e2-medium`.
         * 
         * @return builder
         * 
         */
        public Builder machineType(String machineType) {
            return machineType(Output.of(machineType));
        }

        /**
         * @param metadata The metadata key/value pairs assigned to instances in the cluster. Keys must conform to the regexp `[a-zA-Z0-9-_]+` and be less than 128 bytes in length. These are reflected as part of a URL in the metadata server. Additionally, to avoid ambiguity, keys must not conflict with any other metadata keys for the project or be one of the reserved keys: - &#34;cluster-location&#34; - &#34;cluster-name&#34; - &#34;cluster-uid&#34; - &#34;configure-sh&#34; - &#34;containerd-configure-sh&#34; - &#34;enable-os-login&#34; - &#34;gci-ensure-gke-docker&#34; - &#34;gci-metrics-enabled&#34; - &#34;gci-update-strategy&#34; - &#34;instance-template&#34; - &#34;kube-env&#34; - &#34;startup-script&#34; - &#34;user-data&#34; - &#34;disable-address-manager&#34; - &#34;windows-startup-script-ps1&#34; - &#34;common-psm1&#34; - &#34;k8s-node-setup-psm1&#34; - &#34;install-ssh-psm1&#34; - &#34;user-profile-psm1&#34; Values are free-form strings, and only have meaning as interpreted by the image running in the instance. The only restriction placed on them is that each value&#39;s size must be less than or equal to 32 KB. The total size of all keys and values must be less than 512 KB.
         * 
         * @return builder
         * 
         */
        public Builder metadata(@Nullable Output<Map<String,String>> metadata) {
            $.metadata = metadata;
            return this;
        }

        /**
         * @param metadata The metadata key/value pairs assigned to instances in the cluster. Keys must conform to the regexp `[a-zA-Z0-9-_]+` and be less than 128 bytes in length. These are reflected as part of a URL in the metadata server. Additionally, to avoid ambiguity, keys must not conflict with any other metadata keys for the project or be one of the reserved keys: - &#34;cluster-location&#34; - &#34;cluster-name&#34; - &#34;cluster-uid&#34; - &#34;configure-sh&#34; - &#34;containerd-configure-sh&#34; - &#34;enable-os-login&#34; - &#34;gci-ensure-gke-docker&#34; - &#34;gci-metrics-enabled&#34; - &#34;gci-update-strategy&#34; - &#34;instance-template&#34; - &#34;kube-env&#34; - &#34;startup-script&#34; - &#34;user-data&#34; - &#34;disable-address-manager&#34; - &#34;windows-startup-script-ps1&#34; - &#34;common-psm1&#34; - &#34;k8s-node-setup-psm1&#34; - &#34;install-ssh-psm1&#34; - &#34;user-profile-psm1&#34; Values are free-form strings, and only have meaning as interpreted by the image running in the instance. The only restriction placed on them is that each value&#39;s size must be less than or equal to 32 KB. The total size of all keys and values must be less than 512 KB.
         * 
         * @return builder
         * 
         */
        public Builder metadata(Map<String,String> metadata) {
            return metadata(Output.of(metadata));
        }

        /**
         * @param minCpuPlatform Minimum CPU platform to be used by this instance. The instance may be scheduled on the specified or newer CPU platform. Applicable values are the friendly names of CPU platforms, such as `minCpuPlatform: &#34;Intel Haswell&#34;` or `minCpuPlatform: &#34;Intel Sandy Bridge&#34;`. For more information, read [how to specify min CPU platform](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform)
         * 
         * @return builder
         * 
         */
        public Builder minCpuPlatform(@Nullable Output<String> minCpuPlatform) {
            $.minCpuPlatform = minCpuPlatform;
            return this;
        }

        /**
         * @param minCpuPlatform Minimum CPU platform to be used by this instance. The instance may be scheduled on the specified or newer CPU platform. Applicable values are the friendly names of CPU platforms, such as `minCpuPlatform: &#34;Intel Haswell&#34;` or `minCpuPlatform: &#34;Intel Sandy Bridge&#34;`. For more information, read [how to specify min CPU platform](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform)
         * 
         * @return builder
         * 
         */
        public Builder minCpuPlatform(String minCpuPlatform) {
            return minCpuPlatform(Output.of(minCpuPlatform));
        }

        /**
         * @param nodeGroup Setting this field will assign instances of this pool to run on the specified node group. This is useful for running workloads on [sole tenant nodes](https://cloud.google.com/compute/docs/nodes/sole-tenant-nodes).
         * 
         * @return builder
         * 
         */
        public Builder nodeGroup(@Nullable Output<String> nodeGroup) {
            $.nodeGroup = nodeGroup;
            return this;
        }

        /**
         * @param nodeGroup Setting this field will assign instances of this pool to run on the specified node group. This is useful for running workloads on [sole tenant nodes](https://cloud.google.com/compute/docs/nodes/sole-tenant-nodes).
         * 
         * @return builder
         * 
         */
        public Builder nodeGroup(String nodeGroup) {
            return nodeGroup(Output.of(nodeGroup));
        }

        /**
         * @param oauthScopes The set of Google API scopes to be made available on all of the node VMs under the &#34;default&#34; service account. The following scopes are recommended, but not required, and by default are not included: * `https://www.googleapis.com/auth/compute` is required for mounting persistent storage on your nodes. * `https://www.googleapis.com/auth/devstorage.read_only` is required for communicating with **gcr.io** (the [Google Container Registry](https://cloud.google.com/container-registry/)). If unspecified, no scopes are added, unless Cloud Logging or Cloud Monitoring are enabled, in which case their required scopes will be added.
         * 
         * @return builder
         * 
         */
        public Builder oauthScopes(@Nullable Output<List<String>> oauthScopes) {
            $.oauthScopes = oauthScopes;
            return this;
        }

        /**
         * @param oauthScopes The set of Google API scopes to be made available on all of the node VMs under the &#34;default&#34; service account. The following scopes are recommended, but not required, and by default are not included: * `https://www.googleapis.com/auth/compute` is required for mounting persistent storage on your nodes. * `https://www.googleapis.com/auth/devstorage.read_only` is required for communicating with **gcr.io** (the [Google Container Registry](https://cloud.google.com/container-registry/)). If unspecified, no scopes are added, unless Cloud Logging or Cloud Monitoring are enabled, in which case their required scopes will be added.
         * 
         * @return builder
         * 
         */
        public Builder oauthScopes(List<String> oauthScopes) {
            return oauthScopes(Output.of(oauthScopes));
        }

        /**
         * @param oauthScopes The set of Google API scopes to be made available on all of the node VMs under the &#34;default&#34; service account. The following scopes are recommended, but not required, and by default are not included: * `https://www.googleapis.com/auth/compute` is required for mounting persistent storage on your nodes. * `https://www.googleapis.com/auth/devstorage.read_only` is required for communicating with **gcr.io** (the [Google Container Registry](https://cloud.google.com/container-registry/)). If unspecified, no scopes are added, unless Cloud Logging or Cloud Monitoring are enabled, in which case their required scopes will be added.
         * 
         * @return builder
         * 
         */
        public Builder oauthScopes(String... oauthScopes) {
            return oauthScopes(List.of(oauthScopes));
        }

        /**
         * @param preemptible Whether the nodes are created as preemptible VM instances. See: https://cloud.google.com/compute/docs/instances/preemptible for more information about preemptible VM instances.
         * 
         * @return builder
         * 
         */
        public Builder preemptible(@Nullable Output<Boolean> preemptible) {
            $.preemptible = preemptible;
            return this;
        }

        /**
         * @param preemptible Whether the nodes are created as preemptible VM instances. See: https://cloud.google.com/compute/docs/instances/preemptible for more information about preemptible VM instances.
         * 
         * @return builder
         * 
         */
        public Builder preemptible(Boolean preemptible) {
            return preemptible(Output.of(preemptible));
        }

        /**
         * @param reservationAffinity The optional reservation affinity. Setting this field will apply the specified [Zonal Compute Reservation](https://cloud.google.com/compute/docs/instances/reserving-zonal-resources) to this node pool.
         * 
         * @return builder
         * 
         */
        public Builder reservationAffinity(@Nullable Output<ReservationAffinityArgs> reservationAffinity) {
            $.reservationAffinity = reservationAffinity;
            return this;
        }

        /**
         * @param reservationAffinity The optional reservation affinity. Setting this field will apply the specified [Zonal Compute Reservation](https://cloud.google.com/compute/docs/instances/reserving-zonal-resources) to this node pool.
         * 
         * @return builder
         * 
         */
        public Builder reservationAffinity(ReservationAffinityArgs reservationAffinity) {
            return reservationAffinity(Output.of(reservationAffinity));
        }

        /**
         * @param sandboxConfig Sandbox configuration for this node.
         * 
         * @return builder
         * 
         */
        public Builder sandboxConfig(@Nullable Output<SandboxConfigArgs> sandboxConfig) {
            $.sandboxConfig = sandboxConfig;
            return this;
        }

        /**
         * @param sandboxConfig Sandbox configuration for this node.
         * 
         * @return builder
         * 
         */
        public Builder sandboxConfig(SandboxConfigArgs sandboxConfig) {
            return sandboxConfig(Output.of(sandboxConfig));
        }

        /**
         * @param serviceAccount The Google Cloud Platform Service Account to be used by the node VMs. Specify the email address of the Service Account; otherwise, if no Service Account is specified, the &#34;default&#34; service account is used.
         * 
         * @return builder
         * 
         */
        public Builder serviceAccount(@Nullable Output<String> serviceAccount) {
            $.serviceAccount = serviceAccount;
            return this;
        }

        /**
         * @param serviceAccount The Google Cloud Platform Service Account to be used by the node VMs. Specify the email address of the Service Account; otherwise, if no Service Account is specified, the &#34;default&#34; service account is used.
         * 
         * @return builder
         * 
         */
        public Builder serviceAccount(String serviceAccount) {
            return serviceAccount(Output.of(serviceAccount));
        }

        /**
         * @param shieldedInstanceConfig Shielded Instance options.
         * 
         * @return builder
         * 
         */
        public Builder shieldedInstanceConfig(@Nullable Output<ShieldedInstanceConfigArgs> shieldedInstanceConfig) {
            $.shieldedInstanceConfig = shieldedInstanceConfig;
            return this;
        }

        /**
         * @param shieldedInstanceConfig Shielded Instance options.
         * 
         * @return builder
         * 
         */
        public Builder shieldedInstanceConfig(ShieldedInstanceConfigArgs shieldedInstanceConfig) {
            return shieldedInstanceConfig(Output.of(shieldedInstanceConfig));
        }

        /**
         * @param spot Spot flag for enabling Spot VM, which is a rebrand of the existing preemptible flag.
         * 
         * @return builder
         * 
         */
        public Builder spot(@Nullable Output<Boolean> spot) {
            $.spot = spot;
            return this;
        }

        /**
         * @param spot Spot flag for enabling Spot VM, which is a rebrand of the existing preemptible flag.
         * 
         * @return builder
         * 
         */
        public Builder spot(Boolean spot) {
            return spot(Output.of(spot));
        }

        /**
         * @param tags The list of instance tags applied to all nodes. Tags are used to identify valid sources or targets for network firewalls and are specified by the client during cluster or node pool creation. Each tag within the list must comply with RFC1035.
         * 
         * @return builder
         * 
         */
        public Builder tags(@Nullable Output<List<String>> tags) {
            $.tags = tags;
            return this;
        }

        /**
         * @param tags The list of instance tags applied to all nodes. Tags are used to identify valid sources or targets for network firewalls and are specified by the client during cluster or node pool creation. Each tag within the list must comply with RFC1035.
         * 
         * @return builder
         * 
         */
        public Builder tags(List<String> tags) {
            return tags(Output.of(tags));
        }

        /**
         * @param tags The list of instance tags applied to all nodes. Tags are used to identify valid sources or targets for network firewalls and are specified by the client during cluster or node pool creation. Each tag within the list must comply with RFC1035.
         * 
         * @return builder
         * 
         */
        public Builder tags(String... tags) {
            return tags(List.of(tags));
        }

        /**
         * @param taints List of kubernetes taints to be applied to each node. For more information, including usage and the valid values, see: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
         * 
         * @return builder
         * 
         */
        public Builder taints(@Nullable Output<List<NodeTaintArgs>> taints) {
            $.taints = taints;
            return this;
        }

        /**
         * @param taints List of kubernetes taints to be applied to each node. For more information, including usage and the valid values, see: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
         * 
         * @return builder
         * 
         */
        public Builder taints(List<NodeTaintArgs> taints) {
            return taints(Output.of(taints));
        }

        /**
         * @param taints List of kubernetes taints to be applied to each node. For more information, including usage and the valid values, see: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
         * 
         * @return builder
         * 
         */
        public Builder taints(NodeTaintArgs... taints) {
            return taints(List.of(taints));
        }

        /**
         * @param workloadMetadataConfig The workload metadata configuration for this node.
         * 
         * @return builder
         * 
         */
        public Builder workloadMetadataConfig(@Nullable Output<WorkloadMetadataConfigArgs> workloadMetadataConfig) {
            $.workloadMetadataConfig = workloadMetadataConfig;
            return this;
        }

        /**
         * @param workloadMetadataConfig The workload metadata configuration for this node.
         * 
         * @return builder
         * 
         */
        public Builder workloadMetadataConfig(WorkloadMetadataConfigArgs workloadMetadataConfig) {
            return workloadMetadataConfig(Output.of(workloadMetadataConfig));
        }

        public NodeConfigArgs build() {
            return $;
        }
    }

}
