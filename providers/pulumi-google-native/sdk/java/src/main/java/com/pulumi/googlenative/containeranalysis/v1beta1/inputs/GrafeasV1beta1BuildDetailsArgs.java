// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.googlenative.containeranalysis.v1beta1.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.googlenative.containeranalysis.v1beta1.inputs.BuildProvenanceArgs;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


/**
 * Details of a build occurrence.
 * 
 */
public final class GrafeasV1beta1BuildDetailsArgs extends com.pulumi.resources.ResourceArgs {

    public static final GrafeasV1beta1BuildDetailsArgs Empty = new GrafeasV1beta1BuildDetailsArgs();

    /**
     * The actual provenance for the build.
     * 
     */
    @Import(name="provenance", required=true)
    private Output<BuildProvenanceArgs> provenance;

    /**
     * @return The actual provenance for the build.
     * 
     */
    public Output<BuildProvenanceArgs> provenance() {
        return this.provenance;
    }

    /**
     * Serialized JSON representation of the provenance, used in generating the build signature in the corresponding build note. After verifying the signature, `provenance_bytes` can be unmarshalled and compared to the provenance to confirm that it is unchanged. A base64-encoded string representation of the provenance bytes is used for the signature in order to interoperate with openssl which expects this format for signature verification. The serialized form is captured both to avoid ambiguity in how the provenance is marshalled to json as well to prevent incompatibilities with future changes.
     * 
     */
    @Import(name="provenanceBytes")
    private @Nullable Output<String> provenanceBytes;

    /**
     * @return Serialized JSON representation of the provenance, used in generating the build signature in the corresponding build note. After verifying the signature, `provenance_bytes` can be unmarshalled and compared to the provenance to confirm that it is unchanged. A base64-encoded string representation of the provenance bytes is used for the signature in order to interoperate with openssl which expects this format for signature verification. The serialized form is captured both to avoid ambiguity in how the provenance is marshalled to json as well to prevent incompatibilities with future changes.
     * 
     */
    public Optional<Output<String>> provenanceBytes() {
        return Optional.ofNullable(this.provenanceBytes);
    }

    private GrafeasV1beta1BuildDetailsArgs() {}

    private GrafeasV1beta1BuildDetailsArgs(GrafeasV1beta1BuildDetailsArgs $) {
        this.provenance = $.provenance;
        this.provenanceBytes = $.provenanceBytes;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(GrafeasV1beta1BuildDetailsArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private GrafeasV1beta1BuildDetailsArgs $;

        public Builder() {
            $ = new GrafeasV1beta1BuildDetailsArgs();
        }

        public Builder(GrafeasV1beta1BuildDetailsArgs defaults) {
            $ = new GrafeasV1beta1BuildDetailsArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param provenance The actual provenance for the build.
         * 
         * @return builder
         * 
         */
        public Builder provenance(Output<BuildProvenanceArgs> provenance) {
            $.provenance = provenance;
            return this;
        }

        /**
         * @param provenance The actual provenance for the build.
         * 
         * @return builder
         * 
         */
        public Builder provenance(BuildProvenanceArgs provenance) {
            return provenance(Output.of(provenance));
        }

        /**
         * @param provenanceBytes Serialized JSON representation of the provenance, used in generating the build signature in the corresponding build note. After verifying the signature, `provenance_bytes` can be unmarshalled and compared to the provenance to confirm that it is unchanged. A base64-encoded string representation of the provenance bytes is used for the signature in order to interoperate with openssl which expects this format for signature verification. The serialized form is captured both to avoid ambiguity in how the provenance is marshalled to json as well to prevent incompatibilities with future changes.
         * 
         * @return builder
         * 
         */
        public Builder provenanceBytes(@Nullable Output<String> provenanceBytes) {
            $.provenanceBytes = provenanceBytes;
            return this;
        }

        /**
         * @param provenanceBytes Serialized JSON representation of the provenance, used in generating the build signature in the corresponding build note. After verifying the signature, `provenance_bytes` can be unmarshalled and compared to the provenance to confirm that it is unchanged. A base64-encoded string representation of the provenance bytes is used for the signature in order to interoperate with openssl which expects this format for signature verification. The serialized form is captured both to avoid ambiguity in how the provenance is marshalled to json as well to prevent incompatibilities with future changes.
         * 
         * @return builder
         * 
         */
        public Builder provenanceBytes(String provenanceBytes) {
            return provenanceBytes(Output.of(provenanceBytes));
        }

        public GrafeasV1beta1BuildDetailsArgs build() {
            $.provenance = Objects.requireNonNull($.provenance, "expected parameter 'provenance' to be non-null");
            return $;
        }
    }

}
