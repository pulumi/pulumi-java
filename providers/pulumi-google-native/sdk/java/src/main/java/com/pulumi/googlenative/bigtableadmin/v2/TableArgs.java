// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.googlenative.bigtableadmin.v2;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.googlenative.bigtableadmin.v2.enums.TableGranularity;
import com.pulumi.googlenative.bigtableadmin.v2.inputs.SplitArgs;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class TableArgs extends com.pulumi.resources.ResourceArgs {

    public static final TableArgs Empty = new TableArgs();

    /**
     * The column families configured for this table, mapped by column family ID. Views: `SCHEMA_VIEW`, `FULL`
     * 
     */
    @Import(name="columnFamilies")
    private @Nullable Output<Map<String,String>> columnFamilies;

    /**
     * @return The column families configured for this table, mapped by column family ID. Views: `SCHEMA_VIEW`, `FULL`
     * 
     */
    public Optional<Output<Map<String,String>>> columnFamilies() {
        return Optional.ofNullable(this.columnFamilies);
    }

    /**
     * Immutable. The granularity (i.e. `MILLIS`) at which timestamps are stored in this table. Timestamps not matching the granularity will be rejected. If unspecified at creation time, the value will be set to `MILLIS`. Views: `SCHEMA_VIEW`, `FULL`.
     * 
     */
    @Import(name="granularity")
    private @Nullable Output<TableGranularity> granularity;

    /**
     * @return Immutable. The granularity (i.e. `MILLIS`) at which timestamps are stored in this table. Timestamps not matching the granularity will be rejected. If unspecified at creation time, the value will be set to `MILLIS`. Views: `SCHEMA_VIEW`, `FULL`.
     * 
     */
    public Optional<Output<TableGranularity>> granularity() {
        return Optional.ofNullable(this.granularity);
    }

    /**
     * The optional list of row keys that will be used to initially split the table into several tablets (tablets are similar to HBase regions). Given two split keys, `s1` and `s2`, three tablets will be created, spanning the key ranges: `[, s1), [s1, s2), [s2, )`. Example: * Row keys := `[&#34;a&#34;, &#34;apple&#34;, &#34;custom&#34;, &#34;customer_1&#34;, &#34;customer_2&#34;,` `&#34;other&#34;, &#34;zz&#34;]` * initial_split_keys := `[&#34;apple&#34;, &#34;customer_1&#34;, &#34;customer_2&#34;, &#34;other&#34;]` * Key assignment: - Tablet 1 `[, apple) =&gt; {&#34;a&#34;}.` - Tablet 2 `[apple, customer_1) =&gt; {&#34;apple&#34;, &#34;custom&#34;}.` - Tablet 3 `[customer_1, customer_2) =&gt; {&#34;customer_1&#34;}.` - Tablet 4 `[customer_2, other) =&gt; {&#34;customer_2&#34;}.` - Tablet 5 `[other, ) =&gt; {&#34;other&#34;, &#34;zz&#34;}.`
     * 
     */
    @Import(name="initialSplits")
    private @Nullable Output<List<SplitArgs>> initialSplits;

    /**
     * @return The optional list of row keys that will be used to initially split the table into several tablets (tablets are similar to HBase regions). Given two split keys, `s1` and `s2`, three tablets will be created, spanning the key ranges: `[, s1), [s1, s2), [s2, )`. Example: * Row keys := `[&#34;a&#34;, &#34;apple&#34;, &#34;custom&#34;, &#34;customer_1&#34;, &#34;customer_2&#34;,` `&#34;other&#34;, &#34;zz&#34;]` * initial_split_keys := `[&#34;apple&#34;, &#34;customer_1&#34;, &#34;customer_2&#34;, &#34;other&#34;]` * Key assignment: - Tablet 1 `[, apple) =&gt; {&#34;a&#34;}.` - Tablet 2 `[apple, customer_1) =&gt; {&#34;apple&#34;, &#34;custom&#34;}.` - Tablet 3 `[customer_1, customer_2) =&gt; {&#34;customer_1&#34;}.` - Tablet 4 `[customer_2, other) =&gt; {&#34;customer_2&#34;}.` - Tablet 5 `[other, ) =&gt; {&#34;other&#34;, &#34;zz&#34;}.`
     * 
     */
    public Optional<Output<List<SplitArgs>>> initialSplits() {
        return Optional.ofNullable(this.initialSplits);
    }

    @Import(name="instanceId", required=true)
    private Output<String> instanceId;

    public Output<String> instanceId() {
        return this.instanceId;
    }

    /**
     * The unique name of the table. Values are of the form `projects/{project}/instances/{instance}/tables/_a-zA-Z0-9*`. Views: `NAME_ONLY`, `SCHEMA_VIEW`, `REPLICATION_VIEW`, `FULL`
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return The unique name of the table. Values are of the form `projects/{project}/instances/{instance}/tables/_a-zA-Z0-9*`. Views: `NAME_ONLY`, `SCHEMA_VIEW`, `REPLICATION_VIEW`, `FULL`
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    @Import(name="project")
    private @Nullable Output<String> project;

    public Optional<Output<String>> project() {
        return Optional.ofNullable(this.project);
    }

    /**
     * The name by which the new table should be referred to within the parent instance, e.g., `foobar` rather than `{parent}/tables/foobar`. Maximum 50 characters.
     * 
     */
    @Import(name="tableId", required=true)
    private Output<String> tableId;

    /**
     * @return The name by which the new table should be referred to within the parent instance, e.g., `foobar` rather than `{parent}/tables/foobar`. Maximum 50 characters.
     * 
     */
    public Output<String> tableId() {
        return this.tableId;
    }

    private TableArgs() {}

    private TableArgs(TableArgs $) {
        this.columnFamilies = $.columnFamilies;
        this.granularity = $.granularity;
        this.initialSplits = $.initialSplits;
        this.instanceId = $.instanceId;
        this.name = $.name;
        this.project = $.project;
        this.tableId = $.tableId;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(TableArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private TableArgs $;

        public Builder() {
            $ = new TableArgs();
        }

        public Builder(TableArgs defaults) {
            $ = new TableArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param columnFamilies The column families configured for this table, mapped by column family ID. Views: `SCHEMA_VIEW`, `FULL`
         * 
         * @return builder
         * 
         */
        public Builder columnFamilies(@Nullable Output<Map<String,String>> columnFamilies) {
            $.columnFamilies = columnFamilies;
            return this;
        }

        /**
         * @param columnFamilies The column families configured for this table, mapped by column family ID. Views: `SCHEMA_VIEW`, `FULL`
         * 
         * @return builder
         * 
         */
        public Builder columnFamilies(Map<String,String> columnFamilies) {
            return columnFamilies(Output.of(columnFamilies));
        }

        /**
         * @param granularity Immutable. The granularity (i.e. `MILLIS`) at which timestamps are stored in this table. Timestamps not matching the granularity will be rejected. If unspecified at creation time, the value will be set to `MILLIS`. Views: `SCHEMA_VIEW`, `FULL`.
         * 
         * @return builder
         * 
         */
        public Builder granularity(@Nullable Output<TableGranularity> granularity) {
            $.granularity = granularity;
            return this;
        }

        /**
         * @param granularity Immutable. The granularity (i.e. `MILLIS`) at which timestamps are stored in this table. Timestamps not matching the granularity will be rejected. If unspecified at creation time, the value will be set to `MILLIS`. Views: `SCHEMA_VIEW`, `FULL`.
         * 
         * @return builder
         * 
         */
        public Builder granularity(TableGranularity granularity) {
            return granularity(Output.of(granularity));
        }

        /**
         * @param initialSplits The optional list of row keys that will be used to initially split the table into several tablets (tablets are similar to HBase regions). Given two split keys, `s1` and `s2`, three tablets will be created, spanning the key ranges: `[, s1), [s1, s2), [s2, )`. Example: * Row keys := `[&#34;a&#34;, &#34;apple&#34;, &#34;custom&#34;, &#34;customer_1&#34;, &#34;customer_2&#34;,` `&#34;other&#34;, &#34;zz&#34;]` * initial_split_keys := `[&#34;apple&#34;, &#34;customer_1&#34;, &#34;customer_2&#34;, &#34;other&#34;]` * Key assignment: - Tablet 1 `[, apple) =&gt; {&#34;a&#34;}.` - Tablet 2 `[apple, customer_1) =&gt; {&#34;apple&#34;, &#34;custom&#34;}.` - Tablet 3 `[customer_1, customer_2) =&gt; {&#34;customer_1&#34;}.` - Tablet 4 `[customer_2, other) =&gt; {&#34;customer_2&#34;}.` - Tablet 5 `[other, ) =&gt; {&#34;other&#34;, &#34;zz&#34;}.`
         * 
         * @return builder
         * 
         */
        public Builder initialSplits(@Nullable Output<List<SplitArgs>> initialSplits) {
            $.initialSplits = initialSplits;
            return this;
        }

        /**
         * @param initialSplits The optional list of row keys that will be used to initially split the table into several tablets (tablets are similar to HBase regions). Given two split keys, `s1` and `s2`, three tablets will be created, spanning the key ranges: `[, s1), [s1, s2), [s2, )`. Example: * Row keys := `[&#34;a&#34;, &#34;apple&#34;, &#34;custom&#34;, &#34;customer_1&#34;, &#34;customer_2&#34;,` `&#34;other&#34;, &#34;zz&#34;]` * initial_split_keys := `[&#34;apple&#34;, &#34;customer_1&#34;, &#34;customer_2&#34;, &#34;other&#34;]` * Key assignment: - Tablet 1 `[, apple) =&gt; {&#34;a&#34;}.` - Tablet 2 `[apple, customer_1) =&gt; {&#34;apple&#34;, &#34;custom&#34;}.` - Tablet 3 `[customer_1, customer_2) =&gt; {&#34;customer_1&#34;}.` - Tablet 4 `[customer_2, other) =&gt; {&#34;customer_2&#34;}.` - Tablet 5 `[other, ) =&gt; {&#34;other&#34;, &#34;zz&#34;}.`
         * 
         * @return builder
         * 
         */
        public Builder initialSplits(List<SplitArgs> initialSplits) {
            return initialSplits(Output.of(initialSplits));
        }

        /**
         * @param initialSplits The optional list of row keys that will be used to initially split the table into several tablets (tablets are similar to HBase regions). Given two split keys, `s1` and `s2`, three tablets will be created, spanning the key ranges: `[, s1), [s1, s2), [s2, )`. Example: * Row keys := `[&#34;a&#34;, &#34;apple&#34;, &#34;custom&#34;, &#34;customer_1&#34;, &#34;customer_2&#34;,` `&#34;other&#34;, &#34;zz&#34;]` * initial_split_keys := `[&#34;apple&#34;, &#34;customer_1&#34;, &#34;customer_2&#34;, &#34;other&#34;]` * Key assignment: - Tablet 1 `[, apple) =&gt; {&#34;a&#34;}.` - Tablet 2 `[apple, customer_1) =&gt; {&#34;apple&#34;, &#34;custom&#34;}.` - Tablet 3 `[customer_1, customer_2) =&gt; {&#34;customer_1&#34;}.` - Tablet 4 `[customer_2, other) =&gt; {&#34;customer_2&#34;}.` - Tablet 5 `[other, ) =&gt; {&#34;other&#34;, &#34;zz&#34;}.`
         * 
         * @return builder
         * 
         */
        public Builder initialSplits(SplitArgs... initialSplits) {
            return initialSplits(List.of(initialSplits));
        }

        public Builder instanceId(Output<String> instanceId) {
            $.instanceId = instanceId;
            return this;
        }

        public Builder instanceId(String instanceId) {
            return instanceId(Output.of(instanceId));
        }

        /**
         * @param name The unique name of the table. Values are of the form `projects/{project}/instances/{instance}/tables/_a-zA-Z0-9*`. Views: `NAME_ONLY`, `SCHEMA_VIEW`, `REPLICATION_VIEW`, `FULL`
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name The unique name of the table. Values are of the form `projects/{project}/instances/{instance}/tables/_a-zA-Z0-9*`. Views: `NAME_ONLY`, `SCHEMA_VIEW`, `REPLICATION_VIEW`, `FULL`
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        public Builder project(@Nullable Output<String> project) {
            $.project = project;
            return this;
        }

        public Builder project(String project) {
            return project(Output.of(project));
        }

        /**
         * @param tableId The name by which the new table should be referred to within the parent instance, e.g., `foobar` rather than `{parent}/tables/foobar`. Maximum 50 characters.
         * 
         * @return builder
         * 
         */
        public Builder tableId(Output<String> tableId) {
            $.tableId = tableId;
            return this;
        }

        /**
         * @param tableId The name by which the new table should be referred to within the parent instance, e.g., `foobar` rather than `{parent}/tables/foobar`. Maximum 50 characters.
         * 
         * @return builder
         * 
         */
        public Builder tableId(String tableId) {
            return tableId(Output.of(tableId));
        }

        public TableArgs build() {
            $.instanceId = Objects.requireNonNull($.instanceId, "expected parameter 'instanceId' to be non-null");
            $.tableId = Objects.requireNonNull($.tableId, "expected parameter 'tableId' to be non-null");
            return $;
        }
    }

}
