// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.googlenative.dataflow_v1b3.inputs;

import com.pulumi.core.annotations.Import;
import com.pulumi.googlenative.dataflow_v1b3.inputs.WorkerSettingsResponse;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Objects;


/**
 * Taskrunner configuration settings.
 * 
 */
public final class TaskRunnerSettingsResponse extends com.pulumi.resources.InvokeArgs {

    public static final TaskRunnerSettingsResponse Empty = new TaskRunnerSettingsResponse();

    /**
     * Whether to also send taskrunner log info to stderr.
     * 
     */
    @Import(name="alsologtostderr", required=true)
      private final Boolean alsologtostderr;

    public Boolean alsologtostderr() {
        return this.alsologtostderr;
    }

    /**
     * The location on the worker for task-specific subdirectories.
     * 
     */
    @Import(name="baseTaskDir", required=true)
      private final String baseTaskDir;

    public String baseTaskDir() {
        return this.baseTaskDir;
    }

    /**
     * The base URL for the taskrunner to use when accessing Google Cloud APIs. When workers access Google Cloud APIs, they logically do so via relative URLs. If this field is specified, it supplies the base URL to use for resolving these relative URLs. The normative algorithm used is defined by RFC 1808, &#34;Relative Uniform Resource Locators&#34;. If not specified, the default value is &#34;http://www.googleapis.com/&#34;
     * 
     */
    @Import(name="baseUrl", required=true)
      private final String baseUrl;

    public String baseUrl() {
        return this.baseUrl;
    }

    /**
     * The file to store preprocessing commands in.
     * 
     */
    @Import(name="commandlinesFileName", required=true)
      private final String commandlinesFileName;

    public String commandlinesFileName() {
        return this.commandlinesFileName;
    }

    /**
     * Whether to continue taskrunner if an exception is hit.
     * 
     */
    @Import(name="continueOnException", required=true)
      private final Boolean continueOnException;

    public Boolean continueOnException() {
        return this.continueOnException;
    }

    /**
     * The API version of endpoint, e.g. &#34;v1b3&#34;
     * 
     */
    @Import(name="dataflowApiVersion", required=true)
      private final String dataflowApiVersion;

    public String dataflowApiVersion() {
        return this.dataflowApiVersion;
    }

    /**
     * The command to launch the worker harness.
     * 
     */
    @Import(name="harnessCommand", required=true)
      private final String harnessCommand;

    public String harnessCommand() {
        return this.harnessCommand;
    }

    /**
     * The suggested backend language.
     * 
     */
    @Import(name="languageHint", required=true)
      private final String languageHint;

    public String languageHint() {
        return this.languageHint;
    }

    /**
     * The directory on the VM to store logs.
     * 
     */
    @Import(name="logDir", required=true)
      private final String logDir;

    public String logDir() {
        return this.logDir;
    }

    /**
     * Whether to send taskrunner log info to Google Compute Engine VM serial console.
     * 
     */
    @Import(name="logToSerialconsole", required=true)
      private final Boolean logToSerialconsole;

    public Boolean logToSerialconsole() {
        return this.logToSerialconsole;
    }

    /**
     * Indicates where to put logs. If this is not specified, the logs will not be uploaded. The supported resource type is: Google Cloud Storage: storage.googleapis.com/{bucket}/{object} bucket.storage.googleapis.com/{object}
     * 
     */
    @Import(name="logUploadLocation", required=true)
      private final String logUploadLocation;

    public String logUploadLocation() {
        return this.logUploadLocation;
    }

    /**
     * The OAuth2 scopes to be requested by the taskrunner in order to access the Cloud Dataflow API.
     * 
     */
    @Import(name="oauthScopes", required=true)
      private final List<String> oauthScopes;

    public List<String> oauthScopes() {
        return this.oauthScopes;
    }

    /**
     * The settings to pass to the parallel worker harness.
     * 
     */
    @Import(name="parallelWorkerSettings", required=true)
      private final WorkerSettingsResponse parallelWorkerSettings;

    public WorkerSettingsResponse parallelWorkerSettings() {
        return this.parallelWorkerSettings;
    }

    /**
     * The streaming worker main class name.
     * 
     */
    @Import(name="streamingWorkerMainClass", required=true)
      private final String streamingWorkerMainClass;

    public String streamingWorkerMainClass() {
        return this.streamingWorkerMainClass;
    }

    /**
     * The UNIX group ID on the worker VM to use for tasks launched by taskrunner; e.g. &#34;wheel&#34;.
     * 
     */
    @Import(name="taskGroup", required=true)
      private final String taskGroup;

    public String taskGroup() {
        return this.taskGroup;
    }

    /**
     * The UNIX user ID on the worker VM to use for tasks launched by taskrunner; e.g. &#34;root&#34;.
     * 
     */
    @Import(name="taskUser", required=true)
      private final String taskUser;

    public String taskUser() {
        return this.taskUser;
    }

    /**
     * The prefix of the resources the taskrunner should use for temporary storage. The supported resource type is: Google Cloud Storage: storage.googleapis.com/{bucket}/{object} bucket.storage.googleapis.com/{object}
     * 
     */
    @Import(name="tempStoragePrefix", required=true)
      private final String tempStoragePrefix;

    public String tempStoragePrefix() {
        return this.tempStoragePrefix;
    }

    /**
     * The ID string of the VM.
     * 
     */
    @Import(name="vmId", required=true)
      private final String vmId;

    public String vmId() {
        return this.vmId;
    }

    /**
     * The file to store the workflow in.
     * 
     */
    @Import(name="workflowFileName", required=true)
      private final String workflowFileName;

    public String workflowFileName() {
        return this.workflowFileName;
    }

    public TaskRunnerSettingsResponse(
        Boolean alsologtostderr,
        String baseTaskDir,
        String baseUrl,
        String commandlinesFileName,
        Boolean continueOnException,
        String dataflowApiVersion,
        String harnessCommand,
        String languageHint,
        String logDir,
        Boolean logToSerialconsole,
        String logUploadLocation,
        List<String> oauthScopes,
        WorkerSettingsResponse parallelWorkerSettings,
        String streamingWorkerMainClass,
        String taskGroup,
        String taskUser,
        String tempStoragePrefix,
        String vmId,
        String workflowFileName) {
        this.alsologtostderr = Objects.requireNonNull(alsologtostderr, "expected parameter 'alsologtostderr' to be non-null");
        this.baseTaskDir = Objects.requireNonNull(baseTaskDir, "expected parameter 'baseTaskDir' to be non-null");
        this.baseUrl = Objects.requireNonNull(baseUrl, "expected parameter 'baseUrl' to be non-null");
        this.commandlinesFileName = Objects.requireNonNull(commandlinesFileName, "expected parameter 'commandlinesFileName' to be non-null");
        this.continueOnException = Objects.requireNonNull(continueOnException, "expected parameter 'continueOnException' to be non-null");
        this.dataflowApiVersion = Objects.requireNonNull(dataflowApiVersion, "expected parameter 'dataflowApiVersion' to be non-null");
        this.harnessCommand = Objects.requireNonNull(harnessCommand, "expected parameter 'harnessCommand' to be non-null");
        this.languageHint = Objects.requireNonNull(languageHint, "expected parameter 'languageHint' to be non-null");
        this.logDir = Objects.requireNonNull(logDir, "expected parameter 'logDir' to be non-null");
        this.logToSerialconsole = Objects.requireNonNull(logToSerialconsole, "expected parameter 'logToSerialconsole' to be non-null");
        this.logUploadLocation = Objects.requireNonNull(logUploadLocation, "expected parameter 'logUploadLocation' to be non-null");
        this.oauthScopes = Objects.requireNonNull(oauthScopes, "expected parameter 'oauthScopes' to be non-null");
        this.parallelWorkerSettings = Objects.requireNonNull(parallelWorkerSettings, "expected parameter 'parallelWorkerSettings' to be non-null");
        this.streamingWorkerMainClass = Objects.requireNonNull(streamingWorkerMainClass, "expected parameter 'streamingWorkerMainClass' to be non-null");
        this.taskGroup = Objects.requireNonNull(taskGroup, "expected parameter 'taskGroup' to be non-null");
        this.taskUser = Objects.requireNonNull(taskUser, "expected parameter 'taskUser' to be non-null");
        this.tempStoragePrefix = Objects.requireNonNull(tempStoragePrefix, "expected parameter 'tempStoragePrefix' to be non-null");
        this.vmId = Objects.requireNonNull(vmId, "expected parameter 'vmId' to be non-null");
        this.workflowFileName = Objects.requireNonNull(workflowFileName, "expected parameter 'workflowFileName' to be non-null");
    }

    private TaskRunnerSettingsResponse() {
        this.alsologtostderr = null;
        this.baseTaskDir = null;
        this.baseUrl = null;
        this.commandlinesFileName = null;
        this.continueOnException = null;
        this.dataflowApiVersion = null;
        this.harnessCommand = null;
        this.languageHint = null;
        this.logDir = null;
        this.logToSerialconsole = null;
        this.logUploadLocation = null;
        this.oauthScopes = List.of();
        this.parallelWorkerSettings = null;
        this.streamingWorkerMainClass = null;
        this.taskGroup = null;
        this.taskUser = null;
        this.tempStoragePrefix = null;
        this.vmId = null;
        this.workflowFileName = null;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(TaskRunnerSettingsResponse defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private Boolean alsologtostderr;
        private String baseTaskDir;
        private String baseUrl;
        private String commandlinesFileName;
        private Boolean continueOnException;
        private String dataflowApiVersion;
        private String harnessCommand;
        private String languageHint;
        private String logDir;
        private Boolean logToSerialconsole;
        private String logUploadLocation;
        private List<String> oauthScopes;
        private WorkerSettingsResponse parallelWorkerSettings;
        private String streamingWorkerMainClass;
        private String taskGroup;
        private String taskUser;
        private String tempStoragePrefix;
        private String vmId;
        private String workflowFileName;

        public Builder() {
    	      // Empty
        }

        public Builder(TaskRunnerSettingsResponse defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.alsologtostderr = defaults.alsologtostderr;
    	      this.baseTaskDir = defaults.baseTaskDir;
    	      this.baseUrl = defaults.baseUrl;
    	      this.commandlinesFileName = defaults.commandlinesFileName;
    	      this.continueOnException = defaults.continueOnException;
    	      this.dataflowApiVersion = defaults.dataflowApiVersion;
    	      this.harnessCommand = defaults.harnessCommand;
    	      this.languageHint = defaults.languageHint;
    	      this.logDir = defaults.logDir;
    	      this.logToSerialconsole = defaults.logToSerialconsole;
    	      this.logUploadLocation = defaults.logUploadLocation;
    	      this.oauthScopes = defaults.oauthScopes;
    	      this.parallelWorkerSettings = defaults.parallelWorkerSettings;
    	      this.streamingWorkerMainClass = defaults.streamingWorkerMainClass;
    	      this.taskGroup = defaults.taskGroup;
    	      this.taskUser = defaults.taskUser;
    	      this.tempStoragePrefix = defaults.tempStoragePrefix;
    	      this.vmId = defaults.vmId;
    	      this.workflowFileName = defaults.workflowFileName;
        }

        public Builder alsologtostderr(Boolean alsologtostderr) {
            this.alsologtostderr = Objects.requireNonNull(alsologtostderr);
            return this;
        }
        public Builder baseTaskDir(String baseTaskDir) {
            this.baseTaskDir = Objects.requireNonNull(baseTaskDir);
            return this;
        }
        public Builder baseUrl(String baseUrl) {
            this.baseUrl = Objects.requireNonNull(baseUrl);
            return this;
        }
        public Builder commandlinesFileName(String commandlinesFileName) {
            this.commandlinesFileName = Objects.requireNonNull(commandlinesFileName);
            return this;
        }
        public Builder continueOnException(Boolean continueOnException) {
            this.continueOnException = Objects.requireNonNull(continueOnException);
            return this;
        }
        public Builder dataflowApiVersion(String dataflowApiVersion) {
            this.dataflowApiVersion = Objects.requireNonNull(dataflowApiVersion);
            return this;
        }
        public Builder harnessCommand(String harnessCommand) {
            this.harnessCommand = Objects.requireNonNull(harnessCommand);
            return this;
        }
        public Builder languageHint(String languageHint) {
            this.languageHint = Objects.requireNonNull(languageHint);
            return this;
        }
        public Builder logDir(String logDir) {
            this.logDir = Objects.requireNonNull(logDir);
            return this;
        }
        public Builder logToSerialconsole(Boolean logToSerialconsole) {
            this.logToSerialconsole = Objects.requireNonNull(logToSerialconsole);
            return this;
        }
        public Builder logUploadLocation(String logUploadLocation) {
            this.logUploadLocation = Objects.requireNonNull(logUploadLocation);
            return this;
        }
        public Builder oauthScopes(List<String> oauthScopes) {
            this.oauthScopes = Objects.requireNonNull(oauthScopes);
            return this;
        }
        public Builder oauthScopes(String... oauthScopes) {
            return oauthScopes(List.of(oauthScopes));
        }
        public Builder parallelWorkerSettings(WorkerSettingsResponse parallelWorkerSettings) {
            this.parallelWorkerSettings = Objects.requireNonNull(parallelWorkerSettings);
            return this;
        }
        public Builder streamingWorkerMainClass(String streamingWorkerMainClass) {
            this.streamingWorkerMainClass = Objects.requireNonNull(streamingWorkerMainClass);
            return this;
        }
        public Builder taskGroup(String taskGroup) {
            this.taskGroup = Objects.requireNonNull(taskGroup);
            return this;
        }
        public Builder taskUser(String taskUser) {
            this.taskUser = Objects.requireNonNull(taskUser);
            return this;
        }
        public Builder tempStoragePrefix(String tempStoragePrefix) {
            this.tempStoragePrefix = Objects.requireNonNull(tempStoragePrefix);
            return this;
        }
        public Builder vmId(String vmId) {
            this.vmId = Objects.requireNonNull(vmId);
            return this;
        }
        public Builder workflowFileName(String workflowFileName) {
            this.workflowFileName = Objects.requireNonNull(workflowFileName);
            return this;
        }        public TaskRunnerSettingsResponse build() {
            return new TaskRunnerSettingsResponse(alsologtostderr, baseTaskDir, baseUrl, commandlinesFileName, continueOnException, dataflowApiVersion, harnessCommand, languageHint, logDir, logToSerialconsole, logUploadLocation, oauthScopes, parallelWorkerSettings, streamingWorkerMainClass, taskGroup, taskUser, tempStoragePrefix, vmId, workflowFileName);
        }
    }
}
