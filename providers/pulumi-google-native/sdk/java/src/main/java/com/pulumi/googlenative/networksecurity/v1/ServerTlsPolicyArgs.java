// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.googlenative.networksecurity.v1;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.googlenative.networksecurity.v1.inputs.GoogleCloudNetworksecurityV1CertificateProviderArgs;
import com.pulumi.googlenative.networksecurity.v1.inputs.MTLSPolicyArgs;
import java.lang.Boolean;
import java.lang.String;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class ServerTlsPolicyArgs extends com.pulumi.resources.ResourceArgs {

    public static final ServerTlsPolicyArgs Empty = new ServerTlsPolicyArgs();

    /**
     *  Determines if server allows plaintext connections. If set to true, server allows plain text connections. By default, it is set to false. This setting is not exclusive of other encryption modes. For example, if `allow_open` and `mtls_policy` are set, server allows both plain text and mTLS connections. See documentation of other encryption modes to confirm compatibility. Consider using it if you wish to upgrade in place your deployment to TLS while having mixed TLS and non-TLS traffic reaching port :80.
     * 
     */
    @Import(name="allowOpen")
    private @Nullable Output<Boolean> allowOpen;

    /**
     * @return  Determines if server allows plaintext connections. If set to true, server allows plain text connections. By default, it is set to false. This setting is not exclusive of other encryption modes. For example, if `allow_open` and `mtls_policy` are set, server allows both plain text and mTLS connections. See documentation of other encryption modes to confirm compatibility. Consider using it if you wish to upgrade in place your deployment to TLS while having mixed TLS and non-TLS traffic reaching port :80.
     * 
     */
    public Optional<Output<Boolean>> allowOpen() {
        return Optional.ofNullable(this.allowOpen);
    }

    /**
     * Free-text description of the resource.
     * 
     */
    @Import(name="description")
    private @Nullable Output<String> description;

    /**
     * @return Free-text description of the resource.
     * 
     */
    public Optional<Output<String>> description() {
        return Optional.ofNullable(this.description);
    }

    /**
     * Set of label tags associated with the resource.
     * 
     */
    @Import(name="labels")
    private @Nullable Output<Map<String,String>> labels;

    /**
     * @return Set of label tags associated with the resource.
     * 
     */
    public Optional<Output<Map<String,String>>> labels() {
        return Optional.ofNullable(this.labels);
    }

    @Import(name="location")
    private @Nullable Output<String> location;

    public Optional<Output<String>> location() {
        return Optional.ofNullable(this.location);
    }

    /**
     *  Defines a mechanism to provision peer validation certificates for peer to peer authentication (Mutual TLS - mTLS). If not specified, client certificate will not be requested. The connection is treated as TLS and not mTLS. If `allow_open` and `mtls_policy` are set, server allows both plain text and mTLS connections.
     * 
     */
    @Import(name="mtlsPolicy")
    private @Nullable Output<MTLSPolicyArgs> mtlsPolicy;

    /**
     * @return  Defines a mechanism to provision peer validation certificates for peer to peer authentication (Mutual TLS - mTLS). If not specified, client certificate will not be requested. The connection is treated as TLS and not mTLS. If `allow_open` and `mtls_policy` are set, server allows both plain text and mTLS connections.
     * 
     */
    public Optional<Output<MTLSPolicyArgs>> mtlsPolicy() {
        return Optional.ofNullable(this.mtlsPolicy);
    }

    /**
     * Name of the ServerTlsPolicy resource. It matches the pattern `projects/*{@literal /}locations/{location}/serverTlsPolicies/{server_tls_policy}`
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return Name of the ServerTlsPolicy resource. It matches the pattern `projects/*{@literal /}locations/{location}/serverTlsPolicies/{server_tls_policy}`
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    @Import(name="project")
    private @Nullable Output<String> project;

    public Optional<Output<String>> project() {
        return Optional.ofNullable(this.project);
    }

    /**
     *  Defines a mechanism to provision server identity (public and private keys). Cannot be combined with `allow_open` as a permissive mode that allows both plain text and TLS is not supported.
     * 
     */
    @Import(name="serverCertificate")
    private @Nullable Output<GoogleCloudNetworksecurityV1CertificateProviderArgs> serverCertificate;

    /**
     * @return  Defines a mechanism to provision server identity (public and private keys). Cannot be combined with `allow_open` as a permissive mode that allows both plain text and TLS is not supported.
     * 
     */
    public Optional<Output<GoogleCloudNetworksecurityV1CertificateProviderArgs>> serverCertificate() {
        return Optional.ofNullable(this.serverCertificate);
    }

    /**
     * Required. Short name of the ServerTlsPolicy resource to be created. This value should be 1-63 characters long, containing only letters, numbers, hyphens, and underscores, and should not start with a number. E.g. &#34;server_mtls_policy&#34;.
     * 
     */
    @Import(name="serverTlsPolicyId", required=true)
    private Output<String> serverTlsPolicyId;

    /**
     * @return Required. Short name of the ServerTlsPolicy resource to be created. This value should be 1-63 characters long, containing only letters, numbers, hyphens, and underscores, and should not start with a number. E.g. &#34;server_mtls_policy&#34;.
     * 
     */
    public Output<String> serverTlsPolicyId() {
        return this.serverTlsPolicyId;
    }

    private ServerTlsPolicyArgs() {}

    private ServerTlsPolicyArgs(ServerTlsPolicyArgs $) {
        this.allowOpen = $.allowOpen;
        this.description = $.description;
        this.labels = $.labels;
        this.location = $.location;
        this.mtlsPolicy = $.mtlsPolicy;
        this.name = $.name;
        this.project = $.project;
        this.serverCertificate = $.serverCertificate;
        this.serverTlsPolicyId = $.serverTlsPolicyId;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(ServerTlsPolicyArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private ServerTlsPolicyArgs $;

        public Builder() {
            $ = new ServerTlsPolicyArgs();
        }

        public Builder(ServerTlsPolicyArgs defaults) {
            $ = new ServerTlsPolicyArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param allowOpen  Determines if server allows plaintext connections. If set to true, server allows plain text connections. By default, it is set to false. This setting is not exclusive of other encryption modes. For example, if `allow_open` and `mtls_policy` are set, server allows both plain text and mTLS connections. See documentation of other encryption modes to confirm compatibility. Consider using it if you wish to upgrade in place your deployment to TLS while having mixed TLS and non-TLS traffic reaching port :80.
         * 
         * @return builder
         * 
         */
        public Builder allowOpen(@Nullable Output<Boolean> allowOpen) {
            $.allowOpen = allowOpen;
            return this;
        }

        /**
         * @param allowOpen  Determines if server allows plaintext connections. If set to true, server allows plain text connections. By default, it is set to false. This setting is not exclusive of other encryption modes. For example, if `allow_open` and `mtls_policy` are set, server allows both plain text and mTLS connections. See documentation of other encryption modes to confirm compatibility. Consider using it if you wish to upgrade in place your deployment to TLS while having mixed TLS and non-TLS traffic reaching port :80.
         * 
         * @return builder
         * 
         */
        public Builder allowOpen(Boolean allowOpen) {
            return allowOpen(Output.of(allowOpen));
        }

        /**
         * @param description Free-text description of the resource.
         * 
         * @return builder
         * 
         */
        public Builder description(@Nullable Output<String> description) {
            $.description = description;
            return this;
        }

        /**
         * @param description Free-text description of the resource.
         * 
         * @return builder
         * 
         */
        public Builder description(String description) {
            return description(Output.of(description));
        }

        /**
         * @param labels Set of label tags associated with the resource.
         * 
         * @return builder
         * 
         */
        public Builder labels(@Nullable Output<Map<String,String>> labels) {
            $.labels = labels;
            return this;
        }

        /**
         * @param labels Set of label tags associated with the resource.
         * 
         * @return builder
         * 
         */
        public Builder labels(Map<String,String> labels) {
            return labels(Output.of(labels));
        }

        public Builder location(@Nullable Output<String> location) {
            $.location = location;
            return this;
        }

        public Builder location(String location) {
            return location(Output.of(location));
        }

        /**
         * @param mtlsPolicy  Defines a mechanism to provision peer validation certificates for peer to peer authentication (Mutual TLS - mTLS). If not specified, client certificate will not be requested. The connection is treated as TLS and not mTLS. If `allow_open` and `mtls_policy` are set, server allows both plain text and mTLS connections.
         * 
         * @return builder
         * 
         */
        public Builder mtlsPolicy(@Nullable Output<MTLSPolicyArgs> mtlsPolicy) {
            $.mtlsPolicy = mtlsPolicy;
            return this;
        }

        /**
         * @param mtlsPolicy  Defines a mechanism to provision peer validation certificates for peer to peer authentication (Mutual TLS - mTLS). If not specified, client certificate will not be requested. The connection is treated as TLS and not mTLS. If `allow_open` and `mtls_policy` are set, server allows both plain text and mTLS connections.
         * 
         * @return builder
         * 
         */
        public Builder mtlsPolicy(MTLSPolicyArgs mtlsPolicy) {
            return mtlsPolicy(Output.of(mtlsPolicy));
        }

        /**
         * @param name Name of the ServerTlsPolicy resource. It matches the pattern `projects/*{@literal /}locations/{location}/serverTlsPolicies/{server_tls_policy}`
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name Name of the ServerTlsPolicy resource. It matches the pattern `projects/*{@literal /}locations/{location}/serverTlsPolicies/{server_tls_policy}`
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        public Builder project(@Nullable Output<String> project) {
            $.project = project;
            return this;
        }

        public Builder project(String project) {
            return project(Output.of(project));
        }

        /**
         * @param serverCertificate  Defines a mechanism to provision server identity (public and private keys). Cannot be combined with `allow_open` as a permissive mode that allows both plain text and TLS is not supported.
         * 
         * @return builder
         * 
         */
        public Builder serverCertificate(@Nullable Output<GoogleCloudNetworksecurityV1CertificateProviderArgs> serverCertificate) {
            $.serverCertificate = serverCertificate;
            return this;
        }

        /**
         * @param serverCertificate  Defines a mechanism to provision server identity (public and private keys). Cannot be combined with `allow_open` as a permissive mode that allows both plain text and TLS is not supported.
         * 
         * @return builder
         * 
         */
        public Builder serverCertificate(GoogleCloudNetworksecurityV1CertificateProviderArgs serverCertificate) {
            return serverCertificate(Output.of(serverCertificate));
        }

        /**
         * @param serverTlsPolicyId Required. Short name of the ServerTlsPolicy resource to be created. This value should be 1-63 characters long, containing only letters, numbers, hyphens, and underscores, and should not start with a number. E.g. &#34;server_mtls_policy&#34;.
         * 
         * @return builder
         * 
         */
        public Builder serverTlsPolicyId(Output<String> serverTlsPolicyId) {
            $.serverTlsPolicyId = serverTlsPolicyId;
            return this;
        }

        /**
         * @param serverTlsPolicyId Required. Short name of the ServerTlsPolicy resource to be created. This value should be 1-63 characters long, containing only letters, numbers, hyphens, and underscores, and should not start with a number. E.g. &#34;server_mtls_policy&#34;.
         * 
         * @return builder
         * 
         */
        public Builder serverTlsPolicyId(String serverTlsPolicyId) {
            return serverTlsPolicyId(Output.of(serverTlsPolicyId));
        }

        public ServerTlsPolicyArgs build() {
            $.serverTlsPolicyId = Objects.requireNonNull($.serverTlsPolicyId, "expected parameter 'serverTlsPolicyId' to be non-null");
            return $;
        }
    }

}
