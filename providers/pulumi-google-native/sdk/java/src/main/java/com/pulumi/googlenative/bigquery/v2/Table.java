// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.googlenative.bigquery.v2;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.googlenative.Utilities;
import com.pulumi.googlenative.bigquery.v2.TableArgs;
import com.pulumi.googlenative.bigquery.v2.outputs.CloneDefinitionResponse;
import com.pulumi.googlenative.bigquery.v2.outputs.ClusteringResponse;
import com.pulumi.googlenative.bigquery.v2.outputs.EncryptionConfigurationResponse;
import com.pulumi.googlenative.bigquery.v2.outputs.ExternalDataConfigurationResponse;
import com.pulumi.googlenative.bigquery.v2.outputs.MaterializedViewDefinitionResponse;
import com.pulumi.googlenative.bigquery.v2.outputs.ModelDefinitionResponse;
import com.pulumi.googlenative.bigquery.v2.outputs.RangePartitioningResponse;
import com.pulumi.googlenative.bigquery.v2.outputs.SnapshotDefinitionResponse;
import com.pulumi.googlenative.bigquery.v2.outputs.StreamingbufferResponse;
import com.pulumi.googlenative.bigquery.v2.outputs.TableReferenceResponse;
import com.pulumi.googlenative.bigquery.v2.outputs.TableSchemaResponse;
import com.pulumi.googlenative.bigquery.v2.outputs.TimePartitioningResponse;
import com.pulumi.googlenative.bigquery.v2.outputs.ViewDefinitionResponse;
import java.lang.Boolean;
import java.lang.String;
import java.util.Map;
import javax.annotation.Nullable;

/**
 * Creates a new, empty table in the dataset.
 * Auto-naming is currently not supported for this resource.
 * 
 */
@ResourceType(type="google-native:bigquery/v2:Table")
public class Table extends com.pulumi.resources.CustomResource {
    /**
     * Clone definition.
     * 
     */
    @Export(name="cloneDefinition", type=CloneDefinitionResponse.class, parameters={})
    private Output<CloneDefinitionResponse> cloneDefinition;

    /**
     * @return Clone definition.
     * 
     */
    public Output<CloneDefinitionResponse> cloneDefinition() {
        return this.cloneDefinition;
    }
    /**
     * [Beta] Clustering specification for the table. Must be specified with partitioning, data in the table will be first partitioned and subsequently clustered.
     * 
     */
    @Export(name="clustering", type=ClusteringResponse.class, parameters={})
    private Output<ClusteringResponse> clustering;

    /**
     * @return [Beta] Clustering specification for the table. Must be specified with partitioning, data in the table will be first partitioned and subsequently clustered.
     * 
     */
    public Output<ClusteringResponse> clustering() {
        return this.clustering;
    }
    /**
     * The time when this table was created, in milliseconds since the epoch.
     * 
     */
    @Export(name="creationTime", type=String.class, parameters={})
    private Output<String> creationTime;

    /**
     * @return The time when this table was created, in milliseconds since the epoch.
     * 
     */
    public Output<String> creationTime() {
        return this.creationTime;
    }
    @Export(name="datasetId", type=String.class, parameters={})
    private Output<String> datasetId;

    public Output<String> datasetId() {
        return this.datasetId;
    }
    /**
     * The default collation of the table.
     * 
     */
    @Export(name="defaultCollation", type=String.class, parameters={})
    private Output<String> defaultCollation;

    /**
     * @return The default collation of the table.
     * 
     */
    public Output<String> defaultCollation() {
        return this.defaultCollation;
    }
    /**
     * [Optional] A user-friendly description of this table.
     * 
     */
    @Export(name="description", type=String.class, parameters={})
    private Output<String> description;

    /**
     * @return [Optional] A user-friendly description of this table.
     * 
     */
    public Output<String> description() {
        return this.description;
    }
    /**
     * Custom encryption configuration (e.g., Cloud KMS keys).
     * 
     */
    @Export(name="encryptionConfiguration", type=EncryptionConfigurationResponse.class, parameters={})
    private Output<EncryptionConfigurationResponse> encryptionConfiguration;

    /**
     * @return Custom encryption configuration (e.g., Cloud KMS keys).
     * 
     */
    public Output<EncryptionConfigurationResponse> encryptionConfiguration() {
        return this.encryptionConfiguration;
    }
    /**
     * A hash of the table metadata. Used to ensure there were no concurrent modifications to the resource when attempting an update. Not guaranteed to change when the table contents or the fields numRows, numBytes, numLongTermBytes or lastModifiedTime change.
     * 
     */
    @Export(name="etag", type=String.class, parameters={})
    private Output<String> etag;

    /**
     * @return A hash of the table metadata. Used to ensure there were no concurrent modifications to the resource when attempting an update. Not guaranteed to change when the table contents or the fields numRows, numBytes, numLongTermBytes or lastModifiedTime change.
     * 
     */
    public Output<String> etag() {
        return this.etag;
    }
    /**
     * [Optional] The time when this table expires, in milliseconds since the epoch. If not present, the table will persist indefinitely. Expired tables will be deleted and their storage reclaimed. The defaultTableExpirationMs property of the encapsulating dataset can be used to set a default expirationTime on newly created tables.
     * 
     */
    @Export(name="expirationTime", type=String.class, parameters={})
    private Output<String> expirationTime;

    /**
     * @return [Optional] The time when this table expires, in milliseconds since the epoch. If not present, the table will persist indefinitely. Expired tables will be deleted and their storage reclaimed. The defaultTableExpirationMs property of the encapsulating dataset can be used to set a default expirationTime on newly created tables.
     * 
     */
    public Output<String> expirationTime() {
        return this.expirationTime;
    }
    /**
     * [Optional] Describes the data format, location, and other properties of a table stored outside of BigQuery. By defining these properties, the data source can then be queried as if it were a standard BigQuery table.
     * 
     */
    @Export(name="externalDataConfiguration", type=ExternalDataConfigurationResponse.class, parameters={})
    private Output<ExternalDataConfigurationResponse> externalDataConfiguration;

    /**
     * @return [Optional] Describes the data format, location, and other properties of a table stored outside of BigQuery. By defining these properties, the data source can then be queried as if it were a standard BigQuery table.
     * 
     */
    public Output<ExternalDataConfigurationResponse> externalDataConfiguration() {
        return this.externalDataConfiguration;
    }
    /**
     * [Optional] A descriptive name for this table.
     * 
     */
    @Export(name="friendlyName", type=String.class, parameters={})
    private Output<String> friendlyName;

    /**
     * @return [Optional] A descriptive name for this table.
     * 
     */
    public Output<String> friendlyName() {
        return this.friendlyName;
    }
    /**
     * The type of the resource.
     * 
     */
    @Export(name="kind", type=String.class, parameters={})
    private Output<String> kind;

    /**
     * @return The type of the resource.
     * 
     */
    public Output<String> kind() {
        return this.kind;
    }
    /**
     * The labels associated with this table. You can use these to organize and group your tables. Label keys and values can be no longer than 63 characters, can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. Label values are optional. Label keys must start with a letter and each label in the list must have a different key.
     * 
     */
    @Export(name="labels", type=Map.class, parameters={String.class, String.class})
    private Output<Map<String,String>> labels;

    /**
     * @return The labels associated with this table. You can use these to organize and group your tables. Label keys and values can be no longer than 63 characters, can only contain lowercase letters, numeric characters, underscores and dashes. International characters are allowed. Label values are optional. Label keys must start with a letter and each label in the list must have a different key.
     * 
     */
    public Output<Map<String,String>> labels() {
        return this.labels;
    }
    /**
     * The time when this table was last modified, in milliseconds since the epoch.
     * 
     */
    @Export(name="lastModifiedTime", type=String.class, parameters={})
    private Output<String> lastModifiedTime;

    /**
     * @return The time when this table was last modified, in milliseconds since the epoch.
     * 
     */
    public Output<String> lastModifiedTime() {
        return this.lastModifiedTime;
    }
    /**
     * The geographic location where the table resides. This value is inherited from the dataset.
     * 
     */
    @Export(name="location", type=String.class, parameters={})
    private Output<String> location;

    /**
     * @return The geographic location where the table resides. This value is inherited from the dataset.
     * 
     */
    public Output<String> location() {
        return this.location;
    }
    /**
     * [Optional] Materialized view definition.
     * 
     */
    @Export(name="materializedView", type=MaterializedViewDefinitionResponse.class, parameters={})
    private Output<MaterializedViewDefinitionResponse> materializedView;

    /**
     * @return [Optional] Materialized view definition.
     * 
     */
    public Output<MaterializedViewDefinitionResponse> materializedView() {
        return this.materializedView;
    }
    /**
     * [Optional] Max staleness of data that could be returned when table or materialized view is queried (formatted as Google SQL Interval type).
     * 
     */
    @Export(name="maxStaleness", type=String.class, parameters={})
    private Output<String> maxStaleness;

    /**
     * @return [Optional] Max staleness of data that could be returned when table or materialized view is queried (formatted as Google SQL Interval type).
     * 
     */
    public Output<String> maxStaleness() {
        return this.maxStaleness;
    }
    /**
     * [Output-only, Beta] Present iff this table represents a ML model. Describes the training information for the model, and it is required to run &#39;PREDICT&#39; queries.
     * 
     */
    @Export(name="model", type=ModelDefinitionResponse.class, parameters={})
    private Output<ModelDefinitionResponse> model;

    /**
     * @return [Output-only, Beta] Present iff this table represents a ML model. Describes the training information for the model, and it is required to run &#39;PREDICT&#39; queries.
     * 
     */
    public Output<ModelDefinitionResponse> model() {
        return this.model;
    }
    /**
     * Number of logical bytes that are less than 90 days old.
     * 
     */
    @Export(name="numActiveLogicalBytes", type=String.class, parameters={})
    private Output<String> numActiveLogicalBytes;

    /**
     * @return Number of logical bytes that are less than 90 days old.
     * 
     */
    public Output<String> numActiveLogicalBytes() {
        return this.numActiveLogicalBytes;
    }
    /**
     * Number of physical bytes less than 90 days old. This data is not kept in real time, and might be delayed by a few seconds to a few minutes.
     * 
     */
    @Export(name="numActivePhysicalBytes", type=String.class, parameters={})
    private Output<String> numActivePhysicalBytes;

    /**
     * @return Number of physical bytes less than 90 days old. This data is not kept in real time, and might be delayed by a few seconds to a few minutes.
     * 
     */
    public Output<String> numActivePhysicalBytes() {
        return this.numActivePhysicalBytes;
    }
    /**
     * The size of this table in bytes, excluding any data in the streaming buffer.
     * 
     */
    @Export(name="numBytes", type=String.class, parameters={})
    private Output<String> numBytes;

    /**
     * @return The size of this table in bytes, excluding any data in the streaming buffer.
     * 
     */
    public Output<String> numBytes() {
        return this.numBytes;
    }
    /**
     * The number of bytes in the table that are considered &#34;long-term storage&#34;.
     * 
     */
    @Export(name="numLongTermBytes", type=String.class, parameters={})
    private Output<String> numLongTermBytes;

    /**
     * @return The number of bytes in the table that are considered &#34;long-term storage&#34;.
     * 
     */
    public Output<String> numLongTermBytes() {
        return this.numLongTermBytes;
    }
    /**
     * Number of logical bytes that are more than 90 days old.
     * 
     */
    @Export(name="numLongTermLogicalBytes", type=String.class, parameters={})
    private Output<String> numLongTermLogicalBytes;

    /**
     * @return Number of logical bytes that are more than 90 days old.
     * 
     */
    public Output<String> numLongTermLogicalBytes() {
        return this.numLongTermLogicalBytes;
    }
    /**
     * Number of physical bytes more than 90 days old. This data is not kept in real time, and might be delayed by a few seconds to a few minutes.
     * 
     */
    @Export(name="numLongTermPhysicalBytes", type=String.class, parameters={})
    private Output<String> numLongTermPhysicalBytes;

    /**
     * @return Number of physical bytes more than 90 days old. This data is not kept in real time, and might be delayed by a few seconds to a few minutes.
     * 
     */
    public Output<String> numLongTermPhysicalBytes() {
        return this.numLongTermPhysicalBytes;
    }
    /**
     * The number of partitions present in the table or materialized view. This data is not kept in real time, and might be delayed by a few seconds to a few minutes.
     * 
     */
    @Export(name="numPartitions", type=String.class, parameters={})
    private Output<String> numPartitions;

    /**
     * @return The number of partitions present in the table or materialized view. This data is not kept in real time, and might be delayed by a few seconds to a few minutes.
     * 
     */
    public Output<String> numPartitions() {
        return this.numPartitions;
    }
    /**
     * [TrustedTester] The physical size of this table in bytes, excluding any data in the streaming buffer. This includes compression and storage used for time travel.
     * 
     */
    @Export(name="numPhysicalBytes", type=String.class, parameters={})
    private Output<String> numPhysicalBytes;

    /**
     * @return [TrustedTester] The physical size of this table in bytes, excluding any data in the streaming buffer. This includes compression and storage used for time travel.
     * 
     */
    public Output<String> numPhysicalBytes() {
        return this.numPhysicalBytes;
    }
    /**
     * The number of rows of data in this table, excluding any data in the streaming buffer.
     * 
     */
    @Export(name="numRows", type=String.class, parameters={})
    private Output<String> numRows;

    /**
     * @return The number of rows of data in this table, excluding any data in the streaming buffer.
     * 
     */
    public Output<String> numRows() {
        return this.numRows;
    }
    /**
     * Number of physical bytes used by time travel storage (deleted or changed data). This data is not kept in real time, and might be delayed by a few seconds to a few minutes.
     * 
     */
    @Export(name="numTimeTravelPhysicalBytes", type=String.class, parameters={})
    private Output<String> numTimeTravelPhysicalBytes;

    /**
     * @return Number of physical bytes used by time travel storage (deleted or changed data). This data is not kept in real time, and might be delayed by a few seconds to a few minutes.
     * 
     */
    public Output<String> numTimeTravelPhysicalBytes() {
        return this.numTimeTravelPhysicalBytes;
    }
    /**
     * Total number of logical bytes in the table or materialized view.
     * 
     */
    @Export(name="numTotalLogicalBytes", type=String.class, parameters={})
    private Output<String> numTotalLogicalBytes;

    /**
     * @return Total number of logical bytes in the table or materialized view.
     * 
     */
    public Output<String> numTotalLogicalBytes() {
        return this.numTotalLogicalBytes;
    }
    /**
     * The physical size of this table in bytes. This also includes storage used for time travel. This data is not kept in real time, and might be delayed by a few seconds to a few minutes.
     * 
     */
    @Export(name="numTotalPhysicalBytes", type=String.class, parameters={})
    private Output<String> numTotalPhysicalBytes;

    /**
     * @return The physical size of this table in bytes. This also includes storage used for time travel. This data is not kept in real time, and might be delayed by a few seconds to a few minutes.
     * 
     */
    public Output<String> numTotalPhysicalBytes() {
        return this.numTotalPhysicalBytes;
    }
    @Export(name="project", type=String.class, parameters={})
    private Output<String> project;

    public Output<String> project() {
        return this.project;
    }
    /**
     * [TrustedTester] Range partitioning specification for this table. Only one of timePartitioning and rangePartitioning should be specified.
     * 
     */
    @Export(name="rangePartitioning", type=RangePartitioningResponse.class, parameters={})
    private Output<RangePartitioningResponse> rangePartitioning;

    /**
     * @return [TrustedTester] Range partitioning specification for this table. Only one of timePartitioning and rangePartitioning should be specified.
     * 
     */
    public Output<RangePartitioningResponse> rangePartitioning() {
        return this.rangePartitioning;
    }
    /**
     * [Optional] If set to true, queries over this table require a partition filter that can be used for partition elimination to be specified.
     * 
     */
    @Export(name="requirePartitionFilter", type=Boolean.class, parameters={})
    private Output<Boolean> requirePartitionFilter;

    /**
     * @return [Optional] If set to true, queries over this table require a partition filter that can be used for partition elimination to be specified.
     * 
     */
    public Output<Boolean> requirePartitionFilter() {
        return this.requirePartitionFilter;
    }
    /**
     * [Optional] Describes the schema of this table.
     * 
     */
    @Export(name="schema", type=TableSchemaResponse.class, parameters={})
    private Output<TableSchemaResponse> schema;

    /**
     * @return [Optional] Describes the schema of this table.
     * 
     */
    public Output<TableSchemaResponse> schema() {
        return this.schema;
    }
    /**
     * A URL that can be used to access this resource again.
     * 
     */
    @Export(name="selfLink", type=String.class, parameters={})
    private Output<String> selfLink;

    /**
     * @return A URL that can be used to access this resource again.
     * 
     */
    public Output<String> selfLink() {
        return this.selfLink;
    }
    /**
     * Snapshot definition.
     * 
     */
    @Export(name="snapshotDefinition", type=SnapshotDefinitionResponse.class, parameters={})
    private Output<SnapshotDefinitionResponse> snapshotDefinition;

    /**
     * @return Snapshot definition.
     * 
     */
    public Output<SnapshotDefinitionResponse> snapshotDefinition() {
        return this.snapshotDefinition;
    }
    /**
     * Contains information regarding this table&#39;s streaming buffer, if one is present. This field will be absent if the table is not being streamed to or if there is no data in the streaming buffer.
     * 
     */
    @Export(name="streamingBuffer", type=StreamingbufferResponse.class, parameters={})
    private Output<StreamingbufferResponse> streamingBuffer;

    /**
     * @return Contains information regarding this table&#39;s streaming buffer, if one is present. This field will be absent if the table is not being streamed to or if there is no data in the streaming buffer.
     * 
     */
    public Output<StreamingbufferResponse> streamingBuffer() {
        return this.streamingBuffer;
    }
    /**
     * [Required] Reference describing the ID of this table.
     * 
     */
    @Export(name="tableReference", type=TableReferenceResponse.class, parameters={})
    private Output<TableReferenceResponse> tableReference;

    /**
     * @return [Required] Reference describing the ID of this table.
     * 
     */
    public Output<TableReferenceResponse> tableReference() {
        return this.tableReference;
    }
    /**
     * Time-based partitioning specification for this table. Only one of timePartitioning and rangePartitioning should be specified.
     * 
     */
    @Export(name="timePartitioning", type=TimePartitioningResponse.class, parameters={})
    private Output<TimePartitioningResponse> timePartitioning;

    /**
     * @return Time-based partitioning specification for this table. Only one of timePartitioning and rangePartitioning should be specified.
     * 
     */
    public Output<TimePartitioningResponse> timePartitioning() {
        return this.timePartitioning;
    }
    /**
     * Describes the table type. The following values are supported: TABLE: A normal BigQuery table. VIEW: A virtual table defined by a SQL query. SNAPSHOT: An immutable, read-only table that is a copy of another table. [TrustedTester] MATERIALIZED_VIEW: SQL query whose result is persisted. EXTERNAL: A table that references data stored in an external storage system, such as Google Cloud Storage. The default value is TABLE.
     * 
     */
    @Export(name="type", type=String.class, parameters={})
    private Output<String> type;

    /**
     * @return Describes the table type. The following values are supported: TABLE: A normal BigQuery table. VIEW: A virtual table defined by a SQL query. SNAPSHOT: An immutable, read-only table that is a copy of another table. [TrustedTester] MATERIALIZED_VIEW: SQL query whose result is persisted. EXTERNAL: A table that references data stored in an external storage system, such as Google Cloud Storage. The default value is TABLE.
     * 
     */
    public Output<String> type() {
        return this.type;
    }
    /**
     * [Optional] The view definition.
     * 
     */
    @Export(name="view", type=ViewDefinitionResponse.class, parameters={})
    private Output<ViewDefinitionResponse> view;

    /**
     * @return [Optional] The view definition.
     * 
     */
    public Output<ViewDefinitionResponse> view() {
        return this.view;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public Table(String name) {
        this(name, TableArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public Table(String name, TableArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public Table(String name, TableArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("google-native:bigquery/v2:Table", name, args == null ? TableArgs.Empty : args, makeResourceOptions(options, Codegen.empty()));
    }

    private Table(String name, Output<String> id, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("google-native:bigquery/v2:Table", name, null, makeResourceOptions(options, id));
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static Table get(String name, Output<String> id, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new Table(name, id, options);
    }
}
