// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.googlenative.compute.alpha.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


/**
 * [Deprecated] All fields defined in a principal are ANDed.
 * 
 */
public final class PrincipalArgs extends com.pulumi.resources.ResourceArgs {

    public static final PrincipalArgs Empty = new PrincipalArgs();

    /**
     * An expression to specify custom condition.
     * 
     */
    @Import(name="condition")
    private @Nullable Output<String> condition;

    /**
     * @return An expression to specify custom condition.
     * 
     */
    public Optional<Output<String>> condition() {
        return Optional.ofNullable(this.condition);
    }

    /**
     * The groups the principal belongs to. Exact match, prefix match, and suffix match are supported.
     * 
     */
    @Import(name="groups")
    private @Nullable Output<List<String>> groups;

    /**
     * @return The groups the principal belongs to. Exact match, prefix match, and suffix match are supported.
     * 
     */
    public Optional<Output<List<String>>> groups() {
        return Optional.ofNullable(this.groups);
    }

    /**
     * IPv4 or IPv6 address or range (In CIDR format)
     * 
     */
    @Import(name="ips")
    private @Nullable Output<List<String>> ips;

    /**
     * @return IPv4 or IPv6 address or range (In CIDR format)
     * 
     */
    public Optional<Output<List<String>>> ips() {
        return Optional.ofNullable(this.ips);
    }

    /**
     * The namespaces. Exact match, prefix match, and suffix match are supported.
     * 
     */
    @Import(name="namespaces")
    private @Nullable Output<List<String>> namespaces;

    /**
     * @return The namespaces. Exact match, prefix match, and suffix match are supported.
     * 
     */
    public Optional<Output<List<String>>> namespaces() {
        return Optional.ofNullable(this.namespaces);
    }

    /**
     * Negate of groups. Specifies exclusions.
     * 
     */
    @Import(name="notGroups")
    private @Nullable Output<List<String>> notGroups;

    /**
     * @return Negate of groups. Specifies exclusions.
     * 
     */
    public Optional<Output<List<String>>> notGroups() {
        return Optional.ofNullable(this.notGroups);
    }

    /**
     * Negate of IPs. Specifies exclusions.
     * 
     */
    @Import(name="notIps")
    private @Nullable Output<List<String>> notIps;

    /**
     * @return Negate of IPs. Specifies exclusions.
     * 
     */
    public Optional<Output<List<String>>> notIps() {
        return Optional.ofNullable(this.notIps);
    }

    /**
     * Negate of namespaces. Specifies exclusions.
     * 
     */
    @Import(name="notNamespaces")
    private @Nullable Output<List<String>> notNamespaces;

    /**
     * @return Negate of namespaces. Specifies exclusions.
     * 
     */
    public Optional<Output<List<String>>> notNamespaces() {
        return Optional.ofNullable(this.notNamespaces);
    }

    /**
     * Negate of users. Specifies exclusions.
     * 
     */
    @Import(name="notUsers")
    private @Nullable Output<List<String>> notUsers;

    /**
     * @return Negate of users. Specifies exclusions.
     * 
     */
    public Optional<Output<List<String>>> notUsers() {
        return Optional.ofNullable(this.notUsers);
    }

    /**
     * A map of Istio attribute to expected values. Exact match, prefix match, and suffix match are supported for values. For example, `request.headers[version]: &#34;v1&#34;`. The properties are ANDed together.
     * 
     */
    @Import(name="properties")
    private @Nullable Output<Map<String,String>> properties;

    /**
     * @return A map of Istio attribute to expected values. Exact match, prefix match, and suffix match are supported for values. For example, `request.headers[version]: &#34;v1&#34;`. The properties are ANDed together.
     * 
     */
    public Optional<Output<Map<String,String>>> properties() {
        return Optional.ofNullable(this.properties);
    }

    /**
     * The user names/IDs or service accounts. Exact match, prefix match, and suffix match are supported.
     * 
     */
    @Import(name="users")
    private @Nullable Output<List<String>> users;

    /**
     * @return The user names/IDs or service accounts. Exact match, prefix match, and suffix match are supported.
     * 
     */
    public Optional<Output<List<String>>> users() {
        return Optional.ofNullable(this.users);
    }

    private PrincipalArgs() {}

    private PrincipalArgs(PrincipalArgs $) {
        this.condition = $.condition;
        this.groups = $.groups;
        this.ips = $.ips;
        this.namespaces = $.namespaces;
        this.notGroups = $.notGroups;
        this.notIps = $.notIps;
        this.notNamespaces = $.notNamespaces;
        this.notUsers = $.notUsers;
        this.properties = $.properties;
        this.users = $.users;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(PrincipalArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private PrincipalArgs $;

        public Builder() {
            $ = new PrincipalArgs();
        }

        public Builder(PrincipalArgs defaults) {
            $ = new PrincipalArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param condition An expression to specify custom condition.
         * 
         * @return builder
         * 
         */
        public Builder condition(@Nullable Output<String> condition) {
            $.condition = condition;
            return this;
        }

        /**
         * @param condition An expression to specify custom condition.
         * 
         * @return builder
         * 
         */
        public Builder condition(String condition) {
            return condition(Output.of(condition));
        }

        /**
         * @param groups The groups the principal belongs to. Exact match, prefix match, and suffix match are supported.
         * 
         * @return builder
         * 
         */
        public Builder groups(@Nullable Output<List<String>> groups) {
            $.groups = groups;
            return this;
        }

        /**
         * @param groups The groups the principal belongs to. Exact match, prefix match, and suffix match are supported.
         * 
         * @return builder
         * 
         */
        public Builder groups(List<String> groups) {
            return groups(Output.of(groups));
        }

        /**
         * @param groups The groups the principal belongs to. Exact match, prefix match, and suffix match are supported.
         * 
         * @return builder
         * 
         */
        public Builder groups(String... groups) {
            return groups(List.of(groups));
        }

        /**
         * @param ips IPv4 or IPv6 address or range (In CIDR format)
         * 
         * @return builder
         * 
         */
        public Builder ips(@Nullable Output<List<String>> ips) {
            $.ips = ips;
            return this;
        }

        /**
         * @param ips IPv4 or IPv6 address or range (In CIDR format)
         * 
         * @return builder
         * 
         */
        public Builder ips(List<String> ips) {
            return ips(Output.of(ips));
        }

        /**
         * @param ips IPv4 or IPv6 address or range (In CIDR format)
         * 
         * @return builder
         * 
         */
        public Builder ips(String... ips) {
            return ips(List.of(ips));
        }

        /**
         * @param namespaces The namespaces. Exact match, prefix match, and suffix match are supported.
         * 
         * @return builder
         * 
         */
        public Builder namespaces(@Nullable Output<List<String>> namespaces) {
            $.namespaces = namespaces;
            return this;
        }

        /**
         * @param namespaces The namespaces. Exact match, prefix match, and suffix match are supported.
         * 
         * @return builder
         * 
         */
        public Builder namespaces(List<String> namespaces) {
            return namespaces(Output.of(namespaces));
        }

        /**
         * @param namespaces The namespaces. Exact match, prefix match, and suffix match are supported.
         * 
         * @return builder
         * 
         */
        public Builder namespaces(String... namespaces) {
            return namespaces(List.of(namespaces));
        }

        /**
         * @param notGroups Negate of groups. Specifies exclusions.
         * 
         * @return builder
         * 
         */
        public Builder notGroups(@Nullable Output<List<String>> notGroups) {
            $.notGroups = notGroups;
            return this;
        }

        /**
         * @param notGroups Negate of groups. Specifies exclusions.
         * 
         * @return builder
         * 
         */
        public Builder notGroups(List<String> notGroups) {
            return notGroups(Output.of(notGroups));
        }

        /**
         * @param notGroups Negate of groups. Specifies exclusions.
         * 
         * @return builder
         * 
         */
        public Builder notGroups(String... notGroups) {
            return notGroups(List.of(notGroups));
        }

        /**
         * @param notIps Negate of IPs. Specifies exclusions.
         * 
         * @return builder
         * 
         */
        public Builder notIps(@Nullable Output<List<String>> notIps) {
            $.notIps = notIps;
            return this;
        }

        /**
         * @param notIps Negate of IPs. Specifies exclusions.
         * 
         * @return builder
         * 
         */
        public Builder notIps(List<String> notIps) {
            return notIps(Output.of(notIps));
        }

        /**
         * @param notIps Negate of IPs. Specifies exclusions.
         * 
         * @return builder
         * 
         */
        public Builder notIps(String... notIps) {
            return notIps(List.of(notIps));
        }

        /**
         * @param notNamespaces Negate of namespaces. Specifies exclusions.
         * 
         * @return builder
         * 
         */
        public Builder notNamespaces(@Nullable Output<List<String>> notNamespaces) {
            $.notNamespaces = notNamespaces;
            return this;
        }

        /**
         * @param notNamespaces Negate of namespaces. Specifies exclusions.
         * 
         * @return builder
         * 
         */
        public Builder notNamespaces(List<String> notNamespaces) {
            return notNamespaces(Output.of(notNamespaces));
        }

        /**
         * @param notNamespaces Negate of namespaces. Specifies exclusions.
         * 
         * @return builder
         * 
         */
        public Builder notNamespaces(String... notNamespaces) {
            return notNamespaces(List.of(notNamespaces));
        }

        /**
         * @param notUsers Negate of users. Specifies exclusions.
         * 
         * @return builder
         * 
         */
        public Builder notUsers(@Nullable Output<List<String>> notUsers) {
            $.notUsers = notUsers;
            return this;
        }

        /**
         * @param notUsers Negate of users. Specifies exclusions.
         * 
         * @return builder
         * 
         */
        public Builder notUsers(List<String> notUsers) {
            return notUsers(Output.of(notUsers));
        }

        /**
         * @param notUsers Negate of users. Specifies exclusions.
         * 
         * @return builder
         * 
         */
        public Builder notUsers(String... notUsers) {
            return notUsers(List.of(notUsers));
        }

        /**
         * @param properties A map of Istio attribute to expected values. Exact match, prefix match, and suffix match are supported for values. For example, `request.headers[version]: &#34;v1&#34;`. The properties are ANDed together.
         * 
         * @return builder
         * 
         */
        public Builder properties(@Nullable Output<Map<String,String>> properties) {
            $.properties = properties;
            return this;
        }

        /**
         * @param properties A map of Istio attribute to expected values. Exact match, prefix match, and suffix match are supported for values. For example, `request.headers[version]: &#34;v1&#34;`. The properties are ANDed together.
         * 
         * @return builder
         * 
         */
        public Builder properties(Map<String,String> properties) {
            return properties(Output.of(properties));
        }

        /**
         * @param users The user names/IDs or service accounts. Exact match, prefix match, and suffix match are supported.
         * 
         * @return builder
         * 
         */
        public Builder users(@Nullable Output<List<String>> users) {
            $.users = users;
            return this;
        }

        /**
         * @param users The user names/IDs or service accounts. Exact match, prefix match, and suffix match are supported.
         * 
         * @return builder
         * 
         */
        public Builder users(List<String> users) {
            return users(Output.of(users));
        }

        /**
         * @param users The user names/IDs or service accounts. Exact match, prefix match, and suffix match are supported.
         * 
         * @return builder
         * 
         */
        public Builder users(String... users) {
            return users(List.of(users));
        }

        public PrincipalArgs build() {
            return $;
        }
    }

}
