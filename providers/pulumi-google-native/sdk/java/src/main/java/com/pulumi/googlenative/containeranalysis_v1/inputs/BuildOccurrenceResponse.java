// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.googlenative.containeranalysis_v1.inputs;

import com.pulumi.core.annotations.Import;
import com.pulumi.googlenative.containeranalysis_v1.inputs.BuildProvenanceResponse;
import com.pulumi.googlenative.containeranalysis_v1.inputs.InTotoStatementResponse;
import java.lang.String;
import java.util.Objects;


/**
 * Details of a build occurrence.
 * 
 */
public final class BuildOccurrenceResponse extends com.pulumi.resources.InvokeArgs {

    public static final BuildOccurrenceResponse Empty = new BuildOccurrenceResponse();

    /**
     * In-toto Statement representation as defined in spec. The intoto_statement can contain any type of provenance. The serialized payload of the statement can be stored and signed in the Occurrence&#39;s envelope.
     * 
     */
    @Import(name="intotoStatement", required=true)
    private InTotoStatementResponse intotoStatement;

    /**
     * @return In-toto Statement representation as defined in spec. The intoto_statement can contain any type of provenance. The serialized payload of the statement can be stored and signed in the Occurrence&#39;s envelope.
     * 
     */
    public InTotoStatementResponse intotoStatement() {
        return this.intotoStatement;
    }

    /**
     * The actual provenance for the build.
     * 
     */
    @Import(name="provenance", required=true)
    private BuildProvenanceResponse provenance;

    /**
     * @return The actual provenance for the build.
     * 
     */
    public BuildProvenanceResponse provenance() {
        return this.provenance;
    }

    /**
     * Serialized JSON representation of the provenance, used in generating the build signature in the corresponding build note. After verifying the signature, `provenance_bytes` can be unmarshalled and compared to the provenance to confirm that it is unchanged. A base64-encoded string representation of the provenance bytes is used for the signature in order to interoperate with openssl which expects this format for signature verification. The serialized form is captured both to avoid ambiguity in how the provenance is marshalled to json as well to prevent incompatibilities with future changes.
     * 
     */
    @Import(name="provenanceBytes", required=true)
    private String provenanceBytes;

    /**
     * @return Serialized JSON representation of the provenance, used in generating the build signature in the corresponding build note. After verifying the signature, `provenance_bytes` can be unmarshalled and compared to the provenance to confirm that it is unchanged. A base64-encoded string representation of the provenance bytes is used for the signature in order to interoperate with openssl which expects this format for signature verification. The serialized form is captured both to avoid ambiguity in how the provenance is marshalled to json as well to prevent incompatibilities with future changes.
     * 
     */
    public String provenanceBytes() {
        return this.provenanceBytes;
    }

    private BuildOccurrenceResponse() {}

    private BuildOccurrenceResponse(BuildOccurrenceResponse $) {
        this.intotoStatement = $.intotoStatement;
        this.provenance = $.provenance;
        this.provenanceBytes = $.provenanceBytes;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(BuildOccurrenceResponse defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private BuildOccurrenceResponse $;

        public Builder() {
            $ = new BuildOccurrenceResponse();
        }

        public Builder(BuildOccurrenceResponse defaults) {
            $ = new BuildOccurrenceResponse(Objects.requireNonNull(defaults));
        }

        /**
         * @param intotoStatement In-toto Statement representation as defined in spec. The intoto_statement can contain any type of provenance. The serialized payload of the statement can be stored and signed in the Occurrence&#39;s envelope.
         * 
         * @return builder
         * 
         */
        public Builder intotoStatement(InTotoStatementResponse intotoStatement) {
            $.intotoStatement = intotoStatement;
            return this;
        }

        /**
         * @param provenance The actual provenance for the build.
         * 
         * @return builder
         * 
         */
        public Builder provenance(BuildProvenanceResponse provenance) {
            $.provenance = provenance;
            return this;
        }

        /**
         * @param provenanceBytes Serialized JSON representation of the provenance, used in generating the build signature in the corresponding build note. After verifying the signature, `provenance_bytes` can be unmarshalled and compared to the provenance to confirm that it is unchanged. A base64-encoded string representation of the provenance bytes is used for the signature in order to interoperate with openssl which expects this format for signature verification. The serialized form is captured both to avoid ambiguity in how the provenance is marshalled to json as well to prevent incompatibilities with future changes.
         * 
         * @return builder
         * 
         */
        public Builder provenanceBytes(String provenanceBytes) {
            $.provenanceBytes = provenanceBytes;
            return this;
        }

        public BuildOccurrenceResponse build() {
            $.intotoStatement = Objects.requireNonNull($.intotoStatement, "expected parameter 'intotoStatement' to be non-null");
            $.provenance = Objects.requireNonNull($.provenance, "expected parameter 'provenance' to be non-null");
            $.provenanceBytes = Objects.requireNonNull($.provenanceBytes, "expected parameter 'provenanceBytes' to be non-null");
            return $;
        }
    }

}
