// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.googlenative.healthcare.v1;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.googlenative.healthcare.v1.enums.FhirStoreComplexDataTypeReferenceParsing;
import com.pulumi.googlenative.healthcare.v1.enums.FhirStoreVersion;
import com.pulumi.googlenative.healthcare.v1.inputs.NotificationConfigArgs;
import com.pulumi.googlenative.healthcare.v1.inputs.StreamConfigArgs;
import com.pulumi.googlenative.healthcare.v1.inputs.ValidationConfigArgs;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class FhirStoreArgs extends com.pulumi.resources.ResourceArgs {

    public static final FhirStoreArgs Empty = new FhirStoreArgs();

    /**
     * Enable parsing of references within complex FHIR data types such as Extensions. If this value is set to ENABLED, then features like referential integrity and Bundle reference rewriting apply to all references. If this flag has not been specified the behavior of the FHIR store will not change, references in complex data types will not be parsed. New stores will have this value set to ENABLED after a notification period. Warning: turning on this flag causes processing existing resources to fail if they contain references to non-existent resources.
     * 
     */
    @Import(name="complexDataTypeReferenceParsing")
    private @Nullable Output<FhirStoreComplexDataTypeReferenceParsing> complexDataTypeReferenceParsing;

    /**
     * @return Enable parsing of references within complex FHIR data types such as Extensions. If this value is set to ENABLED, then features like referential integrity and Bundle reference rewriting apply to all references. If this flag has not been specified the behavior of the FHIR store will not change, references in complex data types will not be parsed. New stores will have this value set to ENABLED after a notification period. Warning: turning on this flag causes processing existing resources to fail if they contain references to non-existent resources.
     * 
     */
    public Optional<Output<FhirStoreComplexDataTypeReferenceParsing>> complexDataTypeReferenceParsing() {
        return Optional.ofNullable(this.complexDataTypeReferenceParsing);
    }

    @Import(name="datasetId", required=true)
    private Output<String> datasetId;

    public Output<String> datasetId() {
        return this.datasetId;
    }

    /**
     * If true, overrides the default search behavior for this FHIR store to `handling=strict` which returns an error for unrecognized search parameters. If false, uses the FHIR specification default `handling=lenient` which ignores unrecognized search parameters. The handling can always be changed from the default on an individual API call by setting the HTTP header `Prefer: handling=strict` or `Prefer: handling=lenient`.
     * 
     */
    @Import(name="defaultSearchHandlingStrict")
    private @Nullable Output<Boolean> defaultSearchHandlingStrict;

    /**
     * @return If true, overrides the default search behavior for this FHIR store to `handling=strict` which returns an error for unrecognized search parameters. If false, uses the FHIR specification default `handling=lenient` which ignores unrecognized search parameters. The handling can always be changed from the default on an individual API call by setting the HTTP header `Prefer: handling=strict` or `Prefer: handling=lenient`.
     * 
     */
    public Optional<Output<Boolean>> defaultSearchHandlingStrict() {
        return Optional.ofNullable(this.defaultSearchHandlingStrict);
    }

    /**
     * Immutable. Whether to disable referential integrity in this FHIR store. This field is immutable after FHIR store creation. The default value is false, meaning that the API enforces referential integrity and fails the requests that result in inconsistent state in the FHIR store. When this field is set to true, the API skips referential integrity checks. Consequently, operations that rely on references, such as GetPatientEverything, do not return all the results if broken references exist.
     * 
     */
    @Import(name="disableReferentialIntegrity")
    private @Nullable Output<Boolean> disableReferentialIntegrity;

    /**
     * @return Immutable. Whether to disable referential integrity in this FHIR store. This field is immutable after FHIR store creation. The default value is false, meaning that the API enforces referential integrity and fails the requests that result in inconsistent state in the FHIR store. When this field is set to true, the API skips referential integrity checks. Consequently, operations that rely on references, such as GetPatientEverything, do not return all the results if broken references exist.
     * 
     */
    public Optional<Output<Boolean>> disableReferentialIntegrity() {
        return Optional.ofNullable(this.disableReferentialIntegrity);
    }

    /**
     * Immutable. Whether to disable resource versioning for this FHIR store. This field can not be changed after the creation of FHIR store. If set to false, which is the default behavior, all write operations cause historical versions to be recorded automatically. The historical versions can be fetched through the history APIs, but cannot be updated. If set to true, no historical versions are kept. The server sends errors for attempts to read the historical versions.
     * 
     */
    @Import(name="disableResourceVersioning")
    private @Nullable Output<Boolean> disableResourceVersioning;

    /**
     * @return Immutable. Whether to disable resource versioning for this FHIR store. This field can not be changed after the creation of FHIR store. If set to false, which is the default behavior, all write operations cause historical versions to be recorded automatically. The historical versions can be fetched through the history APIs, but cannot be updated. If set to true, no historical versions are kept. The server sends errors for attempts to read the historical versions.
     * 
     */
    public Optional<Output<Boolean>> disableResourceVersioning() {
        return Optional.ofNullable(this.disableResourceVersioning);
    }

    /**
     * Whether this FHIR store has the [updateCreate capability](https://www.hl7.org/fhir/capabilitystatement-definitions.html#CapabilityStatement.rest.resource.updateCreate). This determines if the client can use an Update operation to create a new resource with a client-specified ID. If false, all IDs are server-assigned through the Create operation and attempts to update a non-existent resource return errors. It is strongly advised not to include or encode any sensitive data such as patient identifiers in client-specified resource IDs. Those IDs are part of the FHIR resource path recorded in Cloud audit logs and Pub/Sub notifications. Those IDs can also be contained in reference fields within other resources.
     * 
     */
    @Import(name="enableUpdateCreate")
    private @Nullable Output<Boolean> enableUpdateCreate;

    /**
     * @return Whether this FHIR store has the [updateCreate capability](https://www.hl7.org/fhir/capabilitystatement-definitions.html#CapabilityStatement.rest.resource.updateCreate). This determines if the client can use an Update operation to create a new resource with a client-specified ID. If false, all IDs are server-assigned through the Create operation and attempts to update a non-existent resource return errors. It is strongly advised not to include or encode any sensitive data such as patient identifiers in client-specified resource IDs. Those IDs are part of the FHIR resource path recorded in Cloud audit logs and Pub/Sub notifications. Those IDs can also be contained in reference fields within other resources.
     * 
     */
    public Optional<Output<Boolean>> enableUpdateCreate() {
        return Optional.ofNullable(this.enableUpdateCreate);
    }

    /**
     * The ID of the FHIR store that is being created. The string must match the following regex: `[\p{L}\p{N}_\-\.]{1,256}`.
     * 
     */
    @Import(name="fhirStoreId")
    private @Nullable Output<String> fhirStoreId;

    /**
     * @return The ID of the FHIR store that is being created. The string must match the following regex: `[\p{L}\p{N}_\-\.]{1,256}`.
     * 
     */
    public Optional<Output<String>> fhirStoreId() {
        return Optional.ofNullable(this.fhirStoreId);
    }

    /**
     * User-supplied key-value pairs used to organize FHIR stores. Label keys must be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128 bytes, and must conform to the following PCRE regular expression: \p{Ll}\p{Lo}{0,62} Label values are optional, must be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128 bytes, and must conform to the following PCRE regular expression: [\p{Ll}\p{Lo}\p{N}_-]{0,63} No more than 64 labels can be associated with a given store.
     * 
     */
    @Import(name="labels")
    private @Nullable Output<Map<String,String>> labels;

    /**
     * @return User-supplied key-value pairs used to organize FHIR stores. Label keys must be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128 bytes, and must conform to the following PCRE regular expression: \p{Ll}\p{Lo}{0,62} Label values are optional, must be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128 bytes, and must conform to the following PCRE regular expression: [\p{Ll}\p{Lo}\p{N}_-]{0,63} No more than 64 labels can be associated with a given store.
     * 
     */
    public Optional<Output<Map<String,String>>> labels() {
        return Optional.ofNullable(this.labels);
    }

    @Import(name="location")
    private @Nullable Output<String> location;

    public Optional<Output<String>> location() {
        return Optional.ofNullable(this.location);
    }

    /**
     * If non-empty, publish all resource modifications of this FHIR store to this destination. The Pub/Sub message attributes contain a map with a string describing the action that has triggered the notification. For example, &#34;action&#34;:&#34;CreateResource&#34;.
     * 
     */
    @Import(name="notificationConfig")
    private @Nullable Output<NotificationConfigArgs> notificationConfig;

    /**
     * @return If non-empty, publish all resource modifications of this FHIR store to this destination. The Pub/Sub message attributes contain a map with a string describing the action that has triggered the notification. For example, &#34;action&#34;:&#34;CreateResource&#34;.
     * 
     */
    public Optional<Output<NotificationConfigArgs>> notificationConfig() {
        return Optional.ofNullable(this.notificationConfig);
    }

    @Import(name="project")
    private @Nullable Output<String> project;

    public Optional<Output<String>> project() {
        return Optional.ofNullable(this.project);
    }

    /**
     * A list of streaming configs that configure the destinations of streaming export for every resource mutation in this FHIR store. Each store is allowed to have up to 10 streaming configs. After a new config is added, the next resource mutation is streamed to the new location in addition to the existing ones. When a location is removed from the list, the server stops streaming to that location. Before adding a new config, you must add the required [`bigquery.dataEditor`](https://cloud.google.com/bigquery/docs/access-control#bigquery.dataEditor) role to your project&#39;s **Cloud Healthcare Service Agent** [service account](https://cloud.google.com/iam/docs/service-accounts). Some lag (typically on the order of dozens of seconds) is expected before the results show up in the streaming destination.
     * 
     */
    @Import(name="streamConfigs")
    private @Nullable Output<List<StreamConfigArgs>> streamConfigs;

    /**
     * @return A list of streaming configs that configure the destinations of streaming export for every resource mutation in this FHIR store. Each store is allowed to have up to 10 streaming configs. After a new config is added, the next resource mutation is streamed to the new location in addition to the existing ones. When a location is removed from the list, the server stops streaming to that location. Before adding a new config, you must add the required [`bigquery.dataEditor`](https://cloud.google.com/bigquery/docs/access-control#bigquery.dataEditor) role to your project&#39;s **Cloud Healthcare Service Agent** [service account](https://cloud.google.com/iam/docs/service-accounts). Some lag (typically on the order of dozens of seconds) is expected before the results show up in the streaming destination.
     * 
     */
    public Optional<Output<List<StreamConfigArgs>>> streamConfigs() {
        return Optional.ofNullable(this.streamConfigs);
    }

    /**
     * Configuration for how to validate incoming FHIR resources against configured profiles.
     * 
     */
    @Import(name="validationConfig")
    private @Nullable Output<ValidationConfigArgs> validationConfig;

    /**
     * @return Configuration for how to validate incoming FHIR resources against configured profiles.
     * 
     */
    public Optional<Output<ValidationConfigArgs>> validationConfig() {
        return Optional.ofNullable(this.validationConfig);
    }

    /**
     * Immutable. The FHIR specification version that this FHIR store supports natively. This field is immutable after store creation. Requests are rejected if they contain FHIR resources of a different version. Version is required for every FHIR store.
     * 
     */
    @Import(name="version")
    private @Nullable Output<FhirStoreVersion> version;

    /**
     * @return Immutable. The FHIR specification version that this FHIR store supports natively. This field is immutable after store creation. Requests are rejected if they contain FHIR resources of a different version. Version is required for every FHIR store.
     * 
     */
    public Optional<Output<FhirStoreVersion>> version() {
        return Optional.ofNullable(this.version);
    }

    private FhirStoreArgs() {}

    private FhirStoreArgs(FhirStoreArgs $) {
        this.complexDataTypeReferenceParsing = $.complexDataTypeReferenceParsing;
        this.datasetId = $.datasetId;
        this.defaultSearchHandlingStrict = $.defaultSearchHandlingStrict;
        this.disableReferentialIntegrity = $.disableReferentialIntegrity;
        this.disableResourceVersioning = $.disableResourceVersioning;
        this.enableUpdateCreate = $.enableUpdateCreate;
        this.fhirStoreId = $.fhirStoreId;
        this.labels = $.labels;
        this.location = $.location;
        this.notificationConfig = $.notificationConfig;
        this.project = $.project;
        this.streamConfigs = $.streamConfigs;
        this.validationConfig = $.validationConfig;
        this.version = $.version;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(FhirStoreArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private FhirStoreArgs $;

        public Builder() {
            $ = new FhirStoreArgs();
        }

        public Builder(FhirStoreArgs defaults) {
            $ = new FhirStoreArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param complexDataTypeReferenceParsing Enable parsing of references within complex FHIR data types such as Extensions. If this value is set to ENABLED, then features like referential integrity and Bundle reference rewriting apply to all references. If this flag has not been specified the behavior of the FHIR store will not change, references in complex data types will not be parsed. New stores will have this value set to ENABLED after a notification period. Warning: turning on this flag causes processing existing resources to fail if they contain references to non-existent resources.
         * 
         * @return builder
         * 
         */
        public Builder complexDataTypeReferenceParsing(@Nullable Output<FhirStoreComplexDataTypeReferenceParsing> complexDataTypeReferenceParsing) {
            $.complexDataTypeReferenceParsing = complexDataTypeReferenceParsing;
            return this;
        }

        /**
         * @param complexDataTypeReferenceParsing Enable parsing of references within complex FHIR data types such as Extensions. If this value is set to ENABLED, then features like referential integrity and Bundle reference rewriting apply to all references. If this flag has not been specified the behavior of the FHIR store will not change, references in complex data types will not be parsed. New stores will have this value set to ENABLED after a notification period. Warning: turning on this flag causes processing existing resources to fail if they contain references to non-existent resources.
         * 
         * @return builder
         * 
         */
        public Builder complexDataTypeReferenceParsing(FhirStoreComplexDataTypeReferenceParsing complexDataTypeReferenceParsing) {
            return complexDataTypeReferenceParsing(Output.of(complexDataTypeReferenceParsing));
        }

        public Builder datasetId(Output<String> datasetId) {
            $.datasetId = datasetId;
            return this;
        }

        public Builder datasetId(String datasetId) {
            return datasetId(Output.of(datasetId));
        }

        /**
         * @param defaultSearchHandlingStrict If true, overrides the default search behavior for this FHIR store to `handling=strict` which returns an error for unrecognized search parameters. If false, uses the FHIR specification default `handling=lenient` which ignores unrecognized search parameters. The handling can always be changed from the default on an individual API call by setting the HTTP header `Prefer: handling=strict` or `Prefer: handling=lenient`.
         * 
         * @return builder
         * 
         */
        public Builder defaultSearchHandlingStrict(@Nullable Output<Boolean> defaultSearchHandlingStrict) {
            $.defaultSearchHandlingStrict = defaultSearchHandlingStrict;
            return this;
        }

        /**
         * @param defaultSearchHandlingStrict If true, overrides the default search behavior for this FHIR store to `handling=strict` which returns an error for unrecognized search parameters. If false, uses the FHIR specification default `handling=lenient` which ignores unrecognized search parameters. The handling can always be changed from the default on an individual API call by setting the HTTP header `Prefer: handling=strict` or `Prefer: handling=lenient`.
         * 
         * @return builder
         * 
         */
        public Builder defaultSearchHandlingStrict(Boolean defaultSearchHandlingStrict) {
            return defaultSearchHandlingStrict(Output.of(defaultSearchHandlingStrict));
        }

        /**
         * @param disableReferentialIntegrity Immutable. Whether to disable referential integrity in this FHIR store. This field is immutable after FHIR store creation. The default value is false, meaning that the API enforces referential integrity and fails the requests that result in inconsistent state in the FHIR store. When this field is set to true, the API skips referential integrity checks. Consequently, operations that rely on references, such as GetPatientEverything, do not return all the results if broken references exist.
         * 
         * @return builder
         * 
         */
        public Builder disableReferentialIntegrity(@Nullable Output<Boolean> disableReferentialIntegrity) {
            $.disableReferentialIntegrity = disableReferentialIntegrity;
            return this;
        }

        /**
         * @param disableReferentialIntegrity Immutable. Whether to disable referential integrity in this FHIR store. This field is immutable after FHIR store creation. The default value is false, meaning that the API enforces referential integrity and fails the requests that result in inconsistent state in the FHIR store. When this field is set to true, the API skips referential integrity checks. Consequently, operations that rely on references, such as GetPatientEverything, do not return all the results if broken references exist.
         * 
         * @return builder
         * 
         */
        public Builder disableReferentialIntegrity(Boolean disableReferentialIntegrity) {
            return disableReferentialIntegrity(Output.of(disableReferentialIntegrity));
        }

        /**
         * @param disableResourceVersioning Immutable. Whether to disable resource versioning for this FHIR store. This field can not be changed after the creation of FHIR store. If set to false, which is the default behavior, all write operations cause historical versions to be recorded automatically. The historical versions can be fetched through the history APIs, but cannot be updated. If set to true, no historical versions are kept. The server sends errors for attempts to read the historical versions.
         * 
         * @return builder
         * 
         */
        public Builder disableResourceVersioning(@Nullable Output<Boolean> disableResourceVersioning) {
            $.disableResourceVersioning = disableResourceVersioning;
            return this;
        }

        /**
         * @param disableResourceVersioning Immutable. Whether to disable resource versioning for this FHIR store. This field can not be changed after the creation of FHIR store. If set to false, which is the default behavior, all write operations cause historical versions to be recorded automatically. The historical versions can be fetched through the history APIs, but cannot be updated. If set to true, no historical versions are kept. The server sends errors for attempts to read the historical versions.
         * 
         * @return builder
         * 
         */
        public Builder disableResourceVersioning(Boolean disableResourceVersioning) {
            return disableResourceVersioning(Output.of(disableResourceVersioning));
        }

        /**
         * @param enableUpdateCreate Whether this FHIR store has the [updateCreate capability](https://www.hl7.org/fhir/capabilitystatement-definitions.html#CapabilityStatement.rest.resource.updateCreate). This determines if the client can use an Update operation to create a new resource with a client-specified ID. If false, all IDs are server-assigned through the Create operation and attempts to update a non-existent resource return errors. It is strongly advised not to include or encode any sensitive data such as patient identifiers in client-specified resource IDs. Those IDs are part of the FHIR resource path recorded in Cloud audit logs and Pub/Sub notifications. Those IDs can also be contained in reference fields within other resources.
         * 
         * @return builder
         * 
         */
        public Builder enableUpdateCreate(@Nullable Output<Boolean> enableUpdateCreate) {
            $.enableUpdateCreate = enableUpdateCreate;
            return this;
        }

        /**
         * @param enableUpdateCreate Whether this FHIR store has the [updateCreate capability](https://www.hl7.org/fhir/capabilitystatement-definitions.html#CapabilityStatement.rest.resource.updateCreate). This determines if the client can use an Update operation to create a new resource with a client-specified ID. If false, all IDs are server-assigned through the Create operation and attempts to update a non-existent resource return errors. It is strongly advised not to include or encode any sensitive data such as patient identifiers in client-specified resource IDs. Those IDs are part of the FHIR resource path recorded in Cloud audit logs and Pub/Sub notifications. Those IDs can also be contained in reference fields within other resources.
         * 
         * @return builder
         * 
         */
        public Builder enableUpdateCreate(Boolean enableUpdateCreate) {
            return enableUpdateCreate(Output.of(enableUpdateCreate));
        }

        /**
         * @param fhirStoreId The ID of the FHIR store that is being created. The string must match the following regex: `[\p{L}\p{N}_\-\.]{1,256}`.
         * 
         * @return builder
         * 
         */
        public Builder fhirStoreId(@Nullable Output<String> fhirStoreId) {
            $.fhirStoreId = fhirStoreId;
            return this;
        }

        /**
         * @param fhirStoreId The ID of the FHIR store that is being created. The string must match the following regex: `[\p{L}\p{N}_\-\.]{1,256}`.
         * 
         * @return builder
         * 
         */
        public Builder fhirStoreId(String fhirStoreId) {
            return fhirStoreId(Output.of(fhirStoreId));
        }

        /**
         * @param labels User-supplied key-value pairs used to organize FHIR stores. Label keys must be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128 bytes, and must conform to the following PCRE regular expression: \p{Ll}\p{Lo}{0,62} Label values are optional, must be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128 bytes, and must conform to the following PCRE regular expression: [\p{Ll}\p{Lo}\p{N}_-]{0,63} No more than 64 labels can be associated with a given store.
         * 
         * @return builder
         * 
         */
        public Builder labels(@Nullable Output<Map<String,String>> labels) {
            $.labels = labels;
            return this;
        }

        /**
         * @param labels User-supplied key-value pairs used to organize FHIR stores. Label keys must be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128 bytes, and must conform to the following PCRE regular expression: \p{Ll}\p{Lo}{0,62} Label values are optional, must be between 1 and 63 characters long, have a UTF-8 encoding of maximum 128 bytes, and must conform to the following PCRE regular expression: [\p{Ll}\p{Lo}\p{N}_-]{0,63} No more than 64 labels can be associated with a given store.
         * 
         * @return builder
         * 
         */
        public Builder labels(Map<String,String> labels) {
            return labels(Output.of(labels));
        }

        public Builder location(@Nullable Output<String> location) {
            $.location = location;
            return this;
        }

        public Builder location(String location) {
            return location(Output.of(location));
        }

        /**
         * @param notificationConfig If non-empty, publish all resource modifications of this FHIR store to this destination. The Pub/Sub message attributes contain a map with a string describing the action that has triggered the notification. For example, &#34;action&#34;:&#34;CreateResource&#34;.
         * 
         * @return builder
         * 
         */
        public Builder notificationConfig(@Nullable Output<NotificationConfigArgs> notificationConfig) {
            $.notificationConfig = notificationConfig;
            return this;
        }

        /**
         * @param notificationConfig If non-empty, publish all resource modifications of this FHIR store to this destination. The Pub/Sub message attributes contain a map with a string describing the action that has triggered the notification. For example, &#34;action&#34;:&#34;CreateResource&#34;.
         * 
         * @return builder
         * 
         */
        public Builder notificationConfig(NotificationConfigArgs notificationConfig) {
            return notificationConfig(Output.of(notificationConfig));
        }

        public Builder project(@Nullable Output<String> project) {
            $.project = project;
            return this;
        }

        public Builder project(String project) {
            return project(Output.of(project));
        }

        /**
         * @param streamConfigs A list of streaming configs that configure the destinations of streaming export for every resource mutation in this FHIR store. Each store is allowed to have up to 10 streaming configs. After a new config is added, the next resource mutation is streamed to the new location in addition to the existing ones. When a location is removed from the list, the server stops streaming to that location. Before adding a new config, you must add the required [`bigquery.dataEditor`](https://cloud.google.com/bigquery/docs/access-control#bigquery.dataEditor) role to your project&#39;s **Cloud Healthcare Service Agent** [service account](https://cloud.google.com/iam/docs/service-accounts). Some lag (typically on the order of dozens of seconds) is expected before the results show up in the streaming destination.
         * 
         * @return builder
         * 
         */
        public Builder streamConfigs(@Nullable Output<List<StreamConfigArgs>> streamConfigs) {
            $.streamConfigs = streamConfigs;
            return this;
        }

        /**
         * @param streamConfigs A list of streaming configs that configure the destinations of streaming export for every resource mutation in this FHIR store. Each store is allowed to have up to 10 streaming configs. After a new config is added, the next resource mutation is streamed to the new location in addition to the existing ones. When a location is removed from the list, the server stops streaming to that location. Before adding a new config, you must add the required [`bigquery.dataEditor`](https://cloud.google.com/bigquery/docs/access-control#bigquery.dataEditor) role to your project&#39;s **Cloud Healthcare Service Agent** [service account](https://cloud.google.com/iam/docs/service-accounts). Some lag (typically on the order of dozens of seconds) is expected before the results show up in the streaming destination.
         * 
         * @return builder
         * 
         */
        public Builder streamConfigs(List<StreamConfigArgs> streamConfigs) {
            return streamConfigs(Output.of(streamConfigs));
        }

        /**
         * @param streamConfigs A list of streaming configs that configure the destinations of streaming export for every resource mutation in this FHIR store. Each store is allowed to have up to 10 streaming configs. After a new config is added, the next resource mutation is streamed to the new location in addition to the existing ones. When a location is removed from the list, the server stops streaming to that location. Before adding a new config, you must add the required [`bigquery.dataEditor`](https://cloud.google.com/bigquery/docs/access-control#bigquery.dataEditor) role to your project&#39;s **Cloud Healthcare Service Agent** [service account](https://cloud.google.com/iam/docs/service-accounts). Some lag (typically on the order of dozens of seconds) is expected before the results show up in the streaming destination.
         * 
         * @return builder
         * 
         */
        public Builder streamConfigs(StreamConfigArgs... streamConfigs) {
            return streamConfigs(List.of(streamConfigs));
        }

        /**
         * @param validationConfig Configuration for how to validate incoming FHIR resources against configured profiles.
         * 
         * @return builder
         * 
         */
        public Builder validationConfig(@Nullable Output<ValidationConfigArgs> validationConfig) {
            $.validationConfig = validationConfig;
            return this;
        }

        /**
         * @param validationConfig Configuration for how to validate incoming FHIR resources against configured profiles.
         * 
         * @return builder
         * 
         */
        public Builder validationConfig(ValidationConfigArgs validationConfig) {
            return validationConfig(Output.of(validationConfig));
        }

        /**
         * @param version Immutable. The FHIR specification version that this FHIR store supports natively. This field is immutable after store creation. Requests are rejected if they contain FHIR resources of a different version. Version is required for every FHIR store.
         * 
         * @return builder
         * 
         */
        public Builder version(@Nullable Output<FhirStoreVersion> version) {
            $.version = version;
            return this;
        }

        /**
         * @param version Immutable. The FHIR specification version that this FHIR store supports natively. This field is immutable after store creation. Requests are rejected if they contain FHIR resources of a different version. Version is required for every FHIR store.
         * 
         * @return builder
         * 
         */
        public Builder version(FhirStoreVersion version) {
            return version(Output.of(version));
        }

        public FhirStoreArgs build() {
            $.datasetId = Objects.requireNonNull($.datasetId, "expected parameter 'datasetId' to be non-null");
            return $;
        }
    }

}
