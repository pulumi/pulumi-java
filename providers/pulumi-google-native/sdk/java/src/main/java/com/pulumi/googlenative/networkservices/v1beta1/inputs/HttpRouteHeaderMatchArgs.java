// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.googlenative.networkservices.v1beta1.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.googlenative.networkservices.v1beta1.inputs.HttpRouteHeaderMatchIntegerRangeArgs;
import java.lang.Boolean;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


/**
 * Specifies how to select a route rule based on HTTP request headers.
 * 
 */
public final class HttpRouteHeaderMatchArgs extends com.pulumi.resources.ResourceArgs {

    public static final HttpRouteHeaderMatchArgs Empty = new HttpRouteHeaderMatchArgs();

    /**
     * The value of the header should match exactly the content of exact_match.
     * 
     */
    @Import(name="exactMatch")
    private @Nullable Output<String> exactMatch;

    /**
     * @return The value of the header should match exactly the content of exact_match.
     * 
     */
    public Optional<Output<String>> exactMatch() {
        return Optional.ofNullable(this.exactMatch);
    }

    /**
     * The name of the HTTP header to match against.
     * 
     */
    @Import(name="header")
    private @Nullable Output<String> header;

    /**
     * @return The name of the HTTP header to match against.
     * 
     */
    public Optional<Output<String>> header() {
        return Optional.ofNullable(this.header);
    }

    /**
     * If specified, the match result will be inverted before checking. Default value is set to false.
     * 
     */
    @Import(name="invertMatch")
    private @Nullable Output<Boolean> invertMatch;

    /**
     * @return If specified, the match result will be inverted before checking. Default value is set to false.
     * 
     */
    public Optional<Output<Boolean>> invertMatch() {
        return Optional.ofNullable(this.invertMatch);
    }

    /**
     * The value of the header must start with the contents of prefix_match.
     * 
     */
    @Import(name="prefixMatch")
    private @Nullable Output<String> prefixMatch;

    /**
     * @return The value of the header must start with the contents of prefix_match.
     * 
     */
    public Optional<Output<String>> prefixMatch() {
        return Optional.ofNullable(this.prefixMatch);
    }

    /**
     * A header with header_name must exist. The match takes place whether or not the header has a value.
     * 
     */
    @Import(name="presentMatch")
    private @Nullable Output<Boolean> presentMatch;

    /**
     * @return A header with header_name must exist. The match takes place whether or not the header has a value.
     * 
     */
    public Optional<Output<Boolean>> presentMatch() {
        return Optional.ofNullable(this.presentMatch);
    }

    /**
     * If specified, the rule will match if the request header value is within the range.
     * 
     */
    @Import(name="rangeMatch")
    private @Nullable Output<HttpRouteHeaderMatchIntegerRangeArgs> rangeMatch;

    /**
     * @return If specified, the rule will match if the request header value is within the range.
     * 
     */
    public Optional<Output<HttpRouteHeaderMatchIntegerRangeArgs>> rangeMatch() {
        return Optional.ofNullable(this.rangeMatch);
    }

    /**
     * The value of the header must match the regular expression specified in regex_match. For regular expression grammar, please see: https://github.com/google/re2/wiki/Syntax
     * 
     */
    @Import(name="regexMatch")
    private @Nullable Output<String> regexMatch;

    /**
     * @return The value of the header must match the regular expression specified in regex_match. For regular expression grammar, please see: https://github.com/google/re2/wiki/Syntax
     * 
     */
    public Optional<Output<String>> regexMatch() {
        return Optional.ofNullable(this.regexMatch);
    }

    /**
     * The value of the header must end with the contents of suffix_match.
     * 
     */
    @Import(name="suffixMatch")
    private @Nullable Output<String> suffixMatch;

    /**
     * @return The value of the header must end with the contents of suffix_match.
     * 
     */
    public Optional<Output<String>> suffixMatch() {
        return Optional.ofNullable(this.suffixMatch);
    }

    private HttpRouteHeaderMatchArgs() {}

    private HttpRouteHeaderMatchArgs(HttpRouteHeaderMatchArgs $) {
        this.exactMatch = $.exactMatch;
        this.header = $.header;
        this.invertMatch = $.invertMatch;
        this.prefixMatch = $.prefixMatch;
        this.presentMatch = $.presentMatch;
        this.rangeMatch = $.rangeMatch;
        this.regexMatch = $.regexMatch;
        this.suffixMatch = $.suffixMatch;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(HttpRouteHeaderMatchArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private HttpRouteHeaderMatchArgs $;

        public Builder() {
            $ = new HttpRouteHeaderMatchArgs();
        }

        public Builder(HttpRouteHeaderMatchArgs defaults) {
            $ = new HttpRouteHeaderMatchArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param exactMatch The value of the header should match exactly the content of exact_match.
         * 
         * @return builder
         * 
         */
        public Builder exactMatch(@Nullable Output<String> exactMatch) {
            $.exactMatch = exactMatch;
            return this;
        }

        /**
         * @param exactMatch The value of the header should match exactly the content of exact_match.
         * 
         * @return builder
         * 
         */
        public Builder exactMatch(String exactMatch) {
            return exactMatch(Output.of(exactMatch));
        }

        /**
         * @param header The name of the HTTP header to match against.
         * 
         * @return builder
         * 
         */
        public Builder header(@Nullable Output<String> header) {
            $.header = header;
            return this;
        }

        /**
         * @param header The name of the HTTP header to match against.
         * 
         * @return builder
         * 
         */
        public Builder header(String header) {
            return header(Output.of(header));
        }

        /**
         * @param invertMatch If specified, the match result will be inverted before checking. Default value is set to false.
         * 
         * @return builder
         * 
         */
        public Builder invertMatch(@Nullable Output<Boolean> invertMatch) {
            $.invertMatch = invertMatch;
            return this;
        }

        /**
         * @param invertMatch If specified, the match result will be inverted before checking. Default value is set to false.
         * 
         * @return builder
         * 
         */
        public Builder invertMatch(Boolean invertMatch) {
            return invertMatch(Output.of(invertMatch));
        }

        /**
         * @param prefixMatch The value of the header must start with the contents of prefix_match.
         * 
         * @return builder
         * 
         */
        public Builder prefixMatch(@Nullable Output<String> prefixMatch) {
            $.prefixMatch = prefixMatch;
            return this;
        }

        /**
         * @param prefixMatch The value of the header must start with the contents of prefix_match.
         * 
         * @return builder
         * 
         */
        public Builder prefixMatch(String prefixMatch) {
            return prefixMatch(Output.of(prefixMatch));
        }

        /**
         * @param presentMatch A header with header_name must exist. The match takes place whether or not the header has a value.
         * 
         * @return builder
         * 
         */
        public Builder presentMatch(@Nullable Output<Boolean> presentMatch) {
            $.presentMatch = presentMatch;
            return this;
        }

        /**
         * @param presentMatch A header with header_name must exist. The match takes place whether or not the header has a value.
         * 
         * @return builder
         * 
         */
        public Builder presentMatch(Boolean presentMatch) {
            return presentMatch(Output.of(presentMatch));
        }

        /**
         * @param rangeMatch If specified, the rule will match if the request header value is within the range.
         * 
         * @return builder
         * 
         */
        public Builder rangeMatch(@Nullable Output<HttpRouteHeaderMatchIntegerRangeArgs> rangeMatch) {
            $.rangeMatch = rangeMatch;
            return this;
        }

        /**
         * @param rangeMatch If specified, the rule will match if the request header value is within the range.
         * 
         * @return builder
         * 
         */
        public Builder rangeMatch(HttpRouteHeaderMatchIntegerRangeArgs rangeMatch) {
            return rangeMatch(Output.of(rangeMatch));
        }

        /**
         * @param regexMatch The value of the header must match the regular expression specified in regex_match. For regular expression grammar, please see: https://github.com/google/re2/wiki/Syntax
         * 
         * @return builder
         * 
         */
        public Builder regexMatch(@Nullable Output<String> regexMatch) {
            $.regexMatch = regexMatch;
            return this;
        }

        /**
         * @param regexMatch The value of the header must match the regular expression specified in regex_match. For regular expression grammar, please see: https://github.com/google/re2/wiki/Syntax
         * 
         * @return builder
         * 
         */
        public Builder regexMatch(String regexMatch) {
            return regexMatch(Output.of(regexMatch));
        }

        /**
         * @param suffixMatch The value of the header must end with the contents of suffix_match.
         * 
         * @return builder
         * 
         */
        public Builder suffixMatch(@Nullable Output<String> suffixMatch) {
            $.suffixMatch = suffixMatch;
            return this;
        }

        /**
         * @param suffixMatch The value of the header must end with the contents of suffix_match.
         * 
         * @return builder
         * 
         */
        public Builder suffixMatch(String suffixMatch) {
            return suffixMatch(Output.of(suffixMatch));
        }

        public HttpRouteHeaderMatchArgs build() {
            return $;
        }
    }

}
