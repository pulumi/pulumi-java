// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.googlenative.compute_alpha.outputs;

import com.pulumi.core.annotations.CustomType;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;

@CustomType
public final class PrincipalResponse {
    /**
     * @return An expression to specify custom condition.
     * 
     */
    private final String condition;
    /**
     * @return The groups the principal belongs to. Exact match, prefix match, and suffix match are supported.
     * 
     */
    private final List<String> groups;
    /**
     * @return IPv4 or IPv6 address or range (In CIDR format)
     * 
     */
    private final List<String> ips;
    /**
     * @return The namespaces. Exact match, prefix match, and suffix match are supported.
     * 
     */
    private final List<String> namespaces;
    /**
     * @return Negate of groups. Specifies exclusions.
     * 
     */
    private final List<String> notGroups;
    /**
     * @return Negate of IPs. Specifies exclusions.
     * 
     */
    private final List<String> notIps;
    /**
     * @return Negate of namespaces. Specifies exclusions.
     * 
     */
    private final List<String> notNamespaces;
    /**
     * @return Negate of users. Specifies exclusions.
     * 
     */
    private final List<String> notUsers;
    /**
     * @return A map of Istio attribute to expected values. Exact match, prefix match, and suffix match are supported for values. For example, `request.headers[version]: &#34;v1&#34;`. The properties are ANDed together.
     * 
     */
    private final Map<String,String> properties;
    /**
     * @return The user names/IDs or service accounts. Exact match, prefix match, and suffix match are supported.
     * 
     */
    private final List<String> users;

    @CustomType.Constructor
    private PrincipalResponse(
        @CustomType.Parameter("condition") String condition,
        @CustomType.Parameter("groups") List<String> groups,
        @CustomType.Parameter("ips") List<String> ips,
        @CustomType.Parameter("namespaces") List<String> namespaces,
        @CustomType.Parameter("notGroups") List<String> notGroups,
        @CustomType.Parameter("notIps") List<String> notIps,
        @CustomType.Parameter("notNamespaces") List<String> notNamespaces,
        @CustomType.Parameter("notUsers") List<String> notUsers,
        @CustomType.Parameter("properties") Map<String,String> properties,
        @CustomType.Parameter("users") List<String> users) {
        this.condition = condition;
        this.groups = groups;
        this.ips = ips;
        this.namespaces = namespaces;
        this.notGroups = notGroups;
        this.notIps = notIps;
        this.notNamespaces = notNamespaces;
        this.notUsers = notUsers;
        this.properties = properties;
        this.users = users;
    }

    /**
     * @return An expression to specify custom condition.
     * 
     */
    public String condition() {
        return this.condition;
    }
    /**
     * @return The groups the principal belongs to. Exact match, prefix match, and suffix match are supported.
     * 
     */
    public List<String> groups() {
        return this.groups;
    }
    /**
     * @return IPv4 or IPv6 address or range (In CIDR format)
     * 
     */
    public List<String> ips() {
        return this.ips;
    }
    /**
     * @return The namespaces. Exact match, prefix match, and suffix match are supported.
     * 
     */
    public List<String> namespaces() {
        return this.namespaces;
    }
    /**
     * @return Negate of groups. Specifies exclusions.
     * 
     */
    public List<String> notGroups() {
        return this.notGroups;
    }
    /**
     * @return Negate of IPs. Specifies exclusions.
     * 
     */
    public List<String> notIps() {
        return this.notIps;
    }
    /**
     * @return Negate of namespaces. Specifies exclusions.
     * 
     */
    public List<String> notNamespaces() {
        return this.notNamespaces;
    }
    /**
     * @return Negate of users. Specifies exclusions.
     * 
     */
    public List<String> notUsers() {
        return this.notUsers;
    }
    /**
     * @return A map of Istio attribute to expected values. Exact match, prefix match, and suffix match are supported for values. For example, `request.headers[version]: &#34;v1&#34;`. The properties are ANDed together.
     * 
     */
    public Map<String,String> properties() {
        return this.properties;
    }
    /**
     * @return The user names/IDs or service accounts. Exact match, prefix match, and suffix match are supported.
     * 
     */
    public List<String> users() {
        return this.users;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(PrincipalResponse defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private String condition;
        private List<String> groups;
        private List<String> ips;
        private List<String> namespaces;
        private List<String> notGroups;
        private List<String> notIps;
        private List<String> notNamespaces;
        private List<String> notUsers;
        private Map<String,String> properties;
        private List<String> users;

        public Builder() {
    	      // Empty
        }

        public Builder(PrincipalResponse defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.condition = defaults.condition;
    	      this.groups = defaults.groups;
    	      this.ips = defaults.ips;
    	      this.namespaces = defaults.namespaces;
    	      this.notGroups = defaults.notGroups;
    	      this.notIps = defaults.notIps;
    	      this.notNamespaces = defaults.notNamespaces;
    	      this.notUsers = defaults.notUsers;
    	      this.properties = defaults.properties;
    	      this.users = defaults.users;
        }

        public Builder condition(String condition) {
            this.condition = Objects.requireNonNull(condition);
            return this;
        }
        public Builder groups(List<String> groups) {
            this.groups = Objects.requireNonNull(groups);
            return this;
        }
        public Builder groups(String... groups) {
            return groups(List.of(groups));
        }
        public Builder ips(List<String> ips) {
            this.ips = Objects.requireNonNull(ips);
            return this;
        }
        public Builder ips(String... ips) {
            return ips(List.of(ips));
        }
        public Builder namespaces(List<String> namespaces) {
            this.namespaces = Objects.requireNonNull(namespaces);
            return this;
        }
        public Builder namespaces(String... namespaces) {
            return namespaces(List.of(namespaces));
        }
        public Builder notGroups(List<String> notGroups) {
            this.notGroups = Objects.requireNonNull(notGroups);
            return this;
        }
        public Builder notGroups(String... notGroups) {
            return notGroups(List.of(notGroups));
        }
        public Builder notIps(List<String> notIps) {
            this.notIps = Objects.requireNonNull(notIps);
            return this;
        }
        public Builder notIps(String... notIps) {
            return notIps(List.of(notIps));
        }
        public Builder notNamespaces(List<String> notNamespaces) {
            this.notNamespaces = Objects.requireNonNull(notNamespaces);
            return this;
        }
        public Builder notNamespaces(String... notNamespaces) {
            return notNamespaces(List.of(notNamespaces));
        }
        public Builder notUsers(List<String> notUsers) {
            this.notUsers = Objects.requireNonNull(notUsers);
            return this;
        }
        public Builder notUsers(String... notUsers) {
            return notUsers(List.of(notUsers));
        }
        public Builder properties(Map<String,String> properties) {
            this.properties = Objects.requireNonNull(properties);
            return this;
        }
        public Builder users(List<String> users) {
            this.users = Objects.requireNonNull(users);
            return this;
        }
        public Builder users(String... users) {
            return users(List.of(users));
        }        public PrincipalResponse build() {
            return new PrincipalResponse(condition, groups, ips, namespaces, notGroups, notIps, notNamespaces, notUsers, properties, users);
        }
    }
}
