// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package io.pulumi.googlenative.storagetransfer_v1.inputs;

import io.pulumi.core.Input;
import io.pulumi.core.annotations.InputImport;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import javax.annotation.Nullable;


/**
 * Conditions that determine which objects are transferred. Applies only to Cloud Data Sources such as S3, Azure, and Cloud Storage. The "last modification time" refers to the time of the last change to the object's content or metadata â€” specifically, this is the `updated` property of Cloud Storage objects, the `LastModified` field of S3 objects, and the `Last-Modified` header of Azure blobs. Transfers with a PosixFilesystem source or destination don't support `ObjectConditions`.
 * 
 */
public final class ObjectConditionsArgs extends io.pulumi.resources.ResourceArgs {

    public static final ObjectConditionsArgs Empty = new ObjectConditionsArgs();

    /**
     * If you specify `exclude_prefixes`, Storage Transfer Service uses the items in the `exclude_prefixes` array to determine which objects to exclude from a transfer. Objects must not start with one of the matching `exclude_prefixes` for inclusion in a transfer. The following are requirements of `exclude_prefixes`: * Each exclude-prefix can contain any sequence of Unicode characters, to a max length of 1024 bytes when UTF8-encoded, and must not contain Carriage Return or Line Feed characters. Wildcard matching and regular expression matching are not supported. * Each exclude-prefix must omit the leading slash. For example, to exclude the object `s3://my-aws-bucket/logs/y=2015/requests.gz`, specify the exclude-prefix as `logs/y=2015/requests.gz`. * None of the exclude-prefix values can be empty, if specified. * Each exclude-prefix must exclude a distinct portion of the object namespace. No exclude-prefix may be a prefix of another exclude-prefix. * If include_prefixes is specified, then each exclude-prefix must start with the value of a path explicitly included by `include_prefixes`. The max size of `exclude_prefixes` is 1000. For more information, see [Filtering objects from transfers](/storage-transfer/docs/filtering-objects-from-transfers).
     * 
     */
    @InputImport(name="excludePrefixes")
      private final @Nullable Input<List<String>> excludePrefixes;

    public Input<List<String>> getExcludePrefixes() {
        return this.excludePrefixes == null ? Input.empty() : this.excludePrefixes;
    }

    /**
     * If you specify `include_prefixes`, Storage Transfer Service uses the items in the `include_prefixes` array to determine which objects to include in a transfer. Objects must start with one of the matching `include_prefixes` for inclusion in the transfer. If exclude_prefixes is specified, objects must not start with any of the `exclude_prefixes` specified for inclusion in the transfer. The following are requirements of `include_prefixes`: * Each include-prefix can contain any sequence of Unicode characters, to a max length of 1024 bytes when UTF8-encoded, and must not contain Carriage Return or Line Feed characters. Wildcard matching and regular expression matching are not supported. * Each include-prefix must omit the leading slash. For example, to include the object `s3://my-aws-bucket/logs/y=2015/requests.gz`, specify the include-prefix as `logs/y=2015/requests.gz`. * None of the include-prefix values can be empty, if specified. * Each include-prefix must include a distinct portion of the object namespace. No include-prefix may be a prefix of another include-prefix. The max size of `include_prefixes` is 1000. For more information, see [Filtering objects from transfers](/storage-transfer/docs/filtering-objects-from-transfers).
     * 
     */
    @InputImport(name="includePrefixes")
      private final @Nullable Input<List<String>> includePrefixes;

    public Input<List<String>> getIncludePrefixes() {
        return this.includePrefixes == null ? Input.empty() : this.includePrefixes;
    }

    /**
     * If specified, only objects with a "last modification time" before this timestamp and objects that don't have a "last modification time" are transferred.
     * 
     */
    @InputImport(name="lastModifiedBefore")
      private final @Nullable Input<String> lastModifiedBefore;

    public Input<String> getLastModifiedBefore() {
        return this.lastModifiedBefore == null ? Input.empty() : this.lastModifiedBefore;
    }

    /**
     * If specified, only objects with a "last modification time" on or after this timestamp and objects that don't have a "last modification time" are transferred. The `last_modified_since` and `last_modified_before` fields can be used together for chunked data processing. For example, consider a script that processes each day's worth of data at a time. For that you'd set each of the fields as follows: * `last_modified_since` to the start of the day * `last_modified_before` to the end of the day
     * 
     */
    @InputImport(name="lastModifiedSince")
      private final @Nullable Input<String> lastModifiedSince;

    public Input<String> getLastModifiedSince() {
        return this.lastModifiedSince == null ? Input.empty() : this.lastModifiedSince;
    }

    /**
     * Ensures that objects are not transferred if a specific maximum time has elapsed since the "last modification time". When a TransferOperation begins, objects with a "last modification time" are transferred only if the elapsed time between the start_time of the `TransferOperation`and the "last modification time" of the object is less than the value of max_time_elapsed_since_last_modification`. Objects that do not have a "last modification time" are also transferred.
     * 
     */
    @InputImport(name="maxTimeElapsedSinceLastModification")
      private final @Nullable Input<String> maxTimeElapsedSinceLastModification;

    public Input<String> getMaxTimeElapsedSinceLastModification() {
        return this.maxTimeElapsedSinceLastModification == null ? Input.empty() : this.maxTimeElapsedSinceLastModification;
    }

    /**
     * Ensures that objects are not transferred until a specific minimum time has elapsed after the "last modification time". When a TransferOperation begins, objects with a "last modification time" are transferred only if the elapsed time between the start_time of the `TransferOperation` and the "last modification time" of the object is equal to or greater than the value of min_time_elapsed_since_last_modification`. Objects that do not have a "last modification time" are also transferred.
     * 
     */
    @InputImport(name="minTimeElapsedSinceLastModification")
      private final @Nullable Input<String> minTimeElapsedSinceLastModification;

    public Input<String> getMinTimeElapsedSinceLastModification() {
        return this.minTimeElapsedSinceLastModification == null ? Input.empty() : this.minTimeElapsedSinceLastModification;
    }

    public ObjectConditionsArgs(
        @Nullable Input<List<String>> excludePrefixes,
        @Nullable Input<List<String>> includePrefixes,
        @Nullable Input<String> lastModifiedBefore,
        @Nullable Input<String> lastModifiedSince,
        @Nullable Input<String> maxTimeElapsedSinceLastModification,
        @Nullable Input<String> minTimeElapsedSinceLastModification) {
        this.excludePrefixes = excludePrefixes;
        this.includePrefixes = includePrefixes;
        this.lastModifiedBefore = lastModifiedBefore;
        this.lastModifiedSince = lastModifiedSince;
        this.maxTimeElapsedSinceLastModification = maxTimeElapsedSinceLastModification;
        this.minTimeElapsedSinceLastModification = minTimeElapsedSinceLastModification;
    }

    private ObjectConditionsArgs() {
        this.excludePrefixes = Input.empty();
        this.includePrefixes = Input.empty();
        this.lastModifiedBefore = Input.empty();
        this.lastModifiedSince = Input.empty();
        this.maxTimeElapsedSinceLastModification = Input.empty();
        this.minTimeElapsedSinceLastModification = Input.empty();
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(ObjectConditionsArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private @Nullable Input<List<String>> excludePrefixes;
        private @Nullable Input<List<String>> includePrefixes;
        private @Nullable Input<String> lastModifiedBefore;
        private @Nullable Input<String> lastModifiedSince;
        private @Nullable Input<String> maxTimeElapsedSinceLastModification;
        private @Nullable Input<String> minTimeElapsedSinceLastModification;

        public Builder() {
    	      // Empty
        }

        public Builder(ObjectConditionsArgs defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.excludePrefixes = defaults.excludePrefixes;
    	      this.includePrefixes = defaults.includePrefixes;
    	      this.lastModifiedBefore = defaults.lastModifiedBefore;
    	      this.lastModifiedSince = defaults.lastModifiedSince;
    	      this.maxTimeElapsedSinceLastModification = defaults.maxTimeElapsedSinceLastModification;
    	      this.minTimeElapsedSinceLastModification = defaults.minTimeElapsedSinceLastModification;
        }

        public Builder setExcludePrefixes(@Nullable Input<List<String>> excludePrefixes) {
            this.excludePrefixes = excludePrefixes;
            return this;
        }

        public Builder setExcludePrefixes(@Nullable List<String> excludePrefixes) {
            this.excludePrefixes = Input.ofNullable(excludePrefixes);
            return this;
        }

        public Builder setIncludePrefixes(@Nullable Input<List<String>> includePrefixes) {
            this.includePrefixes = includePrefixes;
            return this;
        }

        public Builder setIncludePrefixes(@Nullable List<String> includePrefixes) {
            this.includePrefixes = Input.ofNullable(includePrefixes);
            return this;
        }

        public Builder setLastModifiedBefore(@Nullable Input<String> lastModifiedBefore) {
            this.lastModifiedBefore = lastModifiedBefore;
            return this;
        }

        public Builder setLastModifiedBefore(@Nullable String lastModifiedBefore) {
            this.lastModifiedBefore = Input.ofNullable(lastModifiedBefore);
            return this;
        }

        public Builder setLastModifiedSince(@Nullable Input<String> lastModifiedSince) {
            this.lastModifiedSince = lastModifiedSince;
            return this;
        }

        public Builder setLastModifiedSince(@Nullable String lastModifiedSince) {
            this.lastModifiedSince = Input.ofNullable(lastModifiedSince);
            return this;
        }

        public Builder setMaxTimeElapsedSinceLastModification(@Nullable Input<String> maxTimeElapsedSinceLastModification) {
            this.maxTimeElapsedSinceLastModification = maxTimeElapsedSinceLastModification;
            return this;
        }

        public Builder setMaxTimeElapsedSinceLastModification(@Nullable String maxTimeElapsedSinceLastModification) {
            this.maxTimeElapsedSinceLastModification = Input.ofNullable(maxTimeElapsedSinceLastModification);
            return this;
        }

        public Builder setMinTimeElapsedSinceLastModification(@Nullable Input<String> minTimeElapsedSinceLastModification) {
            this.minTimeElapsedSinceLastModification = minTimeElapsedSinceLastModification;
            return this;
        }

        public Builder setMinTimeElapsedSinceLastModification(@Nullable String minTimeElapsedSinceLastModification) {
            this.minTimeElapsedSinceLastModification = Input.ofNullable(minTimeElapsedSinceLastModification);
            return this;
        }
        public ObjectConditionsArgs build() {
            return new ObjectConditionsArgs(excludePrefixes, includePrefixes, lastModifiedBefore, lastModifiedSince, maxTimeElapsedSinceLastModification, minTimeElapsedSinceLastModification);
        }
    }
}
