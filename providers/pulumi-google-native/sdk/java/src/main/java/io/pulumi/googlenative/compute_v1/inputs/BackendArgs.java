// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package io.pulumi.googlenative.compute_v1.inputs;

import io.pulumi.core.Input;
import io.pulumi.core.annotations.InputImport;
import io.pulumi.googlenative.compute_v1.enums.BackendBalancingMode;
import java.lang.Boolean;
import java.lang.Double;
import java.lang.Integer;
import java.lang.String;
import java.util.Objects;
import javax.annotation.Nullable;


/**
 * Message containing information of one individual backend.
 * 
 */
public final class BackendArgs extends io.pulumi.resources.ResourceArgs {

    public static final BackendArgs Empty = new BackendArgs();

    /**
     * Specifies how to determine whether the backend of a load balancer can handle additional traffic or is fully loaded. For usage guidelines, see Connection balancing mode. Backends must use compatible balancing modes. For more information, see Supported balancing modes and target capacity settings and Restrictions and guidance for instance groups. Note: Currently, if you use the API to configure incompatible balancing modes, the configuration might be accepted even though it has no impact and is ignored. Specifically, Backend.maxUtilization is ignored when Backend.balancingMode is RATE. In the future, this incompatible combination will be rejected.
     * 
     */
    @InputImport(name="balancingMode")
    private final @Nullable Input<BackendBalancingMode> balancingMode;

    public Input<BackendBalancingMode> getBalancingMode() {
        return this.balancingMode == null ? Input.empty() : this.balancingMode;
    }

    /**
     * A multiplier applied to the backend's target capacity of its balancing mode. The default value is 1, which means the group serves up to 100% of its configured capacity (depending on balancingMode). A setting of 0 means the group is completely drained, offering 0% of its available capacity. The valid ranges are 0.0 and [0.1,1.0]. You cannot configure a setting larger than 0 and smaller than 0.1. You cannot configure a setting of 0 when there is only one backend attached to the backend service.
     * 
     */
    @InputImport(name="capacityScaler")
    private final @Nullable Input<Double> capacityScaler;

    public Input<Double> getCapacityScaler() {
        return this.capacityScaler == null ? Input.empty() : this.capacityScaler;
    }

    /**
     * An optional description of this resource. Provide this property when you create the resource.
     * 
     */
    @InputImport(name="description")
    private final @Nullable Input<String> description;

    public Input<String> getDescription() {
        return this.description == null ? Input.empty() : this.description;
    }

    /**
     * This field designates whether this is a failover backend. More than one failover backend can be configured for a given BackendService.
     * 
     */
    @InputImport(name="failover")
    private final @Nullable Input<Boolean> failover;

    public Input<Boolean> getFailover() {
        return this.failover == null ? Input.empty() : this.failover;
    }

    /**
     * The fully-qualified URL of an instance group or network endpoint group (NEG) resource. To determine what types of backends a load balancer supports, see the [Backend services overview](https://cloud.google.com/load-balancing/docs/backend-service#backends). You must use the *fully-qualified* URL (starting with https://www.googleapis.com/) to specify the instance group or NEG. Partial URLs are not supported.
     * 
     */
    @InputImport(name="group")
    private final @Nullable Input<String> group;

    public Input<String> getGroup() {
        return this.group == null ? Input.empty() : this.group;
    }

    /**
     * Defines a target maximum number of simultaneous connections. For usage guidelines, see Connection balancing mode and Utilization balancing mode. Not available if the backend's balancingMode is RATE.
     * 
     */
    @InputImport(name="maxConnections")
    private final @Nullable Input<Integer> maxConnections;

    public Input<Integer> getMaxConnections() {
        return this.maxConnections == null ? Input.empty() : this.maxConnections;
    }

    /**
     * Defines a target maximum number of simultaneous connections. For usage guidelines, see Connection balancing mode and Utilization balancing mode. Not available if the backend's balancingMode is RATE.
     * 
     */
    @InputImport(name="maxConnectionsPerEndpoint")
    private final @Nullable Input<Integer> maxConnectionsPerEndpoint;

    public Input<Integer> getMaxConnectionsPerEndpoint() {
        return this.maxConnectionsPerEndpoint == null ? Input.empty() : this.maxConnectionsPerEndpoint;
    }

    /**
     * Defines a target maximum number of simultaneous connections. For usage guidelines, see Connection balancing mode and Utilization balancing mode. Not available if the backend's balancingMode is RATE.
     * 
     */
    @InputImport(name="maxConnectionsPerInstance")
    private final @Nullable Input<Integer> maxConnectionsPerInstance;

    public Input<Integer> getMaxConnectionsPerInstance() {
        return this.maxConnectionsPerInstance == null ? Input.empty() : this.maxConnectionsPerInstance;
    }

    /**
     * Defines a maximum number of HTTP requests per second (RPS). For usage guidelines, see Rate balancing mode and Utilization balancing mode. Not available if the backend's balancingMode is CONNECTION.
     * 
     */
    @InputImport(name="maxRate")
    private final @Nullable Input<Integer> maxRate;

    public Input<Integer> getMaxRate() {
        return this.maxRate == null ? Input.empty() : this.maxRate;
    }

    /**
     * Defines a maximum target for requests per second (RPS). For usage guidelines, see Rate balancing mode and Utilization balancing mode. Not available if the backend's balancingMode is CONNECTION.
     * 
     */
    @InputImport(name="maxRatePerEndpoint")
    private final @Nullable Input<Double> maxRatePerEndpoint;

    public Input<Double> getMaxRatePerEndpoint() {
        return this.maxRatePerEndpoint == null ? Input.empty() : this.maxRatePerEndpoint;
    }

    /**
     * Defines a maximum target for requests per second (RPS). For usage guidelines, see Rate balancing mode and Utilization balancing mode. Not available if the backend's balancingMode is CONNECTION.
     * 
     */
    @InputImport(name="maxRatePerInstance")
    private final @Nullable Input<Double> maxRatePerInstance;

    public Input<Double> getMaxRatePerInstance() {
        return this.maxRatePerInstance == null ? Input.empty() : this.maxRatePerInstance;
    }

    /**
     * Optional parameter to define a target capacity for the UTILIZATIONbalancing mode. The valid range is [0.0, 1.0]. For usage guidelines, see Utilization balancing mode.
     * 
     */
    @InputImport(name="maxUtilization")
    private final @Nullable Input<Double> maxUtilization;

    public Input<Double> getMaxUtilization() {
        return this.maxUtilization == null ? Input.empty() : this.maxUtilization;
    }

    public BackendArgs(
        @Nullable Input<BackendBalancingMode> balancingMode,
        @Nullable Input<Double> capacityScaler,
        @Nullable Input<String> description,
        @Nullable Input<Boolean> failover,
        @Nullable Input<String> group,
        @Nullable Input<Integer> maxConnections,
        @Nullable Input<Integer> maxConnectionsPerEndpoint,
        @Nullable Input<Integer> maxConnectionsPerInstance,
        @Nullable Input<Integer> maxRate,
        @Nullable Input<Double> maxRatePerEndpoint,
        @Nullable Input<Double> maxRatePerInstance,
        @Nullable Input<Double> maxUtilization) {
        this.balancingMode = balancingMode;
        this.capacityScaler = capacityScaler;
        this.description = description;
        this.failover = failover;
        this.group = group;
        this.maxConnections = maxConnections;
        this.maxConnectionsPerEndpoint = maxConnectionsPerEndpoint;
        this.maxConnectionsPerInstance = maxConnectionsPerInstance;
        this.maxRate = maxRate;
        this.maxRatePerEndpoint = maxRatePerEndpoint;
        this.maxRatePerInstance = maxRatePerInstance;
        this.maxUtilization = maxUtilization;
    }

    private BackendArgs() {
        this.balancingMode = Input.empty();
        this.capacityScaler = Input.empty();
        this.description = Input.empty();
        this.failover = Input.empty();
        this.group = Input.empty();
        this.maxConnections = Input.empty();
        this.maxConnectionsPerEndpoint = Input.empty();
        this.maxConnectionsPerInstance = Input.empty();
        this.maxRate = Input.empty();
        this.maxRatePerEndpoint = Input.empty();
        this.maxRatePerInstance = Input.empty();
        this.maxUtilization = Input.empty();
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(BackendArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private @Nullable Input<BackendBalancingMode> balancingMode;
        private @Nullable Input<Double> capacityScaler;
        private @Nullable Input<String> description;
        private @Nullable Input<Boolean> failover;
        private @Nullable Input<String> group;
        private @Nullable Input<Integer> maxConnections;
        private @Nullable Input<Integer> maxConnectionsPerEndpoint;
        private @Nullable Input<Integer> maxConnectionsPerInstance;
        private @Nullable Input<Integer> maxRate;
        private @Nullable Input<Double> maxRatePerEndpoint;
        private @Nullable Input<Double> maxRatePerInstance;
        private @Nullable Input<Double> maxUtilization;

        public Builder() {
    	      // Empty
        }

        public Builder(BackendArgs defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.balancingMode = defaults.balancingMode;
    	      this.capacityScaler = defaults.capacityScaler;
    	      this.description = defaults.description;
    	      this.failover = defaults.failover;
    	      this.group = defaults.group;
    	      this.maxConnections = defaults.maxConnections;
    	      this.maxConnectionsPerEndpoint = defaults.maxConnectionsPerEndpoint;
    	      this.maxConnectionsPerInstance = defaults.maxConnectionsPerInstance;
    	      this.maxRate = defaults.maxRate;
    	      this.maxRatePerEndpoint = defaults.maxRatePerEndpoint;
    	      this.maxRatePerInstance = defaults.maxRatePerInstance;
    	      this.maxUtilization = defaults.maxUtilization;
        }

        public Builder setBalancingMode(@Nullable Input<BackendBalancingMode> balancingMode) {
            this.balancingMode = balancingMode;
            return this;
        }

        public Builder setBalancingMode(@Nullable BackendBalancingMode balancingMode) {
            this.balancingMode = Input.ofNullable(balancingMode);
            return this;
        }

        public Builder setCapacityScaler(@Nullable Input<Double> capacityScaler) {
            this.capacityScaler = capacityScaler;
            return this;
        }

        public Builder setCapacityScaler(@Nullable Double capacityScaler) {
            this.capacityScaler = Input.ofNullable(capacityScaler);
            return this;
        }

        public Builder setDescription(@Nullable Input<String> description) {
            this.description = description;
            return this;
        }

        public Builder setDescription(@Nullable String description) {
            this.description = Input.ofNullable(description);
            return this;
        }

        public Builder setFailover(@Nullable Input<Boolean> failover) {
            this.failover = failover;
            return this;
        }

        public Builder setFailover(@Nullable Boolean failover) {
            this.failover = Input.ofNullable(failover);
            return this;
        }

        public Builder setGroup(@Nullable Input<String> group) {
            this.group = group;
            return this;
        }

        public Builder setGroup(@Nullable String group) {
            this.group = Input.ofNullable(group);
            return this;
        }

        public Builder setMaxConnections(@Nullable Input<Integer> maxConnections) {
            this.maxConnections = maxConnections;
            return this;
        }

        public Builder setMaxConnections(@Nullable Integer maxConnections) {
            this.maxConnections = Input.ofNullable(maxConnections);
            return this;
        }

        public Builder setMaxConnectionsPerEndpoint(@Nullable Input<Integer> maxConnectionsPerEndpoint) {
            this.maxConnectionsPerEndpoint = maxConnectionsPerEndpoint;
            return this;
        }

        public Builder setMaxConnectionsPerEndpoint(@Nullable Integer maxConnectionsPerEndpoint) {
            this.maxConnectionsPerEndpoint = Input.ofNullable(maxConnectionsPerEndpoint);
            return this;
        }

        public Builder setMaxConnectionsPerInstance(@Nullable Input<Integer> maxConnectionsPerInstance) {
            this.maxConnectionsPerInstance = maxConnectionsPerInstance;
            return this;
        }

        public Builder setMaxConnectionsPerInstance(@Nullable Integer maxConnectionsPerInstance) {
            this.maxConnectionsPerInstance = Input.ofNullable(maxConnectionsPerInstance);
            return this;
        }

        public Builder setMaxRate(@Nullable Input<Integer> maxRate) {
            this.maxRate = maxRate;
            return this;
        }

        public Builder setMaxRate(@Nullable Integer maxRate) {
            this.maxRate = Input.ofNullable(maxRate);
            return this;
        }

        public Builder setMaxRatePerEndpoint(@Nullable Input<Double> maxRatePerEndpoint) {
            this.maxRatePerEndpoint = maxRatePerEndpoint;
            return this;
        }

        public Builder setMaxRatePerEndpoint(@Nullable Double maxRatePerEndpoint) {
            this.maxRatePerEndpoint = Input.ofNullable(maxRatePerEndpoint);
            return this;
        }

        public Builder setMaxRatePerInstance(@Nullable Input<Double> maxRatePerInstance) {
            this.maxRatePerInstance = maxRatePerInstance;
            return this;
        }

        public Builder setMaxRatePerInstance(@Nullable Double maxRatePerInstance) {
            this.maxRatePerInstance = Input.ofNullable(maxRatePerInstance);
            return this;
        }

        public Builder setMaxUtilization(@Nullable Input<Double> maxUtilization) {
            this.maxUtilization = maxUtilization;
            return this;
        }

        public Builder setMaxUtilization(@Nullable Double maxUtilization) {
            this.maxUtilization = Input.ofNullable(maxUtilization);
            return this;
        }

        public BackendArgs build() {
            return new BackendArgs(balancingMode, capacityScaler, description, failover, group, maxConnections, maxConnectionsPerEndpoint, maxConnectionsPerInstance, maxRate, maxRatePerEndpoint, maxRatePerInstance, maxUtilization);
        }
    }
}
