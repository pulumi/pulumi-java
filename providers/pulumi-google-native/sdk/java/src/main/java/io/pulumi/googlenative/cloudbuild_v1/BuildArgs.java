// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package io.pulumi.googlenative.cloudbuild_v1;

import io.pulumi.core.Input;
import io.pulumi.core.internal.annotations.InputImport;
import io.pulumi.googlenative.cloudbuild_v1.inputs.ArtifactsArgs;
import io.pulumi.googlenative.cloudbuild_v1.inputs.BuildOptionsArgs;
import io.pulumi.googlenative.cloudbuild_v1.inputs.BuildStepArgs;
import io.pulumi.googlenative.cloudbuild_v1.inputs.SecretArgs;
import io.pulumi.googlenative.cloudbuild_v1.inputs.SecretsArgs;
import io.pulumi.googlenative.cloudbuild_v1.inputs.SourceArgs;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import javax.annotation.Nullable;


/**
 * 
 */
public final class BuildArgs extends io.pulumi.resources.ResourceArgs {

    public static final BuildArgs Empty = new BuildArgs();

    /**
     * Artifacts produced by the build that should be uploaded upon successful completion of all build steps.
     */
    @InputImport(name="artifacts")
    private final @Nullable Input<ArtifactsArgs> artifacts;

    public Input<ArtifactsArgs> getArtifacts() {
        return this.artifacts == null ? Input.empty() : this.artifacts;
    }

    /**
     * Secrets and secret environment variables.
     */
    @InputImport(name="availableSecrets")
    private final @Nullable Input<SecretsArgs> availableSecrets;

    public Input<SecretsArgs> getAvailableSecrets() {
        return this.availableSecrets == null ? Input.empty() : this.availableSecrets;
    }

    /**
     * A list of images to be pushed upon the successful completion of all build steps. The images are pushed using the builder service account's credentials. The digests of the pushed images will be stored in the `Build` resource's results field. If any of the images fail to be pushed, the build status is marked `FAILURE`.
     */
    @InputImport(name="images")
    private final @Nullable Input<List<String>> images;

    public Input<List<String>> getImages() {
        return this.images == null ? Input.empty() : this.images;
    }

    /**
     * 
     */
    @InputImport(name="location")
    private final @Nullable Input<String> location;

    public Input<String> getLocation() {
        return this.location == null ? Input.empty() : this.location;
    }

    /**
     * Google Cloud Storage bucket where logs should be written (see [Bucket Name Requirements](https://cloud.google.com/storage/docs/bucket-naming#requirements)). Logs file names will be of the format `${logs_bucket}/log-${build_id}.txt`.
     */
    @InputImport(name="logsBucket")
    private final @Nullable Input<String> logsBucket;

    public Input<String> getLogsBucket() {
        return this.logsBucket == null ? Input.empty() : this.logsBucket;
    }

    /**
     * Special options for this build.
     */
    @InputImport(name="options")
    private final @Nullable Input<BuildOptionsArgs> options;

    public Input<BuildOptionsArgs> getOptions() {
        return this.options == null ? Input.empty() : this.options;
    }

    /**
     * 
     */
    @InputImport(name="project")
    private final @Nullable Input<String> project;

    public Input<String> getProject() {
        return this.project == null ? Input.empty() : this.project;
    }

    /**
     * 
     */
    @InputImport(name="projectId", required=true)
    private final Input<String> projectId;

    public Input<String> getProjectId() {
        return this.projectId;
    }

    /**
     * TTL in queue for this build. If provided and the build is enqueued longer than this value, the build will expire and the build status will be `EXPIRED`. The TTL starts ticking from create_time.
     */
    @InputImport(name="queueTtl")
    private final @Nullable Input<String> queueTtl;

    public Input<String> getQueueTtl() {
        return this.queueTtl == null ? Input.empty() : this.queueTtl;
    }

    /**
     * Secrets to decrypt using Cloud Key Management Service. Note: Secret Manager is the recommended technique for managing sensitive data with Cloud Build. Use `available_secrets` to configure builds to access secrets from Secret Manager. For instructions, see: https://cloud.google.com/cloud-build/docs/securing-builds/use-secrets
     */
    @InputImport(name="secrets")
    private final @Nullable Input<List<SecretArgs>> secrets;

    public Input<List<SecretArgs>> getSecrets() {
        return this.secrets == null ? Input.empty() : this.secrets;
    }

    /**
     * IAM service account whose credentials will be used at build runtime. Must be of the format `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}`. ACCOUNT can be email address or uniqueId of the service account. 
     */
    @InputImport(name="serviceAccount")
    private final @Nullable Input<String> serviceAccount;

    public Input<String> getServiceAccount() {
        return this.serviceAccount == null ? Input.empty() : this.serviceAccount;
    }

    /**
     * The location of the source files to build.
     */
    @InputImport(name="source")
    private final @Nullable Input<SourceArgs> source;

    public Input<SourceArgs> getSource() {
        return this.source == null ? Input.empty() : this.source;
    }

    /**
     * The operations to be performed on the workspace.
     */
    @InputImport(name="steps", required=true)
    private final Input<List<BuildStepArgs>> steps;

    public Input<List<BuildStepArgs>> getSteps() {
        return this.steps;
    }

    /**
     * Substitutions data for `Build` resource.
     */
    @InputImport(name="substitutions")
    private final @Nullable Input<Map<String,String>> substitutions;

    public Input<Map<String,String>> getSubstitutions() {
        return this.substitutions == null ? Input.empty() : this.substitutions;
    }

    /**
     * Tags for annotation of a `Build`. These are not docker tags.
     */
    @InputImport(name="tags")
    private final @Nullable Input<List<String>> tags;

    public Input<List<String>> getTags() {
        return this.tags == null ? Input.empty() : this.tags;
    }

    /**
     * Amount of time that this build should be allowed to run, to second granularity. If this amount of time elapses, work on the build will cease and the build status will be `TIMEOUT`. `timeout` starts ticking from `startTime`. Default time is ten minutes.
     */
    @InputImport(name="timeout")
    private final @Nullable Input<String> timeout;

    public Input<String> getTimeout() {
        return this.timeout == null ? Input.empty() : this.timeout;
    }

    public BuildArgs(
        @Nullable Input<ArtifactsArgs> artifacts,
        @Nullable Input<SecretsArgs> availableSecrets,
        @Nullable Input<List<String>> images,
        @Nullable Input<String> location,
        @Nullable Input<String> logsBucket,
        @Nullable Input<BuildOptionsArgs> options,
        @Nullable Input<String> project,
        Input<String> projectId,
        @Nullable Input<String> queueTtl,
        @Nullable Input<List<SecretArgs>> secrets,
        @Nullable Input<String> serviceAccount,
        @Nullable Input<SourceArgs> source,
        Input<List<BuildStepArgs>> steps,
        @Nullable Input<Map<String,String>> substitutions,
        @Nullable Input<List<String>> tags,
        @Nullable Input<String> timeout) {
        this.artifacts = artifacts;
        this.availableSecrets = availableSecrets;
        this.images = images;
        this.location = location;
        this.logsBucket = logsBucket;
        this.options = options;
        this.project = project;
        this.projectId = Objects.requireNonNull(projectId, "expected parameter 'projectId' to be non-null");
        this.queueTtl = queueTtl;
        this.secrets = secrets;
        this.serviceAccount = serviceAccount;
        this.source = source;
        this.steps = Objects.requireNonNull(steps, "expected parameter 'steps' to be non-null");
        this.substitutions = substitutions;
        this.tags = tags;
        this.timeout = timeout;
    }

    private BuildArgs() {
        this.artifacts = Input.empty();
        this.availableSecrets = Input.empty();
        this.images = Input.empty();
        this.location = Input.empty();
        this.logsBucket = Input.empty();
        this.options = Input.empty();
        this.project = Input.empty();
        this.projectId = Input.empty();
        this.queueTtl = Input.empty();
        this.secrets = Input.empty();
        this.serviceAccount = Input.empty();
        this.source = Input.empty();
        this.steps = Input.empty();
        this.substitutions = Input.empty();
        this.tags = Input.empty();
        this.timeout = Input.empty();
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(BuildArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private @Nullable Input<ArtifactsArgs> artifacts;
        private @Nullable Input<SecretsArgs> availableSecrets;
        private @Nullable Input<List<String>> images;
        private @Nullable Input<String> location;
        private @Nullable Input<String> logsBucket;
        private @Nullable Input<BuildOptionsArgs> options;
        private @Nullable Input<String> project;
        private Input<String> projectId;
        private @Nullable Input<String> queueTtl;
        private @Nullable Input<List<SecretArgs>> secrets;
        private @Nullable Input<String> serviceAccount;
        private @Nullable Input<SourceArgs> source;
        private Input<List<BuildStepArgs>> steps;
        private @Nullable Input<Map<String,String>> substitutions;
        private @Nullable Input<List<String>> tags;
        private @Nullable Input<String> timeout;

        public Builder() {
    	      // Empty
        }

        public Builder(BuildArgs defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.artifacts = defaults.artifacts;
    	      this.availableSecrets = defaults.availableSecrets;
    	      this.images = defaults.images;
    	      this.location = defaults.location;
    	      this.logsBucket = defaults.logsBucket;
    	      this.options = defaults.options;
    	      this.project = defaults.project;
    	      this.projectId = defaults.projectId;
    	      this.queueTtl = defaults.queueTtl;
    	      this.secrets = defaults.secrets;
    	      this.serviceAccount = defaults.serviceAccount;
    	      this.source = defaults.source;
    	      this.steps = defaults.steps;
    	      this.substitutions = defaults.substitutions;
    	      this.tags = defaults.tags;
    	      this.timeout = defaults.timeout;
        }

        public Builder setArtifacts(@Nullable Input<ArtifactsArgs> artifacts) {
            this.artifacts = artifacts;
            return this;
        }

        public Builder setArtifacts(@Nullable ArtifactsArgs artifacts) {
            this.artifacts = Input.ofNullable(artifacts);
            return this;
        }

        public Builder setAvailableSecrets(@Nullable Input<SecretsArgs> availableSecrets) {
            this.availableSecrets = availableSecrets;
            return this;
        }

        public Builder setAvailableSecrets(@Nullable SecretsArgs availableSecrets) {
            this.availableSecrets = Input.ofNullable(availableSecrets);
            return this;
        }

        public Builder setImages(@Nullable Input<List<String>> images) {
            this.images = images;
            return this;
        }

        public Builder setImages(@Nullable List<String> images) {
            this.images = Input.ofNullable(images);
            return this;
        }

        public Builder setLocation(@Nullable Input<String> location) {
            this.location = location;
            return this;
        }

        public Builder setLocation(@Nullable String location) {
            this.location = Input.ofNullable(location);
            return this;
        }

        public Builder setLogsBucket(@Nullable Input<String> logsBucket) {
            this.logsBucket = logsBucket;
            return this;
        }

        public Builder setLogsBucket(@Nullable String logsBucket) {
            this.logsBucket = Input.ofNullable(logsBucket);
            return this;
        }

        public Builder setOptions(@Nullable Input<BuildOptionsArgs> options) {
            this.options = options;
            return this;
        }

        public Builder setOptions(@Nullable BuildOptionsArgs options) {
            this.options = Input.ofNullable(options);
            return this;
        }

        public Builder setProject(@Nullable Input<String> project) {
            this.project = project;
            return this;
        }

        public Builder setProject(@Nullable String project) {
            this.project = Input.ofNullable(project);
            return this;
        }

        public Builder setProjectId(Input<String> projectId) {
            this.projectId = Objects.requireNonNull(projectId);
            return this;
        }

        public Builder setProjectId(String projectId) {
            this.projectId = Input.of(Objects.requireNonNull(projectId));
            return this;
        }

        public Builder setQueueTtl(@Nullable Input<String> queueTtl) {
            this.queueTtl = queueTtl;
            return this;
        }

        public Builder setQueueTtl(@Nullable String queueTtl) {
            this.queueTtl = Input.ofNullable(queueTtl);
            return this;
        }

        public Builder setSecrets(@Nullable Input<List<SecretArgs>> secrets) {
            this.secrets = secrets;
            return this;
        }

        public Builder setSecrets(@Nullable List<SecretArgs> secrets) {
            this.secrets = Input.ofNullable(secrets);
            return this;
        }

        public Builder setServiceAccount(@Nullable Input<String> serviceAccount) {
            this.serviceAccount = serviceAccount;
            return this;
        }

        public Builder setServiceAccount(@Nullable String serviceAccount) {
            this.serviceAccount = Input.ofNullable(serviceAccount);
            return this;
        }

        public Builder setSource(@Nullable Input<SourceArgs> source) {
            this.source = source;
            return this;
        }

        public Builder setSource(@Nullable SourceArgs source) {
            this.source = Input.ofNullable(source);
            return this;
        }

        public Builder setSteps(Input<List<BuildStepArgs>> steps) {
            this.steps = Objects.requireNonNull(steps);
            return this;
        }

        public Builder setSteps(List<BuildStepArgs> steps) {
            this.steps = Input.of(Objects.requireNonNull(steps));
            return this;
        }

        public Builder setSubstitutions(@Nullable Input<Map<String,String>> substitutions) {
            this.substitutions = substitutions;
            return this;
        }

        public Builder setSubstitutions(@Nullable Map<String,String> substitutions) {
            this.substitutions = Input.ofNullable(substitutions);
            return this;
        }

        public Builder setTags(@Nullable Input<List<String>> tags) {
            this.tags = tags;
            return this;
        }

        public Builder setTags(@Nullable List<String> tags) {
            this.tags = Input.ofNullable(tags);
            return this;
        }

        public Builder setTimeout(@Nullable Input<String> timeout) {
            this.timeout = timeout;
            return this;
        }

        public Builder setTimeout(@Nullable String timeout) {
            this.timeout = Input.ofNullable(timeout);
            return this;
        }

        public BuildArgs build() {
            return new BuildArgs(artifacts, availableSecrets, images, location, logsBucket, options, project, projectId, queueTtl, secrets, serviceAccount, source, steps, substitutions, tags, timeout);
        }
    }
}
