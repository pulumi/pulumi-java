// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package io.pulumi.docker;

import io.pulumi.core.Input;
import io.pulumi.core.Output;
import io.pulumi.core.annotations.OutputExport;
import io.pulumi.core.annotations.ResourceType;
import io.pulumi.docker.ContainerArgs;
import io.pulumi.docker.Utilities;
import io.pulumi.docker.inputs.ContainerState;
import io.pulumi.docker.outputs.ContainerCapabilities;
import io.pulumi.docker.outputs.ContainerDevice;
import io.pulumi.docker.outputs.ContainerHealthcheck;
import io.pulumi.docker.outputs.ContainerHost;
import io.pulumi.docker.outputs.ContainerLabel;
import io.pulumi.docker.outputs.ContainerMount;
import io.pulumi.docker.outputs.ContainerNetworkData;
import io.pulumi.docker.outputs.ContainerNetworksAdvanced;
import io.pulumi.docker.outputs.ContainerPort;
import io.pulumi.docker.outputs.ContainerUlimit;
import io.pulumi.docker.outputs.ContainerUpload;
import io.pulumi.docker.outputs.ContainerVolume;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.Object;
import java.lang.String;
import java.util.List;
import java.util.Map;
import javax.annotation.Nullable;

/**
 * ## Import
 * 
 * ### Example Assuming you created a `container` as follows #!/bin/bash docker run --name foo -p8080:80 -d nginx
 * 
 * # prints the container ID
 * 
 * 9a550c0f0163d39d77222d3efd58701b625d47676c25c686c95b5b92d1cba6fd you provide the definition for the resource as follows terraform resource "docker_container" "foo" {
 * 
 *  name
 * 
 * = "foo"
 * 
 *  image = "nginx"
 * 
 *  ports {
 * 
 *  internal = "80"
 * 
 *  external = "8080"
 * 
 *  } } then the import command is as follows #!/bin/bash
 * 
 * ```sh
 *  $ pulumi import docker:index/container:Container foo 9a550c0f0163d39d77222d3efd58701b625d47676c25c686c95b5b92d1cba6fd
 * ```
 * 
 */
@ResourceType(type="docker:index/container:Container")
public class Container extends io.pulumi.resources.CustomResource {
    /**
     * If `true` attach to the container after its creation and waits the end of its execution. Defaults to `false`.
     * 
     */
    @OutputExport(name="attach", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> attach;

    /**
     * @return If `true` attach to the container after its creation and waits the end of its execution. Defaults to `false`.
     * 
     */
    public Output</* @Nullable */ Boolean> getAttach() {
        return this.attach;
    }
    /**
     * The network bridge of the container as read from its NetworkSettings.
     * 
     */
    @OutputExport(name="bridge", type=String.class, parameters={})
    private Output<String> bridge;

    /**
     * @return The network bridge of the container as read from its NetworkSettings.
     * 
     */
    public Output<String> getBridge() {
        return this.bridge;
    }
    /**
     * Add or drop certrain linux capabilities.
     * 
     */
    @OutputExport(name="capabilities", type=ContainerCapabilities.class, parameters={})
    private Output</* @Nullable */ ContainerCapabilities> capabilities;

    /**
     * @return Add or drop certrain linux capabilities.
     * 
     */
    public Output</* @Nullable */ ContainerCapabilities> getCapabilities() {
        return this.capabilities;
    }
    /**
     * The command to use to start the container. For example, to run `/usr/bin/myprogram -f baz.conf` set the command to be
     * `["/usr/bin/myprogram","-","baz.con"]`.
     * 
     */
    @OutputExport(name="command", type=List.class, parameters={String.class})
    private Output<List<String>> command;

    /**
     * @return The command to use to start the container. For example, to run `/usr/bin/myprogram -f baz.conf` set the command to be
     * `["/usr/bin/myprogram","-","baz.con"]`.
     * 
     */
    public Output<List<String>> getCommand() {
        return this.command;
    }
    /**
     * The logs of the container if its execution is done (`attach` must be disabled).
     * 
     */
    @OutputExport(name="containerLogs", type=String.class, parameters={})
    private Output<String> containerLogs;

    /**
     * @return The logs of the container if its execution is done (`attach` must be disabled).
     * 
     */
    public Output<String> getContainerLogs() {
        return this.containerLogs;
    }
    /**
     * A comma-separated list or hyphen-separated range of CPUs a container can use, e.g. `0-1`.
     * 
     */
    @OutputExport(name="cpuSet", type=String.class, parameters={})
    private Output</* @Nullable */ String> cpuSet;

    /**
     * @return A comma-separated list or hyphen-separated range of CPUs a container can use, e.g. `0-1`.
     * 
     */
    public Output</* @Nullable */ String> getCpuSet() {
        return this.cpuSet;
    }
    /**
     * CPU shares (relative weight) for the container.
     * 
     */
    @OutputExport(name="cpuShares", type=Integer.class, parameters={})
    private Output</* @Nullable */ Integer> cpuShares;

    /**
     * @return CPU shares (relative weight) for the container.
     * 
     */
    public Output</* @Nullable */ Integer> getCpuShares() {
        return this.cpuShares;
    }
    /**
     * If defined will attempt to stop the container before destroying. Container will be destroyed after `n` seconds or on
     * successful stop.
     * 
     */
    @OutputExport(name="destroyGraceSeconds", type=Integer.class, parameters={})
    private Output</* @Nullable */ Integer> destroyGraceSeconds;

    /**
     * @return If defined will attempt to stop the container before destroying. Container will be destroyed after `n` seconds or on
     * successful stop.
     * 
     */
    public Output</* @Nullable */ Integer> getDestroyGraceSeconds() {
        return this.destroyGraceSeconds;
    }
    /**
     * Bind devices to the container.
     * 
     */
    @OutputExport(name="devices", type=List.class, parameters={ContainerDevice.class})
    private Output</* @Nullable */ List<ContainerDevice>> devices;

    /**
     * @return Bind devices to the container.
     * 
     */
    public Output</* @Nullable */ List<ContainerDevice>> getDevices() {
        return this.devices;
    }
    /**
     * DNS servers to use.
     * 
     */
    @OutputExport(name="dns", type=List.class, parameters={String.class})
    private Output</* @Nullable */ List<String>> dns;

    /**
     * @return DNS servers to use.
     * 
     */
    public Output</* @Nullable */ List<String>> getDns() {
        return this.dns;
    }
    /**
     * DNS options used by the DNS provider(s), see `resolv.conf` documentation for valid list of options.
     * 
     */
    @OutputExport(name="dnsOpts", type=List.class, parameters={String.class})
    private Output</* @Nullable */ List<String>> dnsOpts;

    /**
     * @return DNS options used by the DNS provider(s), see `resolv.conf` documentation for valid list of options.
     * 
     */
    public Output</* @Nullable */ List<String>> getDnsOpts() {
        return this.dnsOpts;
    }
    /**
     * DNS search domains that are used when bare unqualified hostnames are used inside of the container.
     * 
     */
    @OutputExport(name="dnsSearches", type=List.class, parameters={String.class})
    private Output</* @Nullable */ List<String>> dnsSearches;

    /**
     * @return DNS search domains that are used when bare unqualified hostnames are used inside of the container.
     * 
     */
    public Output</* @Nullable */ List<String>> getDnsSearches() {
        return this.dnsSearches;
    }
    /**
     * Domain name of the container.
     * 
     */
    @OutputExport(name="domainname", type=String.class, parameters={})
    private Output</* @Nullable */ String> domainname;

    /**
     * @return Domain name of the container.
     * 
     */
    public Output</* @Nullable */ String> getDomainname() {
        return this.domainname;
    }
    /**
     * The command to use as the Entrypoint for the container. The Entrypoint allows you to configure a container to run as an
     * executable. For example, to run `/usr/bin/myprogram` when starting a container, set the entrypoint to be
     * `"/usr/bin/myprogra"]`.
     * 
     */
    @OutputExport(name="entrypoints", type=List.class, parameters={String.class})
    private Output<List<String>> entrypoints;

    /**
     * @return The command to use as the Entrypoint for the container. The Entrypoint allows you to configure a container to run as an
     * executable. For example, to run `/usr/bin/myprogram` when starting a container, set the entrypoint to be
     * `"/usr/bin/myprogra"]`.
     * 
     */
    public Output<List<String>> getEntrypoints() {
        return this.entrypoints;
    }
    /**
     * Environment variables to set in the form of `KEY=VALUE`, e.g. `DEBUG=0`
     * 
     */
    @OutputExport(name="envs", type=List.class, parameters={String.class})
    private Output<List<String>> envs;

    /**
     * @return Environment variables to set in the form of `KEY=VALUE`, e.g. `DEBUG=0`
     * 
     */
    public Output<List<String>> getEnvs() {
        return this.envs;
    }
    /**
     * The exit code of the container if its execution is done (`must_run` must be disabled).
     * 
     */
    @OutputExport(name="exitCode", type=Integer.class, parameters={})
    private Output<Integer> exitCode;

    /**
     * @return The exit code of the container if its execution is done (`must_run` must be disabled).
     * 
     */
    public Output<Integer> getExitCode() {
        return this.exitCode;
    }
    /**
     * The network gateway of the container.
     * 
     * @deprecated
     * Use `network_data` instead. The network gateway of the container as read from its NetworkSettings.
     * 
     */
    @Deprecated /* Use `network_data` instead. The network gateway of the container as read from its NetworkSettings. */
    @OutputExport(name="gateway", type=String.class, parameters={})
    private Output<String> gateway;

    /**
     * @return The network gateway of the container.
     * 
     */
    public Output<String> getGateway() {
        return this.gateway;
    }
    /**
     * Additional groups for the container user
     * 
     */
    @OutputExport(name="groupAdds", type=List.class, parameters={String.class})
    private Output</* @Nullable */ List<String>> groupAdds;

    /**
     * @return Additional groups for the container user
     * 
     */
    public Output</* @Nullable */ List<String>> getGroupAdds() {
        return this.groupAdds;
    }
    /**
     * A test to perform to check that the container is healthy
     * 
     */
    @OutputExport(name="healthcheck", type=ContainerHealthcheck.class, parameters={})
    private Output<ContainerHealthcheck> healthcheck;

    /**
     * @return A test to perform to check that the container is healthy
     * 
     */
    public Output<ContainerHealthcheck> getHealthcheck() {
        return this.healthcheck;
    }
    /**
     * Hostname of the container.
     * 
     */
    @OutputExport(name="hostname", type=String.class, parameters={})
    private Output<String> hostname;

    /**
     * @return Hostname of the container.
     * 
     */
    public Output<String> getHostname() {
        return this.hostname;
    }
    /**
     * Additional hosts to add to the container.
     * 
     */
    @OutputExport(name="hosts", type=List.class, parameters={ContainerHost.class})
    private Output</* @Nullable */ List<ContainerHost>> hosts;

    /**
     * @return Additional hosts to add to the container.
     * 
     */
    public Output</* @Nullable */ List<ContainerHost>> getHosts() {
        return this.hosts;
    }
    /**
     * The ID of the image to back this container. The easiest way to get this value is to use the `docker_image` resource as
     * is shown in the example.
     * 
     */
    @OutputExport(name="image", type=String.class, parameters={})
    private Output<String> image;

    /**
     * @return The ID of the image to back this container. The easiest way to get this value is to use the `docker_image` resource as
     * is shown in the example.
     * 
     */
    public Output<String> getImage() {
        return this.image;
    }
    /**
     * Configured whether an init process should be injected for this container. If unset this will default to the `dockerd`
     * defaults.
     * 
     */
    @OutputExport(name="init", type=Boolean.class, parameters={})
    private Output<Boolean> init;

    /**
     * @return Configured whether an init process should be injected for this container. If unset this will default to the `dockerd`
     * defaults.
     * 
     */
    public Output<Boolean> getInit() {
        return this.init;
    }
    /**
     * The IP address of the container.
     * 
     * @deprecated
     * Use `network_data` instead. The IP address of the container's first network it.
     * 
     */
    @Deprecated /* Use `network_data` instead. The IP address of the container's first network it. */
    @OutputExport(name="ipAddress", type=String.class, parameters={})
    private Output<String> ipAddress;

    /**
     * @return The IP address of the container.
     * 
     */
    public Output<String> getIpAddress() {
        return this.ipAddress;
    }
    /**
     * The IP prefix length of the container.
     * 
     * @deprecated
     * Use `network_data` instead. The IP prefix length of the container as read from its NetworkSettings.
     * 
     */
    @Deprecated /* Use `network_data` instead. The IP prefix length of the container as read from its NetworkSettings. */
    @OutputExport(name="ipPrefixLength", type=Integer.class, parameters={})
    private Output<Integer> ipPrefixLength;

    /**
     * @return The IP prefix length of the container.
     * 
     */
    public Output<Integer> getIpPrefixLength() {
        return this.ipPrefixLength;
    }
    /**
     * IPC sharing mode for the container. Possible values are: `none`, `private`, `shareable`, `container:<name|id>` or
     * `host`.
     * 
     */
    @OutputExport(name="ipcMode", type=String.class, parameters={})
    private Output<String> ipcMode;

    /**
     * @return IPC sharing mode for the container. Possible values are: `none`, `private`, `shareable`, `container:<name|id>` or
     * `host`.
     * 
     */
    public Output<String> getIpcMode() {
        return this.ipcMode;
    }
    /**
     * User-defined key/value metadata
     * 
     */
    @OutputExport(name="labels", type=List.class, parameters={ContainerLabel.class})
    private Output<List<ContainerLabel>> labels;

    /**
     * @return User-defined key/value metadata
     * 
     */
    public Output<List<ContainerLabel>> getLabels() {
        return this.labels;
    }
    /**
     * Set of links for link based connectivity between containers that are running on the same host.
     * 
     * @deprecated
     * The --link flag is a legacy feature of Docker. It may eventually be removed.
     * 
     */
    @Deprecated /* The --link flag is a legacy feature of Docker. It may eventually be removed. */
    @OutputExport(name="links", type=List.class, parameters={String.class})
    private Output</* @Nullable */ List<String>> links;

    /**
     * @return Set of links for link based connectivity between containers that are running on the same host.
     * 
     */
    public Output</* @Nullable */ List<String>> getLinks() {
        return this.links;
    }
    /**
     * The logging driver to use for the container. Defaults to `json-file`.
     * 
     */
    @OutputExport(name="logDriver", type=String.class, parameters={})
    private Output</* @Nullable */ String> logDriver;

    /**
     * @return The logging driver to use for the container. Defaults to `json-file`.
     * 
     */
    public Output</* @Nullable */ String> getLogDriver() {
        return this.logDriver;
    }
    /**
     * Key/value pairs to use as options for the logging driver.
     * 
     */
    @OutputExport(name="logOpts", type=Map.class, parameters={String.class, Object.class})
    private Output</* @Nullable */ Map<String,Object>> logOpts;

    /**
     * @return Key/value pairs to use as options for the logging driver.
     * 
     */
    public Output</* @Nullable */ Map<String,Object>> getLogOpts() {
        return this.logOpts;
    }
    /**
     * Save the container logs (`attach` must be enabled). Defaults to `false`.
     * 
     */
    @OutputExport(name="logs", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> logs;

    /**
     * @return Save the container logs (`attach` must be enabled). Defaults to `false`.
     * 
     */
    public Output</* @Nullable */ Boolean> getLogs() {
        return this.logs;
    }
    /**
     * The maximum amount of times to an attempt a restart when `restart` is set to 'on-failure'.
     * 
     */
    @OutputExport(name="maxRetryCount", type=Integer.class, parameters={})
    private Output</* @Nullable */ Integer> maxRetryCount;

    /**
     * @return The maximum amount of times to an attempt a restart when `restart` is set to 'on-failure'.
     * 
     */
    public Output</* @Nullable */ Integer> getMaxRetryCount() {
        return this.maxRetryCount;
    }
    /**
     * The memory limit for the container in MBs.
     * 
     */
    @OutputExport(name="memory", type=Integer.class, parameters={})
    private Output</* @Nullable */ Integer> memory;

    /**
     * @return The memory limit for the container in MBs.
     * 
     */
    public Output</* @Nullable */ Integer> getMemory() {
        return this.memory;
    }
    /**
     * The total memory limit (memory + swap) for the container in MBs. This setting may compute to `-1` after `terraform
     * apply` if the target host doesn't support memory swap, when that is the case docker will use a soft limitation.
     * 
     */
    @OutputExport(name="memorySwap", type=Integer.class, parameters={})
    private Output</* @Nullable */ Integer> memorySwap;

    /**
     * @return The total memory limit (memory + swap) for the container in MBs. This setting may compute to `-1` after `terraform
     * apply` if the target host doesn't support memory swap, when that is the case docker will use a soft limitation.
     * 
     */
    public Output</* @Nullable */ Integer> getMemorySwap() {
        return this.memorySwap;
    }
    /**
     * Specification for mounts to be added to containers created as part of the service.
     * 
     */
    @OutputExport(name="mounts", type=List.class, parameters={ContainerMount.class})
    private Output</* @Nullable */ List<ContainerMount>> mounts;

    /**
     * @return Specification for mounts to be added to containers created as part of the service.
     * 
     */
    public Output</* @Nullable */ List<ContainerMount>> getMounts() {
        return this.mounts;
    }
    /**
     * If `true`, then the Docker container will be kept running. If `false`, then as long as the container exists, Terraform
     * assumes it is successful. Defaults to `true`.
     * 
     */
    @OutputExport(name="mustRun", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> mustRun;

    /**
     * @return If `true`, then the Docker container will be kept running. If `false`, then as long as the container exists, Terraform
     * assumes it is successful. Defaults to `true`.
     * 
     */
    public Output</* @Nullable */ Boolean> getMustRun() {
        return this.mustRun;
    }
    /**
     * The name of the container.
     * 
     */
    @OutputExport(name="name", type=String.class, parameters={})
    private Output<String> name;

    /**
     * @return The name of the container.
     * 
     */
    public Output<String> getName() {
        return this.name;
    }
    /**
     * Set an alias for the container in all specified networks
     * 
     * @deprecated
     * Use networks_advanced instead. Will be removed in v3.0.0
     * 
     */
    @Deprecated /* Use networks_advanced instead. Will be removed in v3.0.0 */
    @OutputExport(name="networkAliases", type=List.class, parameters={String.class})
    private Output</* @Nullable */ List<String>> networkAliases;

    /**
     * @return Set an alias for the container in all specified networks
     * 
     */
    public Output</* @Nullable */ List<String>> getNetworkAliases() {
        return this.networkAliases;
    }
    /**
     * The data of the networks the container is connected to.
     * 
     */
    @OutputExport(name="networkDatas", type=List.class, parameters={ContainerNetworkData.class})
    private Output<List<ContainerNetworkData>> networkDatas;

    /**
     * @return The data of the networks the container is connected to.
     * 
     */
    public Output<List<ContainerNetworkData>> getNetworkDatas() {
        return this.networkDatas;
    }
    /**
     * Network mode of the container.
     * 
     */
    @OutputExport(name="networkMode", type=String.class, parameters={})
    private Output</* @Nullable */ String> networkMode;

    /**
     * @return Network mode of the container.
     * 
     */
    public Output</* @Nullable */ String> getNetworkMode() {
        return this.networkMode;
    }
    /**
     * ID of the networks in which the container is.
     * 
     * @deprecated
     * Use networks_advanced instead. Will be removed in v3.0.0
     * 
     */
    @Deprecated /* Use networks_advanced instead. Will be removed in v3.0.0 */
    @OutputExport(name="networks", type=List.class, parameters={String.class})
    private Output</* @Nullable */ List<String>> networks;

    /**
     * @return ID of the networks in which the container is.
     * 
     */
    public Output</* @Nullable */ List<String>> getNetworks() {
        return this.networks;
    }
    /**
     * The networks the container is attached to
     * 
     */
    @OutputExport(name="networksAdvanced", type=List.class, parameters={ContainerNetworksAdvanced.class})
    private Output</* @Nullable */ List<ContainerNetworksAdvanced>> networksAdvanced;

    /**
     * @return The networks the container is attached to
     * 
     */
    public Output</* @Nullable */ List<ContainerNetworksAdvanced>> getNetworksAdvanced() {
        return this.networksAdvanced;
    }
    /**
     * he PID (Process) Namespace mode for the container. Either `container:<name|id>` or `host`.
     * 
     */
    @OutputExport(name="pidMode", type=String.class, parameters={})
    private Output</* @Nullable */ String> pidMode;

    /**
     * @return he PID (Process) Namespace mode for the container. Either `container:<name|id>` or `host`.
     * 
     */
    public Output</* @Nullable */ String> getPidMode() {
        return this.pidMode;
    }
    /**
     * Publish a container's port(s) to the host.
     * 
     */
    @OutputExport(name="ports", type=List.class, parameters={ContainerPort.class})
    private Output</* @Nullable */ List<ContainerPort>> ports;

    /**
     * @return Publish a container's port(s) to the host.
     * 
     */
    public Output</* @Nullable */ List<ContainerPort>> getPorts() {
        return this.ports;
    }
    /**
     * If `true`, the container runs in privileged mode.
     * 
     */
    @OutputExport(name="privileged", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> privileged;

    /**
     * @return If `true`, the container runs in privileged mode.
     * 
     */
    public Output</* @Nullable */ Boolean> getPrivileged() {
        return this.privileged;
    }
    /**
     * Publish all ports of the container.
     * 
     */
    @OutputExport(name="publishAllPorts", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> publishAllPorts;

    /**
     * @return Publish all ports of the container.
     * 
     */
    public Output</* @Nullable */ Boolean> getPublishAllPorts() {
        return this.publishAllPorts;
    }
    /**
     * If `true`, the container will be started as readonly. Defaults to `false`.
     * 
     */
    @OutputExport(name="readOnly", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> readOnly;

    /**
     * @return If `true`, the container will be started as readonly. Defaults to `false`.
     * 
     */
    public Output</* @Nullable */ Boolean> getReadOnly() {
        return this.readOnly;
    }
    /**
     * If `true`, it will remove anonymous volumes associated with the container. Defaults to `true`.
     * 
     */
    @OutputExport(name="removeVolumes", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> removeVolumes;

    /**
     * @return If `true`, it will remove anonymous volumes associated with the container. Defaults to `true`.
     * 
     */
    public Output</* @Nullable */ Boolean> getRemoveVolumes() {
        return this.removeVolumes;
    }
    /**
     * The restart policy for the container. Must be one of 'no', 'on-failure', 'always', 'unless-stopped'. Defaults to `no`.
     * 
     */
    @OutputExport(name="restart", type=String.class, parameters={})
    private Output</* @Nullable */ String> restart;

    /**
     * @return The restart policy for the container. Must be one of 'no', 'on-failure', 'always', 'unless-stopped'. Defaults to `no`.
     * 
     */
    public Output</* @Nullable */ String> getRestart() {
        return this.restart;
    }
    /**
     * If `true`, then the container will be automatically removed after his execution. Terraform won't check this container
     * after creation. Defaults to `false`.
     * 
     */
    @OutputExport(name="rm", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> rm;

    /**
     * @return If `true`, then the container will be automatically removed after his execution. Terraform won't check this container
     * after creation. Defaults to `false`.
     * 
     */
    public Output</* @Nullable */ Boolean> getRm() {
        return this.rm;
    }
    /**
     * List of string values to customize labels for MLS systems, such as SELinux. See
     * https://docs.docker.com/engine/reference/run/#security-configuration.
     * 
     */
    @OutputExport(name="securityOpts", type=List.class, parameters={String.class})
    private Output<List<String>> securityOpts;

    /**
     * @return List of string values to customize labels for MLS systems, such as SELinux. See
     * https://docs.docker.com/engine/reference/run/#security-configuration.
     * 
     */
    public Output<List<String>> getSecurityOpts() {
        return this.securityOpts;
    }
    /**
     * Size of `/dev/shm` in MBs.
     * 
     */
    @OutputExport(name="shmSize", type=Integer.class, parameters={})
    private Output<Integer> shmSize;

    /**
     * @return Size of `/dev/shm` in MBs.
     * 
     */
    public Output<Integer> getShmSize() {
        return this.shmSize;
    }
    /**
     * If `true`, then the Docker container will be started after creation. If `false`, then the container is only created.
     * Defaults to `true`.
     * 
     */
    @OutputExport(name="start", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> start;

    /**
     * @return If `true`, then the Docker container will be started after creation. If `false`, then the container is only created.
     * Defaults to `true`.
     * 
     */
    public Output</* @Nullable */ Boolean> getStart() {
        return this.start;
    }
    /**
     * If `true`, keep STDIN open even if not attached (`docker run -i`). Defaults to `false`.
     * 
     */
    @OutputExport(name="stdinOpen", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> stdinOpen;

    /**
     * @return If `true`, keep STDIN open even if not attached (`docker run -i`). Defaults to `false`.
     * 
     */
    public Output</* @Nullable */ Boolean> getStdinOpen() {
        return this.stdinOpen;
    }
    /**
     * Key/value pairs for the storage driver options, e.g. `size`: `120G`
     * 
     */
    @OutputExport(name="storageOpts", type=Map.class, parameters={String.class, Object.class})
    private Output</* @Nullable */ Map<String,Object>> storageOpts;

    /**
     * @return Key/value pairs for the storage driver options, e.g. `size`: `120G`
     * 
     */
    public Output</* @Nullable */ Map<String,Object>> getStorageOpts() {
        return this.storageOpts;
    }
    /**
     * A map of kernel parameters (sysctls) to set in the container.
     * 
     */
    @OutputExport(name="sysctls", type=Map.class, parameters={String.class, Object.class})
    private Output</* @Nullable */ Map<String,Object>> sysctls;

    /**
     * @return A map of kernel parameters (sysctls) to set in the container.
     * 
     */
    public Output</* @Nullable */ Map<String,Object>> getSysctls() {
        return this.sysctls;
    }
    /**
     * A map of container directories which should be replaced by `tmpfs mounts`, and their corresponding mount options.
     * 
     */
    @OutputExport(name="tmpfs", type=Map.class, parameters={String.class, Object.class})
    private Output</* @Nullable */ Map<String,Object>> tmpfs;

    /**
     * @return A map of container directories which should be replaced by `tmpfs mounts`, and their corresponding mount options.
     * 
     */
    public Output</* @Nullable */ Map<String,Object>> getTmpfs() {
        return this.tmpfs;
    }
    /**
     * If `true`, allocate a pseudo-tty (`docker run -t`). Defaults to `false`.
     * 
     */
    @OutputExport(name="tty", type=Boolean.class, parameters={})
    private Output</* @Nullable */ Boolean> tty;

    /**
     * @return If `true`, allocate a pseudo-tty (`docker run -t`). Defaults to `false`.
     * 
     */
    public Output</* @Nullable */ Boolean> getTty() {
        return this.tty;
    }
    /**
     * Ulimit options to add.
     * 
     */
    @OutputExport(name="ulimits", type=List.class, parameters={ContainerUlimit.class})
    private Output</* @Nullable */ List<ContainerUlimit>> ulimits;

    /**
     * @return Ulimit options to add.
     * 
     */
    public Output</* @Nullable */ List<ContainerUlimit>> getUlimits() {
        return this.ulimits;
    }
    /**
     * Specifies files to upload to the container before starting it. Only one of `content` or `content_base64` can be set and
     * at least one of them has to be set.
     * 
     */
    @OutputExport(name="uploads", type=List.class, parameters={ContainerUpload.class})
    private Output</* @Nullable */ List<ContainerUpload>> uploads;

    /**
     * @return Specifies files to upload to the container before starting it. Only one of `content` or `content_base64` can be set and
     * at least one of them has to be set.
     * 
     */
    public Output</* @Nullable */ List<ContainerUpload>> getUploads() {
        return this.uploads;
    }
    /**
     * User used for run the first process. Format is `user` or `user:group` which user and group can be passed literraly or by
     * name.
     * 
     */
    @OutputExport(name="user", type=String.class, parameters={})
    private Output</* @Nullable */ String> user;

    /**
     * @return User used for run the first process. Format is `user` or `user:group` which user and group can be passed literraly or by
     * name.
     * 
     */
    public Output</* @Nullable */ String> getUser() {
        return this.user;
    }
    /**
     * Sets the usernamespace mode for the container when usernamespace remapping option is enabled.
     * 
     */
    @OutputExport(name="usernsMode", type=String.class, parameters={})
    private Output</* @Nullable */ String> usernsMode;

    /**
     * @return Sets the usernamespace mode for the container when usernamespace remapping option is enabled.
     * 
     */
    public Output</* @Nullable */ String> getUsernsMode() {
        return this.usernsMode;
    }
    /**
     * Spec for mounting volumes in the container.
     * 
     */
    @OutputExport(name="volumes", type=List.class, parameters={ContainerVolume.class})
    private Output</* @Nullable */ List<ContainerVolume>> volumes;

    /**
     * @return Spec for mounting volumes in the container.
     * 
     */
    public Output</* @Nullable */ List<ContainerVolume>> getVolumes() {
        return this.volumes;
    }
    /**
     * The working directory for commands to run in.
     * 
     */
    @OutputExport(name="workingDir", type=String.class, parameters={})
    private Output</* @Nullable */ String> workingDir;

    /**
     * @return The working directory for commands to run in.
     * 
     */
    public Output</* @Nullable */ String> getWorkingDir() {
        return this.workingDir;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public Container(String name) {
        this(name, ContainerArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public Container(String name, ContainerArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public Container(String name, ContainerArgs args, @Nullable io.pulumi.resources.CustomResourceOptions options) {
        super("docker:index/container:Container", name, args == null ? ContainerArgs.Empty : args, makeResourceOptions(options, Input.empty()));
    }

    private Container(String name, Input<String> id, @Nullable ContainerState state, @Nullable io.pulumi.resources.CustomResourceOptions options) {
        super("docker:index/container:Container", name, state, makeResourceOptions(options, id));
    }

    private static io.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable io.pulumi.resources.CustomResourceOptions options, @Nullable Input<String> id) {
        var defaultOptions = io.pulumi.resources.CustomResourceOptions.builder()
            .setVersion(Utilities.getVersion())
            .build();
        return io.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static Container get(String name, Input<String> id, @Nullable ContainerState state, @Nullable io.pulumi.resources.CustomResourceOptions options) {
        return new Container(name, id, state, options);
    }
}
