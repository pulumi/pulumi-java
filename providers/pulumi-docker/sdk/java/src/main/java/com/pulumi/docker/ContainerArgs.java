// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.docker;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.core.internal.Codegen;
import com.pulumi.docker.inputs.ContainerCapabilitiesArgs;
import com.pulumi.docker.inputs.ContainerDeviceArgs;
import com.pulumi.docker.inputs.ContainerHealthcheckArgs;
import com.pulumi.docker.inputs.ContainerHostArgs;
import com.pulumi.docker.inputs.ContainerLabelArgs;
import com.pulumi.docker.inputs.ContainerMountArgs;
import com.pulumi.docker.inputs.ContainerNetworksAdvancedArgs;
import com.pulumi.docker.inputs.ContainerPortArgs;
import com.pulumi.docker.inputs.ContainerUlimitArgs;
import com.pulumi.docker.inputs.ContainerUploadArgs;
import com.pulumi.docker.inputs.ContainerVolumeArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.Object;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import javax.annotation.Nullable;


public final class ContainerArgs extends com.pulumi.resources.ResourceArgs {

    public static final ContainerArgs Empty = new ContainerArgs();

    /**
     * If `true` attach to the container after its creation and waits the end of its execution. Defaults to `false`.
     * 
     */
    @Import(name="attach")
      private final @Nullable Output<Boolean> attach;

    public Output<Boolean> attach() {
        return this.attach == null ? Codegen.empty() : this.attach;
    }

    /**
     * Add or drop certrain linux capabilities.
     * 
     */
    @Import(name="capabilities")
      private final @Nullable Output<ContainerCapabilitiesArgs> capabilities;

    public Output<ContainerCapabilitiesArgs> capabilities() {
        return this.capabilities == null ? Codegen.empty() : this.capabilities;
    }

    /**
     * The command to use to start the container. For example, to run `/usr/bin/myprogram -f baz.conf` set the command to be
     * `[&#34;/usr/bin/myprogram&#34;,&#34;-&#34;,&#34;baz.con&#34;]`.
     * 
     */
    @Import(name="command")
      private final @Nullable Output<List<String>> command;

    public Output<List<String>> command() {
        return this.command == null ? Codegen.empty() : this.command;
    }

    /**
     * A comma-separated list or hyphen-separated range of CPUs a container can use, e.g. `0-1`.
     * 
     */
    @Import(name="cpuSet")
      private final @Nullable Output<String> cpuSet;

    public Output<String> cpuSet() {
        return this.cpuSet == null ? Codegen.empty() : this.cpuSet;
    }

    /**
     * CPU shares (relative weight) for the container.
     * 
     */
    @Import(name="cpuShares")
      private final @Nullable Output<Integer> cpuShares;

    public Output<Integer> cpuShares() {
        return this.cpuShares == null ? Codegen.empty() : this.cpuShares;
    }

    /**
     * If defined will attempt to stop the container before destroying. Container will be destroyed after `n` seconds or on
     * successful stop.
     * 
     */
    @Import(name="destroyGraceSeconds")
      private final @Nullable Output<Integer> destroyGraceSeconds;

    public Output<Integer> destroyGraceSeconds() {
        return this.destroyGraceSeconds == null ? Codegen.empty() : this.destroyGraceSeconds;
    }

    /**
     * Bind devices to the container.
     * 
     */
    @Import(name="devices")
      private final @Nullable Output<List<ContainerDeviceArgs>> devices;

    public Output<List<ContainerDeviceArgs>> devices() {
        return this.devices == null ? Codegen.empty() : this.devices;
    }

    /**
     * DNS servers to use.
     * 
     */
    @Import(name="dns")
      private final @Nullable Output<List<String>> dns;

    public Output<List<String>> dns() {
        return this.dns == null ? Codegen.empty() : this.dns;
    }

    /**
     * DNS options used by the DNS provider(s), see `resolv.conf` documentation for valid list of options.
     * 
     */
    @Import(name="dnsOpts")
      private final @Nullable Output<List<String>> dnsOpts;

    public Output<List<String>> dnsOpts() {
        return this.dnsOpts == null ? Codegen.empty() : this.dnsOpts;
    }

    /**
     * DNS search domains that are used when bare unqualified hostnames are used inside of the container.
     * 
     */
    @Import(name="dnsSearches")
      private final @Nullable Output<List<String>> dnsSearches;

    public Output<List<String>> dnsSearches() {
        return this.dnsSearches == null ? Codegen.empty() : this.dnsSearches;
    }

    /**
     * Domain name of the container.
     * 
     */
    @Import(name="domainname")
      private final @Nullable Output<String> domainname;

    public Output<String> domainname() {
        return this.domainname == null ? Codegen.empty() : this.domainname;
    }

    /**
     * The command to use as the Entrypoint for the container. The Entrypoint allows you to configure a container to run as an
     * executable. For example, to run `/usr/bin/myprogram` when starting a container, set the entrypoint to be
     * `&#34;/usr/bin/myprogra&#34;]`.
     * 
     */
    @Import(name="entrypoints")
      private final @Nullable Output<List<String>> entrypoints;

    public Output<List<String>> entrypoints() {
        return this.entrypoints == null ? Codegen.empty() : this.entrypoints;
    }

    /**
     * Environment variables to set in the form of `KEY=VALUE`, e.g. `DEBUG=0`
     * 
     */
    @Import(name="envs")
      private final @Nullable Output<List<String>> envs;

    public Output<List<String>> envs() {
        return this.envs == null ? Codegen.empty() : this.envs;
    }

    /**
     * Additional groups for the container user
     * 
     */
    @Import(name="groupAdds")
      private final @Nullable Output<List<String>> groupAdds;

    public Output<List<String>> groupAdds() {
        return this.groupAdds == null ? Codegen.empty() : this.groupAdds;
    }

    /**
     * A test to perform to check that the container is healthy
     * 
     */
    @Import(name="healthcheck")
      private final @Nullable Output<ContainerHealthcheckArgs> healthcheck;

    public Output<ContainerHealthcheckArgs> healthcheck() {
        return this.healthcheck == null ? Codegen.empty() : this.healthcheck;
    }

    /**
     * Hostname of the container.
     * 
     */
    @Import(name="hostname")
      private final @Nullable Output<String> hostname;

    public Output<String> hostname() {
        return this.hostname == null ? Codegen.empty() : this.hostname;
    }

    /**
     * Additional hosts to add to the container.
     * 
     */
    @Import(name="hosts")
      private final @Nullable Output<List<ContainerHostArgs>> hosts;

    public Output<List<ContainerHostArgs>> hosts() {
        return this.hosts == null ? Codegen.empty() : this.hosts;
    }

    /**
     * The ID of the image to back this container. The easiest way to get this value is to use the `docker_image` resource as
     * is shown in the example.
     * 
     */
    @Import(name="image", required=true)
      private final Output<String> image;

    public Output<String> image() {
        return this.image;
    }

    /**
     * Configured whether an init process should be injected for this container. If unset this will default to the `dockerd`
     * defaults.
     * 
     */
    @Import(name="init")
      private final @Nullable Output<Boolean> init;

    public Output<Boolean> init() {
        return this.init == null ? Codegen.empty() : this.init;
    }

    /**
     * IPC sharing mode for the container. Possible values are: `none`, `private`, `shareable`, `container:&lt;name|id&gt;` or
     * `host`.
     * 
     */
    @Import(name="ipcMode")
      private final @Nullable Output<String> ipcMode;

    public Output<String> ipcMode() {
        return this.ipcMode == null ? Codegen.empty() : this.ipcMode;
    }

    /**
     * User-defined key/value metadata
     * 
     */
    @Import(name="labels")
      private final @Nullable Output<List<ContainerLabelArgs>> labels;

    public Output<List<ContainerLabelArgs>> labels() {
        return this.labels == null ? Codegen.empty() : this.labels;
    }

    /**
     * Set of links for link based connectivity between containers that are running on the same host.
     * 
     * @deprecated
     * The --link flag is a legacy feature of Docker. It may eventually be removed.
     * 
     */
    @Deprecated /* The --link flag is a legacy feature of Docker. It may eventually be removed. */
    @Import(name="links")
      private final @Nullable Output<List<String>> links;

    @Deprecated /* The --link flag is a legacy feature of Docker. It may eventually be removed. */
    public Output<List<String>> links() {
        return this.links == null ? Codegen.empty() : this.links;
    }

    /**
     * The logging driver to use for the container. Defaults to `json-file`.
     * 
     */
    @Import(name="logDriver")
      private final @Nullable Output<String> logDriver;

    public Output<String> logDriver() {
        return this.logDriver == null ? Codegen.empty() : this.logDriver;
    }

    /**
     * Key/value pairs to use as options for the logging driver.
     * 
     */
    @Import(name="logOpts")
      private final @Nullable Output<Map<String,Object>> logOpts;

    public Output<Map<String,Object>> logOpts() {
        return this.logOpts == null ? Codegen.empty() : this.logOpts;
    }

    /**
     * Save the container logs (`attach` must be enabled). Defaults to `false`.
     * 
     */
    @Import(name="logs")
      private final @Nullable Output<Boolean> logs;

    public Output<Boolean> logs() {
        return this.logs == null ? Codegen.empty() : this.logs;
    }

    /**
     * The maximum amount of times to an attempt a restart when `restart` is set to &#39;on-failure&#39;.
     * 
     */
    @Import(name="maxRetryCount")
      private final @Nullable Output<Integer> maxRetryCount;

    public Output<Integer> maxRetryCount() {
        return this.maxRetryCount == null ? Codegen.empty() : this.maxRetryCount;
    }

    /**
     * The memory limit for the container in MBs.
     * 
     */
    @Import(name="memory")
      private final @Nullable Output<Integer> memory;

    public Output<Integer> memory() {
        return this.memory == null ? Codegen.empty() : this.memory;
    }

    /**
     * The total memory limit (memory + swap) for the container in MBs. This setting may compute to `-1` after `terraform
     * apply` if the target host doesn&#39;t support memory swap, when that is the case docker will use a soft limitation.
     * 
     */
    @Import(name="memorySwap")
      private final @Nullable Output<Integer> memorySwap;

    public Output<Integer> memorySwap() {
        return this.memorySwap == null ? Codegen.empty() : this.memorySwap;
    }

    /**
     * Specification for mounts to be added to containers created as part of the service.
     * 
     */
    @Import(name="mounts")
      private final @Nullable Output<List<ContainerMountArgs>> mounts;

    public Output<List<ContainerMountArgs>> mounts() {
        return this.mounts == null ? Codegen.empty() : this.mounts;
    }

    /**
     * If `true`, then the Docker container will be kept running. If `false`, then as long as the container exists, Terraform
     * assumes it is successful. Defaults to `true`.
     * 
     */
    @Import(name="mustRun")
      private final @Nullable Output<Boolean> mustRun;

    public Output<Boolean> mustRun() {
        return this.mustRun == null ? Codegen.empty() : this.mustRun;
    }

    /**
     * The name of the container.
     * 
     */
    @Import(name="name")
      private final @Nullable Output<String> name;

    public Output<String> name() {
        return this.name == null ? Codegen.empty() : this.name;
    }

    /**
     * Set an alias for the container in all specified networks
     * 
     * @deprecated
     * Use networks_advanced instead. Will be removed in v3.0.0
     * 
     */
    @Deprecated /* Use networks_advanced instead. Will be removed in v3.0.0 */
    @Import(name="networkAliases")
      private final @Nullable Output<List<String>> networkAliases;

    @Deprecated /* Use networks_advanced instead. Will be removed in v3.0.0 */
    public Output<List<String>> networkAliases() {
        return this.networkAliases == null ? Codegen.empty() : this.networkAliases;
    }

    /**
     * Network mode of the container.
     * 
     */
    @Import(name="networkMode")
      private final @Nullable Output<String> networkMode;

    public Output<String> networkMode() {
        return this.networkMode == null ? Codegen.empty() : this.networkMode;
    }

    /**
     * ID of the networks in which the container is.
     * 
     * @deprecated
     * Use networks_advanced instead. Will be removed in v3.0.0
     * 
     */
    @Deprecated /* Use networks_advanced instead. Will be removed in v3.0.0 */
    @Import(name="networks")
      private final @Nullable Output<List<String>> networks;

    @Deprecated /* Use networks_advanced instead. Will be removed in v3.0.0 */
    public Output<List<String>> networks() {
        return this.networks == null ? Codegen.empty() : this.networks;
    }

    /**
     * The networks the container is attached to
     * 
     */
    @Import(name="networksAdvanced")
      private final @Nullable Output<List<ContainerNetworksAdvancedArgs>> networksAdvanced;

    public Output<List<ContainerNetworksAdvancedArgs>> networksAdvanced() {
        return this.networksAdvanced == null ? Codegen.empty() : this.networksAdvanced;
    }

    /**
     * he PID (Process) Namespace mode for the container. Either `container:&lt;name|id&gt;` or `host`.
     * 
     */
    @Import(name="pidMode")
      private final @Nullable Output<String> pidMode;

    public Output<String> pidMode() {
        return this.pidMode == null ? Codegen.empty() : this.pidMode;
    }

    /**
     * Publish a container&#39;s port(s) to the host.
     * 
     */
    @Import(name="ports")
      private final @Nullable Output<List<ContainerPortArgs>> ports;

    public Output<List<ContainerPortArgs>> ports() {
        return this.ports == null ? Codegen.empty() : this.ports;
    }

    /**
     * If `true`, the container runs in privileged mode.
     * 
     */
    @Import(name="privileged")
      private final @Nullable Output<Boolean> privileged;

    public Output<Boolean> privileged() {
        return this.privileged == null ? Codegen.empty() : this.privileged;
    }

    /**
     * Publish all ports of the container.
     * 
     */
    @Import(name="publishAllPorts")
      private final @Nullable Output<Boolean> publishAllPorts;

    public Output<Boolean> publishAllPorts() {
        return this.publishAllPorts == null ? Codegen.empty() : this.publishAllPorts;
    }

    /**
     * If `true`, the container will be started as readonly. Defaults to `false`.
     * 
     */
    @Import(name="readOnly")
      private final @Nullable Output<Boolean> readOnly;

    public Output<Boolean> readOnly() {
        return this.readOnly == null ? Codegen.empty() : this.readOnly;
    }

    /**
     * If `true`, it will remove anonymous volumes associated with the container. Defaults to `true`.
     * 
     */
    @Import(name="removeVolumes")
      private final @Nullable Output<Boolean> removeVolumes;

    public Output<Boolean> removeVolumes() {
        return this.removeVolumes == null ? Codegen.empty() : this.removeVolumes;
    }

    /**
     * The restart policy for the container. Must be one of &#39;no&#39;, &#39;on-failure&#39;, &#39;always&#39;, &#39;unless-stopped&#39;. Defaults to `no`.
     * 
     */
    @Import(name="restart")
      private final @Nullable Output<String> restart;

    public Output<String> restart() {
        return this.restart == null ? Codegen.empty() : this.restart;
    }

    /**
     * If `true`, then the container will be automatically removed after his execution. Terraform won&#39;t check this container
     * after creation. Defaults to `false`.
     * 
     */
    @Import(name="rm")
      private final @Nullable Output<Boolean> rm;

    public Output<Boolean> rm() {
        return this.rm == null ? Codegen.empty() : this.rm;
    }

    /**
     * List of string values to customize labels for MLS systems, such as SELinux. See
     * https://docs.docker.com/engine/reference/run/#security-configuration.
     * 
     */
    @Import(name="securityOpts")
      private final @Nullable Output<List<String>> securityOpts;

    public Output<List<String>> securityOpts() {
        return this.securityOpts == null ? Codegen.empty() : this.securityOpts;
    }

    /**
     * Size of `/dev/shm` in MBs.
     * 
     */
    @Import(name="shmSize")
      private final @Nullable Output<Integer> shmSize;

    public Output<Integer> shmSize() {
        return this.shmSize == null ? Codegen.empty() : this.shmSize;
    }

    /**
     * If `true`, then the Docker container will be started after creation. If `false`, then the container is only created.
     * Defaults to `true`.
     * 
     */
    @Import(name="start")
      private final @Nullable Output<Boolean> start;

    public Output<Boolean> start() {
        return this.start == null ? Codegen.empty() : this.start;
    }

    /**
     * If `true`, keep STDIN open even if not attached (`docker run -i`). Defaults to `false`.
     * 
     */
    @Import(name="stdinOpen")
      private final @Nullable Output<Boolean> stdinOpen;

    public Output<Boolean> stdinOpen() {
        return this.stdinOpen == null ? Codegen.empty() : this.stdinOpen;
    }

    /**
     * Key/value pairs for the storage driver options, e.g. `size`: `120G`
     * 
     */
    @Import(name="storageOpts")
      private final @Nullable Output<Map<String,Object>> storageOpts;

    public Output<Map<String,Object>> storageOpts() {
        return this.storageOpts == null ? Codegen.empty() : this.storageOpts;
    }

    /**
     * A map of kernel parameters (sysctls) to set in the container.
     * 
     */
    @Import(name="sysctls")
      private final @Nullable Output<Map<String,Object>> sysctls;

    public Output<Map<String,Object>> sysctls() {
        return this.sysctls == null ? Codegen.empty() : this.sysctls;
    }

    /**
     * A map of container directories which should be replaced by `tmpfs mounts`, and their corresponding mount options.
     * 
     */
    @Import(name="tmpfs")
      private final @Nullable Output<Map<String,Object>> tmpfs;

    public Output<Map<String,Object>> tmpfs() {
        return this.tmpfs == null ? Codegen.empty() : this.tmpfs;
    }

    /**
     * If `true`, allocate a pseudo-tty (`docker run -t`). Defaults to `false`.
     * 
     */
    @Import(name="tty")
      private final @Nullable Output<Boolean> tty;

    public Output<Boolean> tty() {
        return this.tty == null ? Codegen.empty() : this.tty;
    }

    /**
     * Ulimit options to add.
     * 
     */
    @Import(name="ulimits")
      private final @Nullable Output<List<ContainerUlimitArgs>> ulimits;

    public Output<List<ContainerUlimitArgs>> ulimits() {
        return this.ulimits == null ? Codegen.empty() : this.ulimits;
    }

    /**
     * Specifies files to upload to the container before starting it. Only one of `content` or `content_base64` can be set and
     * at least one of them has to be set.
     * 
     */
    @Import(name="uploads")
      private final @Nullable Output<List<ContainerUploadArgs>> uploads;

    public Output<List<ContainerUploadArgs>> uploads() {
        return this.uploads == null ? Codegen.empty() : this.uploads;
    }

    /**
     * User used for run the first process. Format is `user` or `user:group` which user and group can be passed literraly or by
     * name.
     * 
     */
    @Import(name="user")
      private final @Nullable Output<String> user;

    public Output<String> user() {
        return this.user == null ? Codegen.empty() : this.user;
    }

    /**
     * Sets the usernamespace mode for the container when usernamespace remapping option is enabled.
     * 
     */
    @Import(name="usernsMode")
      private final @Nullable Output<String> usernsMode;

    public Output<String> usernsMode() {
        return this.usernsMode == null ? Codegen.empty() : this.usernsMode;
    }

    /**
     * Spec for mounting volumes in the container.
     * 
     */
    @Import(name="volumes")
      private final @Nullable Output<List<ContainerVolumeArgs>> volumes;

    public Output<List<ContainerVolumeArgs>> volumes() {
        return this.volumes == null ? Codegen.empty() : this.volumes;
    }

    /**
     * The working directory for commands to run in.
     * 
     */
    @Import(name="workingDir")
      private final @Nullable Output<String> workingDir;

    public Output<String> workingDir() {
        return this.workingDir == null ? Codegen.empty() : this.workingDir;
    }

    public ContainerArgs(
        @Nullable Output<Boolean> attach,
        @Nullable Output<ContainerCapabilitiesArgs> capabilities,
        @Nullable Output<List<String>> command,
        @Nullable Output<String> cpuSet,
        @Nullable Output<Integer> cpuShares,
        @Nullable Output<Integer> destroyGraceSeconds,
        @Nullable Output<List<ContainerDeviceArgs>> devices,
        @Nullable Output<List<String>> dns,
        @Nullable Output<List<String>> dnsOpts,
        @Nullable Output<List<String>> dnsSearches,
        @Nullable Output<String> domainname,
        @Nullable Output<List<String>> entrypoints,
        @Nullable Output<List<String>> envs,
        @Nullable Output<List<String>> groupAdds,
        @Nullable Output<ContainerHealthcheckArgs> healthcheck,
        @Nullable Output<String> hostname,
        @Nullable Output<List<ContainerHostArgs>> hosts,
        Output<String> image,
        @Nullable Output<Boolean> init,
        @Nullable Output<String> ipcMode,
        @Nullable Output<List<ContainerLabelArgs>> labels,
        @Nullable Output<List<String>> links,
        @Nullable Output<String> logDriver,
        @Nullable Output<Map<String,Object>> logOpts,
        @Nullable Output<Boolean> logs,
        @Nullable Output<Integer> maxRetryCount,
        @Nullable Output<Integer> memory,
        @Nullable Output<Integer> memorySwap,
        @Nullable Output<List<ContainerMountArgs>> mounts,
        @Nullable Output<Boolean> mustRun,
        @Nullable Output<String> name,
        @Nullable Output<List<String>> networkAliases,
        @Nullable Output<String> networkMode,
        @Nullable Output<List<String>> networks,
        @Nullable Output<List<ContainerNetworksAdvancedArgs>> networksAdvanced,
        @Nullable Output<String> pidMode,
        @Nullable Output<List<ContainerPortArgs>> ports,
        @Nullable Output<Boolean> privileged,
        @Nullable Output<Boolean> publishAllPorts,
        @Nullable Output<Boolean> readOnly,
        @Nullable Output<Boolean> removeVolumes,
        @Nullable Output<String> restart,
        @Nullable Output<Boolean> rm,
        @Nullable Output<List<String>> securityOpts,
        @Nullable Output<Integer> shmSize,
        @Nullable Output<Boolean> start,
        @Nullable Output<Boolean> stdinOpen,
        @Nullable Output<Map<String,Object>> storageOpts,
        @Nullable Output<Map<String,Object>> sysctls,
        @Nullable Output<Map<String,Object>> tmpfs,
        @Nullable Output<Boolean> tty,
        @Nullable Output<List<ContainerUlimitArgs>> ulimits,
        @Nullable Output<List<ContainerUploadArgs>> uploads,
        @Nullable Output<String> user,
        @Nullable Output<String> usernsMode,
        @Nullable Output<List<ContainerVolumeArgs>> volumes,
        @Nullable Output<String> workingDir) {
        this.attach = attach;
        this.capabilities = capabilities;
        this.command = command;
        this.cpuSet = cpuSet;
        this.cpuShares = cpuShares;
        this.destroyGraceSeconds = destroyGraceSeconds;
        this.devices = devices;
        this.dns = dns;
        this.dnsOpts = dnsOpts;
        this.dnsSearches = dnsSearches;
        this.domainname = domainname;
        this.entrypoints = entrypoints;
        this.envs = envs;
        this.groupAdds = groupAdds;
        this.healthcheck = healthcheck;
        this.hostname = hostname;
        this.hosts = hosts;
        this.image = Objects.requireNonNull(image, "expected parameter 'image' to be non-null");
        this.init = init;
        this.ipcMode = ipcMode;
        this.labels = labels;
        this.links = links;
        this.logDriver = logDriver;
        this.logOpts = logOpts;
        this.logs = logs;
        this.maxRetryCount = maxRetryCount;
        this.memory = memory;
        this.memorySwap = memorySwap;
        this.mounts = mounts;
        this.mustRun = mustRun;
        this.name = name;
        this.networkAliases = networkAliases;
        this.networkMode = networkMode;
        this.networks = networks;
        this.networksAdvanced = networksAdvanced;
        this.pidMode = pidMode;
        this.ports = ports;
        this.privileged = privileged;
        this.publishAllPorts = publishAllPorts;
        this.readOnly = readOnly;
        this.removeVolumes = removeVolumes;
        this.restart = restart;
        this.rm = rm;
        this.securityOpts = securityOpts;
        this.shmSize = shmSize;
        this.start = start;
        this.stdinOpen = stdinOpen;
        this.storageOpts = storageOpts;
        this.sysctls = sysctls;
        this.tmpfs = tmpfs;
        this.tty = tty;
        this.ulimits = ulimits;
        this.uploads = uploads;
        this.user = user;
        this.usernsMode = usernsMode;
        this.volumes = volumes;
        this.workingDir = workingDir;
    }

    private ContainerArgs() {
        this.attach = Codegen.empty();
        this.capabilities = Codegen.empty();
        this.command = Codegen.empty();
        this.cpuSet = Codegen.empty();
        this.cpuShares = Codegen.empty();
        this.destroyGraceSeconds = Codegen.empty();
        this.devices = Codegen.empty();
        this.dns = Codegen.empty();
        this.dnsOpts = Codegen.empty();
        this.dnsSearches = Codegen.empty();
        this.domainname = Codegen.empty();
        this.entrypoints = Codegen.empty();
        this.envs = Codegen.empty();
        this.groupAdds = Codegen.empty();
        this.healthcheck = Codegen.empty();
        this.hostname = Codegen.empty();
        this.hosts = Codegen.empty();
        this.image = Codegen.empty();
        this.init = Codegen.empty();
        this.ipcMode = Codegen.empty();
        this.labels = Codegen.empty();
        this.links = Codegen.empty();
        this.logDriver = Codegen.empty();
        this.logOpts = Codegen.empty();
        this.logs = Codegen.empty();
        this.maxRetryCount = Codegen.empty();
        this.memory = Codegen.empty();
        this.memorySwap = Codegen.empty();
        this.mounts = Codegen.empty();
        this.mustRun = Codegen.empty();
        this.name = Codegen.empty();
        this.networkAliases = Codegen.empty();
        this.networkMode = Codegen.empty();
        this.networks = Codegen.empty();
        this.networksAdvanced = Codegen.empty();
        this.pidMode = Codegen.empty();
        this.ports = Codegen.empty();
        this.privileged = Codegen.empty();
        this.publishAllPorts = Codegen.empty();
        this.readOnly = Codegen.empty();
        this.removeVolumes = Codegen.empty();
        this.restart = Codegen.empty();
        this.rm = Codegen.empty();
        this.securityOpts = Codegen.empty();
        this.shmSize = Codegen.empty();
        this.start = Codegen.empty();
        this.stdinOpen = Codegen.empty();
        this.storageOpts = Codegen.empty();
        this.sysctls = Codegen.empty();
        this.tmpfs = Codegen.empty();
        this.tty = Codegen.empty();
        this.ulimits = Codegen.empty();
        this.uploads = Codegen.empty();
        this.user = Codegen.empty();
        this.usernsMode = Codegen.empty();
        this.volumes = Codegen.empty();
        this.workingDir = Codegen.empty();
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(ContainerArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private @Nullable Output<Boolean> attach;
        private @Nullable Output<ContainerCapabilitiesArgs> capabilities;
        private @Nullable Output<List<String>> command;
        private @Nullable Output<String> cpuSet;
        private @Nullable Output<Integer> cpuShares;
        private @Nullable Output<Integer> destroyGraceSeconds;
        private @Nullable Output<List<ContainerDeviceArgs>> devices;
        private @Nullable Output<List<String>> dns;
        private @Nullable Output<List<String>> dnsOpts;
        private @Nullable Output<List<String>> dnsSearches;
        private @Nullable Output<String> domainname;
        private @Nullable Output<List<String>> entrypoints;
        private @Nullable Output<List<String>> envs;
        private @Nullable Output<List<String>> groupAdds;
        private @Nullable Output<ContainerHealthcheckArgs> healthcheck;
        private @Nullable Output<String> hostname;
        private @Nullable Output<List<ContainerHostArgs>> hosts;
        private Output<String> image;
        private @Nullable Output<Boolean> init;
        private @Nullable Output<String> ipcMode;
        private @Nullable Output<List<ContainerLabelArgs>> labels;
        private @Nullable Output<List<String>> links;
        private @Nullable Output<String> logDriver;
        private @Nullable Output<Map<String,Object>> logOpts;
        private @Nullable Output<Boolean> logs;
        private @Nullable Output<Integer> maxRetryCount;
        private @Nullable Output<Integer> memory;
        private @Nullable Output<Integer> memorySwap;
        private @Nullable Output<List<ContainerMountArgs>> mounts;
        private @Nullable Output<Boolean> mustRun;
        private @Nullable Output<String> name;
        private @Nullable Output<List<String>> networkAliases;
        private @Nullable Output<String> networkMode;
        private @Nullable Output<List<String>> networks;
        private @Nullable Output<List<ContainerNetworksAdvancedArgs>> networksAdvanced;
        private @Nullable Output<String> pidMode;
        private @Nullable Output<List<ContainerPortArgs>> ports;
        private @Nullable Output<Boolean> privileged;
        private @Nullable Output<Boolean> publishAllPorts;
        private @Nullable Output<Boolean> readOnly;
        private @Nullable Output<Boolean> removeVolumes;
        private @Nullable Output<String> restart;
        private @Nullable Output<Boolean> rm;
        private @Nullable Output<List<String>> securityOpts;
        private @Nullable Output<Integer> shmSize;
        private @Nullable Output<Boolean> start;
        private @Nullable Output<Boolean> stdinOpen;
        private @Nullable Output<Map<String,Object>> storageOpts;
        private @Nullable Output<Map<String,Object>> sysctls;
        private @Nullable Output<Map<String,Object>> tmpfs;
        private @Nullable Output<Boolean> tty;
        private @Nullable Output<List<ContainerUlimitArgs>> ulimits;
        private @Nullable Output<List<ContainerUploadArgs>> uploads;
        private @Nullable Output<String> user;
        private @Nullable Output<String> usernsMode;
        private @Nullable Output<List<ContainerVolumeArgs>> volumes;
        private @Nullable Output<String> workingDir;

        public Builder() {
    	      // Empty
        }

        public Builder(ContainerArgs defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.attach = defaults.attach;
    	      this.capabilities = defaults.capabilities;
    	      this.command = defaults.command;
    	      this.cpuSet = defaults.cpuSet;
    	      this.cpuShares = defaults.cpuShares;
    	      this.destroyGraceSeconds = defaults.destroyGraceSeconds;
    	      this.devices = defaults.devices;
    	      this.dns = defaults.dns;
    	      this.dnsOpts = defaults.dnsOpts;
    	      this.dnsSearches = defaults.dnsSearches;
    	      this.domainname = defaults.domainname;
    	      this.entrypoints = defaults.entrypoints;
    	      this.envs = defaults.envs;
    	      this.groupAdds = defaults.groupAdds;
    	      this.healthcheck = defaults.healthcheck;
    	      this.hostname = defaults.hostname;
    	      this.hosts = defaults.hosts;
    	      this.image = defaults.image;
    	      this.init = defaults.init;
    	      this.ipcMode = defaults.ipcMode;
    	      this.labels = defaults.labels;
    	      this.links = defaults.links;
    	      this.logDriver = defaults.logDriver;
    	      this.logOpts = defaults.logOpts;
    	      this.logs = defaults.logs;
    	      this.maxRetryCount = defaults.maxRetryCount;
    	      this.memory = defaults.memory;
    	      this.memorySwap = defaults.memorySwap;
    	      this.mounts = defaults.mounts;
    	      this.mustRun = defaults.mustRun;
    	      this.name = defaults.name;
    	      this.networkAliases = defaults.networkAliases;
    	      this.networkMode = defaults.networkMode;
    	      this.networks = defaults.networks;
    	      this.networksAdvanced = defaults.networksAdvanced;
    	      this.pidMode = defaults.pidMode;
    	      this.ports = defaults.ports;
    	      this.privileged = defaults.privileged;
    	      this.publishAllPorts = defaults.publishAllPorts;
    	      this.readOnly = defaults.readOnly;
    	      this.removeVolumes = defaults.removeVolumes;
    	      this.restart = defaults.restart;
    	      this.rm = defaults.rm;
    	      this.securityOpts = defaults.securityOpts;
    	      this.shmSize = defaults.shmSize;
    	      this.start = defaults.start;
    	      this.stdinOpen = defaults.stdinOpen;
    	      this.storageOpts = defaults.storageOpts;
    	      this.sysctls = defaults.sysctls;
    	      this.tmpfs = defaults.tmpfs;
    	      this.tty = defaults.tty;
    	      this.ulimits = defaults.ulimits;
    	      this.uploads = defaults.uploads;
    	      this.user = defaults.user;
    	      this.usernsMode = defaults.usernsMode;
    	      this.volumes = defaults.volumes;
    	      this.workingDir = defaults.workingDir;
        }

        public Builder attach(@Nullable Output<Boolean> attach) {
            this.attach = attach;
            return this;
        }
        public Builder attach(@Nullable Boolean attach) {
            this.attach = Codegen.ofNullable(attach);
            return this;
        }
        public Builder capabilities(@Nullable Output<ContainerCapabilitiesArgs> capabilities) {
            this.capabilities = capabilities;
            return this;
        }
        public Builder capabilities(@Nullable ContainerCapabilitiesArgs capabilities) {
            this.capabilities = Codegen.ofNullable(capabilities);
            return this;
        }
        public Builder command(@Nullable Output<List<String>> command) {
            this.command = command;
            return this;
        }
        public Builder command(@Nullable List<String> command) {
            this.command = Codegen.ofNullable(command);
            return this;
        }
        public Builder command(String... command) {
            return command(List.of(command));
        }
        public Builder cpuSet(@Nullable Output<String> cpuSet) {
            this.cpuSet = cpuSet;
            return this;
        }
        public Builder cpuSet(@Nullable String cpuSet) {
            this.cpuSet = Codegen.ofNullable(cpuSet);
            return this;
        }
        public Builder cpuShares(@Nullable Output<Integer> cpuShares) {
            this.cpuShares = cpuShares;
            return this;
        }
        public Builder cpuShares(@Nullable Integer cpuShares) {
            this.cpuShares = Codegen.ofNullable(cpuShares);
            return this;
        }
        public Builder destroyGraceSeconds(@Nullable Output<Integer> destroyGraceSeconds) {
            this.destroyGraceSeconds = destroyGraceSeconds;
            return this;
        }
        public Builder destroyGraceSeconds(@Nullable Integer destroyGraceSeconds) {
            this.destroyGraceSeconds = Codegen.ofNullable(destroyGraceSeconds);
            return this;
        }
        public Builder devices(@Nullable Output<List<ContainerDeviceArgs>> devices) {
            this.devices = devices;
            return this;
        }
        public Builder devices(@Nullable List<ContainerDeviceArgs> devices) {
            this.devices = Codegen.ofNullable(devices);
            return this;
        }
        public Builder devices(ContainerDeviceArgs... devices) {
            return devices(List.of(devices));
        }
        public Builder dns(@Nullable Output<List<String>> dns) {
            this.dns = dns;
            return this;
        }
        public Builder dns(@Nullable List<String> dns) {
            this.dns = Codegen.ofNullable(dns);
            return this;
        }
        public Builder dns(String... dns) {
            return dns(List.of(dns));
        }
        public Builder dnsOpts(@Nullable Output<List<String>> dnsOpts) {
            this.dnsOpts = dnsOpts;
            return this;
        }
        public Builder dnsOpts(@Nullable List<String> dnsOpts) {
            this.dnsOpts = Codegen.ofNullable(dnsOpts);
            return this;
        }
        public Builder dnsOpts(String... dnsOpts) {
            return dnsOpts(List.of(dnsOpts));
        }
        public Builder dnsSearches(@Nullable Output<List<String>> dnsSearches) {
            this.dnsSearches = dnsSearches;
            return this;
        }
        public Builder dnsSearches(@Nullable List<String> dnsSearches) {
            this.dnsSearches = Codegen.ofNullable(dnsSearches);
            return this;
        }
        public Builder dnsSearches(String... dnsSearches) {
            return dnsSearches(List.of(dnsSearches));
        }
        public Builder domainname(@Nullable Output<String> domainname) {
            this.domainname = domainname;
            return this;
        }
        public Builder domainname(@Nullable String domainname) {
            this.domainname = Codegen.ofNullable(domainname);
            return this;
        }
        public Builder entrypoints(@Nullable Output<List<String>> entrypoints) {
            this.entrypoints = entrypoints;
            return this;
        }
        public Builder entrypoints(@Nullable List<String> entrypoints) {
            this.entrypoints = Codegen.ofNullable(entrypoints);
            return this;
        }
        public Builder entrypoints(String... entrypoints) {
            return entrypoints(List.of(entrypoints));
        }
        public Builder envs(@Nullable Output<List<String>> envs) {
            this.envs = envs;
            return this;
        }
        public Builder envs(@Nullable List<String> envs) {
            this.envs = Codegen.ofNullable(envs);
            return this;
        }
        public Builder envs(String... envs) {
            return envs(List.of(envs));
        }
        public Builder groupAdds(@Nullable Output<List<String>> groupAdds) {
            this.groupAdds = groupAdds;
            return this;
        }
        public Builder groupAdds(@Nullable List<String> groupAdds) {
            this.groupAdds = Codegen.ofNullable(groupAdds);
            return this;
        }
        public Builder groupAdds(String... groupAdds) {
            return groupAdds(List.of(groupAdds));
        }
        public Builder healthcheck(@Nullable Output<ContainerHealthcheckArgs> healthcheck) {
            this.healthcheck = healthcheck;
            return this;
        }
        public Builder healthcheck(@Nullable ContainerHealthcheckArgs healthcheck) {
            this.healthcheck = Codegen.ofNullable(healthcheck);
            return this;
        }
        public Builder hostname(@Nullable Output<String> hostname) {
            this.hostname = hostname;
            return this;
        }
        public Builder hostname(@Nullable String hostname) {
            this.hostname = Codegen.ofNullable(hostname);
            return this;
        }
        public Builder hosts(@Nullable Output<List<ContainerHostArgs>> hosts) {
            this.hosts = hosts;
            return this;
        }
        public Builder hosts(@Nullable List<ContainerHostArgs> hosts) {
            this.hosts = Codegen.ofNullable(hosts);
            return this;
        }
        public Builder hosts(ContainerHostArgs... hosts) {
            return hosts(List.of(hosts));
        }
        public Builder image(Output<String> image) {
            this.image = Objects.requireNonNull(image);
            return this;
        }
        public Builder image(String image) {
            this.image = Output.of(Objects.requireNonNull(image));
            return this;
        }
        public Builder init(@Nullable Output<Boolean> init) {
            this.init = init;
            return this;
        }
        public Builder init(@Nullable Boolean init) {
            this.init = Codegen.ofNullable(init);
            return this;
        }
        public Builder ipcMode(@Nullable Output<String> ipcMode) {
            this.ipcMode = ipcMode;
            return this;
        }
        public Builder ipcMode(@Nullable String ipcMode) {
            this.ipcMode = Codegen.ofNullable(ipcMode);
            return this;
        }
        public Builder labels(@Nullable Output<List<ContainerLabelArgs>> labels) {
            this.labels = labels;
            return this;
        }
        public Builder labels(@Nullable List<ContainerLabelArgs> labels) {
            this.labels = Codegen.ofNullable(labels);
            return this;
        }
        public Builder labels(ContainerLabelArgs... labels) {
            return labels(List.of(labels));
        }
        public Builder links(@Nullable Output<List<String>> links) {
            this.links = links;
            return this;
        }
        public Builder links(@Nullable List<String> links) {
            this.links = Codegen.ofNullable(links);
            return this;
        }
        public Builder links(String... links) {
            return links(List.of(links));
        }
        public Builder logDriver(@Nullable Output<String> logDriver) {
            this.logDriver = logDriver;
            return this;
        }
        public Builder logDriver(@Nullable String logDriver) {
            this.logDriver = Codegen.ofNullable(logDriver);
            return this;
        }
        public Builder logOpts(@Nullable Output<Map<String,Object>> logOpts) {
            this.logOpts = logOpts;
            return this;
        }
        public Builder logOpts(@Nullable Map<String,Object> logOpts) {
            this.logOpts = Codegen.ofNullable(logOpts);
            return this;
        }
        public Builder logs(@Nullable Output<Boolean> logs) {
            this.logs = logs;
            return this;
        }
        public Builder logs(@Nullable Boolean logs) {
            this.logs = Codegen.ofNullable(logs);
            return this;
        }
        public Builder maxRetryCount(@Nullable Output<Integer> maxRetryCount) {
            this.maxRetryCount = maxRetryCount;
            return this;
        }
        public Builder maxRetryCount(@Nullable Integer maxRetryCount) {
            this.maxRetryCount = Codegen.ofNullable(maxRetryCount);
            return this;
        }
        public Builder memory(@Nullable Output<Integer> memory) {
            this.memory = memory;
            return this;
        }
        public Builder memory(@Nullable Integer memory) {
            this.memory = Codegen.ofNullable(memory);
            return this;
        }
        public Builder memorySwap(@Nullable Output<Integer> memorySwap) {
            this.memorySwap = memorySwap;
            return this;
        }
        public Builder memorySwap(@Nullable Integer memorySwap) {
            this.memorySwap = Codegen.ofNullable(memorySwap);
            return this;
        }
        public Builder mounts(@Nullable Output<List<ContainerMountArgs>> mounts) {
            this.mounts = mounts;
            return this;
        }
        public Builder mounts(@Nullable List<ContainerMountArgs> mounts) {
            this.mounts = Codegen.ofNullable(mounts);
            return this;
        }
        public Builder mounts(ContainerMountArgs... mounts) {
            return mounts(List.of(mounts));
        }
        public Builder mustRun(@Nullable Output<Boolean> mustRun) {
            this.mustRun = mustRun;
            return this;
        }
        public Builder mustRun(@Nullable Boolean mustRun) {
            this.mustRun = Codegen.ofNullable(mustRun);
            return this;
        }
        public Builder name(@Nullable Output<String> name) {
            this.name = name;
            return this;
        }
        public Builder name(@Nullable String name) {
            this.name = Codegen.ofNullable(name);
            return this;
        }
        public Builder networkAliases(@Nullable Output<List<String>> networkAliases) {
            this.networkAliases = networkAliases;
            return this;
        }
        public Builder networkAliases(@Nullable List<String> networkAliases) {
            this.networkAliases = Codegen.ofNullable(networkAliases);
            return this;
        }
        public Builder networkAliases(String... networkAliases) {
            return networkAliases(List.of(networkAliases));
        }
        public Builder networkMode(@Nullable Output<String> networkMode) {
            this.networkMode = networkMode;
            return this;
        }
        public Builder networkMode(@Nullable String networkMode) {
            this.networkMode = Codegen.ofNullable(networkMode);
            return this;
        }
        public Builder networks(@Nullable Output<List<String>> networks) {
            this.networks = networks;
            return this;
        }
        public Builder networks(@Nullable List<String> networks) {
            this.networks = Codegen.ofNullable(networks);
            return this;
        }
        public Builder networks(String... networks) {
            return networks(List.of(networks));
        }
        public Builder networksAdvanced(@Nullable Output<List<ContainerNetworksAdvancedArgs>> networksAdvanced) {
            this.networksAdvanced = networksAdvanced;
            return this;
        }
        public Builder networksAdvanced(@Nullable List<ContainerNetworksAdvancedArgs> networksAdvanced) {
            this.networksAdvanced = Codegen.ofNullable(networksAdvanced);
            return this;
        }
        public Builder networksAdvanced(ContainerNetworksAdvancedArgs... networksAdvanced) {
            return networksAdvanced(List.of(networksAdvanced));
        }
        public Builder pidMode(@Nullable Output<String> pidMode) {
            this.pidMode = pidMode;
            return this;
        }
        public Builder pidMode(@Nullable String pidMode) {
            this.pidMode = Codegen.ofNullable(pidMode);
            return this;
        }
        public Builder ports(@Nullable Output<List<ContainerPortArgs>> ports) {
            this.ports = ports;
            return this;
        }
        public Builder ports(@Nullable List<ContainerPortArgs> ports) {
            this.ports = Codegen.ofNullable(ports);
            return this;
        }
        public Builder ports(ContainerPortArgs... ports) {
            return ports(List.of(ports));
        }
        public Builder privileged(@Nullable Output<Boolean> privileged) {
            this.privileged = privileged;
            return this;
        }
        public Builder privileged(@Nullable Boolean privileged) {
            this.privileged = Codegen.ofNullable(privileged);
            return this;
        }
        public Builder publishAllPorts(@Nullable Output<Boolean> publishAllPorts) {
            this.publishAllPorts = publishAllPorts;
            return this;
        }
        public Builder publishAllPorts(@Nullable Boolean publishAllPorts) {
            this.publishAllPorts = Codegen.ofNullable(publishAllPorts);
            return this;
        }
        public Builder readOnly(@Nullable Output<Boolean> readOnly) {
            this.readOnly = readOnly;
            return this;
        }
        public Builder readOnly(@Nullable Boolean readOnly) {
            this.readOnly = Codegen.ofNullable(readOnly);
            return this;
        }
        public Builder removeVolumes(@Nullable Output<Boolean> removeVolumes) {
            this.removeVolumes = removeVolumes;
            return this;
        }
        public Builder removeVolumes(@Nullable Boolean removeVolumes) {
            this.removeVolumes = Codegen.ofNullable(removeVolumes);
            return this;
        }
        public Builder restart(@Nullable Output<String> restart) {
            this.restart = restart;
            return this;
        }
        public Builder restart(@Nullable String restart) {
            this.restart = Codegen.ofNullable(restart);
            return this;
        }
        public Builder rm(@Nullable Output<Boolean> rm) {
            this.rm = rm;
            return this;
        }
        public Builder rm(@Nullable Boolean rm) {
            this.rm = Codegen.ofNullable(rm);
            return this;
        }
        public Builder securityOpts(@Nullable Output<List<String>> securityOpts) {
            this.securityOpts = securityOpts;
            return this;
        }
        public Builder securityOpts(@Nullable List<String> securityOpts) {
            this.securityOpts = Codegen.ofNullable(securityOpts);
            return this;
        }
        public Builder securityOpts(String... securityOpts) {
            return securityOpts(List.of(securityOpts));
        }
        public Builder shmSize(@Nullable Output<Integer> shmSize) {
            this.shmSize = shmSize;
            return this;
        }
        public Builder shmSize(@Nullable Integer shmSize) {
            this.shmSize = Codegen.ofNullable(shmSize);
            return this;
        }
        public Builder start(@Nullable Output<Boolean> start) {
            this.start = start;
            return this;
        }
        public Builder start(@Nullable Boolean start) {
            this.start = Codegen.ofNullable(start);
            return this;
        }
        public Builder stdinOpen(@Nullable Output<Boolean> stdinOpen) {
            this.stdinOpen = stdinOpen;
            return this;
        }
        public Builder stdinOpen(@Nullable Boolean stdinOpen) {
            this.stdinOpen = Codegen.ofNullable(stdinOpen);
            return this;
        }
        public Builder storageOpts(@Nullable Output<Map<String,Object>> storageOpts) {
            this.storageOpts = storageOpts;
            return this;
        }
        public Builder storageOpts(@Nullable Map<String,Object> storageOpts) {
            this.storageOpts = Codegen.ofNullable(storageOpts);
            return this;
        }
        public Builder sysctls(@Nullable Output<Map<String,Object>> sysctls) {
            this.sysctls = sysctls;
            return this;
        }
        public Builder sysctls(@Nullable Map<String,Object> sysctls) {
            this.sysctls = Codegen.ofNullable(sysctls);
            return this;
        }
        public Builder tmpfs(@Nullable Output<Map<String,Object>> tmpfs) {
            this.tmpfs = tmpfs;
            return this;
        }
        public Builder tmpfs(@Nullable Map<String,Object> tmpfs) {
            this.tmpfs = Codegen.ofNullable(tmpfs);
            return this;
        }
        public Builder tty(@Nullable Output<Boolean> tty) {
            this.tty = tty;
            return this;
        }
        public Builder tty(@Nullable Boolean tty) {
            this.tty = Codegen.ofNullable(tty);
            return this;
        }
        public Builder ulimits(@Nullable Output<List<ContainerUlimitArgs>> ulimits) {
            this.ulimits = ulimits;
            return this;
        }
        public Builder ulimits(@Nullable List<ContainerUlimitArgs> ulimits) {
            this.ulimits = Codegen.ofNullable(ulimits);
            return this;
        }
        public Builder ulimits(ContainerUlimitArgs... ulimits) {
            return ulimits(List.of(ulimits));
        }
        public Builder uploads(@Nullable Output<List<ContainerUploadArgs>> uploads) {
            this.uploads = uploads;
            return this;
        }
        public Builder uploads(@Nullable List<ContainerUploadArgs> uploads) {
            this.uploads = Codegen.ofNullable(uploads);
            return this;
        }
        public Builder uploads(ContainerUploadArgs... uploads) {
            return uploads(List.of(uploads));
        }
        public Builder user(@Nullable Output<String> user) {
            this.user = user;
            return this;
        }
        public Builder user(@Nullable String user) {
            this.user = Codegen.ofNullable(user);
            return this;
        }
        public Builder usernsMode(@Nullable Output<String> usernsMode) {
            this.usernsMode = usernsMode;
            return this;
        }
        public Builder usernsMode(@Nullable String usernsMode) {
            this.usernsMode = Codegen.ofNullable(usernsMode);
            return this;
        }
        public Builder volumes(@Nullable Output<List<ContainerVolumeArgs>> volumes) {
            this.volumes = volumes;
            return this;
        }
        public Builder volumes(@Nullable List<ContainerVolumeArgs> volumes) {
            this.volumes = Codegen.ofNullable(volumes);
            return this;
        }
        public Builder volumes(ContainerVolumeArgs... volumes) {
            return volumes(List.of(volumes));
        }
        public Builder workingDir(@Nullable Output<String> workingDir) {
            this.workingDir = workingDir;
            return this;
        }
        public Builder workingDir(@Nullable String workingDir) {
            this.workingDir = Codegen.ofNullable(workingDir);
            return this;
        }        public ContainerArgs build() {
            return new ContainerArgs(attach, capabilities, command, cpuSet, cpuShares, destroyGraceSeconds, devices, dns, dnsOpts, dnsSearches, domainname, entrypoints, envs, groupAdds, healthcheck, hostname, hosts, image, init, ipcMode, labels, links, logDriver, logOpts, logs, maxRetryCount, memory, memorySwap, mounts, mustRun, name, networkAliases, networkMode, networks, networksAdvanced, pidMode, ports, privileged, publishAllPorts, readOnly, removeVolumes, restart, rm, securityOpts, shmSize, start, stdinOpen, storageOpts, sysctls, tmpfs, tty, ulimits, uploads, user, usernsMode, volumes, workingDir);
        }
    }
}
