package com.pulumi.core.internal;

import com.pulumi.core.internal.annotations.InternalUse;
import com.pulumi.deployment.DeploymentInstance;
import com.pulumi.deployment.internal.DeploymentInstanceHolder;

import javax.annotation.Nonnull;
import java.util.concurrent.*;
import java.util.function.*;

/// The Java language host relies on ambient authority to make the Deployment context available to programs.
/// This has to be implemented as some thread-local state.
/// However, the system heavily uses asynchronous patterns, which are not bound to a single thread.
/// This class wraps the usual CompletableFuture and implements the propagation of the ambient state from thread to
/// thread,
///
/// Any code that wants to queue async activities should use the helpers in this class, not CompletableFuture:
///
/// * runAsync
/// * supplyAsync
///
/// When a CompletableFuture is generated by external libraries, we should call ContextAwareCompletableFuture.wrap()
/// to get a context-aware version of it.
@InternalUse
public class ContextAwareCompletableFuture<T> extends CompletableFuture<T>
{
    private final DeploymentInstance   context;
    private final CompletableFuture<T> future;

    private ContextAwareCompletableFuture(DeploymentInstance context,
                                          CompletableFuture<T> future)
    {
        this.context = context;
        this.future = future;
    }

    private void link()
    {
        future.whenComplete((v, t) ->
                            {
                                if (t != null)
                                {
                                    this.completeExceptionally(t);
                                }
                                else
                                {
                                    this.complete(v);
                                }
                            });
    }

    public static <T> CompletableFuture<T> wrap(CompletableFuture<T> future)
    {
        var context = DeploymentInstanceHolder.getInstanceNoThrow();
        if (context == null)
        {
            return future;
        }

        if (future instanceof ContextAwareCompletableFuture)
        {
            return future;
        }

        var wrapped = new ContextAwareCompletableFuture<>(context, future);
        wrapped.link();
        return wrapped;
    }

    private <U> CompletableFuture<U> wrapIfNeeded(CompletableFuture<U> future)
    {
        if (future instanceof ContextAwareCompletableFuture)
        {
            return future;
        }

        var wrapped = new ContextAwareCompletableFuture<>(context, future);
        wrapped.link();
        return wrapped;
    }

    private static <T> Supplier<T> wrap(Supplier<T> callback)
    {
        var context = DeploymentInstanceHolder.getInstanceNoThrow();
        if (context == null)
        {
            return callback;
        }

        return () ->
        {
            DeploymentInstanceHolder.setInstance(context);
            try
            {
                return callback.get();
            }
            finally
            {
                DeploymentInstanceHolder.setInstance(null);
            }
        };
    }

    private static Runnable wrap(Runnable callback)
    {
        var context = DeploymentInstanceHolder.getInstanceNoThrow();
        if (context == null)
        {
            return callback;
        }

        return () ->
        {
            DeploymentInstanceHolder.setInstance(context);
            try
            {
                callback.run();
            }
            finally
            {
                DeploymentInstanceHolder.setInstance(null);
            }
        };
    }

    public static <U> CompletableFuture<U> completedFuture(U value)
    {
        return wrap(CompletableFuture.completedFuture(value));
    }

    public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier)
    {
        supplier = wrap(supplier);
        var future = CompletableFuture.supplyAsync(supplier);
        return wrap(future);
    }

    public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier,
                                                       Executor executor)
    {
        supplier = wrap(supplier);
        var future = CompletableFuture.supplyAsync(supplier, executor);
        return wrap(future);
    }

    public static CompletableFuture<Void> runAsync(Runnable runnable)
    {
        runnable = wrap(runnable);
        var future = CompletableFuture.runAsync(runnable);
        return wrap(future);
    }

    @Nonnull
    public static CompletableFuture<Void> runAsync(Runnable runnable,
                                                   Executor executor)
    {
        runnable = wrap(runnable);
        var future = CompletableFuture.runAsync(runnable, executor);
        return wrap(future);
    }

    @Override
    public T get() throws InterruptedException, ExecutionException
    {
        DeploymentInstanceHolder.setInstance(context);
        return super.get();
    }

    @Override
    public T get(long timeout,
                 TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException
    {
        DeploymentInstanceHolder.setInstance(context);
        return super.get(timeout, unit);
    }

    @Override
    public T join()
    {
        return super.join();
    }

    @Override
    public T getNow(T valueIfAbsent)
    {
        DeploymentInstanceHolder.setInstance(context);
        return super.getNow(valueIfAbsent);
    }

    @Override
    public boolean complete(T value)
    {
        DeploymentInstanceHolder.setInstance(context);
        return super.complete(value);
    }

    @Override
    public boolean completeExceptionally(Throwable ex)
    {
        DeploymentInstanceHolder.setInstance(context);
        return super.completeExceptionally(ex);
    }

    @Override
    @Nonnull
    public <U> CompletableFuture<U> thenApply(@Nonnull Function<? super T, ? extends U> fn)
    {
        CompletableFuture<U> inner = super.thenApply(v ->
                                                     {
                                                         DeploymentInstanceHolder.setInstance(context);
                                                         return fn.apply(v);
                                                     });

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public <U> CompletableFuture<U> thenApplyAsync(@Nonnull Function<? super T, ? extends U> fn)
    {
        return thenApplyAsync(fn, defaultExecutor());
    }

    @Override
    @Nonnull
    public <U> CompletableFuture<U> thenApplyAsync(@Nonnull Function<? super T, ? extends U> fn,
                                                   Executor executor)
    {
        CompletableFuture<U> inner = super.thenApplyAsync(v ->
                                                          {
                                                              DeploymentInstanceHolder.setInstance(context);
                                                              return fn.apply(v);
                                                          }, executor);

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public CompletableFuture<Void> thenAccept(@Nonnull Consumer<? super T> action)
    {
        var inner = super.thenAccept(v ->
                                     {
                                         DeploymentInstanceHolder.setInstance(context);
                                         action.accept(v);
                                     });

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public CompletableFuture<Void> thenAcceptAsync(@Nonnull Consumer<? super T> action)
    {
        return thenAcceptAsync(action, defaultExecutor());
    }

    @Override
    @Nonnull
    public CompletableFuture<Void> thenAcceptAsync(@Nonnull Consumer<? super T> action,
                                                   Executor executor)
    {
        var inner = super.thenAcceptAsync(v ->
                                          {
                                              DeploymentInstanceHolder.setInstance(context);
                                              action.accept(v);
                                          }, executor);

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public CompletableFuture<Void> thenRun(@Nonnull Runnable action)
    {
        var inner = super.thenRun(() ->
                                  {
                                      DeploymentInstanceHolder.setInstance(context);
                                      action.run();
                                  });

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public CompletableFuture<Void> thenRunAsync(@Nonnull Runnable action)
    {
        return thenRunAsync(action, defaultExecutor());
    }

    @Override
    @Nonnull
    public CompletableFuture<Void> thenRunAsync(@Nonnull Runnable action,
                                                Executor executor)
    {
        var inner = super.thenRunAsync(() ->
                                       {
                                           DeploymentInstanceHolder.setInstance(context);
                                           action.run();
                                       }, executor);

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public <U, V> CompletableFuture<V> thenCombine(@Nonnull CompletionStage<? extends U> other,
                                                   @Nonnull BiFunction<? super T, ? super U, ? extends V> fn)
    {
        CompletableFuture<V> inner = super.thenCombine(other, (v, t) ->
        {
            DeploymentInstanceHolder.setInstance(context);
            return fn.apply(v, t);
        });

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public <U, V> CompletableFuture<V> thenCombineAsync(@Nonnull CompletionStage<? extends U> other,
                                                        @Nonnull BiFunction<? super T, ? super U, ? extends V> fn)
    {
        return thenCombineAsync(other, fn, defaultExecutor());
    }

    @Override
    @Nonnull
    public <U, V> CompletableFuture<V> thenCombineAsync(@Nonnull CompletionStage<? extends U> other,
                                                        @Nonnull BiFunction<? super T, ? super U, ? extends V> fn,
                                                        Executor executor)
    {
        CompletableFuture<V> inner = super.thenCombineAsync(other, (v, t) ->
        {
            DeploymentInstanceHolder.setInstance(context);
            return fn.apply(v, t);
        }, executor);

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public <U> CompletableFuture<Void> thenAcceptBoth(@Nonnull CompletionStage<? extends U> other,
                                                      @Nonnull BiConsumer<? super T, ? super U> action)
    {
        CompletableFuture<Void> inner = super.thenAcceptBoth(other, (v, t) ->
        {
            DeploymentInstanceHolder.setInstance(context);
            action.accept(v, t);
        });

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public <U> CompletableFuture<Void> thenAcceptBothAsync(@Nonnull CompletionStage<? extends U> other,
                                                           @Nonnull BiConsumer<? super T, ? super U> action)
    {
        return thenAcceptBothAsync(other, action, defaultExecutor());
    }

    @Override
    @Nonnull
    public <U> CompletableFuture<Void> thenAcceptBothAsync(@Nonnull CompletionStage<? extends U> other,
                                                           @Nonnull BiConsumer<? super T, ? super U> action,
                                                           Executor executor)
    {
        CompletableFuture<Void> inner = super.thenAcceptBothAsync(other, (v, t) ->
        {
            DeploymentInstanceHolder.setInstance(context);
            action.accept(v, t);
        }, executor);

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public CompletableFuture<Void> runAfterBoth(@Nonnull CompletionStage<?> other,
                                                @Nonnull Runnable action)
    {
        CompletableFuture<Void> inner = super.runAfterBoth(other, () ->
        {
            DeploymentInstanceHolder.setInstance(context);
            action.run();
        });

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public CompletableFuture<Void> runAfterBothAsync(@Nonnull CompletionStage<?> other,
                                                     @Nonnull Runnable action)
    {
        return runAfterBothAsync(other, action, defaultExecutor());
    }

    @Override
    @Nonnull
    public CompletableFuture<Void> runAfterBothAsync(@Nonnull CompletionStage<?> other,
                                                     @Nonnull Runnable action,
                                                     Executor executor)
    {
        CompletableFuture<Void> inner = super.runAfterBothAsync(other, () ->
        {
            DeploymentInstanceHolder.setInstance(context);
            action.run();
        }, executor);

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public <U> CompletableFuture<U> applyToEither(@Nonnull CompletionStage<? extends T> other,
                                                  @Nonnull Function<? super T, U> fn)
    {
        CompletableFuture<U> inner = super.applyToEither(other, v ->
        {
            DeploymentInstanceHolder.setInstance(context);
            return fn.apply(v);
        });

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public <U> CompletableFuture<U> applyToEitherAsync(@Nonnull CompletionStage<? extends T> other,
                                                       @Nonnull Function<? super T, U> fn)
    {
        return applyToEitherAsync(other, fn, defaultExecutor());
    }

    @Override
    @Nonnull
    public <U> CompletableFuture<U> applyToEitherAsync(@Nonnull CompletionStage<? extends T> other,
                                                       @Nonnull Function<? super T, U> fn,
                                                       Executor executor)
    {
        CompletableFuture<U> inner = super.applyToEitherAsync(other, v ->
        {
            DeploymentInstanceHolder.setInstance(context);
            return fn.apply(v);
        }, executor);

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public CompletableFuture<Void> acceptEither(@Nonnull CompletionStage<? extends T> other,
                                                @Nonnull Consumer<? super T> action)
    {
        CompletableFuture<Void> inner = super.acceptEither(other, v ->
        {
            DeploymentInstanceHolder.setInstance(context);
            action.accept(v);
        });

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public CompletableFuture<Void> acceptEitherAsync(@Nonnull CompletionStage<? extends T> other,
                                                     @Nonnull Consumer<? super T> action)
    {
        return acceptEitherAsync(other, action, defaultExecutor());
    }

    @Override
    @Nonnull
    public CompletableFuture<Void> acceptEitherAsync(@Nonnull CompletionStage<? extends T> other,
                                                     @Nonnull Consumer<? super T> action,
                                                     Executor executor)
    {
        CompletableFuture<Void> inner = super.acceptEitherAsync(other, v ->
        {
            DeploymentInstanceHolder.setInstance(context);
            action.accept(v);
        }, executor);

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public CompletableFuture<Void> runAfterEither(@Nonnull CompletionStage<?> other,
                                                  @Nonnull Runnable action)
    {
        CompletableFuture<Void> inner = super.runAfterEither(other, () ->
        {
            DeploymentInstanceHolder.setInstance(context);
            action.run();
        });

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public CompletableFuture<Void> runAfterEitherAsync(@Nonnull CompletionStage<?> other,
                                                       @Nonnull Runnable action)
    {
        return runAfterEitherAsync(other, action, defaultExecutor());
    }

    @Override
    @Nonnull
    public CompletableFuture<Void> runAfterEitherAsync(@Nonnull CompletionStage<?> other,
                                                       @Nonnull Runnable action,
                                                       Executor executor)
    {
        CompletableFuture<Void> inner = super.runAfterEitherAsync(other, () ->
        {
            DeploymentInstanceHolder.setInstance(context);
            action.run();
        }, executor);

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public <U> CompletableFuture<U> thenCompose(@Nonnull Function<? super T, ? extends CompletionStage<U>> fn)
    {
        CompletableFuture<U> inner = super.thenCompose((v) ->
                                                       {
                                                           DeploymentInstanceHolder.setInstance(context);
                                                           return fn.apply(v);
                                                       });

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public <U> CompletableFuture<U> thenComposeAsync(@Nonnull Function<? super T, ? extends CompletionStage<U>> fn)
    {
        return thenComposeAsync(fn, defaultExecutor());
    }

    @Override
    @Nonnull
    public <U> CompletableFuture<U> thenComposeAsync(@Nonnull Function<? super T, ? extends CompletionStage<U>> fn,
                                                     Executor executor)
    {
        CompletableFuture<U> inner = super.thenComposeAsync((v) ->
                                                            {
                                                                DeploymentInstanceHolder.setInstance(context);
                                                                return fn.apply(v);
                                                            }, executor);

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public CompletableFuture<T> whenComplete(@Nonnull BiConsumer<? super T, ? super Throwable> action)
    {
        CompletableFuture<T> inner = super.whenComplete((v, t) ->
                                                        {
                                                            DeploymentInstanceHolder.setInstance(context);
                                                            action.accept(v, t);
                                                        });

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public CompletableFuture<T> whenCompleteAsync(@Nonnull BiConsumer<? super T, ? super Throwable> action)
    {
        return whenCompleteAsync(action, defaultExecutor());
    }

    @Override
    @Nonnull
    public CompletableFuture<T> whenCompleteAsync(@Nonnull BiConsumer<? super T, ? super Throwable> action,
                                                  Executor executor)
    {
        CompletableFuture<T> inner = super.whenCompleteAsync((v, t) ->
                                                             {
                                                                 DeploymentInstanceHolder.setInstance(context);
                                                                 action.accept(v, t);
                                                             }, executor);

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public <U> CompletableFuture<U> handle(@Nonnull BiFunction<? super T, Throwable, ? extends U> fn)
    {
        CompletableFuture<U> inner = super.handle((v, t) ->
                                                  {
                                                      DeploymentInstanceHolder.setInstance(context);
                                                      return fn.apply(v, t);
                                                  });

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public <U> CompletableFuture<U> handleAsync(@Nonnull BiFunction<? super T, Throwable, ? extends U> fn)
    {
        return handleAsync(fn, defaultExecutor());
    }

    @Override
    @Nonnull
    public <U> CompletableFuture<U> handleAsync(@Nonnull BiFunction<? super T, Throwable, ? extends U> fn,
                                                Executor executor)
    {
        CompletableFuture<U> inner = super.handleAsync((v, t) ->
                                                       {
                                                           DeploymentInstanceHolder.setInstance(context);
                                                           return fn.apply(v, t);
                                                       }, executor);

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public CompletableFuture<T> exceptionally(@Nonnull Function<Throwable, ? extends T> fn)
    {
        CompletableFuture<T> inner = super.exceptionally(v ->
                                                         {
                                                             DeploymentInstanceHolder.setInstance(context);
                                                             return fn.apply(v);
                                                         });

        return wrapIfNeeded(inner);
    }

    @Override
    public <U> CompletableFuture<U> newIncompleteFuture()
    {
        return wrapIfNeeded(super.newIncompleteFuture());
    }

    @Override
    public CompletableFuture<T> copy()
    {
        var inner = super.copy();

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public CompletableFuture<T> completeAsync(@Nonnull Supplier<? extends T> supplier)
    {
        return completeAsync(supplier, defaultExecutor());
    }

    @Override
    @Nonnull
    public CompletableFuture<T> completeAsync(@Nonnull Supplier<? extends T> supplier,
                                              Executor executor)
    {
        CompletableFuture<T> inner = super.completeAsync(() ->
                                                         {
                                                             DeploymentInstanceHolder.setInstance(context);
                                                             return supplier.get();
                                                         }, executor);

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public CompletableFuture<T> orTimeout(long timeout,
                                          @Nonnull TimeUnit unit)
    {
        var inner = super.orTimeout(timeout, unit);

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public CompletableFuture<T> completeOnTimeout(T value,
                                                  long timeout,
                                                  @Nonnull TimeUnit unit)
    {
        var inner = super.completeOnTimeout(value, timeout, unit);

        return wrapIfNeeded(inner);
    }

    @Override
    public String toString()
    {
        return future.toString();
    }
}
