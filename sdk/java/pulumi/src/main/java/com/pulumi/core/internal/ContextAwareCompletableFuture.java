package com.pulumi.core.internal;

import com.pulumi.core.internal.annotations.InternalUse;
import com.pulumi.deployment.DeploymentInstance;
import com.pulumi.deployment.internal.DeploymentInstanceHolder;

import javax.annotation.Nonnull;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;

///
/// The Java language host relies on ambient authority to make the Deployment context available to programs.
/// This has to be implemented as some thread-local state.
/// However, the system heavily uses asynchronous patterns, which are not bound to a single thread.
/// This class wraps the usual CompletableFuture and implements the propagation of the ambient state from thread to thread,
///
/// Any code that wants to queue async activities should use the helpers in this class, not CompletableFuture:
///
/// * runAsync
/// * supplyAsync
///
/// When a CompletableFuture is generated by external libraries, we should call ContextAwareCompletableFuture.wrap()
/// to get a context-aware version of it.
///
@InternalUse
public class ContextAwareCompletableFuture<T> extends CompletableFuture<T> {
    private final DeploymentInstance context;

    private ContextAwareCompletableFuture(DeploymentInstance context) {
        this.context = context;
    }

    private ContextAwareCompletableFuture(DeploymentInstance context, CompletableFuture<T> future) {
        this(context);

        future.whenComplete((v, t) -> {
            if (t != null) {
                this.completeExceptionally(t);
            } else {
                this.complete(v);
            }
        });
    }

    public static <T> CompletableFuture<T> wrap(CompletableFuture<T> future) {
        if (future instanceof ContextAwareCompletableFuture) {
            return future;
        }

        var context = DeploymentInstanceHolder.getInstanceNoThrow();
        if (context == null) {
            return future;
        }

        return new ContextAwareCompletableFuture<>(context, future);
    }

    private <U> CompletableFuture<U> wrapIfNeeded(CompletableFuture<U> future) {
        if (future instanceof ContextAwareCompletableFuture) {
            return future;
        }

        return new ContextAwareCompletableFuture<>(context, future);
    }

    private  static <T> Supplier<T> wrap(Supplier<T> callback) {
        var context = DeploymentInstanceHolder.getInstanceNoThrow();
        if (context == null) {
            return callback;
        }

        return () ->
        {
            DeploymentInstanceHolder.setInstance(context);
            try {
                return callback.get();
            } finally {
                DeploymentInstanceHolder.setInstance(null);
            }
        };
    }

    private static Runnable wrap(Runnable callback) {
        var context = DeploymentInstanceHolder.getInstanceNoThrow();
        if (context == null) {
            return callback;
        }

        return () ->
        {
            DeploymentInstanceHolder.setInstance(context);
            try {
                callback.run();
            } finally {
                DeploymentInstanceHolder.setInstance(null);
            }
        };
    }

    public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier) {
        supplier = wrap(supplier);
        var future = CompletableFuture.supplyAsync(supplier);
        return wrap(future);
    }

    public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier,
                                                       Executor executor) {
        supplier = wrap(supplier);
        var future = CompletableFuture.supplyAsync(supplier, executor);
        return wrap(future);
    }

    public static CompletableFuture<Void> runAsync(Runnable runnable) {
        runnable = wrap(runnable);
        var future = CompletableFuture.runAsync(runnable);
        return wrap(future);
    }

    @Nonnull
    public static CompletableFuture<Void> runAsync(Runnable runnable,
                                                   Executor executor) {
        runnable = wrap(runnable);
        var future = CompletableFuture.runAsync(runnable, executor);
        return wrap(future);
    }

    @Override
    public T get() throws InterruptedException, ExecutionException {
        DeploymentInstanceHolder.setInstance(context);
        return super.get();
    }

    @Override
    public T get(long timeout,
                 TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
        DeploymentInstanceHolder.setInstance(context);
        return super.get(timeout, unit);
    }

    @Override
    public T join() {
        return super.join();
    }

    @Override
    public T getNow(T valueIfAbsent) {
        DeploymentInstanceHolder.setInstance(context);
        return super.getNow(valueIfAbsent);
    }

    @Override
    public boolean complete(T value) {
        DeploymentInstanceHolder.setInstance(context);
        return super.complete(value);
    }

    @Override
    public boolean completeExceptionally(Throwable ex) {
        DeploymentInstanceHolder.setInstance(context);
        return super.completeExceptionally(ex);
    }

    @Override
    @Nonnull
    public <U> CompletableFuture<U> thenApply(@Nonnull Function<? super T, ? extends U> fn) {
        CompletableFuture<U> inner = super.thenApply(v -> {
            DeploymentInstanceHolder.setInstance(context);
            return fn.apply(v);
        });

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public <U> CompletableFuture<U> thenApplyAsync(@Nonnull Function<? super T, ? extends U> fn) {
        CompletableFuture<U> inner = super.thenApplyAsync(v -> {
            DeploymentInstanceHolder.setInstance(context);
            return fn.apply(v);
        });

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public <U> CompletableFuture<U> thenApplyAsync(@Nonnull Function<? super T, ? extends U> fn,
                                                   Executor executor) {
        CompletableFuture<U> inner = super.thenApplyAsync(v -> {
            DeploymentInstanceHolder.setInstance(context);
            return fn.apply(v);
        }, executor);

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public CompletableFuture<Void> thenAccept(@Nonnull Consumer<? super T> action) {
        var inner = super.thenAccept(v -> {
            DeploymentInstanceHolder.setInstance(context);
            action.accept(v);
        });

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public CompletableFuture<Void> thenAcceptAsync(@Nonnull Consumer<? super T> action) {
        var inner = super.thenAcceptAsync(v -> {
            DeploymentInstanceHolder.setInstance(context);
            action.accept(v);
        });

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public CompletableFuture<Void> thenAcceptAsync(@Nonnull Consumer<? super T> action,
                                                   Executor executor) {
        var inner = super.thenAcceptAsync(v -> {
            DeploymentInstanceHolder.setInstance(context);
            action.accept(v);
        }, executor);

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public CompletableFuture<Void> thenRun(@Nonnull Runnable action) {
        var inner = super.thenRun(() -> {
            DeploymentInstanceHolder.setInstance(context);
            action.run();
        });

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public CompletableFuture<Void> thenRunAsync(@Nonnull Runnable action) {
        var inner = super.thenRunAsync(() -> {
            DeploymentInstanceHolder.setInstance(context);
            action.run();
        });

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public CompletableFuture<Void> thenRunAsync(@Nonnull Runnable action,
                                                Executor executor) {
        var inner = super.thenRunAsync(() -> {
            DeploymentInstanceHolder.setInstance(context);
            action.run();
        }, executor);

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public <U, V> CompletableFuture<V> thenCombine(@Nonnull CompletionStage<? extends U> other,
                                                   @Nonnull BiFunction<? super T, ? super U, ? extends V> fn) {
        CompletableFuture<V> inner = super.thenCombine(other, (v, t) -> {
            DeploymentInstanceHolder.setInstance(context);
            return fn.apply(v, t);
        });

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public <U, V> CompletableFuture<V> thenCombineAsync(@Nonnull CompletionStage<? extends U> other,
                                                        @Nonnull BiFunction<? super T, ? super U, ? extends V> fn) {
        CompletableFuture<V> inner = super.thenCombineAsync(other, (v, t) -> {
            DeploymentInstanceHolder.setInstance(context);
            return fn.apply(v, t);
        });

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public <U, V> CompletableFuture<V> thenCombineAsync(@Nonnull CompletionStage<? extends U> other,
                                                        @Nonnull BiFunction<? super T, ? super U, ? extends V> fn,
                                                        Executor executor) {
        CompletableFuture<V> inner = super.thenCombineAsync(other, (v, t) -> {
            DeploymentInstanceHolder.setInstance(context);
            return fn.apply(v, t);
        }, executor);

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public <U> CompletableFuture<Void> thenAcceptBoth(@Nonnull CompletionStage<? extends U> other,
                                                      @Nonnull BiConsumer<? super T, ? super U> action) {
        CompletableFuture<Void> inner = super.thenAcceptBoth(other, (v, t) -> {
            DeploymentInstanceHolder.setInstance(context);
            action.accept(v, t);
        });

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public <U> CompletableFuture<Void> thenAcceptBothAsync(@Nonnull CompletionStage<? extends U> other,
                                                           @Nonnull BiConsumer<? super T, ? super U> action) {
        CompletableFuture<Void> inner = super.thenAcceptBothAsync(other, (v, t) -> {
            DeploymentInstanceHolder.setInstance(context);
            action.accept(v, t);
        });

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public <U> CompletableFuture<Void> thenAcceptBothAsync(@Nonnull CompletionStage<? extends U> other,
                                                           @Nonnull BiConsumer<? super T, ? super U> action,
                                                           Executor executor) {
        CompletableFuture<Void> inner = super.thenAcceptBothAsync(other, (v, t) -> {
            DeploymentInstanceHolder.setInstance(context);
            action.accept(v, t);
        }, executor);

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public CompletableFuture<Void> runAfterBoth(@Nonnull CompletionStage<?> other,
                                                @Nonnull Runnable action) {
        CompletableFuture<Void> inner = super.runAfterBoth(other, () -> {
            DeploymentInstanceHolder.setInstance(context);
            action.run();
        });

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public CompletableFuture<Void> runAfterBothAsync(@Nonnull CompletionStage<?> other,
                                                     @Nonnull Runnable action) {
        CompletableFuture<Void> inner = super.runAfterBothAsync(other, () -> {
            DeploymentInstanceHolder.setInstance(context);
            action.run();
        });

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public CompletableFuture<Void> runAfterBothAsync(@Nonnull CompletionStage<?> other,
                                                     @Nonnull Runnable action,
                                                     Executor executor) {
        CompletableFuture<Void> inner = super.runAfterBothAsync(other, () -> {
            DeploymentInstanceHolder.setInstance(context);
            action.run();
        }, executor);

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public <U> CompletableFuture<U> applyToEither(@Nonnull CompletionStage<? extends T> other,
                                                  @Nonnull Function<? super T, U> fn) {
        CompletableFuture<U> inner = super.applyToEither(other, v -> {
            DeploymentInstanceHolder.setInstance(context);
            return fn.apply(v);
        });

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public <U> CompletableFuture<U> applyToEitherAsync(@Nonnull CompletionStage<? extends T> other,
                                                       @Nonnull Function<? super T, U> fn) {
        CompletableFuture<U> inner = super.applyToEitherAsync(other, v -> {
            DeploymentInstanceHolder.setInstance(context);
            return fn.apply(v);
        });

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public <U> CompletableFuture<U> applyToEitherAsync(@Nonnull CompletionStage<? extends T> other,
                                                       @Nonnull Function<? super T, U> fn,
                                                       Executor executor) {
        CompletableFuture<U> inner = super.applyToEitherAsync(other, v -> {
            DeploymentInstanceHolder.setInstance(context);
            return fn.apply(v);
        }, executor);

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public CompletableFuture<Void> acceptEither(@Nonnull CompletionStage<? extends T> other,
                                                @Nonnull Consumer<? super T> action) {
        CompletableFuture<Void> inner = super.acceptEither(other, v -> {
            DeploymentInstanceHolder.setInstance(context);
            action.accept(v);
        });

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public CompletableFuture<Void> acceptEitherAsync(@Nonnull CompletionStage<? extends T> other,
                                                     @Nonnull Consumer<? super T> action) {
        CompletableFuture<Void> inner = super.acceptEitherAsync(other, v -> {
            DeploymentInstanceHolder.setInstance(context);
            action.accept(v);
        });

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public CompletableFuture<Void> acceptEitherAsync(@Nonnull CompletionStage<? extends T> other,
                                                     @Nonnull Consumer<? super T> action,
                                                     Executor executor) {
        CompletableFuture<Void> inner = super.acceptEitherAsync(other, v -> {
            DeploymentInstanceHolder.setInstance(context);
            action.accept(v);
        }, executor);

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public CompletableFuture<Void> runAfterEither(@Nonnull CompletionStage<?> other,
                                                  @Nonnull Runnable action) {
        CompletableFuture<Void> inner = super.runAfterEither(other, () -> {
            DeploymentInstanceHolder.setInstance(context);
            action.run();
        });

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public CompletableFuture<Void> runAfterEitherAsync(@Nonnull CompletionStage<?> other,
                                                       @Nonnull Runnable action) {
        CompletableFuture<Void> inner = super.runAfterEitherAsync(other, () -> {
            DeploymentInstanceHolder.setInstance(context);
            action.run();
        });

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public CompletableFuture<Void> runAfterEitherAsync(@Nonnull CompletionStage<?> other,
                                                       @Nonnull Runnable action,
                                                       Executor executor) {
        CompletableFuture<Void> inner = super.runAfterEitherAsync(other, () -> {
            DeploymentInstanceHolder.setInstance(context);
            action.run();
        }, executor);

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public <U> CompletableFuture<U> thenCompose(@Nonnull Function<? super T, ? extends CompletionStage<U>> fn) {
        CompletableFuture<U> inner = super.thenCompose((v) -> {
            DeploymentInstanceHolder.setInstance(context);
            return fn.apply(v);
        });

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public <U> CompletableFuture<U> thenComposeAsync(@Nonnull Function<? super T, ? extends CompletionStage<U>> fn) {
        CompletableFuture<U> inner = super.thenComposeAsync((v) -> {
            DeploymentInstanceHolder.setInstance(context);
            return fn.apply(v);
        });

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public <U> CompletableFuture<U> thenComposeAsync(@Nonnull Function<? super T, ? extends CompletionStage<U>> fn,
                                                     Executor executor) {
        CompletableFuture<U> inner = super.thenComposeAsync((v) -> {
            DeploymentInstanceHolder.setInstance(context);
            return fn.apply(v);
        }, executor);

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public CompletableFuture<T> whenComplete(@Nonnull BiConsumer<? super T, ? super Throwable> action) {
        CompletableFuture<T> inner = super.whenComplete((v, t) -> {
            DeploymentInstanceHolder.setInstance(context);
            action.accept(v, t);
        });

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public CompletableFuture<T> whenCompleteAsync(@Nonnull BiConsumer<? super T, ? super Throwable> action) {
        CompletableFuture<T> inner = super.whenCompleteAsync((v, t) -> {
            DeploymentInstanceHolder.setInstance(context);
            action.accept(v, t);
        });

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public CompletableFuture<T> whenCompleteAsync(@Nonnull BiConsumer<? super T, ? super Throwable> action,
                                                  Executor executor) {
        CompletableFuture<T> inner = super.whenCompleteAsync((v, t) -> {
            DeploymentInstanceHolder.setInstance(context);
            action.accept(v, t);
        }, executor);

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public <U> CompletableFuture<U> handle(@Nonnull BiFunction<? super T, Throwable, ? extends U> fn) {
        CompletableFuture<U> inner = super.handle((v, t) -> {
            DeploymentInstanceHolder.setInstance(context);
            return fn.apply(v, t);
        });

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public <U> CompletableFuture<U> handleAsync(@Nonnull BiFunction<? super T, Throwable, ? extends U> fn) {
        CompletableFuture<U> inner = super.handleAsync((v, t) -> {
            DeploymentInstanceHolder.setInstance(context);
            return fn.apply(v, t);
        });

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public <U> CompletableFuture<U> handleAsync(@Nonnull BiFunction<? super T, Throwable, ? extends U> fn,
                                                Executor executor) {
        CompletableFuture<U> inner = super.handleAsync((v, t) -> {
            DeploymentInstanceHolder.setInstance(context);
            return fn.apply(v, t);
        }, executor);

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public CompletableFuture<T> exceptionally(@Nonnull Function<Throwable, ? extends T> fn) {
        CompletableFuture<T> inner = super.exceptionally(v -> {
            DeploymentInstanceHolder.setInstance(context);
            return fn.apply(v);
        });

        return wrapIfNeeded(inner);
    }

    @Override
    public <U> CompletableFuture<U> newIncompleteFuture() {
        return wrapIfNeeded(super.newIncompleteFuture());
    }

    @Override
    public CompletableFuture<T> copy() {
        var inner = super.copy();

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public CompletableFuture<T> completeAsync(@Nonnull Supplier<? extends T> supplier) {
        CompletableFuture<T> inner = super.completeAsync(() -> {
            DeploymentInstanceHolder.setInstance(context);
            return supplier.get();
        });

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public CompletableFuture<T> completeAsync(@Nonnull Supplier<? extends T> supplier,
                                              Executor executor) {
        CompletableFuture<T> inner = super.completeAsync(() -> {
            DeploymentInstanceHolder.setInstance(context);
            return supplier.get();
        }, executor);

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public CompletableFuture<T> orTimeout(long timeout,
                                          @Nonnull TimeUnit unit) {
        var inner = super.orTimeout(timeout, unit);

        return wrapIfNeeded(inner);
    }

    @Override
    @Nonnull
    public CompletableFuture<T> completeOnTimeout(T value,
                                                  long timeout,
                                                  @Nonnull TimeUnit unit) {
        var inner = super.completeOnTimeout(value, timeout, unit);

        return wrapIfNeeded(inner);
    }

}
